/*
 * Google Identity Toolkit API
 *
 * Help the third party sites to implement federated login.
 *
 * The version of the OpenAPI document: v3
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::google_rest_apis::identitytoolkit_v3::models;
use serde::{Deserialize, Serialize};

use serde_with::serde_as;

/// IdentitytoolkitRelyingpartyUploadAccountRequest : Request to upload user account in batch.
#[serde_as]
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct IdentitytoolkitRelyingpartyUploadAccountRequest {
    /// Whether allow overwrite existing account when user local_id exists.
    #[serde(rename = "allowOverwrite", skip_serializing_if = "Option::is_none")]
    pub allow_overwrite: Option<bool>,
    #[serde(rename = "blockSize", skip_serializing_if = "Option::is_none")]
    pub block_size: Option<i32>,
    /// The following 4 fields are for standard scrypt algorithm.
    #[serde(rename = "cpuMemCost", skip_serializing_if = "Option::is_none")]
    pub cpu_mem_cost: Option<i32>,
    /// GCP project number of the requesting delegated app. Currently only intended for Firebase V1 migration.
    #[serde(
        rename = "delegatedProjectNumber",
        skip_serializing_if = "Option::is_none"
    )]
    pub delegated_project_number: Option<String>,
    #[serde(rename = "dkLen", skip_serializing_if = "Option::is_none")]
    pub dk_len: Option<i32>,
    /// The password hash algorithm.
    #[serde(rename = "hashAlgorithm", skip_serializing_if = "Option::is_none")]
    pub hash_algorithm: Option<String>,
    /// Memory cost for hash calculation. Used by scrypt similar algorithms.
    #[serde(rename = "memoryCost", skip_serializing_if = "Option::is_none")]
    pub memory_cost: Option<i32>,
    #[serde(rename = "parallelization", skip_serializing_if = "Option::is_none")]
    pub parallelization: Option<i32>,
    /// Rounds for hash calculation. Used by scrypt and similar algorithms.
    #[serde(rename = "rounds", skip_serializing_if = "Option::is_none")]
    pub rounds: Option<i32>,
    /// The salt separator.
    #[serde_as(as = "Option<serde_with::base64::Base64>")]
    #[serde(rename = "saltSeparator", skip_serializing_if = "Option::is_none")]
    pub salt_separator: Option<Vec<u8>>,
    /// If true, backend will do sanity check(including duplicate email and federated id) when uploading account.
    #[serde(rename = "sanityCheck", skip_serializing_if = "Option::is_none")]
    pub sanity_check: Option<bool>,
    /// The key for to hash the password.
    #[serde_as(as = "Option<serde_with::base64::Base64>")]
    #[serde(rename = "signerKey", skip_serializing_if = "Option::is_none")]
    pub signer_key: Option<Vec<u8>>,
    /// Specify which project (field value is actually project id) to operate. Only used when provided credential.
    #[serde(rename = "targetProjectId", skip_serializing_if = "Option::is_none")]
    pub target_project_id: Option<String>,
    /// The account info to be stored.
    #[serde(rename = "users", skip_serializing_if = "Option::is_none")]
    pub users: Option<Vec<models::UserInfo>>,
}

impl IdentitytoolkitRelyingpartyUploadAccountRequest {
    /// Request to upload user account in batch.
    pub fn new() -> IdentitytoolkitRelyingpartyUploadAccountRequest {
        IdentitytoolkitRelyingpartyUploadAccountRequest {
            allow_overwrite: None,
            block_size: None,
            cpu_mem_cost: None,
            delegated_project_number: None,
            dk_len: None,
            hash_algorithm: None,
            memory_cost: None,
            parallelization: None,
            rounds: None,
            salt_separator: None,
            sanity_check: None,
            signer_key: None,
            target_project_id: None,
            users: None,
        }
    }
}
