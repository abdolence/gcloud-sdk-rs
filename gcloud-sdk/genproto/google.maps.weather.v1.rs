// This file is @generated by prost-build.
/// Represents the atmospheric air pressure conditions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AirPressure {
    /// The mean sea level air pressure in millibars.
    #[prost(float, optional, tag = "1")]
    pub mean_sea_level_millibars: ::core::option::Option<f32>,
}
/// Represents the events related to the sun (e.g. sunrise, sunset).
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SunEvents {
    /// The time when the sun rises.
    ///
    /// NOTE: In some unique cases (e.g. north of the artic circle) there may be no
    /// sunrise time for a day. In these cases, this field will be unset.
    #[prost(message, optional, tag = "1")]
    pub sunrise_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the sun sets.
    ///
    /// NOTE: In some unique cases (e.g. north of the artic circle) there may be no
    /// sunset time for a day. In these cases, this field will be unset.
    #[prost(message, optional, tag = "2")]
    pub sunset_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Represents the events related to the moon (e.g. moonrise, moonset).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoonEvents {
    /// The time when the upper limb of the moon appears above the horizon
    /// (see <https://en.wikipedia.org/wiki/Moonrise_and_moonset>).
    ///
    /// NOTE: For most cases, there'll be a single moon rise time per day. In other
    /// cases, the list might be empty (e.g. when the moon rises after next day
    /// midnight).
    /// However, in unique cases (e.g. in polar regions), the list may contain
    /// more than one value. In these cases, the values are sorted in ascending
    /// order.
    #[prost(message, repeated, tag = "4")]
    pub moonrise_times: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    /// The time when the upper limb of the moon disappears below the
    /// horizon (see <https://en.wikipedia.org/wiki/Moonrise_and_moonset>).
    ///
    /// NOTE: For most cases, there'll be a single moon set time per day. In other
    /// cases, the list might be empty (e.g. when the moon sets after next day
    /// midnight).
    /// However, in unique cases (e.g. in polar regions), the list may contain
    /// more than one value. In these cases, the values are sorted in ascending
    /// order.
    #[prost(message, repeated, tag = "5")]
    pub moonset_times: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    /// The moon phase (a.k.a. lunar phase).
    #[prost(enumeration = "MoonPhase", tag = "3")]
    pub moon_phase: i32,
}
/// Marks the moon phase (a.k.a. lunar phase).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MoonPhase {
    /// Unspecified moon phase.
    Unspecified = 0,
    /// The moon is not illuminated by the sun.
    NewMoon = 1,
    /// The moon is lit by 0%-50% on its right side in the northern hemisphere ðŸŒ’
    /// and on its left side in the southern hemisphere ðŸŒ˜.
    WaxingCrescent = 2,
    /// The moon is lit by 50.1% on its right side in the northern hemisphere ðŸŒ“
    /// and on its left side in the southern hemisphere ðŸŒ—.
    FirstQuarter = 3,
    /// The moon is lit by 50%-100% on its right side in the northern hemisphere ðŸŒ”
    /// and on its left side in the southern hemisphere ðŸŒ–.
    WaxingGibbous = 4,
    /// The moon is fully illuminated.
    FullMoon = 5,
    /// The moon is lit by 50%-100% on its left side in the northern hemisphere ðŸŒ–
    /// and on its right side in the southern hemisphere ðŸŒ”.
    WaningGibbous = 6,
    /// The moon is lit by 50.1% on its left side in the northern hemisphere ðŸŒ—
    /// and on its right side in the southern hemisphere ðŸŒ“.
    LastQuarter = 7,
    /// The moon is lit by 0%-50% on its left side in the northern hemisphere ðŸŒ˜
    /// and on its right side in the southern hemisphere ðŸŒ’.
    WaningCrescent = 8,
}
impl MoonPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MOON_PHASE_UNSPECIFIED",
            Self::NewMoon => "NEW_MOON",
            Self::WaxingCrescent => "WAXING_CRESCENT",
            Self::FirstQuarter => "FIRST_QUARTER",
            Self::WaxingGibbous => "WAXING_GIBBOUS",
            Self::FullMoon => "FULL_MOON",
            Self::WaningGibbous => "WANING_GIBBOUS",
            Self::LastQuarter => "LAST_QUARTER",
            Self::WaningCrescent => "WANING_CRESCENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MOON_PHASE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEW_MOON" => Some(Self::NewMoon),
            "WAXING_CRESCENT" => Some(Self::WaxingCrescent),
            "FIRST_QUARTER" => Some(Self::FirstQuarter),
            "WAXING_GIBBOUS" => Some(Self::WaxingGibbous),
            "FULL_MOON" => Some(Self::FullMoon),
            "WANING_GIBBOUS" => Some(Self::WaningGibbous),
            "LAST_QUARTER" => Some(Self::LastQuarter),
            "WANING_CRESCENT" => Some(Self::WaningCrescent),
            _ => None,
        }
    }
}
/// Represents ice thickness conditions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IceThickness {
    /// The ice thickness value.
    #[prost(float, optional, tag = "1")]
    pub thickness: ::core::option::Option<f32>,
    /// The code that represents the unit used to measure the ice thickness.
    #[prost(enumeration = "ice_thickness::Unit", tag = "2")]
    pub unit: i32,
}
/// Nested message and enum types in `IceThickness`.
pub mod ice_thickness {
    /// Represents the unit used to measure the ice thickness.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// The unit is not specified.
        Unspecified = 0,
        /// The thickness is measured in millimeters.
        Millimeters = 1,
        /// The thickness is measured in inches.
        Inches = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Millimeters => "MILLIMETERS",
                Self::Inches => "INCHES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MILLIMETERS" => Some(Self::Millimeters),
                "INCHES" => Some(Self::Inches),
                _ => None,
            }
        }
    }
}
/// Represents a set of precipitation values at a given location.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Precipitation {
    /// The probability of precipitation (values from 0 to 100).
    #[prost(message, optional, tag = "1")]
    pub probability: ::core::option::Option<PrecipitationProbability>,
    /// The amount of snow, measured as liquid water equivalent, that has
    /// accumulated over a period of time. Note: QPF is an abbreviation for
    /// Quantitative Precipitation Forecast (please see the
    /// QuantitativePrecipitationForecast definition for more details).
    #[prost(message, optional, tag = "3")]
    pub snow_qpf: ::core::option::Option<QuantitativePrecipitationForecast>,
    /// The amount of rain, measured as liquid water equivalent, that has
    /// accumulated over a period of time. Note: QPF is an abbreviation for
    /// Quantitative Precipitation Forecast (please see the
    /// QuantitativePrecipitationForecast definition for more details).
    #[prost(message, optional, tag = "4")]
    pub qpf: ::core::option::Option<QuantitativePrecipitationForecast>,
}
/// Represents the probability of precipitation at a given location.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PrecipitationProbability {
    /// A percentage from 0 to 100 that indicates the chances of precipitation.
    #[prost(int32, optional, tag = "1")]
    pub percent: ::core::option::Option<i32>,
    /// A code that indicates the type of precipitation.
    #[prost(enumeration = "PrecipitationType", tag = "2")]
    pub r#type: i32,
}
/// Represents the expected amount of melted precipitation accumulated over a
/// specified time period over a specified area (reference:
/// <https://en.wikipedia.org/wiki/Quantitative_precipitation_forecast>) -
/// usually abbreviated QPF for short.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuantitativePrecipitationForecast {
    /// The amount of precipitation, measured as liquid water equivalent, that has
    /// accumulated over a period of time.
    #[prost(float, optional, tag = "1")]
    pub quantity: ::core::option::Option<f32>,
    /// The code of the unit used to measure the amount of accumulated
    /// precipitation.
    #[prost(enumeration = "quantitative_precipitation_forecast::Unit", tag = "2")]
    pub unit: i32,
}
/// Nested message and enum types in `QuantitativePrecipitationForecast`.
pub mod quantitative_precipitation_forecast {
    /// Represents the unit used to measure the amount of accumulated
    /// precipitation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// Unspecified precipitation unit.
        Unspecified = 0,
        /// The amount of precipitation is measured in millimeters.
        Millimeters = 3,
        /// The amount of precipitation is measured in inches.
        Inches = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Millimeters => "MILLIMETERS",
                Self::Inches => "INCHES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MILLIMETERS" => Some(Self::Millimeters),
                "INCHES" => Some(Self::Inches),
                _ => None,
            }
        }
    }
}
/// Represents the type of precipitation at a given location.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrecipitationType {
    /// Unspecified precipitation type.
    Unspecified = 0,
    /// No precipitation.
    None = 8,
    /// Snow precipitation.
    Snow = 1,
    /// Rain precipitation.
    Rain = 2,
    /// Light rain precipitation.
    LightRain = 3,
    /// Heavy rain precipitation.
    HeavyRain = 4,
    /// Both rain and snow precipitations.
    RainAndSnow = 5,
    /// Sleet precipitation.
    Sleet = 6,
    /// Freezing rain precipitation.
    FreezingRain = 7,
}
impl PrecipitationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRECIPITATION_TYPE_UNSPECIFIED",
            Self::None => "NONE",
            Self::Snow => "SNOW",
            Self::Rain => "RAIN",
            Self::LightRain => "LIGHT_RAIN",
            Self::HeavyRain => "HEAVY_RAIN",
            Self::RainAndSnow => "RAIN_AND_SNOW",
            Self::Sleet => "SLEET",
            Self::FreezingRain => "FREEZING_RAIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRECIPITATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NONE" => Some(Self::None),
            "SNOW" => Some(Self::Snow),
            "RAIN" => Some(Self::Rain),
            "LIGHT_RAIN" => Some(Self::LightRain),
            "HEAVY_RAIN" => Some(Self::HeavyRain),
            "RAIN_AND_SNOW" => Some(Self::RainAndSnow),
            "SLEET" => Some(Self::Sleet),
            "FREEZING_RAIN" => Some(Self::FreezingRain),
            _ => None,
        }
    }
}
/// Represents a temperature value.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Temperature {
    /// The temperature value (in degrees) in the specified unit.
    #[prost(float, optional, tag = "1")]
    pub degrees: ::core::option::Option<f32>,
    /// The code for the unit used to measure the temperature value.
    #[prost(enumeration = "TemperatureUnit", tag = "2")]
    pub unit: i32,
}
/// Represents a unit used to measure temperatures.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TemperatureUnit {
    /// The temperature unit is unspecified.
    Unspecified = 0,
    /// The temperature is measured in Celsius.
    Celsius = 1,
    /// The temperature is measured in Fahrenheit.
    Fahrenheit = 2,
}
impl TemperatureUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TEMPERATURE_UNIT_UNSPECIFIED",
            Self::Celsius => "CELSIUS",
            Self::Fahrenheit => "FAHRENHEIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEMPERATURE_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "CELSIUS" => Some(Self::Celsius),
            "FAHRENHEIT" => Some(Self::Fahrenheit),
            _ => None,
        }
    }
}
/// Represents a weather condition for a given location at a given period of
/// time.
///
/// Disclaimer: Weather icons and condition codes are subject to change. Google
/// may introduce new codes and icons or update existing ones as needed. We
/// encourage you to refer to this documentation regularly for the most
/// up-to-date information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeatherCondition {
    /// The base URI for the icon not including the file type extension. To display
    /// the icon, append a theme if desired and the file type extension (`.png` or
    /// `.svg`) to this URI. By default, the icon is light themed, but `_dark` can
    /// be appended for dark mode. For example:
    /// "<https://maps.gstatic.com/weather/v1/dust.svg"> or
    /// "<https://maps.gstatic.com/weather/v1/dust_dark.svg",> where `icon_base_uri`
    /// is "<https://maps.gstatic.com/weather/v1/dust".>
    #[prost(string, tag = "1")]
    pub icon_base_uri: ::prost::alloc::string::String,
    /// The textual description for this weather condition (localized).
    #[prost(message, optional, tag = "2")]
    pub description: ::core::option::Option<super::super::super::r#type::LocalizedText>,
    /// The type of weather condition.
    #[prost(enumeration = "weather_condition::Type", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `WeatherCondition`.
pub mod weather_condition {
    /// Marks the weather condition type in a forecast element's context.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// The weather condition is unspecified.
        Unspecified = 0,
        /// No clouds.
        Clear = 1,
        /// Periodic clouds.
        MostlyClear = 2,
        /// Party cloudy (some clouds).
        PartlyCloudy = 3,
        /// Mostly cloudy (more clouds than sun).
        MostlyCloudy = 4,
        /// Cloudy (all clouds, no sun).
        Cloudy = 5,
        /// High wind.
        Windy = 6,
        /// High wind with precipitation.
        WindAndRain = 7,
        /// Light intermittent rain.
        LightRainShowers = 8,
        /// Chance of intermittent rain.
        ChanceOfShowers = 9,
        /// Intermittent rain.
        ScatteredShowers = 10,
        /// Showers are considered to be rainfall that has a shorter duration than
        /// rain, and is characterized by suddenness in terms of start and stop
        /// times, and rapid changes in intensity.
        RainShowers = 12,
        /// Intense showers.
        HeavyRainShowers = 13,
        /// Rain (light to moderate in quantity).
        LightToModerateRain = 14,
        /// Rain (moderate to heavy in quantity).
        ModerateToHeavyRain = 15,
        /// Moderate rain.
        Rain = 16,
        /// Light rain.
        LightRain = 17,
        /// Heavy rain.
        HeavyRain = 18,
        /// Rain periodically heavy.
        RainPeriodicallyHeavy = 19,
        /// Light snow that is falling at varying intensities for brief periods of
        /// time.
        LightSnowShowers = 20,
        /// Chance of snow showers.
        ChanceOfSnowShowers = 21,
        /// Snow that is falling at varying intensities for brief periods of time.
        ScatteredSnowShowers = 22,
        /// Snow showers.
        SnowShowers = 23,
        /// Heavy snow showers.
        HeavySnowShowers = 24,
        /// Light to moderate snow.
        LightToModerateSnow = 25,
        /// Moderate to heavy snow.
        ModerateToHeavySnow = 26,
        /// Moderate snow.
        Snow = 27,
        /// Light snow.
        LightSnow = 28,
        /// Heavy snow.
        HeavySnow = 29,
        /// Snow with possible thunder and lightning.
        Snowstorm = 30,
        /// Snow, at times heavy.
        SnowPeriodicallyHeavy = 31,
        /// Heavy snow with possible thunder and lightning.
        HeavySnowStorm = 32,
        /// Snow with intense wind.
        BlowingSnow = 33,
        /// Rain and snow mix.
        RainAndSnow = 34,
        /// Hail.
        Hail = 35,
        /// Hail that is falling at varying intensities for brief periods of time.
        HailShowers = 36,
        /// Thunderstorm.
        Thunderstorm = 37,
        /// A shower of rain accompanied by thunder and lightning.
        Thundershower = 38,
        /// Light thunderstorm rain.
        LightThunderstormRain = 39,
        /// Thunderstorms that has rain in various intensities for brief periods of
        /// time.
        ScatteredThunderstorms = 40,
        /// Heavy thunderstorm.
        HeavyThunderstorm = 41,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Clear => "CLEAR",
                Self::MostlyClear => "MOSTLY_CLEAR",
                Self::PartlyCloudy => "PARTLY_CLOUDY",
                Self::MostlyCloudy => "MOSTLY_CLOUDY",
                Self::Cloudy => "CLOUDY",
                Self::Windy => "WINDY",
                Self::WindAndRain => "WIND_AND_RAIN",
                Self::LightRainShowers => "LIGHT_RAIN_SHOWERS",
                Self::ChanceOfShowers => "CHANCE_OF_SHOWERS",
                Self::ScatteredShowers => "SCATTERED_SHOWERS",
                Self::RainShowers => "RAIN_SHOWERS",
                Self::HeavyRainShowers => "HEAVY_RAIN_SHOWERS",
                Self::LightToModerateRain => "LIGHT_TO_MODERATE_RAIN",
                Self::ModerateToHeavyRain => "MODERATE_TO_HEAVY_RAIN",
                Self::Rain => "RAIN",
                Self::LightRain => "LIGHT_RAIN",
                Self::HeavyRain => "HEAVY_RAIN",
                Self::RainPeriodicallyHeavy => "RAIN_PERIODICALLY_HEAVY",
                Self::LightSnowShowers => "LIGHT_SNOW_SHOWERS",
                Self::ChanceOfSnowShowers => "CHANCE_OF_SNOW_SHOWERS",
                Self::ScatteredSnowShowers => "SCATTERED_SNOW_SHOWERS",
                Self::SnowShowers => "SNOW_SHOWERS",
                Self::HeavySnowShowers => "HEAVY_SNOW_SHOWERS",
                Self::LightToModerateSnow => "LIGHT_TO_MODERATE_SNOW",
                Self::ModerateToHeavySnow => "MODERATE_TO_HEAVY_SNOW",
                Self::Snow => "SNOW",
                Self::LightSnow => "LIGHT_SNOW",
                Self::HeavySnow => "HEAVY_SNOW",
                Self::Snowstorm => "SNOWSTORM",
                Self::SnowPeriodicallyHeavy => "SNOW_PERIODICALLY_HEAVY",
                Self::HeavySnowStorm => "HEAVY_SNOW_STORM",
                Self::BlowingSnow => "BLOWING_SNOW",
                Self::RainAndSnow => "RAIN_AND_SNOW",
                Self::Hail => "HAIL",
                Self::HailShowers => "HAIL_SHOWERS",
                Self::Thunderstorm => "THUNDERSTORM",
                Self::Thundershower => "THUNDERSHOWER",
                Self::LightThunderstormRain => "LIGHT_THUNDERSTORM_RAIN",
                Self::ScatteredThunderstorms => "SCATTERED_THUNDERSTORMS",
                Self::HeavyThunderstorm => "HEAVY_THUNDERSTORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLEAR" => Some(Self::Clear),
                "MOSTLY_CLEAR" => Some(Self::MostlyClear),
                "PARTLY_CLOUDY" => Some(Self::PartlyCloudy),
                "MOSTLY_CLOUDY" => Some(Self::MostlyCloudy),
                "CLOUDY" => Some(Self::Cloudy),
                "WINDY" => Some(Self::Windy),
                "WIND_AND_RAIN" => Some(Self::WindAndRain),
                "LIGHT_RAIN_SHOWERS" => Some(Self::LightRainShowers),
                "CHANCE_OF_SHOWERS" => Some(Self::ChanceOfShowers),
                "SCATTERED_SHOWERS" => Some(Self::ScatteredShowers),
                "RAIN_SHOWERS" => Some(Self::RainShowers),
                "HEAVY_RAIN_SHOWERS" => Some(Self::HeavyRainShowers),
                "LIGHT_TO_MODERATE_RAIN" => Some(Self::LightToModerateRain),
                "MODERATE_TO_HEAVY_RAIN" => Some(Self::ModerateToHeavyRain),
                "RAIN" => Some(Self::Rain),
                "LIGHT_RAIN" => Some(Self::LightRain),
                "HEAVY_RAIN" => Some(Self::HeavyRain),
                "RAIN_PERIODICALLY_HEAVY" => Some(Self::RainPeriodicallyHeavy),
                "LIGHT_SNOW_SHOWERS" => Some(Self::LightSnowShowers),
                "CHANCE_OF_SNOW_SHOWERS" => Some(Self::ChanceOfSnowShowers),
                "SCATTERED_SNOW_SHOWERS" => Some(Self::ScatteredSnowShowers),
                "SNOW_SHOWERS" => Some(Self::SnowShowers),
                "HEAVY_SNOW_SHOWERS" => Some(Self::HeavySnowShowers),
                "LIGHT_TO_MODERATE_SNOW" => Some(Self::LightToModerateSnow),
                "MODERATE_TO_HEAVY_SNOW" => Some(Self::ModerateToHeavySnow),
                "SNOW" => Some(Self::Snow),
                "LIGHT_SNOW" => Some(Self::LightSnow),
                "HEAVY_SNOW" => Some(Self::HeavySnow),
                "SNOWSTORM" => Some(Self::Snowstorm),
                "SNOW_PERIODICALLY_HEAVY" => Some(Self::SnowPeriodicallyHeavy),
                "HEAVY_SNOW_STORM" => Some(Self::HeavySnowStorm),
                "BLOWING_SNOW" => Some(Self::BlowingSnow),
                "RAIN_AND_SNOW" => Some(Self::RainAndSnow),
                "HAIL" => Some(Self::Hail),
                "HAIL_SHOWERS" => Some(Self::HailShowers),
                "THUNDERSTORM" => Some(Self::Thunderstorm),
                "THUNDERSHOWER" => Some(Self::Thundershower),
                "LIGHT_THUNDERSTORM_RAIN" => Some(Self::LightThunderstormRain),
                "SCATTERED_THUNDERSTORMS" => Some(Self::ScatteredThunderstorms),
                "HEAVY_THUNDERSTORM" => Some(Self::HeavyThunderstorm),
                _ => None,
            }
        }
    }
}
/// Represents a set of wind properties.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Wind {
    /// The direction of the wind, the angle it is coming from.
    #[prost(message, optional, tag = "1")]
    pub direction: ::core::option::Option<WindDirection>,
    /// The speed of the wind.
    #[prost(message, optional, tag = "2")]
    pub speed: ::core::option::Option<WindSpeed>,
    /// The wind gust (sudden increase in the wind speed).
    #[prost(message, optional, tag = "3")]
    pub gust: ::core::option::Option<WindSpeed>,
}
/// Represents the direction from which the wind originates.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindDirection {
    /// The direction of the wind in degrees (values from 0 to 360).
    #[prost(int32, optional, tag = "1")]
    pub degrees: ::core::option::Option<i32>,
    /// The code that represents the cardinal direction from which the wind is
    /// blowing.
    #[prost(enumeration = "CardinalDirection", tag = "2")]
    pub cardinal: i32,
}
/// Represents the speed of the wind.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindSpeed {
    /// The value of the wind speed.
    #[prost(float, optional, tag = "1")]
    pub value: ::core::option::Option<f32>,
    /// The code that represents the unit used to measure the wind speed.
    #[prost(enumeration = "SpeedUnit", tag = "2")]
    pub unit: i32,
}
/// Represents a cardinal direction (including ordinal directions).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CardinalDirection {
    /// The cardinal direction is unspecified.
    Unspecified = 0,
    /// The north cardinal direction.
    North = 1,
    /// The north-northeast secondary intercardinal direction.
    NorthNortheast = 2,
    /// The northeast intercardinal direction.
    Northeast = 3,
    /// The east-northeast secondary intercardinal direction.
    EastNortheast = 4,
    /// The east cardinal direction.
    East = 5,
    /// The east-southeast secondary intercardinal direction.
    EastSoutheast = 6,
    /// The southeast intercardinal direction.
    Southeast = 7,
    /// The south-southeast secondary intercardinal direction.
    SouthSoutheast = 8,
    /// The south cardinal direction.
    South = 9,
    /// The south-southwest secondary intercardinal direction.
    SouthSouthwest = 10,
    /// The southwest intercardinal direction.
    Southwest = 11,
    /// The west-southwest secondary intercardinal direction.
    WestSouthwest = 12,
    /// The west cardinal direction.
    West = 13,
    /// The west-northwest secondary intercardinal direction.
    WestNorthwest = 14,
    /// The northwest intercardinal direction.
    Northwest = 15,
    /// The north-northwest secondary intercardinal direction.
    NorthNorthwest = 16,
}
impl CardinalDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CARDINAL_DIRECTION_UNSPECIFIED",
            Self::North => "NORTH",
            Self::NorthNortheast => "NORTH_NORTHEAST",
            Self::Northeast => "NORTHEAST",
            Self::EastNortheast => "EAST_NORTHEAST",
            Self::East => "EAST",
            Self::EastSoutheast => "EAST_SOUTHEAST",
            Self::Southeast => "SOUTHEAST",
            Self::SouthSoutheast => "SOUTH_SOUTHEAST",
            Self::South => "SOUTH",
            Self::SouthSouthwest => "SOUTH_SOUTHWEST",
            Self::Southwest => "SOUTHWEST",
            Self::WestSouthwest => "WEST_SOUTHWEST",
            Self::West => "WEST",
            Self::WestNorthwest => "WEST_NORTHWEST",
            Self::Northwest => "NORTHWEST",
            Self::NorthNorthwest => "NORTH_NORTHWEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CARDINAL_DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "NORTH" => Some(Self::North),
            "NORTH_NORTHEAST" => Some(Self::NorthNortheast),
            "NORTHEAST" => Some(Self::Northeast),
            "EAST_NORTHEAST" => Some(Self::EastNortheast),
            "EAST" => Some(Self::East),
            "EAST_SOUTHEAST" => Some(Self::EastSoutheast),
            "SOUTHEAST" => Some(Self::Southeast),
            "SOUTH_SOUTHEAST" => Some(Self::SouthSoutheast),
            "SOUTH" => Some(Self::South),
            "SOUTH_SOUTHWEST" => Some(Self::SouthSouthwest),
            "SOUTHWEST" => Some(Self::Southwest),
            "WEST_SOUTHWEST" => Some(Self::WestSouthwest),
            "WEST" => Some(Self::West),
            "WEST_NORTHWEST" => Some(Self::WestNorthwest),
            "NORTHWEST" => Some(Self::Northwest),
            "NORTH_NORTHWEST" => Some(Self::NorthNorthwest),
            _ => None,
        }
    }
}
/// Represents the unit used to measure speed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpeedUnit {
    /// The speed unit is unspecified.
    Unspecified = 0,
    /// The speed is measured in kilometers per hour.
    KilometersPerHour = 1,
    /// The speed is measured in miles per hour.
    MilesPerHour = 2,
}
impl SpeedUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SPEED_UNIT_UNSPECIFIED",
            Self::KilometersPerHour => "KILOMETERS_PER_HOUR",
            Self::MilesPerHour => "MILES_PER_HOUR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPEED_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "KILOMETERS_PER_HOUR" => Some(Self::KilometersPerHour),
            "MILES_PER_HOUR" => Some(Self::MilesPerHour),
            _ => None,
        }
    }
}
/// Represents a daily forecast record at a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastDay {
    /// The UTC time interval when this forecasted day is starts (inclusive) and
    /// ends (exclusive).
    /// Note: a day starts at 7am and ends at 7am next day, local time.
    /// For example: If the local time zone is UTC-7, then the interval will start
    /// at the time `14:00:00.000Z` and end at the same hour the next day.
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The local date in the time zone of the location (civil time) which this
    /// daily forecast is calculated for. This field may be used for display
    /// purposes on the client.
    #[prost(message, optional, tag = "2")]
    pub display_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// The forecasted weather conditions for the daytime part of the day (7am to
    /// 7pm local time).
    #[prost(message, optional, tag = "3")]
    pub daytime_forecast: ::core::option::Option<ForecastDayPart>,
    /// The forecasted weather conditions for the nighttime part of the day (7pm to
    /// 7am next day, local time).
    #[prost(message, optional, tag = "4")]
    pub nighttime_forecast: ::core::option::Option<ForecastDayPart>,
    /// The maximum (high) temperature throughout the day.
    #[prost(message, optional, tag = "5")]
    pub max_temperature: ::core::option::Option<Temperature>,
    /// The minimum (low) temperature throughout the day.
    #[prost(message, optional, tag = "6")]
    pub min_temperature: ::core::option::Option<Temperature>,
    /// The maximum (high) feels-like temperature throughout the day.
    #[prost(message, optional, tag = "7")]
    pub feels_like_max_temperature: ::core::option::Option<Temperature>,
    /// The minimum (low) feels-like temperature throughout the day.
    #[prost(message, optional, tag = "8")]
    pub feels_like_min_temperature: ::core::option::Option<Temperature>,
    /// The maximum heat index temperature throughout the day.
    #[prost(message, optional, tag = "11")]
    pub max_heat_index: ::core::option::Option<Temperature>,
    /// The events related to the sun (e.g. sunrise, sunset).
    #[prost(message, optional, tag = "9")]
    pub sun_events: ::core::option::Option<SunEvents>,
    /// The events related to the moon (e.g. moonrise, moonset).
    #[prost(message, optional, tag = "10")]
    pub moon_events: ::core::option::Option<MoonEvents>,
}
/// Represents a forecast record for a part of the day.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastDayPart {
    /// The UTC date and time when this part of the day starts (inclusive) and ends
    /// (exclusive).
    /// Note: a part of a day starts at 7am and ends at 7pm the same day, local
    /// time. For example: If the local time zone is UTC-7, then the daytime
    /// interval will start at the time `14:00:00.000Z` and end at `02:00:00.000Z`
    /// the next day and the nighttime interval will start at `02:00:00.000Z` the
    /// next day and end at `14:00:00.000Z` that same day.
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The forecasted weather condition.
    #[prost(message, optional, tag = "2")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The forecasted percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "3")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The maximum forecasted ultraviolet (UV) index.
    #[prost(int32, optional, tag = "4")]
    pub uv_index: ::core::option::Option<i32>,
    /// The forecasted precipitation.
    #[prost(message, optional, tag = "5")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The average thunderstorm probability.
    #[prost(int32, optional, tag = "6")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The average wind direction and maximum speed and gust.
    #[prost(message, optional, tag = "7")]
    pub wind: ::core::option::Option<Wind>,
    /// Average cloud cover percent.
    #[prost(int32, optional, tag = "8")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The accumulated amount of ice for the part of the day.
    #[prost(message, optional, tag = "9")]
    pub ice_thickness: ::core::option::Option<IceThickness>,
}
/// Represents visibility conditions, the distance at which objects can be
/// discerned.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Visibility {
    /// The visibility distance in the specified unit.
    #[prost(float, optional, tag = "1")]
    pub distance: ::core::option::Option<f32>,
    /// The code that represents the unit used to measure the distance.
    #[prost(enumeration = "visibility::Unit", tag = "2")]
    pub unit: i32,
}
/// Nested message and enum types in `Visibility`.
pub mod visibility {
    /// Represents the unit used to measure the visibility distance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// The visibility unit is unspecified.
        Unspecified = 0,
        /// The visibility is measured in kilometers.
        Kilometers = 1,
        /// The visibility is measured in miles.
        Miles = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Kilometers => "KILOMETERS",
                Self::Miles => "MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "KILOMETERS" => Some(Self::Kilometers),
                "MILES" => Some(Self::Miles),
                _ => None,
            }
        }
    }
}
/// Represents an hourly forecast record at a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastHour {
    /// The one hour interval (in UTC time) this forecast data is valid for (the
    /// timestamps are rounded down to the closest hour).
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The local date and time in the time zone of the location (civil time) which
    /// this hourly forecast is calculated for. This field may be used for display
    /// purposes on the client.
    /// Note: this date will consist of the year, month, day, hour and offset from
    /// UTC.
    #[prost(message, optional, tag = "2")]
    pub display_date_time: ::core::option::Option<super::super::super::r#type::DateTime>,
    /// True if this hour is between the local sunrise (inclusive) and sunset
    /// (exclusive) times. Otherwise, it is nighttime (between the sunset and the
    /// next sunrise).
    /// Note: this hour will be considered as daytime or nighttime if the interval
    /// intersects with the local sunrise and sunset times respectively (e.g.: if
    /// the interval is from 5am to 6am and sunrise is at 5:59am, then is_daytime
    /// will be true).
    #[prost(bool, optional, tag = "3")]
    pub is_daytime: ::core::option::Option<bool>,
    /// The foreacasted weather condition.
    #[prost(message, optional, tag = "4")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The forecasted temperature.
    #[prost(message, optional, tag = "5")]
    pub temperature: ::core::option::Option<Temperature>,
    /// The measure of how the temperature will feel like at the requested
    /// location.
    #[prost(message, optional, tag = "6")]
    pub feels_like_temperature: ::core::option::Option<Temperature>,
    /// The forecasted dew point temperature.
    #[prost(message, optional, tag = "7")]
    pub dew_point: ::core::option::Option<Temperature>,
    /// The forecasted heat index temperature.
    #[prost(message, optional, tag = "8")]
    pub heat_index: ::core::option::Option<Temperature>,
    /// The forecasted wind chill, air temperature exposed on the skin.
    #[prost(message, optional, tag = "9")]
    pub wind_chill: ::core::option::Option<Temperature>,
    /// The forecasted wet bulb temperature, lowest temperature achievable by
    /// evaporating water.
    #[prost(message, optional, tag = "10")]
    pub wet_bulb_temperature: ::core::option::Option<Temperature>,
    /// The forecasted percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "11")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The forecasted ultraviolet (UV) index.
    #[prost(int32, optional, tag = "12")]
    pub uv_index: ::core::option::Option<i32>,
    /// The forecasted precipitation probability and amount of precipitation
    /// accumulated over the last hour.
    #[prost(message, optional, tag = "13")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The forecasted thunderstorm probability (values from 0 to 100).
    #[prost(int32, optional, tag = "14")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The forecasted air pressure conditions.
    #[prost(message, optional, tag = "15")]
    pub air_pressure: ::core::option::Option<AirPressure>,
    /// The forecasted wind conditions.
    #[prost(message, optional, tag = "16")]
    pub wind: ::core::option::Option<Wind>,
    /// The forecasted visibility.
    #[prost(message, optional, tag = "17")]
    pub visibility: ::core::option::Option<Visibility>,
    /// The forecasted percentage of the sky covered by clouds (values from 0 to
    /// 100).
    #[prost(int32, optional, tag = "18")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The forecasted ice thickness.
    #[prost(message, optional, tag = "19")]
    pub ice_thickness: ::core::option::Option<IceThickness>,
}
/// Represents an hourly history record at a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryHour {
    /// The one hour interval (in UTC time) this historical data is valid for (the
    /// timestamps are rounded down to the closest hour).
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The local date and time in the time zone of the location (civil time) which
    /// this hourly record is calculated for. This field may be used for display
    /// purposes on the client.
    /// Note: this date will consist of the year, month, day, hour and offset from
    /// UTC.
    #[prost(message, optional, tag = "2")]
    pub display_date_time: ::core::option::Option<super::super::super::r#type::DateTime>,
    /// True if this hour is between the local sunrise (inclusive) and sunset
    /// (exclusive) times. Otherwise, it is nighttime (between the sunset and the
    /// next sunrise).
    /// Note: this hour will be considered as daytime or nighttime if the interval
    /// intersects with the local sunrise and sunset times respectively (e.g.: if
    /// the interval is from 5am to 6am and sunrise is at 5:59am, then is_daytime
    /// will be true).
    #[prost(bool, optional, tag = "3")]
    pub is_daytime: ::core::option::Option<bool>,
    /// The historical weather condition.
    #[prost(message, optional, tag = "4")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The historical temperature.
    #[prost(message, optional, tag = "5")]
    pub temperature: ::core::option::Option<Temperature>,
    /// The measure of how the temperature felt like at the requested
    /// location.
    #[prost(message, optional, tag = "6")]
    pub feels_like_temperature: ::core::option::Option<Temperature>,
    /// The historical dew point temperature.
    #[prost(message, optional, tag = "7")]
    pub dew_point: ::core::option::Option<Temperature>,
    /// The historical heat index temperature.
    #[prost(message, optional, tag = "8")]
    pub heat_index: ::core::option::Option<Temperature>,
    /// The historical wind chill, air temperature exposed on the skin.
    #[prost(message, optional, tag = "9")]
    pub wind_chill: ::core::option::Option<Temperature>,
    /// The historical wet bulb temperature, lowest temperature achievable by
    /// evaporating water.
    #[prost(message, optional, tag = "10")]
    pub wet_bulb_temperature: ::core::option::Option<Temperature>,
    /// The historical percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "11")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The historical ultraviolet (UV) index.
    #[prost(int32, optional, tag = "12")]
    pub uv_index: ::core::option::Option<i32>,
    /// The historical precipitation probability and amount of precipitation
    /// accumulated over the last hour.
    #[prost(message, optional, tag = "13")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The historical thunderstorm probability (values from 0 to 100).
    #[prost(int32, optional, tag = "14")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The historical air pressure conditions.
    #[prost(message, optional, tag = "15")]
    pub air_pressure: ::core::option::Option<AirPressure>,
    /// The historical wind conditions.
    #[prost(message, optional, tag = "16")]
    pub wind: ::core::option::Option<Wind>,
    /// The historical visibility.
    #[prost(message, optional, tag = "17")]
    pub visibility: ::core::option::Option<Visibility>,
    /// The historical percentage of the sky covered by clouds (values from 0 to
    /// 100).
    #[prost(int32, optional, tag = "18")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The historical ice thickness.
    #[prost(message, optional, tag = "19")]
    pub ice_thickness: ::core::option::Option<IceThickness>,
}
/// Represents the units system used to measure values.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnitsSystem {
    /// The units system is unspecified.
    Unspecified = 0,
    /// The imperial units system (e.g. Fahrenheit, miles, etc).
    Imperial = 1,
    /// The metric units system (e.g. Celsius, kilometers, etc).
    Metric = 2,
}
impl UnitsSystem {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNITS_SYSTEM_UNSPECIFIED",
            Self::Imperial => "IMPERIAL",
            Self::Metric => "METRIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNITS_SYSTEM_UNSPECIFIED" => Some(Self::Unspecified),
            "IMPERIAL" => Some(Self::Imperial),
            "METRIC" => Some(Self::Metric),
            _ => None,
        }
    }
}
/// Request for the LookupCurrentConditions RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupCurrentConditionsRequest {
    /// Required. The location to get the current weather conditions for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "2")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "3")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response for the LookupCurrentConditions RPC - represents the current weather
/// conditions at the requested location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupCurrentConditionsResponse {
    /// Current time (UTC) associated with the returned data.
    #[prost(message, optional, tag = "1")]
    pub current_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// True if the current time at the requested location is between the local
    /// sunrise (inclusive) and the sunset (exclusive) times. Otherwise, it is
    /// nighttime (between the sunset and the next sunrise).
    #[prost(bool, optional, tag = "3")]
    pub is_daytime: ::core::option::Option<bool>,
    /// The current weather condition.
    #[prost(message, optional, tag = "4")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The current temperature.
    #[prost(message, optional, tag = "5")]
    pub temperature: ::core::option::Option<Temperature>,
    /// The measure of how the temperature currently feels like at the requested
    /// location.
    #[prost(message, optional, tag = "6")]
    pub feels_like_temperature: ::core::option::Option<Temperature>,
    /// The current dew point temperature.
    #[prost(message, optional, tag = "7")]
    pub dew_point: ::core::option::Option<Temperature>,
    /// The current heat index temperature.
    #[prost(message, optional, tag = "8")]
    pub heat_index: ::core::option::Option<Temperature>,
    /// The current wind chill, air temperature exposed on the skin.
    #[prost(message, optional, tag = "9")]
    pub wind_chill: ::core::option::Option<Temperature>,
    /// The current percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "10")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The current ultraviolet (UV) index.
    #[prost(int32, optional, tag = "11")]
    pub uv_index: ::core::option::Option<i32>,
    /// The current precipitation probability and amount of precipitation
    /// accumulated over the last hour.
    #[prost(message, optional, tag = "12")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The current thunderstorm probability (values from 0 to 100).
    #[prost(int32, optional, tag = "13")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The current air pressure conditions.
    #[prost(message, optional, tag = "14")]
    pub air_pressure: ::core::option::Option<AirPressure>,
    /// The current wind conditions.
    #[prost(message, optional, tag = "15")]
    pub wind: ::core::option::Option<Wind>,
    /// The current visibility.
    #[prost(message, optional, tag = "16")]
    pub visibility: ::core::option::Option<Visibility>,
    /// The current percentage of the sky covered by clouds (values from 0 to 100).
    #[prost(int32, optional, tag = "17")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The changes in the current conditions over the last 24 hours.
    #[prost(message, optional, tag = "18")]
    pub current_conditions_history: ::core::option::Option<
        lookup_current_conditions_response::CurrentConditionsHistory,
    >,
}
/// Nested message and enum types in `LookupCurrentConditionsResponse`.
pub mod lookup_current_conditions_response {
    /// Represents a set of changes in the current conditions over the last 24
    /// hours.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CurrentConditionsHistory {
        /// The current temperature minus the temperature 24 hours ago.
        #[prost(message, optional, tag = "1")]
        pub temperature_change: ::core::option::Option<super::Temperature>,
        /// The maximum (high) temperature in the past 24 hours.
        #[prost(message, optional, tag = "2")]
        pub max_temperature: ::core::option::Option<super::Temperature>,
        /// The minimum (low) temperature in the past 24 hours.
        #[prost(message, optional, tag = "3")]
        pub min_temperature: ::core::option::Option<super::Temperature>,
        /// The amount of snow, measured as liquid water equivalent,
        /// that has accumulated over the last 24 hours.
        /// Note: QPF is an abbreviation for Quantitative Precipitation Forecast
        /// (please see the QuantitativePrecipitationForecast definition for more
        /// details).
        #[prost(message, optional, tag = "5")]
        pub snow_qpf: ::core::option::Option<super::QuantitativePrecipitationForecast>,
        /// The amount of rain, measured as liquid water equivalent, that has
        /// accumulated over the last 24 hours. Note: QPF is an abbreviation for
        /// Quantitative Precipitation Forecast (please see the
        /// QuantitativePrecipitationForecast definition for more details).
        #[prost(message, optional, tag = "6")]
        pub qpf: ::core::option::Option<super::QuantitativePrecipitationForecast>,
    }
}
/// Request for the LookupForecastHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastHoursRequest {
    /// Required. The location to get the hourly forecast for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Limits the amount of total hours to fetch starting from the
    /// current hour - a value from 1 to 240 (inclusive). The default is the
    /// maximum allowed value of 240.
    #[prost(int32, optional, tag = "2")]
    pub hours: ::core::option::Option<i32>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "3")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "4")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of hourly forecast records to return per page
    /// - a value from 1 to 24 (inclusive). The default is the maximum allowed
    /// value of 24.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token received from a previous request. It is used to
    /// retrieve the subsequent page.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupForecastHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastHoursResponse {
    /// The hourly forecast records, according to the number of hours and page size
    /// specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub forecast_hours: ::prost::alloc::vec::Vec<ForecastHour>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// The token to retrieve the next page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for the LookupForecastDays RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastDaysRequest {
    /// Required. The location to get the daily forecast for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Limits the amount of total days to fetch starting from the
    /// current day - a value from 1 to 10 (inclusive). The default value is the
    /// maximum allowed value of 10.
    #[prost(int32, optional, tag = "2")]
    pub days: ::core::option::Option<i32>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "3")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "4")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of daily forecast records to return per page -
    /// a value from 1 to 10 (inclusive). The default value is 5.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token received from a previous request. It is used to
    /// retrieve the subsequent page.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupForecastDays RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastDaysResponse {
    /// The daily forecast records, according to the number of days and page size
    /// specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub forecast_days: ::prost::alloc::vec::Vec<ForecastDay>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// The token to retrieve the next page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for the LookupHistoryHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupHistoryHoursRequest {
    /// Required. The location to get the hourly historical data for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Limits the amount of total hours to fetch starting from the last
    /// hour - a from 1 to 24 (inclusive). The default is the maximum allowed value
    /// of 24.
    #[prost(int32, optional, tag = "2")]
    pub hours: ::core::option::Option<i32>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "3")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "4")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of hourly historical records to return per
    /// page - a value from 1 to 24 (inclusive). The default is the maximum allowed
    /// value of 24.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token received from a previous request. It is used to
    /// retrieve the subsequent page.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupHistoryHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupHistoryHoursResponse {
    /// The hourly historical records, according to the number of hours and page
    /// size specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub history_hours: ::prost::alloc::vec::Vec<HistoryHour>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// The token to retrieve the next page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod weather_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service definition for the Weather API.
    #[derive(Debug, Clone)]
    pub struct WeatherClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WeatherClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WeatherClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WeatherClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WeatherClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the current weather conditions at a given location.
        pub async fn lookup_current_conditions(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupCurrentConditionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupCurrentConditionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupCurrentConditions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupCurrentConditions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns up to 240 hours of hourly forecasts at a given location, starting
        /// from the current hour.
        pub async fn lookup_forecast_hours(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupForecastHoursRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupForecastHoursResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupForecastHours",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupForecastHours",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns up to 10 days of daily forecasts at a given location, starting from
        /// the current day.
        pub async fn lookup_forecast_days(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupForecastDaysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupForecastDaysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupForecastDays",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupForecastDays",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns up to 24 hours of hourly historical weather data at a given
        /// location, starting from the last hour.
        pub async fn lookup_history_hours(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupHistoryHoursRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupHistoryHoursResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupHistoryHours",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupHistoryHours",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
