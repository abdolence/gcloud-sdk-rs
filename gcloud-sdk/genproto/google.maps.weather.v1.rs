// This file is @generated by prost-build.
/// Represents the atmospheric air pressure conditions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AirPressure {
    /// The mean sea level air pressure in millibars.
    #[prost(float, optional, tag = "1")]
    pub mean_sea_level_millibars: ::core::option::Option<f32>,
}
/// Represents the events related to the sun (e.g. sunrise, sunset).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SunEvents {
    /// The time when the sun rises.
    ///
    /// NOTE: In some unique cases (e.g. north of the artic circle) there may be no
    /// sunrise time for a day. In these cases, this field will be unset.
    #[prost(message, optional, tag = "1")]
    pub sunrise_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time when the sun sets.
    ///
    /// NOTE: In some unique cases (e.g. north of the artic circle) there may be no
    /// sunset time for a day. In these cases, this field will be unset.
    #[prost(message, optional, tag = "2")]
    pub sunset_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Represents the events related to the moon (e.g. moonrise, moonset).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoonEvents {
    /// The time when the upper limb of the moon appears above the horizon
    /// (see <https://en.wikipedia.org/wiki/Moonrise_and_moonset>).
    ///
    /// NOTE: For most cases, there'll be a single moon rise time per day. In other
    /// cases, the list might be empty (e.g. when the moon rises after next day
    /// midnight).
    /// However, in unique cases (e.g. in polar regions), the list may contain
    /// more than one value. In these cases, the values are sorted in ascending
    /// order.
    #[prost(message, repeated, tag = "4")]
    pub moonrise_times: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    /// The time when the upper limb of the moon disappears below the
    /// horizon (see <https://en.wikipedia.org/wiki/Moonrise_and_moonset>).
    ///
    /// NOTE: For most cases, there'll be a single moon set time per day. In other
    /// cases, the list might be empty (e.g. when the moon sets after next day
    /// midnight).
    /// However, in unique cases (e.g. in polar regions), the list may contain
    /// more than one value. In these cases, the values are sorted in ascending
    /// order.
    #[prost(message, repeated, tag = "5")]
    pub moonset_times: ::prost::alloc::vec::Vec<::prost_types::Timestamp>,
    /// The moon phase (a.k.a. lunar phase).
    #[prost(enumeration = "MoonPhase", tag = "3")]
    pub moon_phase: i32,
}
/// Marks the moon phase (a.k.a. lunar phase).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MoonPhase {
    /// Unspecified moon phase.
    Unspecified = 0,
    /// The moon is not illuminated by the sun.
    NewMoon = 1,
    /// The moon is lit by 0%-50% on its right side in the northern hemisphere ðŸŒ’
    /// and on its left side in the southern hemisphere ðŸŒ˜.
    WaxingCrescent = 2,
    /// The moon is lit by 50.1% on its right side in the northern hemisphere ðŸŒ“
    /// and on its left side in the southern hemisphere ðŸŒ—.
    FirstQuarter = 3,
    /// The moon is lit by 50%-100% on its right side in the northern hemisphere ðŸŒ”
    /// and on its left side in the southern hemisphere ðŸŒ–.
    WaxingGibbous = 4,
    /// The moon is fully illuminated.
    FullMoon = 5,
    /// The moon is lit by 50%-100% on its left side in the northern hemisphere ðŸŒ–
    /// and on its right side in the southern hemisphere ðŸŒ”.
    WaningGibbous = 6,
    /// The moon is lit by 50.1% on its left side in the northern hemisphere ðŸŒ—
    /// and on its right side in the southern hemisphere ðŸŒ“.
    LastQuarter = 7,
    /// The moon is lit by 0%-50% on its left side in the northern hemisphere ðŸŒ˜
    /// and on its right side in the southern hemisphere ðŸŒ’.
    WaningCrescent = 8,
}
impl MoonPhase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MOON_PHASE_UNSPECIFIED",
            Self::NewMoon => "NEW_MOON",
            Self::WaxingCrescent => "WAXING_CRESCENT",
            Self::FirstQuarter => "FIRST_QUARTER",
            Self::WaxingGibbous => "WAXING_GIBBOUS",
            Self::FullMoon => "FULL_MOON",
            Self::WaningGibbous => "WANING_GIBBOUS",
            Self::LastQuarter => "LAST_QUARTER",
            Self::WaningCrescent => "WANING_CRESCENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MOON_PHASE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEW_MOON" => Some(Self::NewMoon),
            "WAXING_CRESCENT" => Some(Self::WaxingCrescent),
            "FIRST_QUARTER" => Some(Self::FirstQuarter),
            "WAXING_GIBBOUS" => Some(Self::WaxingGibbous),
            "FULL_MOON" => Some(Self::FullMoon),
            "WANING_GIBBOUS" => Some(Self::WaningGibbous),
            "LAST_QUARTER" => Some(Self::LastQuarter),
            "WANING_CRESCENT" => Some(Self::WaningCrescent),
            _ => None,
        }
    }
}
/// Represents ice thickness conditions.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IceThickness {
    /// The ice thickness value.
    #[prost(float, optional, tag = "1")]
    pub thickness: ::core::option::Option<f32>,
    /// The code that represents the unit used to measure the ice thickness.
    #[prost(enumeration = "ice_thickness::Unit", tag = "2")]
    pub unit: i32,
}
/// Nested message and enum types in `IceThickness`.
pub mod ice_thickness {
    /// Represents the unit used to measure the ice thickness.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// The unit is not specified.
        Unspecified = 0,
        /// The thickness is measured in millimeters.
        Millimeters = 1,
        /// The thickness is measured in inches.
        Inches = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Millimeters => "MILLIMETERS",
                Self::Inches => "INCHES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MILLIMETERS" => Some(Self::Millimeters),
                "INCHES" => Some(Self::Inches),
                _ => None,
            }
        }
    }
}
/// Represents a set of precipitation values at a given location.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Precipitation {
    /// The probability of precipitation (values from 0 to 100).
    #[prost(message, optional, tag = "1")]
    pub probability: ::core::option::Option<PrecipitationProbability>,
    /// The amount of snow, measured as liquid water equivalent, that has
    /// accumulated over a period of time. Note: QPF is an abbreviation for
    /// Quantitative Precipitation Forecast (please see the
    /// QuantitativePrecipitationForecast definition for more details).
    #[prost(message, optional, tag = "3")]
    pub snow_qpf: ::core::option::Option<QuantitativePrecipitationForecast>,
    /// The amount of rain, measured as liquid water equivalent, that has
    /// accumulated over a period of time. Note: QPF is an abbreviation for
    /// Quantitative Precipitation Forecast (please see the
    /// QuantitativePrecipitationForecast definition for more details).
    #[prost(message, optional, tag = "4")]
    pub qpf: ::core::option::Option<QuantitativePrecipitationForecast>,
}
/// Represents the probability of precipitation at a given location.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrecipitationProbability {
    /// A percentage from 0 to 100 that indicates the chances of precipitation.
    #[prost(int32, optional, tag = "1")]
    pub percent: ::core::option::Option<i32>,
    /// A code that indicates the type of precipitation.
    #[prost(enumeration = "PrecipitationType", tag = "2")]
    pub r#type: i32,
}
/// Represents the expected amount of melted precipitation accumulated over a
/// specified time period over a specified area (reference:
/// <https://en.wikipedia.org/wiki/Quantitative_precipitation_forecast>) -
/// usually abbreviated QPF for short.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuantitativePrecipitationForecast {
    /// The amount of precipitation, measured as liquid water equivalent, that has
    /// accumulated over a period of time.
    #[prost(float, optional, tag = "1")]
    pub quantity: ::core::option::Option<f32>,
    /// The code of the unit used to measure the amount of accumulated
    /// precipitation.
    #[prost(enumeration = "quantitative_precipitation_forecast::Unit", tag = "2")]
    pub unit: i32,
}
/// Nested message and enum types in `QuantitativePrecipitationForecast`.
pub mod quantitative_precipitation_forecast {
    /// Represents the unit used to measure the amount of accumulated
    /// precipitation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// Unspecified precipitation unit.
        Unspecified = 0,
        /// The amount of precipitation is measured in millimeters.
        Millimeters = 3,
        /// The amount of precipitation is measured in inches.
        Inches = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Millimeters => "MILLIMETERS",
                Self::Inches => "INCHES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MILLIMETERS" => Some(Self::Millimeters),
                "INCHES" => Some(Self::Inches),
                _ => None,
            }
        }
    }
}
/// Represents the type of precipitation at a given location.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PrecipitationType {
    /// Unspecified precipitation type.
    Unspecified = 0,
    /// No precipitation.
    None = 8,
    /// Snow precipitation.
    Snow = 1,
    /// Rain precipitation.
    Rain = 2,
    /// Light rain precipitation.
    LightRain = 3,
    /// Heavy rain precipitation.
    HeavyRain = 4,
    /// Both rain and snow precipitations.
    RainAndSnow = 5,
    /// Sleet precipitation.
    Sleet = 6,
    /// Freezing rain precipitation.
    FreezingRain = 7,
}
impl PrecipitationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRECIPITATION_TYPE_UNSPECIFIED",
            Self::None => "NONE",
            Self::Snow => "SNOW",
            Self::Rain => "RAIN",
            Self::LightRain => "LIGHT_RAIN",
            Self::HeavyRain => "HEAVY_RAIN",
            Self::RainAndSnow => "RAIN_AND_SNOW",
            Self::Sleet => "SLEET",
            Self::FreezingRain => "FREEZING_RAIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRECIPITATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NONE" => Some(Self::None),
            "SNOW" => Some(Self::Snow),
            "RAIN" => Some(Self::Rain),
            "LIGHT_RAIN" => Some(Self::LightRain),
            "HEAVY_RAIN" => Some(Self::HeavyRain),
            "RAIN_AND_SNOW" => Some(Self::RainAndSnow),
            "SLEET" => Some(Self::Sleet),
            "FREEZING_RAIN" => Some(Self::FreezingRain),
            _ => None,
        }
    }
}
/// Represents a temperature value.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Temperature {
    /// The temperature value (in degrees) in the specified unit.
    #[prost(float, optional, tag = "1")]
    pub degrees: ::core::option::Option<f32>,
    /// The code for the unit used to measure the temperature value.
    #[prost(enumeration = "TemperatureUnit", tag = "2")]
    pub unit: i32,
}
/// Represents a unit used to measure temperatures.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TemperatureUnit {
    /// The temperature unit is unspecified.
    Unspecified = 0,
    /// The temperature is measured in Celsius.
    Celsius = 1,
    /// The temperature is measured in Fahrenheit.
    Fahrenheit = 2,
}
impl TemperatureUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TEMPERATURE_UNIT_UNSPECIFIED",
            Self::Celsius => "CELSIUS",
            Self::Fahrenheit => "FAHRENHEIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TEMPERATURE_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "CELSIUS" => Some(Self::Celsius),
            "FAHRENHEIT" => Some(Self::Fahrenheit),
            _ => None,
        }
    }
}
/// Represents a weather condition for a given location at a given period of
/// time.
///
/// Disclaimer: Weather icons and condition codes are subject to change. Google
/// may introduce new codes and icons or update existing ones as needed. We
/// encourage you to refer to this documentation regularly for the most
/// up-to-date information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WeatherCondition {
    /// The base URI for the icon not including the file type extension. To display
    /// the icon, append a theme if desired and the file type extension (`.png` or
    /// `.svg`) to this URI. By default, the icon is light themed, but `_dark` can
    /// be appended for dark mode. For example:
    /// "<https://maps.gstatic.com/weather/v1/dust.svg"> or
    /// "<https://maps.gstatic.com/weather/v1/dust_dark.svg",> where `icon_base_uri`
    /// is "<https://maps.gstatic.com/weather/v1/dust".>
    #[prost(string, tag = "1")]
    pub icon_base_uri: ::prost::alloc::string::String,
    /// The textual description for this weather condition (localized).
    #[prost(message, optional, tag = "2")]
    pub description: ::core::option::Option<super::super::super::r#type::LocalizedText>,
    /// The type of weather condition.
    #[prost(enumeration = "weather_condition::Type", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `WeatherCondition`.
pub mod weather_condition {
    /// Marks the weather condition type in a forecast element's context.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// The weather condition is unspecified.
        Unspecified = 0,
        /// No clouds.
        Clear = 1,
        /// Periodic clouds.
        MostlyClear = 2,
        /// Party cloudy (some clouds).
        PartlyCloudy = 3,
        /// Mostly cloudy (more clouds than sun).
        MostlyCloudy = 4,
        /// Cloudy (all clouds, no sun).
        Cloudy = 5,
        /// High wind.
        Windy = 6,
        /// High wind with precipitation.
        WindAndRain = 7,
        /// Light intermittent rain.
        LightRainShowers = 8,
        /// Chance of intermittent rain.
        ChanceOfShowers = 9,
        /// Intermittent rain.
        ScatteredShowers = 10,
        /// Showers are considered to be rainfall that has a shorter duration than
        /// rain, and is characterized by suddenness in terms of start and stop
        /// times, and rapid changes in intensity.
        RainShowers = 12,
        /// Intense showers.
        HeavyRainShowers = 13,
        /// Rain (light to moderate in quantity).
        LightToModerateRain = 14,
        /// Rain (moderate to heavy in quantity).
        ModerateToHeavyRain = 15,
        /// Moderate rain.
        Rain = 16,
        /// Light rain.
        LightRain = 17,
        /// Heavy rain.
        HeavyRain = 18,
        /// Rain periodically heavy.
        RainPeriodicallyHeavy = 19,
        /// Light snow that is falling at varying intensities for brief periods of
        /// time.
        LightSnowShowers = 20,
        /// Chance of snow showers.
        ChanceOfSnowShowers = 21,
        /// Snow that is falling at varying intensities for brief periods of time.
        ScatteredSnowShowers = 22,
        /// Snow showers.
        SnowShowers = 23,
        /// Heavy snow showers.
        HeavySnowShowers = 24,
        /// Light to moderate snow.
        LightToModerateSnow = 25,
        /// Moderate to heavy snow.
        ModerateToHeavySnow = 26,
        /// Moderate snow.
        Snow = 27,
        /// Light snow.
        LightSnow = 28,
        /// Heavy snow.
        HeavySnow = 29,
        /// Snow with possible thunder and lightning.
        Snowstorm = 30,
        /// Snow, at times heavy.
        SnowPeriodicallyHeavy = 31,
        /// Heavy snow with possible thunder and lightning.
        HeavySnowStorm = 32,
        /// Snow with intense wind.
        BlowingSnow = 33,
        /// Rain and snow mix.
        RainAndSnow = 34,
        /// Hail.
        Hail = 35,
        /// Hail that is falling at varying intensities for brief periods of time.
        HailShowers = 36,
        /// Thunderstorm.
        Thunderstorm = 37,
        /// A shower of rain accompanied by thunder and lightning.
        Thundershower = 38,
        /// Light thunderstorm rain.
        LightThunderstormRain = 39,
        /// Thunderstorms that has rain in various intensities for brief periods of
        /// time.
        ScatteredThunderstorms = 40,
        /// Heavy thunderstorm.
        HeavyThunderstorm = 41,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Clear => "CLEAR",
                Self::MostlyClear => "MOSTLY_CLEAR",
                Self::PartlyCloudy => "PARTLY_CLOUDY",
                Self::MostlyCloudy => "MOSTLY_CLOUDY",
                Self::Cloudy => "CLOUDY",
                Self::Windy => "WINDY",
                Self::WindAndRain => "WIND_AND_RAIN",
                Self::LightRainShowers => "LIGHT_RAIN_SHOWERS",
                Self::ChanceOfShowers => "CHANCE_OF_SHOWERS",
                Self::ScatteredShowers => "SCATTERED_SHOWERS",
                Self::RainShowers => "RAIN_SHOWERS",
                Self::HeavyRainShowers => "HEAVY_RAIN_SHOWERS",
                Self::LightToModerateRain => "LIGHT_TO_MODERATE_RAIN",
                Self::ModerateToHeavyRain => "MODERATE_TO_HEAVY_RAIN",
                Self::Rain => "RAIN",
                Self::LightRain => "LIGHT_RAIN",
                Self::HeavyRain => "HEAVY_RAIN",
                Self::RainPeriodicallyHeavy => "RAIN_PERIODICALLY_HEAVY",
                Self::LightSnowShowers => "LIGHT_SNOW_SHOWERS",
                Self::ChanceOfSnowShowers => "CHANCE_OF_SNOW_SHOWERS",
                Self::ScatteredSnowShowers => "SCATTERED_SNOW_SHOWERS",
                Self::SnowShowers => "SNOW_SHOWERS",
                Self::HeavySnowShowers => "HEAVY_SNOW_SHOWERS",
                Self::LightToModerateSnow => "LIGHT_TO_MODERATE_SNOW",
                Self::ModerateToHeavySnow => "MODERATE_TO_HEAVY_SNOW",
                Self::Snow => "SNOW",
                Self::LightSnow => "LIGHT_SNOW",
                Self::HeavySnow => "HEAVY_SNOW",
                Self::Snowstorm => "SNOWSTORM",
                Self::SnowPeriodicallyHeavy => "SNOW_PERIODICALLY_HEAVY",
                Self::HeavySnowStorm => "HEAVY_SNOW_STORM",
                Self::BlowingSnow => "BLOWING_SNOW",
                Self::RainAndSnow => "RAIN_AND_SNOW",
                Self::Hail => "HAIL",
                Self::HailShowers => "HAIL_SHOWERS",
                Self::Thunderstorm => "THUNDERSTORM",
                Self::Thundershower => "THUNDERSHOWER",
                Self::LightThunderstormRain => "LIGHT_THUNDERSTORM_RAIN",
                Self::ScatteredThunderstorms => "SCATTERED_THUNDERSTORMS",
                Self::HeavyThunderstorm => "HEAVY_THUNDERSTORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLEAR" => Some(Self::Clear),
                "MOSTLY_CLEAR" => Some(Self::MostlyClear),
                "PARTLY_CLOUDY" => Some(Self::PartlyCloudy),
                "MOSTLY_CLOUDY" => Some(Self::MostlyCloudy),
                "CLOUDY" => Some(Self::Cloudy),
                "WINDY" => Some(Self::Windy),
                "WIND_AND_RAIN" => Some(Self::WindAndRain),
                "LIGHT_RAIN_SHOWERS" => Some(Self::LightRainShowers),
                "CHANCE_OF_SHOWERS" => Some(Self::ChanceOfShowers),
                "SCATTERED_SHOWERS" => Some(Self::ScatteredShowers),
                "RAIN_SHOWERS" => Some(Self::RainShowers),
                "HEAVY_RAIN_SHOWERS" => Some(Self::HeavyRainShowers),
                "LIGHT_TO_MODERATE_RAIN" => Some(Self::LightToModerateRain),
                "MODERATE_TO_HEAVY_RAIN" => Some(Self::ModerateToHeavyRain),
                "RAIN" => Some(Self::Rain),
                "LIGHT_RAIN" => Some(Self::LightRain),
                "HEAVY_RAIN" => Some(Self::HeavyRain),
                "RAIN_PERIODICALLY_HEAVY" => Some(Self::RainPeriodicallyHeavy),
                "LIGHT_SNOW_SHOWERS" => Some(Self::LightSnowShowers),
                "CHANCE_OF_SNOW_SHOWERS" => Some(Self::ChanceOfSnowShowers),
                "SCATTERED_SNOW_SHOWERS" => Some(Self::ScatteredSnowShowers),
                "SNOW_SHOWERS" => Some(Self::SnowShowers),
                "HEAVY_SNOW_SHOWERS" => Some(Self::HeavySnowShowers),
                "LIGHT_TO_MODERATE_SNOW" => Some(Self::LightToModerateSnow),
                "MODERATE_TO_HEAVY_SNOW" => Some(Self::ModerateToHeavySnow),
                "SNOW" => Some(Self::Snow),
                "LIGHT_SNOW" => Some(Self::LightSnow),
                "HEAVY_SNOW" => Some(Self::HeavySnow),
                "SNOWSTORM" => Some(Self::Snowstorm),
                "SNOW_PERIODICALLY_HEAVY" => Some(Self::SnowPeriodicallyHeavy),
                "HEAVY_SNOW_STORM" => Some(Self::HeavySnowStorm),
                "BLOWING_SNOW" => Some(Self::BlowingSnow),
                "RAIN_AND_SNOW" => Some(Self::RainAndSnow),
                "HAIL" => Some(Self::Hail),
                "HAIL_SHOWERS" => Some(Self::HailShowers),
                "THUNDERSTORM" => Some(Self::Thunderstorm),
                "THUNDERSHOWER" => Some(Self::Thundershower),
                "LIGHT_THUNDERSTORM_RAIN" => Some(Self::LightThunderstormRain),
                "SCATTERED_THUNDERSTORMS" => Some(Self::ScatteredThunderstorms),
                "HEAVY_THUNDERSTORM" => Some(Self::HeavyThunderstorm),
                _ => None,
            }
        }
    }
}
/// Represents a set of wind properties.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Wind {
    /// The direction of the wind, the angle it is coming from.
    #[prost(message, optional, tag = "1")]
    pub direction: ::core::option::Option<WindDirection>,
    /// The speed of the wind.
    #[prost(message, optional, tag = "2")]
    pub speed: ::core::option::Option<WindSpeed>,
    /// The wind gust (sudden increase in the wind speed).
    #[prost(message, optional, tag = "3")]
    pub gust: ::core::option::Option<WindSpeed>,
}
/// Represents the direction from which the wind originates.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WindDirection {
    /// The direction of the wind in degrees (values from 0 to 360).
    #[prost(int32, optional, tag = "1")]
    pub degrees: ::core::option::Option<i32>,
    /// The code that represents the cardinal direction from which the wind is
    /// blowing.
    #[prost(enumeration = "CardinalDirection", tag = "2")]
    pub cardinal: i32,
}
/// Represents the speed of the wind.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WindSpeed {
    /// The value of the wind speed.
    #[prost(float, optional, tag = "1")]
    pub value: ::core::option::Option<f32>,
    /// The code that represents the unit used to measure the wind speed.
    #[prost(enumeration = "SpeedUnit", tag = "2")]
    pub unit: i32,
}
/// Represents a cardinal direction (including ordinal directions).
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CardinalDirection {
    /// The cardinal direction is unspecified.
    Unspecified = 0,
    /// The north cardinal direction.
    North = 1,
    /// The north-northeast secondary intercardinal direction.
    NorthNortheast = 2,
    /// The northeast intercardinal direction.
    Northeast = 3,
    /// The east-northeast secondary intercardinal direction.
    EastNortheast = 4,
    /// The east cardinal direction.
    East = 5,
    /// The east-southeast secondary intercardinal direction.
    EastSoutheast = 6,
    /// The southeast intercardinal direction.
    Southeast = 7,
    /// The south-southeast secondary intercardinal direction.
    SouthSoutheast = 8,
    /// The south cardinal direction.
    South = 9,
    /// The south-southwest secondary intercardinal direction.
    SouthSouthwest = 10,
    /// The southwest intercardinal direction.
    Southwest = 11,
    /// The west-southwest secondary intercardinal direction.
    WestSouthwest = 12,
    /// The west cardinal direction.
    West = 13,
    /// The west-northwest secondary intercardinal direction.
    WestNorthwest = 14,
    /// The northwest intercardinal direction.
    Northwest = 15,
    /// The north-northwest secondary intercardinal direction.
    NorthNorthwest = 16,
}
impl CardinalDirection {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CARDINAL_DIRECTION_UNSPECIFIED",
            Self::North => "NORTH",
            Self::NorthNortheast => "NORTH_NORTHEAST",
            Self::Northeast => "NORTHEAST",
            Self::EastNortheast => "EAST_NORTHEAST",
            Self::East => "EAST",
            Self::EastSoutheast => "EAST_SOUTHEAST",
            Self::Southeast => "SOUTHEAST",
            Self::SouthSoutheast => "SOUTH_SOUTHEAST",
            Self::South => "SOUTH",
            Self::SouthSouthwest => "SOUTH_SOUTHWEST",
            Self::Southwest => "SOUTHWEST",
            Self::WestSouthwest => "WEST_SOUTHWEST",
            Self::West => "WEST",
            Self::WestNorthwest => "WEST_NORTHWEST",
            Self::Northwest => "NORTHWEST",
            Self::NorthNorthwest => "NORTH_NORTHWEST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CARDINAL_DIRECTION_UNSPECIFIED" => Some(Self::Unspecified),
            "NORTH" => Some(Self::North),
            "NORTH_NORTHEAST" => Some(Self::NorthNortheast),
            "NORTHEAST" => Some(Self::Northeast),
            "EAST_NORTHEAST" => Some(Self::EastNortheast),
            "EAST" => Some(Self::East),
            "EAST_SOUTHEAST" => Some(Self::EastSoutheast),
            "SOUTHEAST" => Some(Self::Southeast),
            "SOUTH_SOUTHEAST" => Some(Self::SouthSoutheast),
            "SOUTH" => Some(Self::South),
            "SOUTH_SOUTHWEST" => Some(Self::SouthSouthwest),
            "SOUTHWEST" => Some(Self::Southwest),
            "WEST_SOUTHWEST" => Some(Self::WestSouthwest),
            "WEST" => Some(Self::West),
            "WEST_NORTHWEST" => Some(Self::WestNorthwest),
            "NORTHWEST" => Some(Self::Northwest),
            "NORTH_NORTHWEST" => Some(Self::NorthNorthwest),
            _ => None,
        }
    }
}
/// Represents the unit used to measure speed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SpeedUnit {
    /// The speed unit is unspecified.
    Unspecified = 0,
    /// The speed is measured in kilometers per hour.
    KilometersPerHour = 1,
    /// The speed is measured in miles per hour.
    MilesPerHour = 2,
}
impl SpeedUnit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SPEED_UNIT_UNSPECIFIED",
            Self::KilometersPerHour => "KILOMETERS_PER_HOUR",
            Self::MilesPerHour => "MILES_PER_HOUR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SPEED_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "KILOMETERS_PER_HOUR" => Some(Self::KilometersPerHour),
            "MILES_PER_HOUR" => Some(Self::MilesPerHour),
            _ => None,
        }
    }
}
/// Represents a daily forecast record at a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastDay {
    /// The UTC time interval when this forecasted day is starts (inclusive) and
    /// ends (exclusive).
    /// Note: a day starts at 7am and ends at 7am next day, local time.
    /// For example: If the local time zone is UTC-7, then the interval will start
    /// at the time `14:00:00.000Z` and end at the same hour the next day.
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The local date in the time zone of the location (civil time) which this
    /// daily forecast is calculated for. This field may be used for display
    /// purposes on the client.
    #[prost(message, optional, tag = "2")]
    pub display_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// The forecasted weather conditions for the daytime part of the day (7am to
    /// 7pm local time).
    #[prost(message, optional, tag = "3")]
    pub daytime_forecast: ::core::option::Option<ForecastDayPart>,
    /// The forecasted weather conditions for the nighttime part of the day (7pm to
    /// 7am next day, local time).
    #[prost(message, optional, tag = "4")]
    pub nighttime_forecast: ::core::option::Option<ForecastDayPart>,
    /// The maximum (high) temperature throughout the day.
    #[prost(message, optional, tag = "5")]
    pub max_temperature: ::core::option::Option<Temperature>,
    /// The minimum (low) temperature throughout the day.
    #[prost(message, optional, tag = "6")]
    pub min_temperature: ::core::option::Option<Temperature>,
    /// The maximum (high) feels-like temperature throughout the day.
    #[prost(message, optional, tag = "7")]
    pub feels_like_max_temperature: ::core::option::Option<Temperature>,
    /// The minimum (low) feels-like temperature throughout the day.
    #[prost(message, optional, tag = "8")]
    pub feels_like_min_temperature: ::core::option::Option<Temperature>,
    /// The maximum heat index temperature throughout the day.
    #[prost(message, optional, tag = "11")]
    pub max_heat_index: ::core::option::Option<Temperature>,
    /// The events related to the sun (e.g. sunrise, sunset).
    #[prost(message, optional, tag = "9")]
    pub sun_events: ::core::option::Option<SunEvents>,
    /// The events related to the moon (e.g. moonrise, moonset).
    #[prost(message, optional, tag = "10")]
    pub moon_events: ::core::option::Option<MoonEvents>,
}
/// Represents a forecast record for a part of the day.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastDayPart {
    /// The UTC date and time when this part of the day starts (inclusive) and ends
    /// (exclusive).
    /// Note: a part of a day starts at 7am and ends at 7pm the same day, local
    /// time. For example: If the local time zone is UTC-7, then the daytime
    /// interval will start at the time `14:00:00.000Z` and end at `02:00:00.000Z`
    /// the next day and the nighttime interval will start at `02:00:00.000Z` the
    /// next day and end at `14:00:00.000Z` that same day.
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The forecasted weather condition.
    #[prost(message, optional, tag = "2")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The forecasted percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "3")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The maximum forecasted ultraviolet (UV) index.
    #[prost(int32, optional, tag = "4")]
    pub uv_index: ::core::option::Option<i32>,
    /// The forecasted precipitation.
    #[prost(message, optional, tag = "5")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The average thunderstorm probability.
    #[prost(int32, optional, tag = "6")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The average wind direction and maximum speed and gust.
    #[prost(message, optional, tag = "7")]
    pub wind: ::core::option::Option<Wind>,
    /// Average cloud cover percent.
    #[prost(int32, optional, tag = "8")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The accumulated amount of ice for the part of the day.
    #[prost(message, optional, tag = "9")]
    pub ice_thickness: ::core::option::Option<IceThickness>,
}
/// Represents visibility conditions, the distance at which objects can be
/// discerned.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Visibility {
    /// The visibility distance in the specified unit.
    #[prost(float, optional, tag = "1")]
    pub distance: ::core::option::Option<f32>,
    /// The code that represents the unit used to measure the distance.
    #[prost(enumeration = "visibility::Unit", tag = "2")]
    pub unit: i32,
}
/// Nested message and enum types in `Visibility`.
pub mod visibility {
    /// Represents the unit used to measure the visibility distance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Unit {
        /// The visibility unit is unspecified.
        Unspecified = 0,
        /// The visibility is measured in kilometers.
        Kilometers = 1,
        /// The visibility is measured in miles.
        Miles = 2,
    }
    impl Unit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_UNSPECIFIED",
                Self::Kilometers => "KILOMETERS",
                Self::Miles => "MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "KILOMETERS" => Some(Self::Kilometers),
                "MILES" => Some(Self::Miles),
                _ => None,
            }
        }
    }
}
/// Represents an hourly forecast record at a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForecastHour {
    /// The one hour interval (in UTC time) this forecast data is valid for (the
    /// timestamps are rounded down to the closest hour).
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The local date and time in the time zone of the location (civil time) which
    /// this hourly forecast is calculated for. This field may be used for display
    /// purposes on the client.
    /// Note: this date will consist of the year, month, day, hour and offset from
    /// UTC.
    #[prost(message, optional, tag = "2")]
    pub display_date_time: ::core::option::Option<super::super::super::r#type::DateTime>,
    /// True if this hour is between the local sunrise (inclusive) and sunset
    /// (exclusive) times. Otherwise, it is nighttime (between the sunset and the
    /// next sunrise).
    /// Note: this hour will be considered as daytime or nighttime if the interval
    /// intersects with the local sunrise and sunset times respectively (e.g.: if
    /// the interval is from 5am to 6am and sunrise is at 5:59am, then is_daytime
    /// will be true).
    #[prost(bool, optional, tag = "3")]
    pub is_daytime: ::core::option::Option<bool>,
    /// The foreacasted weather condition.
    #[prost(message, optional, tag = "4")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The forecasted temperature.
    #[prost(message, optional, tag = "5")]
    pub temperature: ::core::option::Option<Temperature>,
    /// The measure of how the temperature will feel like at the requested
    /// location.
    #[prost(message, optional, tag = "6")]
    pub feels_like_temperature: ::core::option::Option<Temperature>,
    /// The forecasted dew point temperature.
    #[prost(message, optional, tag = "7")]
    pub dew_point: ::core::option::Option<Temperature>,
    /// The forecasted heat index temperature.
    #[prost(message, optional, tag = "8")]
    pub heat_index: ::core::option::Option<Temperature>,
    /// The forecasted wind chill, air temperature exposed on the skin.
    #[prost(message, optional, tag = "9")]
    pub wind_chill: ::core::option::Option<Temperature>,
    /// The forecasted wet bulb temperature, lowest temperature achievable by
    /// evaporating water.
    #[prost(message, optional, tag = "10")]
    pub wet_bulb_temperature: ::core::option::Option<Temperature>,
    /// The forecasted percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "11")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The forecasted ultraviolet (UV) index.
    #[prost(int32, optional, tag = "12")]
    pub uv_index: ::core::option::Option<i32>,
    /// The forecasted precipitation probability and amount of precipitation
    /// accumulated over the last hour.
    #[prost(message, optional, tag = "13")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The forecasted thunderstorm probability (values from 0 to 100).
    #[prost(int32, optional, tag = "14")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The forecasted air pressure conditions.
    #[prost(message, optional, tag = "15")]
    pub air_pressure: ::core::option::Option<AirPressure>,
    /// The forecasted wind conditions.
    #[prost(message, optional, tag = "16")]
    pub wind: ::core::option::Option<Wind>,
    /// The forecasted visibility.
    #[prost(message, optional, tag = "17")]
    pub visibility: ::core::option::Option<Visibility>,
    /// The forecasted percentage of the sky covered by clouds (values from 0 to
    /// 100).
    #[prost(int32, optional, tag = "18")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The forecasted ice thickness.
    #[prost(message, optional, tag = "19")]
    pub ice_thickness: ::core::option::Option<IceThickness>,
}
/// Represents an hourly history record at a given location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistoryHour {
    /// The one hour interval (in UTC time) this historical data is valid for (the
    /// timestamps are rounded down to the closest hour).
    #[prost(message, optional, tag = "1")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The local date and time in the time zone of the location (civil time) which
    /// this hourly record is calculated for. This field may be used for display
    /// purposes on the client.
    /// Note: this date will consist of the year, month, day, hour and offset from
    /// UTC.
    #[prost(message, optional, tag = "2")]
    pub display_date_time: ::core::option::Option<super::super::super::r#type::DateTime>,
    /// True if this hour is between the local sunrise (inclusive) and sunset
    /// (exclusive) times. Otherwise, it is nighttime (between the sunset and the
    /// next sunrise).
    /// Note: this hour will be considered as daytime or nighttime if the interval
    /// intersects with the local sunrise and sunset times respectively (e.g.: if
    /// the interval is from 5am to 6am and sunrise is at 5:59am, then is_daytime
    /// will be true).
    #[prost(bool, optional, tag = "3")]
    pub is_daytime: ::core::option::Option<bool>,
    /// The historical weather condition.
    #[prost(message, optional, tag = "4")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The historical temperature.
    #[prost(message, optional, tag = "5")]
    pub temperature: ::core::option::Option<Temperature>,
    /// The measure of how the temperature felt like at the requested
    /// location.
    #[prost(message, optional, tag = "6")]
    pub feels_like_temperature: ::core::option::Option<Temperature>,
    /// The historical dew point temperature.
    #[prost(message, optional, tag = "7")]
    pub dew_point: ::core::option::Option<Temperature>,
    /// The historical heat index temperature.
    #[prost(message, optional, tag = "8")]
    pub heat_index: ::core::option::Option<Temperature>,
    /// The historical wind chill, air temperature exposed on the skin.
    #[prost(message, optional, tag = "9")]
    pub wind_chill: ::core::option::Option<Temperature>,
    /// The historical wet bulb temperature, lowest temperature achievable by
    /// evaporating water.
    #[prost(message, optional, tag = "10")]
    pub wet_bulb_temperature: ::core::option::Option<Temperature>,
    /// The historical percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "11")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The historical ultraviolet (UV) index.
    #[prost(int32, optional, tag = "12")]
    pub uv_index: ::core::option::Option<i32>,
    /// The historical precipitation probability and amount of precipitation
    /// accumulated over the last hour.
    #[prost(message, optional, tag = "13")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The historical thunderstorm probability (values from 0 to 100).
    #[prost(int32, optional, tag = "14")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The historical air pressure conditions.
    #[prost(message, optional, tag = "15")]
    pub air_pressure: ::core::option::Option<AirPressure>,
    /// The historical wind conditions.
    #[prost(message, optional, tag = "16")]
    pub wind: ::core::option::Option<Wind>,
    /// The historical visibility.
    #[prost(message, optional, tag = "17")]
    pub visibility: ::core::option::Option<Visibility>,
    /// The historical percentage of the sky covered by clouds (values from 0 to
    /// 100).
    #[prost(int32, optional, tag = "18")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The historical ice thickness.
    #[prost(message, optional, tag = "19")]
    pub ice_thickness: ::core::option::Option<IceThickness>,
}
/// The type of the weather event.
/// (-- Next available tag: 64 --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WeatherEventType {
    /// Unspecified weather event type.
    Unspecified = 0,
    /// Acid rain event.
    AcidRain = 1,
    /// Aftershock event.
    Aftershock = 2,
    /// Avalanche event.
    Avalanche = 3,
    /// Blizzard event.
    Blizzard = 4,
    /// Blowing snow event.
    BlowingSnow = 5,
    /// Bushfire event.
    Bushfire = 6,
    /// Coastal flood event.
    CoastalFlood = 7,
    /// Coastal hazard event.
    CoastalHazard = 8,
    /// Cold event.
    Cold = 9,
    /// Cyclone event.
    Cyclone = 10,
    /// Drought event.
    Drought = 11,
    /// Dust storm event.
    DustStorm = 12,
    /// Earthquake event.
    Earthquake = 13,
    /// Extra tropical cyclone event.
    ExtratropicalCyclone = 14,
    /// Fire event.
    Fire = 15,
    /// Fire weather event.
    FireWeather = 16,
    /// Flash flood event.
    FlashFlood = 17,
    /// Flood event.
    Flood = 18,
    /// Fog event.
    Fog = 19,
    /// Freezing event.
    Freezing = 20,
    /// Freezing air temperature event.
    FreezingAirTemperature = 21,
    /// Freezing drizzle event.
    FreezingDrizzle = 22,
    /// Freezing rain event.
    FreezingRainEvent = 23,
    /// Frost event.
    Frost = 24,
    /// Gale event.
    Gale = 25,
    /// Glaze event.
    Glaze = 26,
    /// Hail event.
    Hail = 27,
    /// Hazardous seas event.
    HazardousSeas = 28,
    /// Heat event.
    Heat = 29,
    /// Humidity event.
    Humidity = 30,
    /// Hurricane event.
    Hurricane = 31,
    /// Ice storm event.
    IceStorm = 32,
    /// Industrial fire event.
    IndustrialFire = 33,
    /// Lake effect snow event.
    LakeEffectSnow = 34,
    /// Landslide event.
    Landslide = 35,
    /// Monsoon event.
    Monsoon = 36,
    /// Muddy flood event.
    MuddyFlood = 37,
    /// Outflow event.
    Outflow = 38,
    /// Radiation event.
    Radiation = 39,
    /// Rain event.
    RainEvent = 40,
    /// River flooding event.
    RiverFlooding = 41,
    /// Severe thunderstorm warning event.
    SevereThunderstormWarning = 42,
    /// Snowsquall event.
    Snowsquall = 43,
    /// Snow event.
    SnowEvent = 44,
    /// Storm event.
    Storm = 45,
    /// Storm surge event.
    StormSurge = 46,
    /// Thunder event.
    Thunder = 47,
    /// Thunderstorm event.
    Thunderstorm = 48,
    /// Tornado event.
    Tornado = 49,
    /// Tornado warning event.
    TornadoWarning = 50,
    /// Tropical cyclone event.
    TropicalCyclone = 51,
    /// Tropical cyclone warnings and watches event.
    TropicalCycloneWarningsAndWatches = 52,
    /// Tropical disturbance event.
    TropicalDisturbance = 53,
    /// Tropical storm event.
    TropicalStorm = 54,
    /// Tsunami event.
    Tsunami = 55,
    /// Typhoon event.
    Typhoon = 56,
    /// Volcanic ash event.
    VolcanicAsh = 57,
    /// Volcanic eruption event.
    VolcanicEruption = 58,
    /// Wildfire event.
    Wildfire = 59,
    /// Wind event.
    Wind = 60,
    /// Wind chill event.
    WindChill = 61,
    /// Wind wave event.
    WindWave = 62,
    /// Winter storm event.
    WinterStorm = 63,
}
impl WeatherEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "WEATHER_EVENT_TYPE_UNSPECIFIED",
            Self::AcidRain => "ACID_RAIN",
            Self::Aftershock => "AFTERSHOCK",
            Self::Avalanche => "AVALANCHE",
            Self::Blizzard => "BLIZZARD",
            Self::BlowingSnow => "BLOWING_SNOW",
            Self::Bushfire => "BUSHFIRE",
            Self::CoastalFlood => "COASTAL_FLOOD",
            Self::CoastalHazard => "COASTAL_HAZARD",
            Self::Cold => "COLD",
            Self::Cyclone => "CYCLONE",
            Self::Drought => "DROUGHT",
            Self::DustStorm => "DUST_STORM",
            Self::Earthquake => "EARTHQUAKE",
            Self::ExtratropicalCyclone => "EXTRATROPICAL_CYCLONE",
            Self::Fire => "FIRE",
            Self::FireWeather => "FIRE_WEATHER",
            Self::FlashFlood => "FLASH_FLOOD",
            Self::Flood => "FLOOD",
            Self::Fog => "FOG",
            Self::Freezing => "FREEZING",
            Self::FreezingAirTemperature => "FREEZING_AIR_TEMPERATURE",
            Self::FreezingDrizzle => "FREEZING_DRIZZLE",
            Self::FreezingRainEvent => "FREEZING_RAIN_EVENT",
            Self::Frost => "FROST",
            Self::Gale => "GALE",
            Self::Glaze => "GLAZE",
            Self::Hail => "HAIL",
            Self::HazardousSeas => "HAZARDOUS_SEAS",
            Self::Heat => "HEAT",
            Self::Humidity => "HUMIDITY",
            Self::Hurricane => "HURRICANE",
            Self::IceStorm => "ICE_STORM",
            Self::IndustrialFire => "INDUSTRIAL_FIRE",
            Self::LakeEffectSnow => "LAKE_EFFECT_SNOW",
            Self::Landslide => "LANDSLIDE",
            Self::Monsoon => "MONSOON",
            Self::MuddyFlood => "MUDDY_FLOOD",
            Self::Outflow => "OUTFLOW",
            Self::Radiation => "RADIATION",
            Self::RainEvent => "RAIN_EVENT",
            Self::RiverFlooding => "RIVER_FLOODING",
            Self::SevereThunderstormWarning => "SEVERE_THUNDERSTORM_WARNING",
            Self::Snowsquall => "SNOWSQUALL",
            Self::SnowEvent => "SNOW_EVENT",
            Self::Storm => "STORM",
            Self::StormSurge => "STORM_SURGE",
            Self::Thunder => "THUNDER",
            Self::Thunderstorm => "THUNDERSTORM",
            Self::Tornado => "TORNADO",
            Self::TornadoWarning => "TORNADO_WARNING",
            Self::TropicalCyclone => "TROPICAL_CYCLONE",
            Self::TropicalCycloneWarningsAndWatches => {
                "TROPICAL_CYCLONE_WARNINGS_AND_WATCHES"
            }
            Self::TropicalDisturbance => "TROPICAL_DISTURBANCE",
            Self::TropicalStorm => "TROPICAL_STORM",
            Self::Tsunami => "TSUNAMI",
            Self::Typhoon => "TYPHOON",
            Self::VolcanicAsh => "VOLCANIC_ASH",
            Self::VolcanicEruption => "VOLCANIC_ERUPTION",
            Self::Wildfire => "WILDFIRE",
            Self::Wind => "WIND",
            Self::WindChill => "WIND_CHILL",
            Self::WindWave => "WIND_WAVE",
            Self::WinterStorm => "WINTER_STORM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WEATHER_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACID_RAIN" => Some(Self::AcidRain),
            "AFTERSHOCK" => Some(Self::Aftershock),
            "AVALANCHE" => Some(Self::Avalanche),
            "BLIZZARD" => Some(Self::Blizzard),
            "BLOWING_SNOW" => Some(Self::BlowingSnow),
            "BUSHFIRE" => Some(Self::Bushfire),
            "COASTAL_FLOOD" => Some(Self::CoastalFlood),
            "COASTAL_HAZARD" => Some(Self::CoastalHazard),
            "COLD" => Some(Self::Cold),
            "CYCLONE" => Some(Self::Cyclone),
            "DROUGHT" => Some(Self::Drought),
            "DUST_STORM" => Some(Self::DustStorm),
            "EARTHQUAKE" => Some(Self::Earthquake),
            "EXTRATROPICAL_CYCLONE" => Some(Self::ExtratropicalCyclone),
            "FIRE" => Some(Self::Fire),
            "FIRE_WEATHER" => Some(Self::FireWeather),
            "FLASH_FLOOD" => Some(Self::FlashFlood),
            "FLOOD" => Some(Self::Flood),
            "FOG" => Some(Self::Fog),
            "FREEZING" => Some(Self::Freezing),
            "FREEZING_AIR_TEMPERATURE" => Some(Self::FreezingAirTemperature),
            "FREEZING_DRIZZLE" => Some(Self::FreezingDrizzle),
            "FREEZING_RAIN_EVENT" => Some(Self::FreezingRainEvent),
            "FROST" => Some(Self::Frost),
            "GALE" => Some(Self::Gale),
            "GLAZE" => Some(Self::Glaze),
            "HAIL" => Some(Self::Hail),
            "HAZARDOUS_SEAS" => Some(Self::HazardousSeas),
            "HEAT" => Some(Self::Heat),
            "HUMIDITY" => Some(Self::Humidity),
            "HURRICANE" => Some(Self::Hurricane),
            "ICE_STORM" => Some(Self::IceStorm),
            "INDUSTRIAL_FIRE" => Some(Self::IndustrialFire),
            "LAKE_EFFECT_SNOW" => Some(Self::LakeEffectSnow),
            "LANDSLIDE" => Some(Self::Landslide),
            "MONSOON" => Some(Self::Monsoon),
            "MUDDY_FLOOD" => Some(Self::MuddyFlood),
            "OUTFLOW" => Some(Self::Outflow),
            "RADIATION" => Some(Self::Radiation),
            "RAIN_EVENT" => Some(Self::RainEvent),
            "RIVER_FLOODING" => Some(Self::RiverFlooding),
            "SEVERE_THUNDERSTORM_WARNING" => Some(Self::SevereThunderstormWarning),
            "SNOWSQUALL" => Some(Self::Snowsquall),
            "SNOW_EVENT" => Some(Self::SnowEvent),
            "STORM" => Some(Self::Storm),
            "STORM_SURGE" => Some(Self::StormSurge),
            "THUNDER" => Some(Self::Thunder),
            "THUNDERSTORM" => Some(Self::Thunderstorm),
            "TORNADO" => Some(Self::Tornado),
            "TORNADO_WARNING" => Some(Self::TornadoWarning),
            "TROPICAL_CYCLONE" => Some(Self::TropicalCyclone),
            "TROPICAL_CYCLONE_WARNINGS_AND_WATCHES" => {
                Some(Self::TropicalCycloneWarningsAndWatches)
            }
            "TROPICAL_DISTURBANCE" => Some(Self::TropicalDisturbance),
            "TROPICAL_STORM" => Some(Self::TropicalStorm),
            "TSUNAMI" => Some(Self::Tsunami),
            "TYPHOON" => Some(Self::Typhoon),
            "VOLCANIC_ASH" => Some(Self::VolcanicAsh),
            "VOLCANIC_ERUPTION" => Some(Self::VolcanicEruption),
            "WILDFIRE" => Some(Self::Wildfire),
            "WIND" => Some(Self::Wind),
            "WIND_CHILL" => Some(Self::WindChill),
            "WIND_WAVE" => Some(Self::WindWave),
            "WINTER_STORM" => Some(Self::WinterStorm),
            _ => None,
        }
    }
}
/// The publisher of the alert.
/// (-- Next available tag: 52 --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Publisher {
    /// Publisher unspecified.
    Unspecified = 0,
    /// Australia
    /// Australian Capital Territory
    AustraliaActEsa = 1,
    /// New South Wales
    AustraliaNswRfs = 2,
    /// Queensland
    AustraliaQldQfes = 3,
    /// South Australia
    AustraliaSaCfs = 4,
    /// Meteoalarm / EUMETNET
    /// Austria
    MeteoAlarmAt = 5,
    /// Bosnia
    MeteoAlarmBs = 6,
    /// Brazil
    /// Disaster Agency in Brazil
    BrazilCenad = 7,
    /// Meteorological Agency in Brazil
    BrazilInmet = 8,
    /// United Kingdom
    UkEnvAgency = 9,
    /// Meteoalarm / EUMETNET
    /// Bulgaria
    MeteoAlarmBg = 10,
    /// Croatia
    MeteoAlarmCr = 11,
    /// Cyprus
    MeteoAlarmCy = 12,
    /// Czechia
    MeteoAlarmCs = 13,
    /// Denmark
    MeteoAlarmDk = 14,
    /// Ecuador
    EcInamhi = 15,
    /// Meteoalarm / EUMETNET
    /// Finland
    MeteoAlarmFi = 16,
    /// France
    MeteoAlarmFr = 17,
    /// Germany
    DeDwd = 18,
    /// Meteoalarm / EUMETNET
    /// Great Britain
    MeteoAlarmGb = 19,
    /// Greece
    MeteoAlarmGr = 20,
    /// Hungary
    MeteoAlarmHu = 21,
    /// Iceland
    MeteoAlarmIs = 22,
    /// Ireland
    MeteoAlarmIe = 23,
    /// Italy
    MeteoAlarmIt = 24,
    /// Jamaica
    JmJms = 25,
    /// Japan
    Jma = 26,
    /// Meteoalarm / EUMETNET
    /// Netherlands
    MeteoAlarmNl = 27,
    /// Latvia
    MeteoAlarmLv = 28,
    /// Lithuania
    MeteoAlarmLt = 29,
    /// Luxembourg
    MeteoAlarmLu = 30,
    /// Mexico
    /// Mexico CIRES
    MexicoCires = 31,
    /// New Zealand
    /// New Zealand GeoNet
    NzGeonet = 32,
    /// MetService
    NzNms = 33,
    /// Meteoalarm / EUMETNET
    /// North Macedonia
    MeteoAlarmMk = 34,
    /// Norway
    MeteoAlarmNo = 35,
    /// Philippines
    PhilippinesPagasa = 36,
    /// Meteoalarm / EUMETNET
    /// Poland
    MeteoAlarmPl = 37,
    /// Portugal
    MeteoAlarmPt = 38,
    /// Romania
    MeteoAlarmRo = 39,
    /// Serbia
    MeteoAlarmRs = 40,
    /// Singapore
    SgMss = 41,
    /// Meteoalarm / EUMETNET
    /// Slovakia
    MeteoAlarmSk = 42,
    /// Slovenia
    MeteoAlarmSi = 43,
    /// Solomon Islands
    SbMet = 44,
    /// Meteoalarm / EUMETNET
    /// Spain
    MeteoAlarmEs = 45,
    /// Sweden
    MeteoAlarmSe = 46,
    /// Switzerland
    MeteoAlarmCh = 47,
    /// Taiwan
    TaiwanNcdr = 48,
    /// United States
    /// NOAA
    Noaa = 49,
    /// National Tsunami Warning Center
    Wcatwc = 50,
}
impl Publisher {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PUBLISHER_UNSPECIFIED",
            Self::AustraliaActEsa => "AUSTRALIA_ACT_ESA",
            Self::AustraliaNswRfs => "AUSTRALIA_NSW_RFS",
            Self::AustraliaQldQfes => "AUSTRALIA_QLD_QFES",
            Self::AustraliaSaCfs => "AUSTRALIA_SA_CFS",
            Self::MeteoAlarmAt => "METEO_ALARM_AT",
            Self::MeteoAlarmBs => "METEO_ALARM_BS",
            Self::BrazilCenad => "BRAZIL_CENAD",
            Self::BrazilInmet => "BRAZIL_INMET",
            Self::UkEnvAgency => "UK_ENV_AGENCY",
            Self::MeteoAlarmBg => "METEO_ALARM_BG",
            Self::MeteoAlarmCr => "METEO_ALARM_CR",
            Self::MeteoAlarmCy => "METEO_ALARM_CY",
            Self::MeteoAlarmCs => "METEO_ALARM_CS",
            Self::MeteoAlarmDk => "METEO_ALARM_DK",
            Self::EcInamhi => "EC_INAMHI",
            Self::MeteoAlarmFi => "METEO_ALARM_FI",
            Self::MeteoAlarmFr => "METEO_ALARM_FR",
            Self::DeDwd => "DE_DWD",
            Self::MeteoAlarmGb => "METEO_ALARM_GB",
            Self::MeteoAlarmGr => "METEO_ALARM_GR",
            Self::MeteoAlarmHu => "METEO_ALARM_HU",
            Self::MeteoAlarmIs => "METEO_ALARM_IS",
            Self::MeteoAlarmIe => "METEO_ALARM_IE",
            Self::MeteoAlarmIt => "METEO_ALARM_IT",
            Self::JmJms => "JM_JMS",
            Self::Jma => "JMA",
            Self::MeteoAlarmNl => "METEO_ALARM_NL",
            Self::MeteoAlarmLv => "METEO_ALARM_LV",
            Self::MeteoAlarmLt => "METEO_ALARM_LT",
            Self::MeteoAlarmLu => "METEO_ALARM_LU",
            Self::MexicoCires => "MEXICO_CIRES",
            Self::NzGeonet => "NZ_GEONET",
            Self::NzNms => "NZ_NMS",
            Self::MeteoAlarmMk => "METEO_ALARM_MK",
            Self::MeteoAlarmNo => "METEO_ALARM_NO",
            Self::PhilippinesPagasa => "PHILIPPINES_PAGASA",
            Self::MeteoAlarmPl => "METEO_ALARM_PL",
            Self::MeteoAlarmPt => "METEO_ALARM_PT",
            Self::MeteoAlarmRo => "METEO_ALARM_RO",
            Self::MeteoAlarmRs => "METEO_ALARM_RS",
            Self::SgMss => "SG_MSS",
            Self::MeteoAlarmSk => "METEO_ALARM_SK",
            Self::MeteoAlarmSi => "METEO_ALARM_SI",
            Self::SbMet => "SB_MET",
            Self::MeteoAlarmEs => "METEO_ALARM_ES",
            Self::MeteoAlarmSe => "METEO_ALARM_SE",
            Self::MeteoAlarmCh => "METEO_ALARM_CH",
            Self::TaiwanNcdr => "TAIWAN_NCDR",
            Self::Noaa => "NOAA",
            Self::Wcatwc => "WCATWC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PUBLISHER_UNSPECIFIED" => Some(Self::Unspecified),
            "AUSTRALIA_ACT_ESA" => Some(Self::AustraliaActEsa),
            "AUSTRALIA_NSW_RFS" => Some(Self::AustraliaNswRfs),
            "AUSTRALIA_QLD_QFES" => Some(Self::AustraliaQldQfes),
            "AUSTRALIA_SA_CFS" => Some(Self::AustraliaSaCfs),
            "METEO_ALARM_AT" => Some(Self::MeteoAlarmAt),
            "METEO_ALARM_BS" => Some(Self::MeteoAlarmBs),
            "BRAZIL_CENAD" => Some(Self::BrazilCenad),
            "BRAZIL_INMET" => Some(Self::BrazilInmet),
            "UK_ENV_AGENCY" => Some(Self::UkEnvAgency),
            "METEO_ALARM_BG" => Some(Self::MeteoAlarmBg),
            "METEO_ALARM_CR" => Some(Self::MeteoAlarmCr),
            "METEO_ALARM_CY" => Some(Self::MeteoAlarmCy),
            "METEO_ALARM_CS" => Some(Self::MeteoAlarmCs),
            "METEO_ALARM_DK" => Some(Self::MeteoAlarmDk),
            "EC_INAMHI" => Some(Self::EcInamhi),
            "METEO_ALARM_FI" => Some(Self::MeteoAlarmFi),
            "METEO_ALARM_FR" => Some(Self::MeteoAlarmFr),
            "DE_DWD" => Some(Self::DeDwd),
            "METEO_ALARM_GB" => Some(Self::MeteoAlarmGb),
            "METEO_ALARM_GR" => Some(Self::MeteoAlarmGr),
            "METEO_ALARM_HU" => Some(Self::MeteoAlarmHu),
            "METEO_ALARM_IS" => Some(Self::MeteoAlarmIs),
            "METEO_ALARM_IE" => Some(Self::MeteoAlarmIe),
            "METEO_ALARM_IT" => Some(Self::MeteoAlarmIt),
            "JM_JMS" => Some(Self::JmJms),
            "JMA" => Some(Self::Jma),
            "METEO_ALARM_NL" => Some(Self::MeteoAlarmNl),
            "METEO_ALARM_LV" => Some(Self::MeteoAlarmLv),
            "METEO_ALARM_LT" => Some(Self::MeteoAlarmLt),
            "METEO_ALARM_LU" => Some(Self::MeteoAlarmLu),
            "MEXICO_CIRES" => Some(Self::MexicoCires),
            "NZ_GEONET" => Some(Self::NzGeonet),
            "NZ_NMS" => Some(Self::NzNms),
            "METEO_ALARM_MK" => Some(Self::MeteoAlarmMk),
            "METEO_ALARM_NO" => Some(Self::MeteoAlarmNo),
            "PHILIPPINES_PAGASA" => Some(Self::PhilippinesPagasa),
            "METEO_ALARM_PL" => Some(Self::MeteoAlarmPl),
            "METEO_ALARM_PT" => Some(Self::MeteoAlarmPt),
            "METEO_ALARM_RO" => Some(Self::MeteoAlarmRo),
            "METEO_ALARM_RS" => Some(Self::MeteoAlarmRs),
            "SG_MSS" => Some(Self::SgMss),
            "METEO_ALARM_SK" => Some(Self::MeteoAlarmSk),
            "METEO_ALARM_SI" => Some(Self::MeteoAlarmSi),
            "SB_MET" => Some(Self::SbMet),
            "METEO_ALARM_ES" => Some(Self::MeteoAlarmEs),
            "METEO_ALARM_SE" => Some(Self::MeteoAlarmSe),
            "METEO_ALARM_CH" => Some(Self::MeteoAlarmCh),
            "TAIWAN_NCDR" => Some(Self::TaiwanNcdr),
            "NOAA" => Some(Self::Noaa),
            "WCATWC" => Some(Self::Wcatwc),
            _ => None,
        }
    }
}
/// The code denoting the urgency of the subject event of the alert message.
/// (-- Next available tag: 5 --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Urgency {
    /// Urgency not known.
    Unknown = 0,
    /// Responsive action SHOULD be taken immediately.
    Immediate = 1,
    /// Responsive action SHOULD be taken soon (within next hour).
    Expected = 2,
    /// Responsive action SHOULD be taken in the near future.
    Future = 3,
    /// Responsive action is no longer required.
    Past = 4,
}
impl Urgency {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "URGENCY_UNKNOWN",
            Self::Immediate => "IMMEDIATE",
            Self::Expected => "EXPECTED",
            Self::Future => "FUTURE",
            Self::Past => "PAST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "URGENCY_UNKNOWN" => Some(Self::Unknown),
            "IMMEDIATE" => Some(Self::Immediate),
            "EXPECTED" => Some(Self::Expected),
            "FUTURE" => Some(Self::Future),
            "PAST" => Some(Self::Past),
            _ => None,
        }
    }
}
/// The code denoting the severity of the subject event of the alert message.
/// (-- Next available tag: 5 --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// Severity not known.
    Unknown = 0,
    /// Extraordinary threat to life or property.
    Extreme = 1,
    /// Significant threat to life or property.
    Severe = 2,
    /// Possible threat to life or property.
    Moderate = 3,
    /// Minor threat to life or property.
    Minor = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "SEVERITY_UNKNOWN",
            Self::Extreme => "EXTREME",
            Self::Severe => "SEVERE",
            Self::Moderate => "MODERATE",
            Self::Minor => "MINOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNKNOWN" => Some(Self::Unknown),
            "EXTREME" => Some(Self::Extreme),
            "SEVERE" => Some(Self::Severe),
            "MODERATE" => Some(Self::Moderate),
            "MINOR" => Some(Self::Minor),
            _ => None,
        }
    }
}
/// The code denoting the certainty of the subject event of the alert message.
/// (-- Next available tag: 6 --)
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Certainty {
    /// Certainty not known.
    Unknown = 0,
    /// Determined to have occurred or to be ongoing.
    Observed = 1,
    /// Very likely.
    VeryLikely = 2,
    /// Likely (p > ~50%).
    Likely = 3,
    /// Possible but not likely (p \<= ~50%).
    Possible = 4,
    /// Unlikely (p ~ 0%).
    Unlikely = 5,
}
impl Certainty {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "CERTAINTY_UNKNOWN",
            Self::Observed => "OBSERVED",
            Self::VeryLikely => "VERY_LIKELY",
            Self::Likely => "LIKELY",
            Self::Possible => "POSSIBLE",
            Self::Unlikely => "UNLIKELY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CERTAINTY_UNKNOWN" => Some(Self::Unknown),
            "OBSERVED" => Some(Self::Observed),
            "VERY_LIKELY" => Some(Self::VeryLikely),
            "LIKELY" => Some(Self::Likely),
            "POSSIBLE" => Some(Self::Possible),
            "UNLIKELY" => Some(Self::Unlikely),
            _ => None,
        }
    }
}
/// Represents a link to a data source.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataSource {
    /// The publisher of the alert.
    #[prost(enumeration = "Publisher", tag = "1")]
    pub publisher: i32,
    /// Official publisher name. Please note that while this field should be
    /// localized, it is not guaranteed that it will be.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// The URL of the authority's website.
    #[prost(string, tag = "3")]
    pub authority_uri: ::prost::alloc::string::String,
}
/// Represents a safety recommendation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SafetyRecommendation {
    /// A directive to the user. Please note that while this field should be
    /// localized, it is not guaranteed that it will be.
    #[prost(string, tag = "1")]
    pub directive: ::prost::alloc::string::String,
    /// An optional subtext for the directive, which may contain additional
    /// context for the user. Please note that while this field should be
    /// localized, it is not guaranteed that it will be.
    #[prost(string, optional, tag = "2")]
    pub subtext: ::core::option::Option<::prost::alloc::string::String>,
}
/// Represents the public weather alerts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicAlerts {
    /// The unique identifier for this alert.
    #[prost(string, tag = "1")]
    pub alert_id: ::prost::alloc::string::String,
    /// The localized title for the alert.
    #[prost(message, optional, tag = "2")]
    pub alert_title: ::core::option::Option<super::super::super::r#type::LocalizedText>,
    /// The type of weather event.
    #[prost(enumeration = "WeatherEventType", tag = "3")]
    pub event_type: i32,
    /// The name of the area where the alert is issued.
    #[prost(string, tag = "4")]
    pub area_name: ::prost::alloc::string::String,
    /// A GeoJSON representation of the areas where the alert is issued.
    ///
    /// The GeoJSON data must be in RFC 7946 format and represent either a
    /// Polygon (for a single contiguous area) or a MultiPolygon (for multiple
    /// distinct areas).
    ///
    /// Example:
    ///
    /// {
    /// "type": "Polygon",
    /// "coordinates": \[
    /// \[
    /// \[-1, -1\], \[-1, 0\], \[0, 0\], \[-1, -1\]
    /// \]
    /// \]
    /// }
    ///
    /// A sample MultiPolygon GeoJson string looks like:
    ///
    /// {
    /// "type": "MultiPolygon",
    /// "coordinates": \[
    /// \[
    /// \[0, 0\], \[-1, 0\], \[-1, 1\], \[0, 0\]
    /// \],
    /// \[
    /// \[0, 0\], \[-2, 0\], \[-2, 2\], \[0, 0\]
    /// \]
    /// \]
    #[prost(string, optional, tag = "5")]
    pub polygon: ::core::option::Option<::prost::alloc::string::String>,
    /// The latest text describing the alert as issued by the official authority.
    /// Please note that while this field should be localized, it is not guaranteed
    /// that it will be.
    #[prost(string, optional, tag = "6")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// The severity level of the alert.
    #[prost(enumeration = "Severity", tag = "7")]
    pub severity: i32,
    /// The certainty of the alert.
    #[prost(enumeration = "Certainty", optional, tag = "8")]
    pub certainty: ::core::option::Option<i32>,
    /// The urgency of the alert.
    #[prost(enumeration = "Urgency", optional, tag = "9")]
    pub urgency: ::core::option::Option<i32>,
    /// Instructions recommended by the publisher. Please note that while this
    /// field should be localized, it is not guaranteed that it will be.
    #[prost(string, repeated, tag = "10")]
    pub instruction: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Safety recommendations directive to the user, these can be provided by the
    /// publisher or other authorities.
    #[prost(message, repeated, tag = "11")]
    pub safety_recommendations: ::prost::alloc::vec::Vec<SafetyRecommendation>,
    /// The timezone offset of the event, in +/-HH:MM format.
    #[prost(string, tag = "12")]
    pub timezone_offset: ::prost::alloc::string::String,
    /// The start time of the event.
    #[prost(message, optional, tag = "13")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The expiration time of the event.
    #[prost(message, optional, tag = "14")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Details of the publisher that issued the alert.
    #[prost(message, optional, tag = "15")]
    pub data_source: ::core::option::Option<DataSource>,
}
/// Represents the units system used to measure values.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnitsSystem {
    /// The units system is unspecified.
    Unspecified = 0,
    /// The imperial units system (e.g. Fahrenheit, miles, etc).
    Imperial = 1,
    /// The metric units system (e.g. Celsius, kilometers, etc).
    Metric = 2,
}
impl UnitsSystem {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNITS_SYSTEM_UNSPECIFIED",
            Self::Imperial => "IMPERIAL",
            Self::Metric => "METRIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNITS_SYSTEM_UNSPECIFIED" => Some(Self::Unspecified),
            "IMPERIAL" => Some(Self::Imperial),
            "METRIC" => Some(Self::Metric),
            _ => None,
        }
    }
}
/// Request for the LookupCurrentConditions RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupCurrentConditionsRequest {
    /// Required. The location to get the current weather conditions for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "2")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "3")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Response for the LookupCurrentConditions RPC - represents the current weather
/// conditions at the requested location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupCurrentConditionsResponse {
    /// Current time (UTC) associated with the returned data.
    #[prost(message, optional, tag = "1")]
    pub current_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// True if the current time at the requested location is between the local
    /// sunrise (inclusive) and the sunset (exclusive) times. Otherwise, it is
    /// nighttime (between the sunset and the next sunrise).
    #[prost(bool, optional, tag = "3")]
    pub is_daytime: ::core::option::Option<bool>,
    /// The current weather condition.
    #[prost(message, optional, tag = "4")]
    pub weather_condition: ::core::option::Option<WeatherCondition>,
    /// The current temperature.
    #[prost(message, optional, tag = "5")]
    pub temperature: ::core::option::Option<Temperature>,
    /// The measure of how the temperature currently feels like at the requested
    /// location.
    #[prost(message, optional, tag = "6")]
    pub feels_like_temperature: ::core::option::Option<Temperature>,
    /// The current dew point temperature.
    #[prost(message, optional, tag = "7")]
    pub dew_point: ::core::option::Option<Temperature>,
    /// The current heat index temperature.
    #[prost(message, optional, tag = "8")]
    pub heat_index: ::core::option::Option<Temperature>,
    /// The current wind chill, air temperature exposed on the skin.
    #[prost(message, optional, tag = "9")]
    pub wind_chill: ::core::option::Option<Temperature>,
    /// The current percent of relative humidity (values from 0 to 100).
    #[prost(int32, optional, tag = "10")]
    pub relative_humidity: ::core::option::Option<i32>,
    /// The current ultraviolet (UV) index.
    #[prost(int32, optional, tag = "11")]
    pub uv_index: ::core::option::Option<i32>,
    /// The current precipitation probability and amount of precipitation
    /// accumulated over the last hour.
    #[prost(message, optional, tag = "12")]
    pub precipitation: ::core::option::Option<Precipitation>,
    /// The current thunderstorm probability (values from 0 to 100).
    #[prost(int32, optional, tag = "13")]
    pub thunderstorm_probability: ::core::option::Option<i32>,
    /// The current air pressure conditions.
    #[prost(message, optional, tag = "14")]
    pub air_pressure: ::core::option::Option<AirPressure>,
    /// The current wind conditions.
    #[prost(message, optional, tag = "15")]
    pub wind: ::core::option::Option<Wind>,
    /// The current visibility.
    #[prost(message, optional, tag = "16")]
    pub visibility: ::core::option::Option<Visibility>,
    /// The current percentage of the sky covered by clouds (values from 0 to 100).
    #[prost(int32, optional, tag = "17")]
    pub cloud_cover: ::core::option::Option<i32>,
    /// The changes in the current conditions over the last 24 hours.
    #[prost(message, optional, tag = "18")]
    pub current_conditions_history: ::core::option::Option<
        lookup_current_conditions_response::CurrentConditionsHistory,
    >,
}
/// Nested message and enum types in `LookupCurrentConditionsResponse`.
pub mod lookup_current_conditions_response {
    /// Represents a set of changes in the current conditions over the last 24
    /// hours.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CurrentConditionsHistory {
        /// The current temperature minus the temperature 24 hours ago.
        #[prost(message, optional, tag = "1")]
        pub temperature_change: ::core::option::Option<super::Temperature>,
        /// The maximum (high) temperature in the past 24 hours.
        #[prost(message, optional, tag = "2")]
        pub max_temperature: ::core::option::Option<super::Temperature>,
        /// The minimum (low) temperature in the past 24 hours.
        #[prost(message, optional, tag = "3")]
        pub min_temperature: ::core::option::Option<super::Temperature>,
        /// The amount of snow, measured as liquid water equivalent,
        /// that has accumulated over the last 24 hours.
        /// Note: QPF is an abbreviation for Quantitative Precipitation Forecast
        /// (please see the QuantitativePrecipitationForecast definition for more
        /// details).
        #[prost(message, optional, tag = "5")]
        pub snow_qpf: ::core::option::Option<super::QuantitativePrecipitationForecast>,
        /// The amount of rain, measured as liquid water equivalent, that has
        /// accumulated over the last 24 hours. Note: QPF is an abbreviation for
        /// Quantitative Precipitation Forecast (please see the
        /// QuantitativePrecipitationForecast definition for more details).
        #[prost(message, optional, tag = "6")]
        pub qpf: ::core::option::Option<super::QuantitativePrecipitationForecast>,
    }
}
/// Request for the LookupForecastHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastHoursRequest {
    /// Required. The location to get the hourly forecast for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Limits the amount of total hours to fetch starting from the
    /// current hour - a value from 1 to 240 (inclusive). The default is the
    /// maximum allowed value of 240.
    #[prost(int32, optional, tag = "2")]
    pub hours: ::core::option::Option<i32>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "3")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "4")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of hourly forecast records to return per page
    ///
    /// * a value from 1 to 24 (inclusive). The default is the maximum allowed
    ///   value of 24.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token received from a previous request. It is used to
    /// retrieve the subsequent page.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupForecastHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastHoursResponse {
    /// The hourly forecast records, according to the number of hours and page size
    /// specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub forecast_hours: ::prost::alloc::vec::Vec<ForecastHour>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// The token to retrieve the next page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for the LookupForecastDays RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastDaysRequest {
    /// Required. The location to get the daily forecast for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Limits the amount of total days to fetch starting from the
    /// current day - a value from 1 to 10 (inclusive). The default value is the
    /// maximum allowed value of 10.
    #[prost(int32, optional, tag = "2")]
    pub days: ::core::option::Option<i32>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "3")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "4")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of daily forecast records to return per page -
    /// a value from 1 to 10 (inclusive). The default value is 5.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token received from a previous request. It is used to
    /// retrieve the subsequent page.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupForecastDays RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupForecastDaysResponse {
    /// The daily forecast records, according to the number of days and page size
    /// specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub forecast_days: ::prost::alloc::vec::Vec<ForecastDay>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// The token to retrieve the next page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for the LookupHistoryHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupHistoryHoursRequest {
    /// Required. The location to get the hourly historical data for.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Limits the amount of total hours to fetch starting from the last
    /// hour - a from 1 to 24 (inclusive). The default is the maximum allowed value
    /// of 24.
    #[prost(int32, optional, tag = "2")]
    pub hours: ::core::option::Option<i32>,
    /// Optional. The units system to use for the returned weather conditions. If
    /// not provided, the returned weather conditions will be in the metric system
    /// (default = METRIC).
    #[prost(enumeration = "UnitsSystem", tag = "3")]
    pub units_system: i32,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "4")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of hourly historical records to return per
    /// page - a value from 1 to 24 (inclusive). The default is the maximum allowed
    /// value of 24.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token received from a previous request. It is used to
    /// retrieve the subsequent page.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupHistoryHours RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupHistoryHoursResponse {
    /// The hourly historical records, according to the number of hours and page
    /// size specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub history_hours: ::prost::alloc::vec::Vec<HistoryHour>,
    /// The time zone at the requested location.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// The token to retrieve the next page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for the LookupPublicAlerts RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupPublicAlertsRequest {
    /// Required. The location to get public weather alerts for. The service will
    /// return alerts whose affected area intersects with this location.
    #[prost(message, optional, tag = "1")]
    pub location: ::core::option::Option<super::super::super::r#type::LatLng>,
    /// Optional. Allows the client to choose the language for the response. If
    /// data cannot be provided for that language, the API uses the closest match.
    /// Allowed values rely on the IETF BCP-47 standard. The default value is "en".
    #[prost(string, optional, tag = "2")]
    pub language_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The maximum number of public weather alert records to return per
    /// page.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token received from a previous
    /// `LookupPublicAlerts` call. Provide this to retrieve the subsequent
    /// page. When paginating, all other parameters provided to
    /// `LookupPublicAlerts` must match the call that provided the page
    /// token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response for the LookupPublicAlerts RPC.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupPublicAlertsResponse {
    /// The public weather alert records, according to the number of alerts and
    /// page size specified in the request.
    #[prost(message, repeated, tag = "1")]
    pub weather_alerts: ::prost::alloc::vec::Vec<PublicAlerts>,
    /// The ISO_3166-1 alpha-2 code of the region corresponding to the
    /// location provided in the request. The region is stated using
    /// ISO_3166-1_alpha-2.
    #[prost(string, tag = "2")]
    pub region_code: ::prost::alloc::string::String,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod weather_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service definition for the Weather API.
    #[derive(Debug, Clone)]
    pub struct WeatherClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WeatherClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WeatherClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WeatherClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WeatherClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the current weather conditions at a given location.
        pub async fn lookup_current_conditions(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupCurrentConditionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupCurrentConditionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupCurrentConditions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupCurrentConditions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns up to 240 hours of hourly forecasts at a given location, starting
        /// from the current hour.
        pub async fn lookup_forecast_hours(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupForecastHoursRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupForecastHoursResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupForecastHours",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupForecastHours",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns up to 10 days of daily forecasts at a given location, starting from
        /// the current day.
        pub async fn lookup_forecast_days(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupForecastDaysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupForecastDaysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupForecastDays",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupForecastDays",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns up to 24 hours of hourly historical weather data at a given
        /// location, starting from the last hour.
        pub async fn lookup_history_hours(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupHistoryHoursRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupHistoryHoursResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupHistoryHours",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupHistoryHours",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns public weather alerts for a given location.
        pub async fn lookup_public_alerts(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupPublicAlertsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LookupPublicAlertsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.maps.weather.v1.Weather/LookupPublicAlerts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.maps.weather.v1.Weather",
                        "LookupPublicAlerts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
