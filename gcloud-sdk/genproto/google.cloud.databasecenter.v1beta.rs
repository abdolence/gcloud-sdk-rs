// This file is @generated by prost-build.
/// MachineConfig describes the configuration of a machine specific to a Database
/// Resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MachineConfig {
    /// Memory size in bytes.
    #[prost(int64, tag = "2")]
    pub memory_size_bytes: i64,
    /// Optional. The number of Shards (if applicable).
    #[prost(int32, optional, tag = "3")]
    pub shard_count: ::core::option::Option<i32>,
    /// Optional. The number of vCPUs (if applicable).
    #[prost(double, optional, tag = "4")]
    pub vcpu_count: ::core::option::Option<f64>,
}
/// Maintenance window for the database resource. It specifies preferred time
/// and day of the week and phase in some cases, when the maintenance can start.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceMaintenanceSchedule {
    /// Optional. Preferred time to start the maintenance operation on the
    /// specified day.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Optional. Preferred day of the week for maintenance, e.g. MONDAY, TUESDAY,
    /// etc.
    #[prost(enumeration = "super::super::super::r#type::DayOfWeek", tag = "2")]
    pub day: i32,
    /// Optional. Phase of the maintenance window. This is to capture order of
    /// maintenance. For example, for Cloud SQL resources, this can be used to
    /// capture if the maintenance window is in Week1, Week2, Week5, etc. Non
    /// production resources are usually part of early phase.
    /// For more details, refer to Cloud SQL resources -
    /// <https://cloud.google.com/sql/docs/mysql/maintenance>
    #[prost(enumeration = "Phase", tag = "3")]
    pub phase: i32,
}
/// Deny maintenance period for the database resource. It specifies the time
/// range during which the maintenance cannot start. This is configured by the
/// customer.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceMaintenanceDenySchedule {
    /// Optional. The start date of the deny maintenance period.
    #[prost(message, optional, tag = "1")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. Deny period end date.
    #[prost(message, optional, tag = "2")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. Time in UTC when the deny period starts on start_date and ends on
    /// end_date.
    #[prost(message, optional, tag = "3")]
    pub time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
}
/// MaintenanceInfo to capture the maintenance details of database resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceInfo {
    /// Optional. Maintenance window for the database resource.
    #[prost(message, optional, tag = "1")]
    pub maintenance_schedule: ::core::option::Option<ResourceMaintenanceSchedule>,
    /// Optional. List of Deny maintenance period for the database resource.
    #[prost(message, repeated, tag = "2")]
    pub deny_maintenance_schedules: ::prost::alloc::vec::Vec<
        ResourceMaintenanceDenySchedule,
    >,
    /// Optional. Current Maintenance version of the database resource. Example:
    /// "MYSQL_8_0_41.R20250531.01_15"
    #[prost(string, tag = "3")]
    pub maintenance_version: ::prost::alloc::string::String,
}
/// Phase/Week of the maintenance window. This is to capture order of
/// maintenance. For example, for Cloud SQL resources -
/// <https://cloud.google.com/sql/docs/mysql/maintenance.>
/// This enum can be extended to support DB Center specific phases for
/// recommendation plan generation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Phase {
    /// Phase is unspecified.
    Unspecified = 0,
    /// Week 1.
    Week1 = 1,
    /// Week 2.
    Week2 = 2,
    /// Week 5.
    Week5 = 3,
    /// Any phase.
    Any = 4,
}
impl Phase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PHASE_UNSPECIFIED",
            Self::Week1 => "PHASE_WEEK1",
            Self::Week2 => "PHASE_WEEK2",
            Self::Week5 => "PHASE_WEEK5",
            Self::Any => "PHASE_ANY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PHASE_UNSPECIFIED" => Some(Self::Unspecified),
            "PHASE_WEEK1" => Some(Self::Week1),
            "PHASE_WEEK2" => Some(Self::Week2),
            "PHASE_WEEK5" => Some(Self::Week5),
            "PHASE_ANY" => Some(Self::Any),
            _ => None,
        }
    }
}
/// Metrics represents the metrics for a database resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Metrics {
    /// P99 CPU utilization observed for the resource. The value is a
    /// fraction between 0.0 and 1.0 (may momentarily exceed 1.0 in some cases).
    #[prost(message, optional, tag = "1")]
    pub p99_cpu_utilization: ::core::option::Option<MetricData>,
    /// P95 CPU utilization observed for the resource. The value is a
    /// fraction between 0.0 and 1.0 (may momentarily exceed 1.0 in some cases).
    #[prost(message, optional, tag = "2")]
    pub p95_cpu_utilization: ::core::option::Option<MetricData>,
    /// Current storage used by the resource in bytes.
    #[prost(message, optional, tag = "3")]
    pub current_storage_used_bytes: ::core::option::Option<MetricData>,
    /// Peak storage utilization observed for the resource. The value is a
    /// fraction between 0.0 and 1.0 (may momentarily exceed 1.0 in some cases).
    #[prost(message, optional, tag = "4")]
    pub peak_storage_utilization: ::core::option::Option<MetricData>,
    /// Peak memory utilization observed for the resource. The value is a
    /// fraction between 0.0 and 1.0 (may momentarily exceed 1.0 in some cases).
    #[prost(message, optional, tag = "5")]
    pub peak_memory_utilization: ::core::option::Option<MetricData>,
    /// Peak number of connections observed for the resource. The value is a
    /// positive integer.
    #[prost(message, optional, tag = "6")]
    pub peak_number_connections: ::core::option::Option<MetricData>,
    /// Number of nodes in instance for spanner or bigtable.
    #[prost(message, optional, tag = "7")]
    pub node_count: ::core::option::Option<MetricData>,
    /// Number of processing units in spanner.
    #[prost(message, optional, tag = "8")]
    pub processing_unit_count: ::core::option::Option<MetricData>,
    /// Current memory used by the resource in bytes.
    #[prost(message, optional, tag = "9")]
    pub current_memory_used_bytes: ::core::option::Option<MetricData>,
}
/// MetricData represents the metric data for a database resource.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetricData {
    /// The value associated with the metric.
    #[prost(message, optional, tag = "1")]
    pub value: ::core::option::Option<TypedValue>,
    /// The time the metric was observed in the metric source service.
    #[prost(message, optional, tag = "2")]
    pub observation_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// TypedValue represents the value of the metric based on data type.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TypedValue {
    /// The data type of metric value would be chosen based on the metric type.
    #[prost(oneof = "typed_value::Value", tags = "1, 2")]
    pub value: ::core::option::Option<typed_value::Value>,
}
/// Nested message and enum types in `TypedValue`.
pub mod typed_value {
    /// The data type of metric value would be chosen based on the metric type.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// The value of the metric as double.
        #[prost(double, tag = "1")]
        DoubleValue(f64),
        /// The value of the metric as int.
        #[prost(int64, tag = "2")]
        Int64Value(i64),
    }
}
/// OperationErrorType is used to expose specific error type which can happen in
/// database resource while performing an operation. For example, an error can
/// happen while database resource being backed up.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationErrorType {
    /// UNSPECIFIED means operation error type is not known or available.
    Unspecified = 0,
    /// Key destroyed, expired, not found, unreachable or permission denied.
    KmsKeyError = 1,
    /// Database is not accessible.
    DatabaseError = 2,
    /// The zone or region does not have sufficient resources to handle the request
    /// at the moment.
    StockoutError = 3,
    /// User initiated cancellation.
    CancellationError = 4,
    /// SQL server specific error.
    SqlserverError = 5,
    /// Any other internal error.
    InternalError = 6,
}
impl OperationErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATION_ERROR_TYPE_UNSPECIFIED",
            Self::KmsKeyError => "KMS_KEY_ERROR",
            Self::DatabaseError => "DATABASE_ERROR",
            Self::StockoutError => "STOCKOUT_ERROR",
            Self::CancellationError => "CANCELLATION_ERROR",
            Self::SqlserverError => "SQLSERVER_ERROR",
            Self::InternalError => "INTERNAL_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATION_ERROR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "KMS_KEY_ERROR" => Some(Self::KmsKeyError),
            "DATABASE_ERROR" => Some(Self::DatabaseError),
            "STOCKOUT_ERROR" => Some(Self::StockoutError),
            "CANCELLATION_ERROR" => Some(Self::CancellationError),
            "SQLSERVER_ERROR" => Some(Self::SqlserverError),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            _ => None,
        }
    }
}
/// Product specification for databasecenter resources.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Product {
    /// Optional. Type of specific database product. It could be CloudSQL, AlloyDB
    /// etc..
    #[prost(enumeration = "ProductType", tag = "1")]
    pub r#type: i32,
    /// Optional. The specific engine that the underlying database is running.
    #[prost(enumeration = "Engine", tag = "2")]
    pub engine: i32,
    /// Optional. Version of the underlying database engine. Example values: For
    /// MySQL, it could be "8.0", "5.7" etc. For Postgres, it could be "14", "15"
    /// etc.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
    /// Optional. Minor version of the underlying database engine. Example values:
    /// For MySQL, it could be "8.0.35", "5.7.25" etc. For PostgreSQL, it could be
    /// "14.4", "15.5" etc.
    #[prost(string, tag = "4")]
    pub minor_version: ::prost::alloc::string::String,
}
/// Engine refers to underlying database binary running in an instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Engine {
    /// UNSPECIFIED means engine type is not known or available.
    Unspecified = 0,
    /// MySQL binary running as an engine in the database instance.
    Mysql = 1,
    /// Postgres binary running as engine in database instance.
    Postgres = 2,
    /// SQLServer binary running as engine in database instance.
    SqlServer = 3,
    /// Native database binary running as engine in instance.
    Native = 4,
    /// Memorystore with Redis dialect.
    MemorystoreForRedis = 8,
    /// Memorystore with Redis cluster dialect.
    MemorystoreForRedisCluster = 9,
    /// Firestore with native mode.
    FirestoreWithNativeMode = 10,
    /// Firestore with datastore mode.
    FirestoreWithDatastoreMode = 11,
    /// Oracle Exadata engine.
    ExadataOracle = 12,
    /// Oracle Autonomous DB Serverless engine.
    AdbServerlessOracle = 13,
    /// Firestore with MongoDB compatibility.
    FirestoreWithMongodbCompatibilityMode = 14,
    /// Other refers to rest of other database engine. This is to be when engine is
    /// known, but it is not present in this enum.
    Other = 6,
}
impl Engine {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENGINE_UNSPECIFIED",
            Self::Mysql => "ENGINE_MYSQL",
            Self::Postgres => "ENGINE_POSTGRES",
            Self::SqlServer => "ENGINE_SQL_SERVER",
            Self::Native => "ENGINE_NATIVE",
            Self::MemorystoreForRedis => "ENGINE_MEMORYSTORE_FOR_REDIS",
            Self::MemorystoreForRedisCluster => "ENGINE_MEMORYSTORE_FOR_REDIS_CLUSTER",
            Self::FirestoreWithNativeMode => "ENGINE_FIRESTORE_WITH_NATIVE_MODE",
            Self::FirestoreWithDatastoreMode => "ENGINE_FIRESTORE_WITH_DATASTORE_MODE",
            Self::ExadataOracle => "ENGINE_EXADATA_ORACLE",
            Self::AdbServerlessOracle => "ENGINE_ADB_SERVERLESS_ORACLE",
            Self::FirestoreWithMongodbCompatibilityMode => {
                "ENGINE_FIRESTORE_WITH_MONGODB_COMPATIBILITY_MODE"
            }
            Self::Other => "ENGINE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENGINE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENGINE_MYSQL" => Some(Self::Mysql),
            "ENGINE_POSTGRES" => Some(Self::Postgres),
            "ENGINE_SQL_SERVER" => Some(Self::SqlServer),
            "ENGINE_NATIVE" => Some(Self::Native),
            "ENGINE_MEMORYSTORE_FOR_REDIS" => Some(Self::MemorystoreForRedis),
            "ENGINE_MEMORYSTORE_FOR_REDIS_CLUSTER" => {
                Some(Self::MemorystoreForRedisCluster)
            }
            "ENGINE_FIRESTORE_WITH_NATIVE_MODE" => Some(Self::FirestoreWithNativeMode),
            "ENGINE_FIRESTORE_WITH_DATASTORE_MODE" => {
                Some(Self::FirestoreWithDatastoreMode)
            }
            "ENGINE_EXADATA_ORACLE" => Some(Self::ExadataOracle),
            "ENGINE_ADB_SERVERLESS_ORACLE" => Some(Self::AdbServerlessOracle),
            "ENGINE_FIRESTORE_WITH_MONGODB_COMPATIBILITY_MODE" => {
                Some(Self::FirestoreWithMongodbCompatibilityMode)
            }
            "ENGINE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// ProductType is used to identify a database service offering either in a cloud
/// provider or on-premise. This enum needs to be updated whenever we introduce
/// a new ProductType.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProductType {
    /// PRODUCT_TYPE_UNSPECIFIED means product type is not known or that the user
    /// didn't provide this field in the request.
    Unspecified = 0,
    /// Cloud SQL product area in GCP
    CloudSql = 1,
    /// AlloyDB product area in GCP
    Alloydb = 2,
    /// Spanner product area in GCP
    Spanner = 3,
    /// Bigtable product area in GCP
    Bigtable = 6,
    /// Memorystore product area in GCP
    Memorystore = 7,
    /// Firestore product area in GCP
    Firestore = 8,
    /// Compute Engine self managed databases
    ComputeEngine = 9,
    /// Oracle product area in GCP
    OracleOnGcp = 10,
    /// BigQuery product area in GCP
    Bigquery = 11,
    /// Other refers to rest of other product type. This is to be when product type
    /// is known, but it is not present in this enum.
    Other = 5,
}
impl ProductType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRODUCT_TYPE_UNSPECIFIED",
            Self::CloudSql => "PRODUCT_TYPE_CLOUD_SQL",
            Self::Alloydb => "PRODUCT_TYPE_ALLOYDB",
            Self::Spanner => "PRODUCT_TYPE_SPANNER",
            Self::Bigtable => "PRODUCT_TYPE_BIGTABLE",
            Self::Memorystore => "PRODUCT_TYPE_MEMORYSTORE",
            Self::Firestore => "PRODUCT_TYPE_FIRESTORE",
            Self::ComputeEngine => "PRODUCT_TYPE_COMPUTE_ENGINE",
            Self::OracleOnGcp => "PRODUCT_TYPE_ORACLE_ON_GCP",
            Self::Bigquery => "PRODUCT_TYPE_BIGQUERY",
            Self::Other => "PRODUCT_TYPE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRODUCT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRODUCT_TYPE_CLOUD_SQL" => Some(Self::CloudSql),
            "PRODUCT_TYPE_ALLOYDB" => Some(Self::Alloydb),
            "PRODUCT_TYPE_SPANNER" => Some(Self::Spanner),
            "PRODUCT_TYPE_BIGTABLE" => Some(Self::Bigtable),
            "PRODUCT_TYPE_MEMORYSTORE" => Some(Self::Memorystore),
            "PRODUCT_TYPE_FIRESTORE" => Some(Self::Firestore),
            "PRODUCT_TYPE_COMPUTE_ENGINE" => Some(Self::ComputeEngine),
            "PRODUCT_TYPE_ORACLE_ON_GCP" => Some(Self::OracleOnGcp),
            "PRODUCT_TYPE_BIGQUERY" => Some(Self::Bigquery),
            "PRODUCT_TYPE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// The reason for suspension of the database resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SuspensionReason {
    /// Suspension reason is unspecified.
    Unspecified = 0,
    /// Wipeout hide event.
    WipeoutHideEvent = 1,
    /// Wipeout purge event.
    WipeoutPurgeEvent = 2,
    /// Billing disabled for project
    BillingDisabled = 3,
    /// Abuse detected for resource
    AbuserDetected = 4,
    /// Encryption key inaccessible.
    EncryptionKeyInaccessible = 5,
    /// Replicated cluster encryption key inaccessible.
    ReplicatedClusterEncryptionKeyInaccessible = 6,
}
impl SuspensionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUSPENSION_REASON_UNSPECIFIED",
            Self::WipeoutHideEvent => "WIPEOUT_HIDE_EVENT",
            Self::WipeoutPurgeEvent => "WIPEOUT_PURGE_EVENT",
            Self::BillingDisabled => "BILLING_DISABLED",
            Self::AbuserDetected => "ABUSER_DETECTED",
            Self::EncryptionKeyInaccessible => "ENCRYPTION_KEY_INACCESSIBLE",
            Self::ReplicatedClusterEncryptionKeyInaccessible => {
                "REPLICATED_CLUSTER_ENCRYPTION_KEY_INACCESSIBLE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUSPENSION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "WIPEOUT_HIDE_EVENT" => Some(Self::WipeoutHideEvent),
            "WIPEOUT_PURGE_EVENT" => Some(Self::WipeoutPurgeEvent),
            "BILLING_DISABLED" => Some(Self::BillingDisabled),
            "ABUSER_DETECTED" => Some(Self::AbuserDetected),
            "ENCRYPTION_KEY_INACCESSIBLE" => Some(Self::EncryptionKeyInaccessible),
            "REPLICATED_CLUSTER_ENCRYPTION_KEY_INACCESSIBLE" => {
                Some(Self::ReplicatedClusterEncryptionKeyInaccessible)
            }
            _ => None,
        }
    }
}
/// A group of signal types that specifies what the user is interested in.
///
/// Used by QueryDatabaseResourceGroups API.
///
/// Example:
///
/// signal_type_group {
/// name = "AVAILABILITY"
/// types = \[SIGNAL_TYPE_NO_PROMOTABLE_REPLICA\]
/// }
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignalTypeGroup {
    /// Required. The display name of a signal group.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. List of signal types present in the group.
    #[prost(enumeration = "SignalType", repeated, packed = "false", tag = "2")]
    pub signal_types: ::prost::alloc::vec::Vec<i32>,
}
/// A filter for Signals.
///
/// If signal_type is left unset, all signals should be returned.
/// For example, the following filter returns all issues.
/// signal_filter: {
/// signal_status: SIGNAL_STATUS_ISSUE;
/// }
///
/// Another example, the following filter returns issues of the given type:
/// signal_filter: {
/// type: SIGNAL_TYPE_NO_PROMOTABLE_REPLICA
/// signal_status: ISSUE
/// }
///
/// If signal_status is left unset or set to SIGNAL_STATE_UNSPECIFIED, an error
/// should be returned.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignalFilter {
    /// Optional. Represents the type of the Signal for which the filter is for.
    #[prost(enumeration = "SignalType", tag = "1")]
    pub signal_type: i32,
    /// Optional. Represents the status of the Signal for which the filter is for.
    #[prost(enumeration = "SignalStatus", tag = "2")]
    pub signal_status: i32,
}
/// A group of signals and their counts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalGroup {
    /// Title of a signal group corresponding to the request.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// When applied to a DatabaseResource represents count of issues associated
    /// with the resource. A signal is an issue when its SignalStatus field is
    /// set to SIGNAL_STATUS_ISSUE.
    #[prost(int32, tag = "2")]
    pub issue_count: i32,
    /// List of signals present in the group and associated with the resource.
    ///
    /// Only applies to a DatabaseResource.
    #[prost(message, repeated, tag = "3")]
    pub signals: ::prost::alloc::vec::Vec<Signal>,
}
/// Count of issues for a group of signals.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IssueCount {
    /// Title of a signal group corresponding to the request.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// The count of the number of issues associated with those resources that
    /// are explicitly filtered in by the filters present in the request.
    /// A signal is an issue when its SignalStatus field is set to
    /// SIGNAL_STATUS_ISSUE.
    #[prost(int32, tag = "2")]
    pub issue_count: i32,
}
/// Details related to signal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalDetail {
    /// Where the signal is coming from.
    #[prost(enumeration = "SignalSource", tag = "1")]
    pub signal_source: i32,
    /// Type of the signal.
    #[prost(enumeration = "SignalType", tag = "5")]
    pub signal_type: i32,
    /// Event time when signal was recorded by source service.
    #[prost(message, optional, tag = "7")]
    pub signal_event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Details related to signal.
    #[prost(
        oneof = "additional_detail::Detail",
        tags = "2, 3, 4, 6, 8, 9, 10, 11, 12, 13"
    )]
    pub detail: ::core::option::Option<additional_detail::Detail>,
}
/// Nested message and enum types in `AdditionalDetail`.
pub mod additional_detail {
    /// Details related to signal.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Detail {
        /// Short backup retention information applies to signals with type
        /// SIGNAL_TYPE_SHORT_BACKUP_RETENTION.
        #[prost(message, tag = "2")]
        ShortBackupRetentionInfo(super::RetentionSettingsInfo),
        /// Backup run information applies to signals with types
        /// SIGNAL_TYPE_LAST_BACKUP_FAILED and SIGNAL_TYPE_LAST_BACKUP_OLD.
        #[prost(message, tag = "3")]
        BackupRunInfo(super::BackupRunInfo),
        /// SCC information applies to SCC signals.
        #[prost(message, tag = "4")]
        SccInfo(super::SccInfo),
        /// Recommendation information applies to recommendations.
        #[prost(message, tag = "6")]
        RecommendationInfo(super::RecommendationInfo),
        /// Automated backup policy information applies to signals with type
        /// SIGNAL_TYPE_NO_AUTOMATED_BACKUP_POLICY.
        #[prost(message, tag = "8")]
        AutomatedBackupPolicyInfo(super::AutomatedBackupPolicyInfo),
        /// Deletion protection information applies to signals with type
        /// \[SIGNAL_TYPE_NO_DELETION_PROTECTION\]\[google.cloud.databasecenter.v1beta.SignalType.SIGNAL_TYPE_NO_DELETION_PROTECTION\]
        #[prost(message, tag = "9")]
        DeletionProtectionInfo(super::DeletionProtectionInfo),
        /// Resource suspension information applies to signals with type
        /// \[SIGNAL_TYPE_RESOURCE_SUSPENDED\]\[google.cloud.databasecenter.v1beta.SignalType.SIGNAL_TYPE_RESOURCE_SUSPENDED\].
        #[prost(message, tag = "10")]
        ResourceSuspensionInfo(super::ResourceSuspensionInfo),
        /// Inefficient query information applies to signals with type
        /// \[SIGNAL_TYPE_INEFFICIENT_QUERY\]\[google.cloud.databasecenter.v1beta.SignalType.SIGNAL_TYPE_INEFFICIENT_QUERY\].
        #[prost(message, tag = "11")]
        InefficientQueryInfo(super::InefficientQueryInfo),
        /// Outdated minor version information applies to signals with type
        /// SIGNAL_TYPE_OUTDATED_MINOR_VERSION.
        #[prost(message, tag = "12")]
        OutdatedMinorVersionInfo(super::OutdatedMinorVersionInfo),
        /// Maintenance recommendation information applies to signals
        /// with type SIGNAL_TYPE_RECOMMENDED_MAINTENANCE_POLICIES.
        #[prost(message, tag = "13")]
        MaintenanceRecommendationInfo(super::MaintenanceRecommendationInfo),
    }
}
/// Sub resource details
/// For Spanner/Bigtable instance certain data protection settings are at
/// sub resource level like database/table.
/// This message is used to capture such sub resource details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubResource {
    /// Optional. Resource type associated with the sub resource where backup
    /// settings are configured. E.g. "spanner.googleapis.com/Database" for Spanner
    /// where backup retention is configured on database within an instance
    /// OPTIONAL
    #[prost(string, tag = "1")]
    pub resource_type: ::prost::alloc::string::String,
    /// Optional. Resource name associated with the sub resource where backup
    /// settings are configured.
    /// E.g."//spanner.googleapis.com/projects/project1/instances/inst1/databases/db1"
    /// for Spanner where backup retention is configured on database within
    /// an instance
    /// OPTIONAL
    #[prost(string, tag = "2")]
    pub full_resource_name: ::prost::alloc::string::String,
    /// Optional. Product information associated with the sub resource where
    /// backup retention settings are configured.
    /// e.g.
    ///
    /// ```text,
    /// product: {
    /// type   : PRODUCT_TYPE_SPANNER
    /// engine : ENGINE_CLOUD_SPANNER_WITH_POSTGRES_DIALECT
    /// }
    /// ```
    ///
    /// for Spanner where backup is configured on database within
    /// an instance
    /// OPTIONAL
    #[prost(message, optional, tag = "3")]
    pub product: ::core::option::Option<Product>,
    /// Specifies where the resource is created. For GCP, it is the full name of
    /// the project.
    #[prost(string, tag = "4")]
    pub container: ::prost::alloc::string::String,
}
/// Metadata about backup retention settings for a database resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RetentionSettingsInfo {
    /// Optional. Sub resource details associated with the backup configuration.
    #[prost(message, optional, tag = "4")]
    pub sub_resource: ::core::option::Option<SubResource>,
    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    #[prost(oneof = "retention_settings_info::Retention", tags = "3, 5, 6")]
    pub retention: ::core::option::Option<retention_settings_info::Retention>,
}
/// Nested message and enum types in `RetentionSettingsInfo`.
pub mod retention_settings_info {
    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Retention {
        /// Number of backups that will be retained.
        #[prost(message, tag = "3")]
        QuantityBasedRetention(i32),
        /// Duration based retention period i.e. 172800 seconds (2 days)
        #[prost(message, tag = "5")]
        DurationBasedRetention(::prost_types::Duration),
        /// Timestamp based retention period i.e. till 2024-05-01T00:00:00Z
        #[prost(message, tag = "6")]
        TimestampBasedRetentionTime(::prost_types::Timestamp),
    }
}
/// Automated backup policy signal info
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutomatedBackupPolicyInfo {
    /// Optional. Sub resource details associated with the signal.
    #[prost(message, optional, tag = "1")]
    pub sub_resource: ::core::option::Option<SubResource>,
    /// Is automated policy enabled.
    #[prost(bool, tag = "2")]
    pub is_enabled: bool,
}
/// Deletion protection signal info for a database resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeletionProtectionInfo {
    /// Optional. Sub resource details associated with the signal.
    #[prost(message, optional, tag = "1")]
    pub sub_resource: ::core::option::Option<SubResource>,
    /// Is deletion protection enabled.
    #[prost(bool, tag = "2")]
    pub deletion_protection_enabled: bool,
}
/// Resource suspension info for a database resource.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceSuspensionInfo {
    /// Is resource suspended.
    #[prost(bool, tag = "1")]
    pub resource_suspended: bool,
    /// Suspension reason for the resource.
    #[prost(enumeration = "SuspensionReason", tag = "2")]
    pub suspension_reason: i32,
}
/// Metadata about latest backup run state for a database resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupRunInfo {
    /// The time the backup operation started.
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the backup operation completed.
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The state of this run.
    #[prost(enumeration = "backup_run_info::State", tag = "2")]
    pub state: i32,
    /// Additional information about the error encountered.
    #[prost(string, tag = "3")]
    pub error_message: ::prost::alloc::string::String,
    /// Optional. OperationErrorType to expose specific error when backup operation
    /// of database resource failed, that is state is FAILED.
    #[prost(enumeration = "OperationErrorType", tag = "4")]
    pub operation_error_type: i32,
    /// Optional. Sub resource details associated with the backup run.
    #[prost(message, optional, tag = "5")]
    pub sub_resource: ::core::option::Option<SubResource>,
}
/// Nested message and enum types in `BackupRunInfo`.
pub mod backup_run_info {
    /// The status of a backup run.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified.
        Unspecified = 0,
        /// The backup succeeded.
        Succeeded = 1,
        /// The backup was unsuccessful.
        Failed = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Metadata about inefficient query signal info for a database resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InefficientQueryInfo {
    /// Name of the database where index is required. For example, "db1", which is
    /// the name of the database present in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Name of the table where index is required
    #[prost(string, tag = "2")]
    pub table: ::prost::alloc::string::String,
    /// SQL statement of the index. Based on the ddl type, this will be either
    /// CREATE INDEX or DROP INDEX.
    #[prost(string, tag = "3")]
    pub sql_index_statement: ::prost::alloc::string::String,
    /// Cost of additional disk usage in bytes
    #[prost(int64, tag = "4")]
    pub storage_cost_bytes: i64,
    /// Count of queries to be impacted if index is applied
    #[prost(int64, tag = "5")]
    pub impacted_queries_count: i64,
}
/// Info associated with SCC signals.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SccInfo {
    /// Name of the signal.
    #[prost(string, tag = "1")]
    pub signal: ::prost::alloc::string::String,
    /// Name by which SCC calls this signal.
    #[prost(string, tag = "2")]
    pub category: ::prost::alloc::string::String,
    /// Compliances that are associated with the signal.
    #[prost(message, repeated, tag = "3")]
    pub regulatory_standards: ::prost::alloc::vec::Vec<RegulatoryStandard>,
    /// External URI which points to a SCC page associated with the signal.
    #[prost(string, tag = "4")]
    pub external_uri: ::prost::alloc::string::String,
}
/// Info associated with recommendation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecommendationInfo {
    /// Name of recommendation.
    /// Examples:
    /// organizations/1234/locations/us-central1/recommenders/google.cloudsql.instance.PerformanceRecommender/recommendations/9876
    #[prost(string, tag = "1")]
    pub recommender: ::prost::alloc::string::String,
    /// ID of recommender.
    /// Examples: "google.cloudsql.instance.PerformanceRecommender"
    #[prost(string, tag = "2")]
    pub recommender_id: ::prost::alloc::string::String,
    /// Contains an identifier for a subtype of recommendations produced for the
    /// same recommender. Subtype is a function of content and impact, meaning a
    /// new subtype might be added when significant changes to `content` or
    /// `primary_impact.category` are introduced. See the Recommenders section
    /// to see a list of subtypes for a given Recommender.
    ///
    /// Examples:
    /// For recommender = "google.cloudsql.instance.PerformanceRecommender",
    /// recommender_subtype can be
    /// "MYSQL_HIGH_NUMBER_OF_OPEN_TABLES_BEST_PRACTICE"/"POSTGRES_HIGH_TRANSACTION_ID_UTILIZATION_BEST_PRACTICE"
    #[prost(string, tag = "3")]
    pub recommender_subtype: ::prost::alloc::string::String,
}
/// Compliances associated with signals.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegulatoryStandard {
    /// Name of industry compliance standards, such as such as CIS, PCI, and
    /// OWASP.
    #[prost(string, tag = "1")]
    pub standard: ::prost::alloc::string::String,
    /// Version of the standard or benchmark, for example, 1.1.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// Info associated with outdated minor version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OutdatedMinorVersionInfo {
    /// Recommended minor version of the underlying database engine. Example
    /// values: For MySQL, it could be "8.0.35", "5.7.25" etc. For PostgreSQL, it
    /// could be "14.4", "15.5" etc.
    #[prost(string, tag = "1")]
    pub recommended_minor_version: ::prost::alloc::string::String,
}
/// Info associated with maintenance recommendation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceRecommendationInfo {
    /// Optional. List of recommended maintenance schedules for the database
    /// resource.
    #[prost(message, repeated, tag = "1")]
    pub resource_maintenance_schedules: ::prost::alloc::vec::Vec<
        ResourceMaintenanceSchedule,
    >,
}
/// Represents a signal.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signal {
    /// Type of the signal.
    #[prost(enumeration = "SignalType", tag = "1")]
    pub signal_type: i32,
    /// Status of the signal.
    #[prost(enumeration = "SignalStatus", tag = "2")]
    pub signal_status: i32,
    /// Additional information related to the signal.
    /// In the case of composite signals, this field encapsulates details
    /// associated with granular signals, having a signal status of "ISSUE";
    /// signals with a status of "OK" are not included.
    /// For granular signals, it encompasses information relevant to the signal,
    /// regardless of the signal status.
    #[prost(message, repeated, tag = "3")]
    pub additional_details: ::prost::alloc::vec::Vec<AdditionalDetail>,
    /// Severity of the issue.
    #[prost(enumeration = "IssueSeverity", tag = "4")]
    pub issue_severity: i32,
    /// Timestamp when the issue was created (when signal status is ISSUE).
    #[prost(message, optional, tag = "5")]
    pub issue_create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Represents the state of a signal. More enum values are expected to be added
/// as needed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignalStatus {
    /// Unspecified.
    Unspecified = 0,
    /// Signal is not applicable to the resource.
    NotApplicable = 1,
    /// Signal is not an issue.
    Ok = 2,
    /// Signal is an issue.
    Issue = 3,
    /// Signal is not enabled for the resource.
    NotEnabled = 4,
}
impl SignalStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNAL_STATUS_UNSPECIFIED",
            Self::NotApplicable => "SIGNAL_STATUS_NOT_APPLICABLE",
            Self::Ok => "SIGNAL_STATUS_OK",
            Self::Issue => "SIGNAL_STATUS_ISSUE",
            Self::NotEnabled => "SIGNAL_STATUS_NOT_ENABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNAL_STATUS_NOT_APPLICABLE" => Some(Self::NotApplicable),
            "SIGNAL_STATUS_OK" => Some(Self::Ok),
            "SIGNAL_STATUS_ISSUE" => Some(Self::Issue),
            "SIGNAL_STATUS_NOT_ENABLED" => Some(Self::NotEnabled),
            _ => None,
        }
    }
}
/// Represents the source system from where a signal comes from.
/// More enum values are expected to be added as needed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignalSource {
    /// Unspecified.
    Unspecified = 0,
    /// Signal comes from resource metadata.
    ResourceMetadata = 1,
    /// Signal comes from SCC findings.
    SecurityFindings = 2,
    /// Signal comes from recommender hub.
    Recommender = 3,
    /// Signal comes from modern observability platform.
    ModernObservability = 4,
}
impl SignalSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNAL_SOURCE_UNSPECIFIED",
            Self::ResourceMetadata => "SIGNAL_SOURCE_RESOURCE_METADATA",
            Self::SecurityFindings => "SIGNAL_SOURCE_SECURITY_FINDINGS",
            Self::Recommender => "SIGNAL_SOURCE_RECOMMENDER",
            Self::ModernObservability => "SIGNAL_SOURCE_MODERN_OBSERVABILITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNAL_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNAL_SOURCE_RESOURCE_METADATA" => Some(Self::ResourceMetadata),
            "SIGNAL_SOURCE_SECURITY_FINDINGS" => Some(Self::SecurityFindings),
            "SIGNAL_SOURCE_RECOMMENDER" => Some(Self::Recommender),
            "SIGNAL_SOURCE_MODERN_OBSERVABILITY" => Some(Self::ModernObservability),
            _ => None,
        }
    }
}
/// IssueSeverity represents the severity of an issue.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IssueSeverity {
    /// Unspecified.
    Unspecified = 0,
    /// Low severity.
    Low = 1,
    /// Medium severity.
    Medium = 2,
    /// High severity.
    High = 3,
    /// Critical severity.
    Critical = 4,
    /// Irrelevant severity. This means the issue should not be surfaced at all.
    Irrelevant = 5,
}
impl IssueSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ISSUE_SEVERITY_UNSPECIFIED",
            Self::Low => "ISSUE_SEVERITY_LOW",
            Self::Medium => "ISSUE_SEVERITY_MEDIUM",
            Self::High => "ISSUE_SEVERITY_HIGH",
            Self::Critical => "ISSUE_SEVERITY_CRITICAL",
            Self::Irrelevant => "ISSUE_SEVERITY_IRRELEVANT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ISSUE_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "ISSUE_SEVERITY_LOW" => Some(Self::Low),
            "ISSUE_SEVERITY_MEDIUM" => Some(Self::Medium),
            "ISSUE_SEVERITY_HIGH" => Some(Self::High),
            "ISSUE_SEVERITY_CRITICAL" => Some(Self::Critical),
            "ISSUE_SEVERITY_IRRELEVANT" => Some(Self::Irrelevant),
            _ => None,
        }
    }
}
/// Represents the type of a signal. More values are expected to be added
/// as needed.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SignalType {
    /// Unspecified.
    Unspecified = 0,
    /// Represents if a resource is protected by automatic failover.
    /// Checks for resources that are configured to have redundancy
    /// within a region that enables automatic failover.
    ResourceFailoverProtected = 1,
    /// Represents if a group is replicating across regions.
    /// Checks for resources that are configured to have redundancy,
    /// and ongoing replication, across regions.
    GroupMultiregional = 2,
    /// Represents if a resource has an automated backup policy.
    NoAutomatedBackupPolicy = 4,
    /// Represents if a resources has a short backup retention period.
    ShortBackupRetention = 5,
    /// Represents if the last backup of a resource failed.
    LastBackupFailed = 6,
    /// Represents if the last backup of a resource is older than some threshold
    /// value.
    LastBackupOld = 7,
    /// Represents if a resource violates CIS GCP Foundation 2.0.
    ViolatesCisGcpFoundation20 = 8,
    /// Represents if a resource violates CIS GCP Foundation 1.3.
    ViolatesCisGcpFoundation13 = 9,
    /// Represents if a resource violates CIS GCP Foundation 1.2.
    ViolatesCisGcpFoundation12 = 10,
    /// Represents if a resource violates CIS GCP Foundation 1.1.
    ViolatesCisGcpFoundation11 = 11,
    /// Represents if a resource violates CIS GCP Foundation 1.0.
    ViolatesCisGcpFoundation10 = 12,
    /// Represents if a resource violates CIS Controls 8.0.
    ViolatesCisControlsV80 = 76,
    /// Represents if a resource violates NIST 800-53.
    ViolatesNist80053 = 13,
    /// Represents if a resource violates NIST 800-53 R5.
    ViolatesNist80053R5 = 69,
    /// Represents if a resource violates NIST Cybersecurity Framework 1.0.
    ViolatesNistCybersecurityFrameworkV10 = 72,
    /// Represents if a resource violates ISO-27001.
    ViolatesIso27001 = 14,
    /// Represents if a resource violates ISO 27001 2022.
    ViolatesIso27001V2022 = 70,
    /// Represents if a resource violates PCI-DSS v3.2.1.
    ViolatesPciDssV321 = 15,
    /// Represents if a resource violates PCI-DSS v4.0.
    ViolatesPciDssV40 = 71,
    /// Represents if a resource violates Cloud Controls Matrix v4.0.
    ViolatesCloudControlsMatrixV4 = 73,
    /// Represents if a resource violates HIPAA.
    ViolatesHipaa = 74,
    /// Represents if a resource violates SOC2 v2017.
    ViolatesSoc2V2017 = 75,
    /// Represents if log_checkpoints database flag for a Cloud SQL for PostgreSQL
    /// instance is not set to on.
    LogsNotOptimizedForTroubleshooting = 16,
    /// Represents if the log_duration database flag for a Cloud SQL for PostgreSQL
    /// instance is not set to on.
    QueryDurationsNotLogged = 17,
    /// Represents if the log_error_verbosity database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to default or stricter (default or terse).
    VerboseErrorLogging = 18,
    /// Represents if the log_lock_waits database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to on.
    QueryLockWaitsNotLogged = 19,
    /// Represents if the log_min_error_statement database flag for a Cloud SQL
    /// for PostgreSQL instance is not set appropriately.
    LoggingMostErrors = 20,
    /// Represents if the log_min_error_statement database flag for a Cloud SQL
    /// for PostgreSQL instance does not have an appropriate severity level.
    LoggingOnlyCriticalErrors = 21,
    /// Represents if the log_min_messages database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to warning or another recommended value.
    MinimalErrorLogging = 22,
    /// Represents if the databaseFlags property of instance metadata for
    /// the log_executor_status field is set to on.
    QueryStatsLogged = 23,
    /// Represents if the log_hostname database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to off.
    ExcessiveLoggingOfClientHostname = 24,
    /// Represents if the log_parser_stats database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to off.
    ExcessiveLoggingOfParserStats = 25,
    /// Represents if the log_planner_stats database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to off.
    ExcessiveLoggingOfPlannerStats = 26,
    /// Represents if the log_statement database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to DDL (all data definition statements).
    NotLoggingOnlyDdlStatements = 27,
    /// Represents if the log_statement_stats database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to off.
    LoggingQueryStats = 28,
    /// Represents if the log_temp_files database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to "0". (NOTE: 0 = ON)
    NotLoggingTemporaryFiles = 29,
    /// Represents if the user connections database flag for a Cloud SQL for SQL
    /// Server instance is configured.
    ConnectionMaxNotConfigured = 30,
    /// Represents if the user options database flag for Cloud SQL SQL Server
    /// instance is configured or not.
    UserOptionsConfigured = 31,
    /// Represents if a resource is exposed to public access.
    ExposedToPublicAccess = 32,
    /// Represents if a resources requires all incoming connections to use SSL
    /// or not.
    UnencryptedConnections = 33,
    /// Represents if a Cloud SQL database has a password configured for the
    /// root account or not.
    NoRootPassword = 34,
    /// Represents if a Cloud SQL database has a weak password configured for the
    /// root account.
    WeakRootPassword = 35,
    /// Represents if a SQL database instance is not encrypted with
    /// customer-managed encryption keys (CMEK).
    EncryptionKeyNotCustomerManaged = 36,
    /// Represents if The contained database authentication database flag for a
    /// Cloud SQL for SQL Server instance is not set to off.
    ServerAuthenticationNotRequired = 37,
    /// Represents if he external scripts enabled database flag for a Cloud SQL
    /// for SQL Server instance is not set to off.
    ExposedToExternalScripts = 39,
    /// Represents if the local_infile database flag for a Cloud SQL for MySQL
    /// instance is not set to off.
    ExposedToLocalDataLoads = 40,
    /// Represents if the log_connections database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to on.
    ConnectionAttemptsNotLogged = 41,
    /// Represents if the log_disconnections database flag for a Cloud SQL for
    /// PostgreSQL instance is not set to on.
    DisconnectionsNotLogged = 42,
    /// Represents if the log_min_duration_statement database flag for a Cloud SQL
    /// for PostgreSQL instance is not set to -1.
    LoggingExcessiveStatementInfo = 43,
    /// Represents if the remote access database flag for a Cloud SQL for SQL
    /// Server instance is not set to off.
    ExposedToRemoteAccess = 44,
    /// Represents if the skip_show_database database flag for a Cloud SQL for
    /// MySQL instance is not set to on.
    DatabaseNamesExposed = 45,
    /// Represents if the 3625 (trace flag) database flag for a Cloud SQL for
    /// SQL Server instance is not set to on.
    SensitiveTraceInfoNotMasked = 46,
    /// Represents if public IP is enabled.
    PublicIpEnabled = 47,
    /// Represents idle instance helps to reduce costs.
    Idle = 48,
    /// Represents instances that are unnecessarily large for given workload.
    Overprovisioned = 49,
    /// Represents high number of concurrently opened tables.
    HighNumberOfOpenTables = 50,
    /// Represents high table count close to SLA limit.
    HighNumberOfTables = 51,
    /// Represents high number of unvacuumed transactions
    HighTransactionIdUtilization = 52,
    /// Represents need for more CPU and/or memory
    Underprovisioned = 53,
    /// Represents out of disk.
    OutOfDisk = 54,
    /// Represents server certificate is near expiry.
    ServerCertificateNearExpiry = 55,
    /// Represents database auditing is disabled.
    DatabaseAuditingDisabled = 56,
    /// Represents not restricted to authorized networks.
    RestrictAuthorizedNetworks = 57,
    /// Represents violate org policy restrict public ip.
    ViolatePolicyRestrictPublicIp = 58,
    /// Cluster nearing quota limit
    QuotaLimit = 59,
    /// No password policy set on resources
    NoPasswordPolicy = 60,
    /// Performance impact of connections settings
    ConnectionsPerformanceImpact = 61,
    /// Performance impact of temporary tables settings
    TmpTablesPerformanceImpact = 62,
    /// Performance impact of transaction logs settings
    TransLogsPerformanceImpact = 63,
    /// Performance impact of high joins without indexes
    HighJoinsWithoutIndexes = 64,
    /// Detects events where a database superuser (postgres for PostgreSQL servers
    /// or root for MySQL users) writes to non-system tables.
    SuperuserWritingToUserTables = 65,
    /// Detects events where a database user or role has been granted all
    /// privileges to a database, or to all tables, procedures, or functions in a
    /// schema.
    UserGrantedAllPermissions = 66,
    /// Detects if database instance data exported to a Cloud Storage bucket
    /// outside of the organization.
    DataExportToExternalCloudStorageBucket = 67,
    /// Detects if database instance data exported to a Cloud Storage bucket that
    /// is owned by the organization and is publicly accessible.
    DataExportToPublicCloudStorageBucket = 68,
    /// Detects if a database instance is using a weak password hash algorithm.
    WeakPasswordHashAlgorithm = 77,
    /// Detects if a database instance has no user password policy set.
    NoUserPasswordPolicy = 78,
    /// Detects if a database instance/cluster has a hot node.
    HotNode = 79,
    /// Deletion Protection Disabled for the resource
    NoDeletionProtection = 80,
    /// Detects if a database instance has no point in time recovery enabled.
    NoPointInTimeRecovery = 81,
    /// Detects if a database instance/cluster has suspended resources.
    ResourceSuspended = 82,
    /// Detects that expensive commands are being run on a database instance
    /// impacting overall performance.
    ExpensiveCommands = 83,
    /// Indicates that the instance does not have a maintenance policy configured.
    NoMaintenancePolicyConfigured = 84,
    /// Indicates that the instance has inefficient queries detected.
    InefficientQuery = 85,
    /// Indicates that the instance has read intensive workload.
    ReadIntensiveWorkload = 86,
    /// Indicates that the instance is nearing memory limit.
    MemoryLimit = 87,
    /// Indicates that the instance's max server memory is configured higher than
    /// the recommended value.
    MaxServerMemory = 88,
    /// Indicates that the database has large rows beyond the recommended limit.
    LargeRows = 89,
    /// Heavy write pressure on the database rows.
    HighWritePressure = 90,
    /// Heavy read pressure on the database rows.
    HighReadPressure = 91,
    /// Encryption org policy not satisfied.
    EncryptionOrgPolicyNotSatisfied = 92,
    /// Location org policy not satisfied.
    LocationOrgPolicyNotSatisfied = 93,
    /// Outdated DB minor version.
    OutdatedMinorVersion = 94,
    /// Schema not optimized.
    SchemaNotOptimized = 95,
    /// Replication delay.
    ReplicationLag = 97,
    /// Outdated client.
    OutdatedClient = 99,
    /// Databoost is disabled.
    DataboostDisabled = 100,
    /// Recommended maintenance policy.
    RecommendedMaintenancePolicies = 101,
    /// Resource version is in extended support.
    ExtendedSupport = 102,
}
impl SignalType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIGNAL_TYPE_UNSPECIFIED",
            Self::ResourceFailoverProtected => "SIGNAL_TYPE_RESOURCE_FAILOVER_PROTECTED",
            Self::GroupMultiregional => "SIGNAL_TYPE_GROUP_MULTIREGIONAL",
            Self::NoAutomatedBackupPolicy => "SIGNAL_TYPE_NO_AUTOMATED_BACKUP_POLICY",
            Self::ShortBackupRetention => "SIGNAL_TYPE_SHORT_BACKUP_RETENTION",
            Self::LastBackupFailed => "SIGNAL_TYPE_LAST_BACKUP_FAILED",
            Self::LastBackupOld => "SIGNAL_TYPE_LAST_BACKUP_OLD",
            Self::ViolatesCisGcpFoundation20 => {
                "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_2_0"
            }
            Self::ViolatesCisGcpFoundation13 => {
                "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_3"
            }
            Self::ViolatesCisGcpFoundation12 => {
                "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_2"
            }
            Self::ViolatesCisGcpFoundation11 => {
                "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_1"
            }
            Self::ViolatesCisGcpFoundation10 => {
                "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_0"
            }
            Self::ViolatesCisControlsV80 => "SIGNAL_TYPE_VIOLATES_CIS_CONTROLS_V8_0",
            Self::ViolatesNist80053 => "SIGNAL_TYPE_VIOLATES_NIST_800_53",
            Self::ViolatesNist80053R5 => "SIGNAL_TYPE_VIOLATES_NIST_800_53_R5",
            Self::ViolatesNistCybersecurityFrameworkV10 => {
                "SIGNAL_TYPE_VIOLATES_NIST_CYBERSECURITY_FRAMEWORK_V1_0"
            }
            Self::ViolatesIso27001 => "SIGNAL_TYPE_VIOLATES_ISO_27001",
            Self::ViolatesIso27001V2022 => "SIGNAL_TYPE_VIOLATES_ISO_27001_V2022",
            Self::ViolatesPciDssV321 => "SIGNAL_TYPE_VIOLATES_PCI_DSS_V3_2_1",
            Self::ViolatesPciDssV40 => "SIGNAL_TYPE_VIOLATES_PCI_DSS_V4_0",
            Self::ViolatesCloudControlsMatrixV4 => {
                "SIGNAL_TYPE_VIOLATES_CLOUD_CONTROLS_MATRIX_V4"
            }
            Self::ViolatesHipaa => "SIGNAL_TYPE_VIOLATES_HIPAA",
            Self::ViolatesSoc2V2017 => "SIGNAL_TYPE_VIOLATES_SOC2_V2017",
            Self::LogsNotOptimizedForTroubleshooting => {
                "SIGNAL_TYPE_LOGS_NOT_OPTIMIZED_FOR_TROUBLESHOOTING"
            }
            Self::QueryDurationsNotLogged => "SIGNAL_TYPE_QUERY_DURATIONS_NOT_LOGGED",
            Self::VerboseErrorLogging => "SIGNAL_TYPE_VERBOSE_ERROR_LOGGING",
            Self::QueryLockWaitsNotLogged => "SIGNAL_TYPE_QUERY_LOCK_WAITS_NOT_LOGGED",
            Self::LoggingMostErrors => "SIGNAL_TYPE_LOGGING_MOST_ERRORS",
            Self::LoggingOnlyCriticalErrors => "SIGNAL_TYPE_LOGGING_ONLY_CRITICAL_ERRORS",
            Self::MinimalErrorLogging => "SIGNAL_TYPE_MINIMAL_ERROR_LOGGING",
            Self::QueryStatsLogged => "SIGNAL_TYPE_QUERY_STATS_LOGGED",
            Self::ExcessiveLoggingOfClientHostname => {
                "SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_CLIENT_HOSTNAME"
            }
            Self::ExcessiveLoggingOfParserStats => {
                "SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PARSER_STATS"
            }
            Self::ExcessiveLoggingOfPlannerStats => {
                "SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PLANNER_STATS"
            }
            Self::NotLoggingOnlyDdlStatements => {
                "SIGNAL_TYPE_NOT_LOGGING_ONLY_DDL_STATEMENTS"
            }
            Self::LoggingQueryStats => "SIGNAL_TYPE_LOGGING_QUERY_STATS",
            Self::NotLoggingTemporaryFiles => "SIGNAL_TYPE_NOT_LOGGING_TEMPORARY_FILES",
            Self::ConnectionMaxNotConfigured => {
                "SIGNAL_TYPE_CONNECTION_MAX_NOT_CONFIGURED"
            }
            Self::UserOptionsConfigured => "SIGNAL_TYPE_USER_OPTIONS_CONFIGURED",
            Self::ExposedToPublicAccess => "SIGNAL_TYPE_EXPOSED_TO_PUBLIC_ACCESS",
            Self::UnencryptedConnections => "SIGNAL_TYPE_UNENCRYPTED_CONNECTIONS",
            Self::NoRootPassword => "SIGNAL_TYPE_NO_ROOT_PASSWORD",
            Self::WeakRootPassword => "SIGNAL_TYPE_WEAK_ROOT_PASSWORD",
            Self::EncryptionKeyNotCustomerManaged => {
                "SIGNAL_TYPE_ENCRYPTION_KEY_NOT_CUSTOMER_MANAGED"
            }
            Self::ServerAuthenticationNotRequired => {
                "SIGNAL_TYPE_SERVER_AUTHENTICATION_NOT_REQUIRED"
            }
            Self::ExposedToExternalScripts => "SIGNAL_TYPE_EXPOSED_TO_EXTERNAL_SCRIPTS",
            Self::ExposedToLocalDataLoads => "SIGNAL_TYPE_EXPOSED_TO_LOCAL_DATA_LOADS",
            Self::ConnectionAttemptsNotLogged => {
                "SIGNAL_TYPE_CONNECTION_ATTEMPTS_NOT_LOGGED"
            }
            Self::DisconnectionsNotLogged => "SIGNAL_TYPE_DISCONNECTIONS_NOT_LOGGED",
            Self::LoggingExcessiveStatementInfo => {
                "SIGNAL_TYPE_LOGGING_EXCESSIVE_STATEMENT_INFO"
            }
            Self::ExposedToRemoteAccess => "SIGNAL_TYPE_EXPOSED_TO_REMOTE_ACCESS",
            Self::DatabaseNamesExposed => "SIGNAL_TYPE_DATABASE_NAMES_EXPOSED",
            Self::SensitiveTraceInfoNotMasked => {
                "SIGNAL_TYPE_SENSITIVE_TRACE_INFO_NOT_MASKED"
            }
            Self::PublicIpEnabled => "SIGNAL_TYPE_PUBLIC_IP_ENABLED",
            Self::Idle => "SIGNAL_TYPE_IDLE",
            Self::Overprovisioned => "SIGNAL_TYPE_OVERPROVISIONED",
            Self::HighNumberOfOpenTables => "SIGNAL_TYPE_HIGH_NUMBER_OF_OPEN_TABLES",
            Self::HighNumberOfTables => "SIGNAL_TYPE_HIGH_NUMBER_OF_TABLES",
            Self::HighTransactionIdUtilization => {
                "SIGNAL_TYPE_HIGH_TRANSACTION_ID_UTILIZATION"
            }
            Self::Underprovisioned => "SIGNAL_TYPE_UNDERPROVISIONED",
            Self::OutOfDisk => "SIGNAL_TYPE_OUT_OF_DISK",
            Self::ServerCertificateNearExpiry => {
                "SIGNAL_TYPE_SERVER_CERTIFICATE_NEAR_EXPIRY"
            }
            Self::DatabaseAuditingDisabled => "SIGNAL_TYPE_DATABASE_AUDITING_DISABLED",
            Self::RestrictAuthorizedNetworks => {
                "SIGNAL_TYPE_RESTRICT_AUTHORIZED_NETWORKS"
            }
            Self::ViolatePolicyRestrictPublicIp => {
                "SIGNAL_TYPE_VIOLATE_POLICY_RESTRICT_PUBLIC_IP"
            }
            Self::QuotaLimit => "SIGNAL_TYPE_QUOTA_LIMIT",
            Self::NoPasswordPolicy => "SIGNAL_TYPE_NO_PASSWORD_POLICY",
            Self::ConnectionsPerformanceImpact => {
                "SIGNAL_TYPE_CONNECTIONS_PERFORMANCE_IMPACT"
            }
            Self::TmpTablesPerformanceImpact => {
                "SIGNAL_TYPE_TMP_TABLES_PERFORMANCE_IMPACT"
            }
            Self::TransLogsPerformanceImpact => {
                "SIGNAL_TYPE_TRANS_LOGS_PERFORMANCE_IMPACT"
            }
            Self::HighJoinsWithoutIndexes => "SIGNAL_TYPE_HIGH_JOINS_WITHOUT_INDEXES",
            Self::SuperuserWritingToUserTables => {
                "SIGNAL_TYPE_SUPERUSER_WRITING_TO_USER_TABLES"
            }
            Self::UserGrantedAllPermissions => "SIGNAL_TYPE_USER_GRANTED_ALL_PERMISSIONS",
            Self::DataExportToExternalCloudStorageBucket => {
                "SIGNAL_TYPE_DATA_EXPORT_TO_EXTERNAL_CLOUD_STORAGE_BUCKET"
            }
            Self::DataExportToPublicCloudStorageBucket => {
                "SIGNAL_TYPE_DATA_EXPORT_TO_PUBLIC_CLOUD_STORAGE_BUCKET"
            }
            Self::WeakPasswordHashAlgorithm => "SIGNAL_TYPE_WEAK_PASSWORD_HASH_ALGORITHM",
            Self::NoUserPasswordPolicy => "SIGNAL_TYPE_NO_USER_PASSWORD_POLICY",
            Self::HotNode => "SIGNAL_TYPE_HOT_NODE",
            Self::NoDeletionProtection => "SIGNAL_TYPE_NO_DELETION_PROTECTION",
            Self::NoPointInTimeRecovery => "SIGNAL_TYPE_NO_POINT_IN_TIME_RECOVERY",
            Self::ResourceSuspended => "SIGNAL_TYPE_RESOURCE_SUSPENDED",
            Self::ExpensiveCommands => "SIGNAL_TYPE_EXPENSIVE_COMMANDS",
            Self::NoMaintenancePolicyConfigured => {
                "SIGNAL_TYPE_NO_MAINTENANCE_POLICY_CONFIGURED"
            }
            Self::InefficientQuery => "SIGNAL_TYPE_INEFFICIENT_QUERY",
            Self::ReadIntensiveWorkload => "SIGNAL_TYPE_READ_INTENSIVE_WORKLOAD",
            Self::MemoryLimit => "SIGNAL_TYPE_MEMORY_LIMIT",
            Self::MaxServerMemory => "SIGNAL_TYPE_MAX_SERVER_MEMORY",
            Self::LargeRows => "SIGNAL_TYPE_LARGE_ROWS",
            Self::HighWritePressure => "SIGNAL_TYPE_HIGH_WRITE_PRESSURE",
            Self::HighReadPressure => "SIGNAL_TYPE_HIGH_READ_PRESSURE",
            Self::EncryptionOrgPolicyNotSatisfied => {
                "SIGNAL_TYPE_ENCRYPTION_ORG_POLICY_NOT_SATISFIED"
            }
            Self::LocationOrgPolicyNotSatisfied => {
                "SIGNAL_TYPE_LOCATION_ORG_POLICY_NOT_SATISFIED"
            }
            Self::OutdatedMinorVersion => "SIGNAL_TYPE_OUTDATED_MINOR_VERSION",
            Self::SchemaNotOptimized => "SIGNAL_TYPE_SCHEMA_NOT_OPTIMIZED",
            Self::ReplicationLag => "SIGNAL_TYPE_REPLICATION_LAG",
            Self::OutdatedClient => "SIGNAL_TYPE_OUTDATED_CLIENT",
            Self::DataboostDisabled => "SIGNAL_TYPE_DATABOOST_DISABLED",
            Self::RecommendedMaintenancePolicies => {
                "SIGNAL_TYPE_RECOMMENDED_MAINTENANCE_POLICIES"
            }
            Self::ExtendedSupport => "SIGNAL_TYPE_EXTENDED_SUPPORT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIGNAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SIGNAL_TYPE_RESOURCE_FAILOVER_PROTECTED" => {
                Some(Self::ResourceFailoverProtected)
            }
            "SIGNAL_TYPE_GROUP_MULTIREGIONAL" => Some(Self::GroupMultiregional),
            "SIGNAL_TYPE_NO_AUTOMATED_BACKUP_POLICY" => {
                Some(Self::NoAutomatedBackupPolicy)
            }
            "SIGNAL_TYPE_SHORT_BACKUP_RETENTION" => Some(Self::ShortBackupRetention),
            "SIGNAL_TYPE_LAST_BACKUP_FAILED" => Some(Self::LastBackupFailed),
            "SIGNAL_TYPE_LAST_BACKUP_OLD" => Some(Self::LastBackupOld),
            "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_2_0" => {
                Some(Self::ViolatesCisGcpFoundation20)
            }
            "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_3" => {
                Some(Self::ViolatesCisGcpFoundation13)
            }
            "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_2" => {
                Some(Self::ViolatesCisGcpFoundation12)
            }
            "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_1" => {
                Some(Self::ViolatesCisGcpFoundation11)
            }
            "SIGNAL_TYPE_VIOLATES_CIS_GCP_FOUNDATION_1_0" => {
                Some(Self::ViolatesCisGcpFoundation10)
            }
            "SIGNAL_TYPE_VIOLATES_CIS_CONTROLS_V8_0" => {
                Some(Self::ViolatesCisControlsV80)
            }
            "SIGNAL_TYPE_VIOLATES_NIST_800_53" => Some(Self::ViolatesNist80053),
            "SIGNAL_TYPE_VIOLATES_NIST_800_53_R5" => Some(Self::ViolatesNist80053R5),
            "SIGNAL_TYPE_VIOLATES_NIST_CYBERSECURITY_FRAMEWORK_V1_0" => {
                Some(Self::ViolatesNistCybersecurityFrameworkV10)
            }
            "SIGNAL_TYPE_VIOLATES_ISO_27001" => Some(Self::ViolatesIso27001),
            "SIGNAL_TYPE_VIOLATES_ISO_27001_V2022" => Some(Self::ViolatesIso27001V2022),
            "SIGNAL_TYPE_VIOLATES_PCI_DSS_V3_2_1" => Some(Self::ViolatesPciDssV321),
            "SIGNAL_TYPE_VIOLATES_PCI_DSS_V4_0" => Some(Self::ViolatesPciDssV40),
            "SIGNAL_TYPE_VIOLATES_CLOUD_CONTROLS_MATRIX_V4" => {
                Some(Self::ViolatesCloudControlsMatrixV4)
            }
            "SIGNAL_TYPE_VIOLATES_HIPAA" => Some(Self::ViolatesHipaa),
            "SIGNAL_TYPE_VIOLATES_SOC2_V2017" => Some(Self::ViolatesSoc2V2017),
            "SIGNAL_TYPE_LOGS_NOT_OPTIMIZED_FOR_TROUBLESHOOTING" => {
                Some(Self::LogsNotOptimizedForTroubleshooting)
            }
            "SIGNAL_TYPE_QUERY_DURATIONS_NOT_LOGGED" => {
                Some(Self::QueryDurationsNotLogged)
            }
            "SIGNAL_TYPE_VERBOSE_ERROR_LOGGING" => Some(Self::VerboseErrorLogging),
            "SIGNAL_TYPE_QUERY_LOCK_WAITS_NOT_LOGGED" => {
                Some(Self::QueryLockWaitsNotLogged)
            }
            "SIGNAL_TYPE_LOGGING_MOST_ERRORS" => Some(Self::LoggingMostErrors),
            "SIGNAL_TYPE_LOGGING_ONLY_CRITICAL_ERRORS" => {
                Some(Self::LoggingOnlyCriticalErrors)
            }
            "SIGNAL_TYPE_MINIMAL_ERROR_LOGGING" => Some(Self::MinimalErrorLogging),
            "SIGNAL_TYPE_QUERY_STATS_LOGGED" => Some(Self::QueryStatsLogged),
            "SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_CLIENT_HOSTNAME" => {
                Some(Self::ExcessiveLoggingOfClientHostname)
            }
            "SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PARSER_STATS" => {
                Some(Self::ExcessiveLoggingOfParserStats)
            }
            "SIGNAL_TYPE_EXCESSIVE_LOGGING_OF_PLANNER_STATS" => {
                Some(Self::ExcessiveLoggingOfPlannerStats)
            }
            "SIGNAL_TYPE_NOT_LOGGING_ONLY_DDL_STATEMENTS" => {
                Some(Self::NotLoggingOnlyDdlStatements)
            }
            "SIGNAL_TYPE_LOGGING_QUERY_STATS" => Some(Self::LoggingQueryStats),
            "SIGNAL_TYPE_NOT_LOGGING_TEMPORARY_FILES" => {
                Some(Self::NotLoggingTemporaryFiles)
            }
            "SIGNAL_TYPE_CONNECTION_MAX_NOT_CONFIGURED" => {
                Some(Self::ConnectionMaxNotConfigured)
            }
            "SIGNAL_TYPE_USER_OPTIONS_CONFIGURED" => Some(Self::UserOptionsConfigured),
            "SIGNAL_TYPE_EXPOSED_TO_PUBLIC_ACCESS" => Some(Self::ExposedToPublicAccess),
            "SIGNAL_TYPE_UNENCRYPTED_CONNECTIONS" => Some(Self::UnencryptedConnections),
            "SIGNAL_TYPE_NO_ROOT_PASSWORD" => Some(Self::NoRootPassword),
            "SIGNAL_TYPE_WEAK_ROOT_PASSWORD" => Some(Self::WeakRootPassword),
            "SIGNAL_TYPE_ENCRYPTION_KEY_NOT_CUSTOMER_MANAGED" => {
                Some(Self::EncryptionKeyNotCustomerManaged)
            }
            "SIGNAL_TYPE_SERVER_AUTHENTICATION_NOT_REQUIRED" => {
                Some(Self::ServerAuthenticationNotRequired)
            }
            "SIGNAL_TYPE_EXPOSED_TO_EXTERNAL_SCRIPTS" => {
                Some(Self::ExposedToExternalScripts)
            }
            "SIGNAL_TYPE_EXPOSED_TO_LOCAL_DATA_LOADS" => {
                Some(Self::ExposedToLocalDataLoads)
            }
            "SIGNAL_TYPE_CONNECTION_ATTEMPTS_NOT_LOGGED" => {
                Some(Self::ConnectionAttemptsNotLogged)
            }
            "SIGNAL_TYPE_DISCONNECTIONS_NOT_LOGGED" => {
                Some(Self::DisconnectionsNotLogged)
            }
            "SIGNAL_TYPE_LOGGING_EXCESSIVE_STATEMENT_INFO" => {
                Some(Self::LoggingExcessiveStatementInfo)
            }
            "SIGNAL_TYPE_EXPOSED_TO_REMOTE_ACCESS" => Some(Self::ExposedToRemoteAccess),
            "SIGNAL_TYPE_DATABASE_NAMES_EXPOSED" => Some(Self::DatabaseNamesExposed),
            "SIGNAL_TYPE_SENSITIVE_TRACE_INFO_NOT_MASKED" => {
                Some(Self::SensitiveTraceInfoNotMasked)
            }
            "SIGNAL_TYPE_PUBLIC_IP_ENABLED" => Some(Self::PublicIpEnabled),
            "SIGNAL_TYPE_IDLE" => Some(Self::Idle),
            "SIGNAL_TYPE_OVERPROVISIONED" => Some(Self::Overprovisioned),
            "SIGNAL_TYPE_HIGH_NUMBER_OF_OPEN_TABLES" => {
                Some(Self::HighNumberOfOpenTables)
            }
            "SIGNAL_TYPE_HIGH_NUMBER_OF_TABLES" => Some(Self::HighNumberOfTables),
            "SIGNAL_TYPE_HIGH_TRANSACTION_ID_UTILIZATION" => {
                Some(Self::HighTransactionIdUtilization)
            }
            "SIGNAL_TYPE_UNDERPROVISIONED" => Some(Self::Underprovisioned),
            "SIGNAL_TYPE_OUT_OF_DISK" => Some(Self::OutOfDisk),
            "SIGNAL_TYPE_SERVER_CERTIFICATE_NEAR_EXPIRY" => {
                Some(Self::ServerCertificateNearExpiry)
            }
            "SIGNAL_TYPE_DATABASE_AUDITING_DISABLED" => {
                Some(Self::DatabaseAuditingDisabled)
            }
            "SIGNAL_TYPE_RESTRICT_AUTHORIZED_NETWORKS" => {
                Some(Self::RestrictAuthorizedNetworks)
            }
            "SIGNAL_TYPE_VIOLATE_POLICY_RESTRICT_PUBLIC_IP" => {
                Some(Self::ViolatePolicyRestrictPublicIp)
            }
            "SIGNAL_TYPE_QUOTA_LIMIT" => Some(Self::QuotaLimit),
            "SIGNAL_TYPE_NO_PASSWORD_POLICY" => Some(Self::NoPasswordPolicy),
            "SIGNAL_TYPE_CONNECTIONS_PERFORMANCE_IMPACT" => {
                Some(Self::ConnectionsPerformanceImpact)
            }
            "SIGNAL_TYPE_TMP_TABLES_PERFORMANCE_IMPACT" => {
                Some(Self::TmpTablesPerformanceImpact)
            }
            "SIGNAL_TYPE_TRANS_LOGS_PERFORMANCE_IMPACT" => {
                Some(Self::TransLogsPerformanceImpact)
            }
            "SIGNAL_TYPE_HIGH_JOINS_WITHOUT_INDEXES" => {
                Some(Self::HighJoinsWithoutIndexes)
            }
            "SIGNAL_TYPE_SUPERUSER_WRITING_TO_USER_TABLES" => {
                Some(Self::SuperuserWritingToUserTables)
            }
            "SIGNAL_TYPE_USER_GRANTED_ALL_PERMISSIONS" => {
                Some(Self::UserGrantedAllPermissions)
            }
            "SIGNAL_TYPE_DATA_EXPORT_TO_EXTERNAL_CLOUD_STORAGE_BUCKET" => {
                Some(Self::DataExportToExternalCloudStorageBucket)
            }
            "SIGNAL_TYPE_DATA_EXPORT_TO_PUBLIC_CLOUD_STORAGE_BUCKET" => {
                Some(Self::DataExportToPublicCloudStorageBucket)
            }
            "SIGNAL_TYPE_WEAK_PASSWORD_HASH_ALGORITHM" => {
                Some(Self::WeakPasswordHashAlgorithm)
            }
            "SIGNAL_TYPE_NO_USER_PASSWORD_POLICY" => Some(Self::NoUserPasswordPolicy),
            "SIGNAL_TYPE_HOT_NODE" => Some(Self::HotNode),
            "SIGNAL_TYPE_NO_DELETION_PROTECTION" => Some(Self::NoDeletionProtection),
            "SIGNAL_TYPE_NO_POINT_IN_TIME_RECOVERY" => Some(Self::NoPointInTimeRecovery),
            "SIGNAL_TYPE_RESOURCE_SUSPENDED" => Some(Self::ResourceSuspended),
            "SIGNAL_TYPE_EXPENSIVE_COMMANDS" => Some(Self::ExpensiveCommands),
            "SIGNAL_TYPE_NO_MAINTENANCE_POLICY_CONFIGURED" => {
                Some(Self::NoMaintenancePolicyConfigured)
            }
            "SIGNAL_TYPE_INEFFICIENT_QUERY" => Some(Self::InefficientQuery),
            "SIGNAL_TYPE_READ_INTENSIVE_WORKLOAD" => Some(Self::ReadIntensiveWorkload),
            "SIGNAL_TYPE_MEMORY_LIMIT" => Some(Self::MemoryLimit),
            "SIGNAL_TYPE_MAX_SERVER_MEMORY" => Some(Self::MaxServerMemory),
            "SIGNAL_TYPE_LARGE_ROWS" => Some(Self::LargeRows),
            "SIGNAL_TYPE_HIGH_WRITE_PRESSURE" => Some(Self::HighWritePressure),
            "SIGNAL_TYPE_HIGH_READ_PRESSURE" => Some(Self::HighReadPressure),
            "SIGNAL_TYPE_ENCRYPTION_ORG_POLICY_NOT_SATISFIED" => {
                Some(Self::EncryptionOrgPolicyNotSatisfied)
            }
            "SIGNAL_TYPE_LOCATION_ORG_POLICY_NOT_SATISFIED" => {
                Some(Self::LocationOrgPolicyNotSatisfied)
            }
            "SIGNAL_TYPE_OUTDATED_MINOR_VERSION" => Some(Self::OutdatedMinorVersion),
            "SIGNAL_TYPE_SCHEMA_NOT_OPTIMIZED" => Some(Self::SchemaNotOptimized),
            "SIGNAL_TYPE_REPLICATION_LAG" => Some(Self::ReplicationLag),
            "SIGNAL_TYPE_OUTDATED_CLIENT" => Some(Self::OutdatedClient),
            "SIGNAL_TYPE_DATABOOST_DISABLED" => Some(Self::DataboostDisabled),
            "SIGNAL_TYPE_RECOMMENDED_MAINTENANCE_POLICIES" => {
                Some(Self::RecommendedMaintenancePolicies)
            }
            "SIGNAL_TYPE_EXTENDED_SUPPORT" => Some(Self::ExtendedSupport),
            _ => None,
        }
    }
}
/// QueryProductsRequest is the request to get a list of products.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryProductsRequest {
    /// Required. Parent can be a project, a folder, or an organization.
    ///
    /// The allowed values are:
    ///
    /// * projects/{PROJECT_ID}/locations/{LOCATION}
    ///   (e.g.,"projects/foo-bar/locations/us-central1")
    /// * projects/{PROJECT_NUMBER}/locations/{LOCATION}
    ///   (e.g.,"projects/12345678/locations/us-central1")
    /// * folders/{FOLDER_NUMBER}/locations/{LOCATION}
    ///   (e.g.,"folders/1234567/locations/us-central1")
    /// * organizations/{ORGANIZATION_NUMBER}/locations/{LOCATION}
    ///   (e.g.,"organizations/123456/locations/us-central1")
    /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If unspecified, at most 50 products will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListLocations` call.
    /// Provide this to retrieve the subsequent page.
    /// All other parameters except page size should match the call that provided
    /// the page page token.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
}
/// QueryProductsResponse represents the response containing a list of products.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryProductsResponse {
    /// List of database products returned.
    #[prost(message, repeated, tag = "1")]
    pub products: ::prost::alloc::vec::Vec<Product>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. List of unreachable regions from where data could not be
    /// retrieved.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// QueryDatabaseResourceGroupsRequest is the request to get a list of database
/// groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDatabaseResourceGroupsRequest {
    /// Required. Parent can be a project, a folder, or an organization. The search
    /// is limited to the resources within the `scope`.
    ///
    /// The allowed values are:
    ///
    /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The expression to filter resources.
    ///
    /// The following fields are filterable:
    ///
    /// * full_resource_name
    /// * resource_type
    /// * container
    /// * product.type
    /// * product.engine
    /// * product.version
    /// * location
    /// * labels
    /// * resource_category
    /// * machine_config.cpu_count
    /// * machine_config.memory_size_bytes
    /// * machine_config.shard_count
    /// * resource_name
    /// * tags
    /// * backupdr_config.backupdr_managed
    /// * edition
    ///
    /// The expression is a list of zero or more restrictions combined via logical
    /// operators `AND` and `OR`. When `AND` and `OR` are both used in the
    /// expression, parentheses must be appropriately used to group the
    /// combinations.
    ///
    /// Example: location="us-east1"
    /// Example: container="projects/123" OR container="projects/456"
    /// Example: (container="projects/123" OR
    /// container="projects/456") AND location="us-east1"
    /// Example: full_resource_name=<sub>"test"
    /// Example: full_resource_name=</sub>"test.\*master"
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Groups of signal types that are requested.
    #[prost(message, repeated, tag = "3")]
    pub signal_type_groups: ::prost::alloc::vec::Vec<SignalTypeGroup>,
    /// Optional. Filters based on signals. The list will be ORed together and then
    /// ANDed with the `filters` field above.
    #[prost(message, repeated, tag = "4")]
    pub signal_filters: ::prost::alloc::vec::Vec<SignalFilter>,
    /// Optional. A field that specifies the sort order of the results.
    ///
    /// The following fields are sortable:
    ///
    /// * full_resource_name
    /// * product.type
    /// * product.engine
    /// * product.version
    /// * container
    /// * issue_count
    /// * machine_config.vcpu_count
    /// * machine_config.memory_size_bytes
    /// * machine_config.shard_count
    /// * resource_name
    /// * issue_severity
    /// * signal_type
    /// * location
    /// * resource_type
    /// * instance_type
    /// * edition
    /// * metrics.p99_cpu_utilization
    /// * metrics.p95_cpu_utilization
    /// * metrics.current_storage_used_bytes
    /// * metrics.node_count
    /// * metrics.processing_unit_count
    /// * metrics.current_memory_used_bytes
    /// * metrics.peak_storage_utilization
    /// * metrics.peak_number_connections
    /// * metrics.peak_memory_utilization
    ///
    /// The default order is ascending. Add "DESC" after the field name to indicate
    /// descending order. Add "ASC" after the field name to indicate ascending
    /// order. It only supports a single field at a time.
    ///
    /// For example:
    /// order_by = "full_resource_name" sorts response in ascending order
    /// order_by = "full_resource_name DESC" sorts response in descending order
    /// order_by = "issue_count DESC" sorts response in descending order of
    /// count of all issues associated with a resource.
    ///
    /// More explicitly, order_by = "full_resource_name, product" is not supported.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. If unspecified, at most 50 resource groups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "6")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `QueryDatabaseResourceGroupsRequest` call. Provide this to retrieve the
    /// subsequent page. All parameters except page_token should match the
    /// parameters in the call that provided the page page token.
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
}
/// QueryDatabaseResourceGroupsResponse represents the response message
/// containing a list of resource groups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDatabaseResourceGroupsResponse {
    /// List of database resource groups that pass the filter.
    #[prost(message, repeated, tag = "1")]
    pub resource_groups: ::prost::alloc::vec::Vec<DatabaseResourceGroup>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. List of unreachable regions from where data could not be
    /// retrieved.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// DatabaseResourceGroup represents all resources that serve a common data set.
/// It is considered notionally as a single entity, powered by any number of
/// units of compute and storage.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseResourceGroup {
    /// A database resource that serves as a root of the group of database
    /// resources. It is repeated just in case we have the concept of multiple
    /// roots in the future, however, it will only be populated with a single value
    /// for now.
    #[prost(message, repeated, tag = "1")]
    pub root_resources: ::prost::alloc::vec::Vec<DatabaseResource>,
    /// The filtered signal groups and the count of issues associated with the
    /// resources that have been filtered in.
    #[prost(message, repeated, tag = "2")]
    pub signal_groups: ::prost::alloc::vec::Vec<IssueCount>,
}
/// DatabaseResource represents every individually configured database unit
/// representing compute and/or storage.
/// NextId: 20
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseResource {
    /// List of children associated with a database group.
    #[prost(message, repeated, tag = "1")]
    pub child_resources: ::prost::alloc::vec::Vec<DatabaseResource>,
    /// The full resource name, based on CAIS resource name format
    /// <https://cloud.google.com/asset-inventory/docs/resource-name-format>
    ///
    /// Example:
    ///
    /// `//cloudsql.googleapis.com/projects/project-number/instances/mysql-1`
    /// `//cloudsql.googleapis.com/projects/project-number/instances/postgres-1`
    /// `//spanner.googleapis.com/projects/project-number/instances/spanner-instance-1`
    /// `//alloydb.googleapis.com/projects/project-number/locations/us-central1/clusters/c1`
    /// `//alloydb.googleapis.com/projects/project-number/locations/us-central1/clusters/c1/instances/i1`
    #[prost(string, tag = "3")]
    pub full_resource_name: ::prost::alloc::string::String,
    /// Specifies where the resource is created. For GCP, it is the full name of
    /// the project.
    #[prost(string, tag = "4")]
    pub container: ::prost::alloc::string::String,
    /// The product this resource represents.
    #[prost(message, optional, tag = "5")]
    pub product: ::core::option::Option<Product>,
    /// The location of the resources. It supports returning only regional
    /// locations in GCP. These are of the form: "us-central1", "us-east1", etc.
    /// See <https://cloud.google.com/about/locations> for a list of such regions.
    #[prost(string, tag = "6")]
    pub location: ::prost::alloc::string::String,
    /// Labels applied on the resource. The requirements for labels assigned to
    /// Google Cloud resources may be found at
    /// <https://cloud.google.com/resource-manager/docs/labels-overview#requirements>
    #[prost(message, repeated, tag = "7")]
    pub labels: ::prost::alloc::vec::Vec<Label>,
    /// Tags applied on the resource. The requirements for tags assigned to
    /// Google Cloud resources may be found at
    /// <https://cloud.google.com/resource-manager/docs/tags/tags-overview>
    #[prost(message, repeated, tag = "16")]
    pub tags: ::prost::alloc::vec::Vec<Tag>,
    /// The type of resource defined according to the pattern:
    /// {Service Name}/{Type}. Ex:
    /// sqladmin.googleapis.com/Instance
    /// alloydb.googleapis.com/Cluster
    /// alloydb.googleapis.com/Instance
    /// spanner.googleapis.com/Instance
    #[prost(string, tag = "8")]
    pub resource_type: ::prost::alloc::string::String,
    /// Subtype of the resource specified at creation time.
    #[prost(enumeration = "SubResourceType", tag = "9")]
    pub sub_resource_type: i32,
    /// Machine configuration like CPU, memory, etc for the resource.
    #[prost(message, optional, tag = "12")]
    pub machine_config: ::core::option::Option<MachineConfig>,
    /// The list of signal groups and count of issues related to the resource.
    /// Only those signals which have been requested would be included.
    #[prost(message, repeated, tag = "10")]
    pub signal_groups: ::prost::alloc::vec::Vec<SignalGroup>,
    /// Observable metrics for the resource e.g. CPU utilization, memory
    /// utilization, etc.
    #[prost(message, optional, tag = "13")]
    pub metrics: ::core::option::Option<Metrics>,
    /// The category of the resource.
    #[prost(enumeration = "ResourceCategory", tag = "14")]
    pub resource_category: i32,
    /// The name of the resource(The last part of the full resource name).
    /// Example:
    /// For full resource name -
    /// `//cloudsql.googleapis.com/projects/project-number/instances/mysql-1`,
    /// resource name - `mysql-1`
    /// For full resource name -
    /// `//cloudsql.googleapis.com/projects/project-number/instances/postgres-1` ,
    /// resource name - `postgres-1`
    /// Note: In some cases, there might be more than one resource with the same
    /// resource name.
    #[prost(string, tag = "15")]
    pub resource_name: ::prost::alloc::string::String,
    /// Optional. Backup and disaster recovery details for the resource.
    #[prost(message, optional, tag = "17")]
    pub backupdr_config: ::core::option::Option<BackupDrConfig>,
    /// The edition of the resource.
    #[prost(enumeration = "Edition", tag = "18")]
    pub edition: i32,
    /// Optional. The maintenance information of the resource.
    #[prost(message, optional, tag = "19")]
    pub maintenance_info: ::core::option::Option<MaintenanceInfo>,
}
/// AggregateIssueStatsRequest represents the input to the AggregateIssueStats
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateIssueStatsRequest {
    /// Required. Parent can be a project, a folder, or an organization. The search
    /// is limited to the resources within the `scope`.
    ///
    /// The allowed values are:
    ///
    /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The expression to filter resources.
    ///
    /// Supported fields are: `full_resource_name`, `resource_type`, `container`,
    /// `product.type`, `product.engine`, `product.version`, `location`,
    /// `labels`, `issues`, fields of availability_info,
    /// data_protection_info,'resource_name', etc.
    ///
    /// The expression is a list of zero or more restrictions combined via logical
    /// operators `AND` and `OR`. When `AND` and `OR` are both used in the
    /// expression, parentheses must be appropriately used to group the
    /// combinations.
    ///
    /// Example: location="us-east1"
    /// Example: container="projects/123" OR container="projects/456"
    /// Example: (container="projects/123" OR
    /// container="projects/456") AND location="us-east1"
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Lists of signal types that are issues.
    #[prost(message, repeated, tag = "3")]
    pub signal_type_groups: ::prost::alloc::vec::Vec<SignalTypeGroup>,
    /// Optional. The baseline date w.r.t. which the delta counts are calculated.
    /// If not set, delta counts are not included in the response and the response
    /// indicates the current state of the fleet.
    #[prost(message, optional, tag = "4")]
    pub baseline_date: ::core::option::Option<super::super::super::r#type::Date>,
}
/// The response message containing one of more group of relevant health issues
/// for database resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateIssueStatsResponse {
    /// List of issue group stats where each group contains stats for resources
    /// having a particular combination of relevant issues.
    #[prost(message, repeated, tag = "1")]
    pub issue_group_stats: ::prost::alloc::vec::Vec<IssueGroupStats>,
    /// Total count of the resources filtered in based on the user given filter.
    #[prost(int32, tag = "2")]
    pub total_resources_count: i32,
    /// Total count of the resource filtered in based on the user given filter.
    #[prost(int32, tag = "3")]
    pub total_resource_groups_count: i32,
    /// Unordered list. List of unreachable regions from where data could not be
    /// retrieved.
    #[prost(string, repeated, tag = "4")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// IssueGroupStats refers to stats for a particulare combination of relevant
/// health issues of database resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueGroupStats {
    /// Database resource level health card name. This will corresponds to one of
    /// the requested input group names.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// Total count of the groups of resources returned by the filter that
    /// also have one or more resources for which any of the specified issues
    /// are applicable.
    #[prost(int32, tag = "2")]
    pub resource_groups_count: i32,
    /// Total count of resources returned by the filter for which any of the
    /// specified issues are applicable.
    #[prost(int32, tag = "3")]
    pub resources_count: i32,
    /// The number of resource groups from the total groups as defined above
    /// that are healthy with respect to all of the specified issues.
    #[prost(int32, tag = "4")]
    pub healthy_resource_groups_count: i32,
    /// The number of resources from the total defined above in field
    /// total_resources_count that are healthy with respect to all of the specified
    /// issues.
    #[prost(int32, tag = "5")]
    pub healthy_resources_count: i32,
    /// List of issues stats containing count of resources having particular issue
    /// category.
    #[prost(message, repeated, tag = "6")]
    pub issue_stats: ::prost::alloc::vec::Vec<IssueStats>,
}
/// IssueStats holds stats for a particular signal category.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueStats {
    /// Type of signal which is an issue.
    #[prost(enumeration = "SignalType", tag = "1")]
    pub signal_type: i32,
    /// Number of resources having issues of a given type.
    #[prost(int32, tag = "2")]
    pub resource_count: i32,
    /// Optional. Delta counts and details of resources for which issue was raised
    /// or fixed.
    #[prost(message, optional, tag = "3")]
    pub delta_details: ::core::option::Option<DeltaDetails>,
    /// Severity of the issue.
    #[prost(enumeration = "IssueSeverity", optional, tag = "4")]
    pub issue_severity: ::core::option::Option<i32>,
}
/// Label is a key value pair applied to a resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Label {
    /// The key part of the label.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The value part of the label.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// The source of the Label. Source is empty if the label is directly attached
    /// to the resource and not inherited.
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
}
/// The request message to aggregate fleet which are grouped by a field.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AggregateFleetRequest {
    /// Required. Parent can be a project, a folder, or an organization. The search
    /// is limited to the resources within the `scope`.
    ///
    /// The allowed values are:
    ///
    /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
    /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
    /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
    /// * organizations/{ORGANIZATION_NUMBER} (e.g.,
    ///   "organizations/123456")
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The expression to filter resources.
    ///
    /// Supported fields are: `full_resource_name`, `resource_type`, `container`,
    /// `product.type`, `product.engine`, `product.version`, `location`,
    /// `labels`, `issues`, fields of availability_info, data_protection_info,
    /// 'resource_name', etc.
    ///
    /// The expression is a list of zero or more restrictions combined via logical
    /// operators `AND` and `OR`. When `AND` and `OR` are both used in the
    /// expression, parentheses must be appropriately used to group the
    /// combinations.
    ///
    /// Example: location="us-east1"
    /// Example: container="projects/123" OR container="projects/456"
    /// Example: (container="projects/123" OR
    /// container="projects/456") AND location="us-east1"
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. A field that statistics are grouped by.
    /// Valid values are any combination of the following:
    ///
    /// * container
    /// * product.type
    /// * product.engine
    /// * product.version
    /// * location
    /// * sub_resource_type
    /// * management_type
    /// * tag.key
    /// * tag.value
    /// * tag.source
    /// * tag.inherited
    /// * label.key
    /// * label.value
    /// * label.source
    /// * has_maintenance_schedule
    /// * has_deny_maintenance_schedules
    ///   Comma separated list.
    #[prost(string, tag = "3")]
    pub group_by: ::prost::alloc::string::String,
    /// Optional. Valid values to order by are:
    ///
    /// * resource_groups_count
    /// * resources_count
    /// * and all fields supported by `group_by`
    ///   The default order is ascending. Add "DESC" after the field name to indicate
    ///   descending order. Add "ASC" after the field name to indicate ascending
    ///   order. It supports ordering using multiple fields.
    ///   For example:
    ///   order_by = "resource_groups_count" sorts response in ascending order
    ///   order_by = "resource_groups_count DESC" sorts response in descending order
    ///   order_by = "product.type, product.version DESC, location" orders by type
    ///   in ascending order, version in descending order and location in ascending
    ///   order
    #[prost(string, tag = "4")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. If unspecified, at most 50 items will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `AggregateFleet` call.
    /// Provide this to retrieve the subsequent page.
    /// All other parameters should match the parameters in the call that provided
    /// the page token except for page_size which can be different.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The baseline date w.r.t. which the delta counts are calculated.
    /// If not set, delta counts are not included in the response and the response
    /// indicates the current state of the fleet.
    #[prost(message, optional, tag = "7")]
    pub baseline_date: ::core::option::Option<super::super::super::r#type::Date>,
}
/// The response message to aggregate a fleet by some group by fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateFleetResponse {
    /// Represents a row grouped by the fields in the input.
    #[prost(message, repeated, tag = "1")]
    pub rows: ::prost::alloc::vec::Vec<AggregateFleetRow>,
    /// Count of all resource groups in the fleet. This includes counts from all
    /// pages.
    #[prost(int32, tag = "2")]
    pub resource_groups_total_count: i32,
    /// Count of all resources in the fleet. This includes counts from all pages.
    #[prost(int32, tag = "3")]
    pub resource_total_count: i32,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "4")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. List of unreachable regions from where data could not be
    /// retrieved.
    #[prost(string, repeated, tag = "5")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Individual row grouped by a particular dimension.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateFleetRow {
    /// Group by dimension.
    #[prost(message, repeated, tag = "1")]
    pub dimension: ::prost::alloc::vec::Vec<Dimension>,
    /// Number of resource groups that have a particular dimension.
    #[prost(int32, tag = "2")]
    pub resource_groups_count: i32,
    /// Number of resources that have a particular dimension.
    #[prost(int32, tag = "3")]
    pub resources_count: i32,
    /// Optional. Delta counts and details of resources which were added to/deleted
    /// from fleet.
    #[prost(message, optional, tag = "4")]
    pub delta_details: ::core::option::Option<DeltaDetails>,
}
/// Dimension used to aggregate the fleet.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Dimension {
    /// Followings are the dimensions to be used to aggregate the fleet.
    #[prost(
        oneof = "dimension::Dimension",
        tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20"
    )]
    pub dimension: ::core::option::Option<dimension::Dimension>,
}
/// Nested message and enum types in `Dimension`.
pub mod dimension {
    /// Followings are the dimensions to be used to aggregate the fleet.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Dimension {
        /// Specifies where the resource is created. For GCP, it is the full name of
        /// the project.
        #[prost(string, tag = "2")]
        Container(::prost::alloc::string::String),
        /// Type to identify a product
        #[prost(enumeration = "super::ProductType", tag = "3")]
        ProductType(i32),
        /// Engine refers to underlying database binary running in an instance.
        #[prost(enumeration = "super::Engine", tag = "4")]
        ProductEngine(i32),
        /// Version of the underlying database engine
        #[prost(string, tag = "5")]
        ProductVersion(::prost::alloc::string::String),
        /// The location of the resources. It supports returning only regional
        /// locations in GCP.
        #[prost(string, tag = "6")]
        Location(::prost::alloc::string::String),
        /// The type of resource defined according to the pattern:
        /// {Service Name}/{Type}. Ex:
        /// sqladmin.googleapis.com/Instance
        /// alloydb.googleapis.com/Cluster
        /// alloydb.googleapis.com/Instance
        /// spanner.googleapis.com/Instance
        #[prost(string, tag = "7")]
        ResourceType(::prost::alloc::string::String),
        /// Subtype of the resource specified at creation time.
        #[prost(enumeration = "super::SubResourceType", tag = "8")]
        SubResourceType(i32),
        /// The category of the resource.
        #[prost(enumeration = "super::ResourceCategory", tag = "9")]
        ResourceCategory(i32),
        /// The management type of the resource.
        #[prost(enumeration = "super::ManagementType", tag = "10")]
        ManagementType(i32),
        /// The edition of the resource.
        #[prost(enumeration = "super::Edition", tag = "11")]
        Edition(i32),
        /// Tag key of the resource.
        #[prost(string, tag = "12")]
        TagKey(::prost::alloc::string::String),
        /// Tag value of the resource.
        #[prost(string, tag = "13")]
        TagValue(::prost::alloc::string::String),
        /// Tag source of the resource.
        #[prost(string, tag = "14")]
        TagSource(::prost::alloc::string::String),
        /// Tag inheritance value of the resource.
        #[prost(bool, tag = "15")]
        TagInherited(bool),
        /// Label key of the resource.
        #[prost(string, tag = "16")]
        LabelKey(::prost::alloc::string::String),
        /// Label value of the resource.
        #[prost(string, tag = "17")]
        LabelValue(::prost::alloc::string::String),
        /// Label source of the resource.
        #[prost(string, tag = "18")]
        LabelSource(::prost::alloc::string::String),
        /// Whether the resource has a maintenance schedule.
        #[prost(bool, tag = "19")]
        HasMaintenanceSchedule(bool),
        /// Whether the resource has deny maintenance schedules.
        #[prost(bool, tag = "20")]
        HasDenyMaintenanceSchedules(bool),
    }
}
/// BackupDRConfig to capture the backup and disaster recovery details of
/// database resource.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupDrConfig {
    /// Indicates if the resource is managed by BackupDR.
    #[prost(bool, optional, tag = "1")]
    pub backupdr_managed: ::core::option::Option<bool>,
}
/// Tag is a key value pair attached to a resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tag {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// The value part of the tag.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// The source of the tag. According to
    /// <https://cloud.google.com/resource-manager/docs/tags/tags-overview#tags_and_labels,>
    /// tags can be created only at the project or organization level. Tags can be
    /// inherited from different project as well not just the current project where
    /// the database resource is present.
    /// Format:
    /// "projects/{PROJECT_ID}",
    /// "projects/{PROJECT_NUMBER}",
    /// "organizations/{ORGANIZATION_ID}"
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
    /// Indicates the inheritance status of a tag value
    /// attached to the given resource. If the tag value is inherited from one of
    /// the resource's ancestors, inherited will be true. If false, then the tag
    /// value is directly attached to the resource.
    #[prost(bool, tag = "4")]
    pub inherited: bool,
}
/// Capture the resource details for resources that are included in the delta
/// counts.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceDetails {
    /// Full resource name of the resource.
    #[prost(string, tag = "1")]
    pub full_resource_name: ::prost::alloc::string::String,
    /// Specifies where the resource is created. For GCP, it is the full name of
    /// the project.
    #[prost(string, tag = "2")]
    pub container: ::prost::alloc::string::String,
    /// Product type of the resource.
    #[prost(message, optional, tag = "3")]
    pub product: ::core::option::Option<Product>,
    /// Location of the resource.
    #[prost(string, tag = "4")]
    pub location: ::prost::alloc::string::String,
}
/// Captures the details of items that have increased or decreased in some bucket
/// when compared to some point in history.
/// It is currently used to capture the delta of resources that have been added
/// or removed in the fleet as well as to capture the resources that have a
/// change in Issue/Signal status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeltaDetails {
    /// Details of resources that have increased.
    #[prost(message, repeated, tag = "1")]
    pub increased_resources: ::prost::alloc::vec::Vec<ResourceDetails>,
    /// Details of resources that have decreased.
    #[prost(message, repeated, tag = "2")]
    pub decreased_resources: ::prost::alloc::vec::Vec<ResourceDetails>,
}
/// The enum value corresponds to 'type' suffix in the resource_type field.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ResourceCategory {
    /// Unspecified.
    Unspecified = 0,
    /// A resource that is an Instance.
    Instance = 1,
    /// A resource that is a Cluster.
    Cluster = 2,
    /// A resource that is a Database.
    Database = 3,
}
impl ResourceCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RESOURCE_CATEGORY_UNSPECIFIED",
            Self::Instance => "INSTANCE",
            Self::Cluster => "CLUSTER",
            Self::Database => "DATABASE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RESOURCE_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTANCE" => Some(Self::Instance),
            "CLUSTER" => Some(Self::Cluster),
            "DATABASE" => Some(Self::Database),
            _ => None,
        }
    }
}
/// Proto representing the edition of the instance.
/// NextId: 4.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Edition {
    /// Default, to make it consistent with instance edition enum.
    Unspecified = 0,
    /// Represents the enterprise edition.
    Enterprise = 1,
    /// Represents the enterprise plus edition.
    EnterprisePlus = 2,
    /// Represents the standard edition.
    Standard = 3,
}
impl Edition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EDITION_UNSPECIFIED",
            Self::Enterprise => "EDITION_ENTERPRISE",
            Self::EnterprisePlus => "EDITION_ENTERPRISE_PLUS",
            Self::Standard => "EDITION_STANDARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDITION_UNSPECIFIED" => Some(Self::Unspecified),
            "EDITION_ENTERPRISE" => Some(Self::Enterprise),
            "EDITION_ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
            "EDITION_STANDARD" => Some(Self::Standard),
            _ => None,
        }
    }
}
/// SubResourceType refers to the sub-type of database resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubResourceType {
    /// Unspecified.
    Unspecified = 0,
    /// A resource acting as a primary.
    Primary = 1,
    /// A resource acting as a secondary.
    Secondary = 2,
    /// A resource acting as a read-replica.
    ReadReplica = 3,
    /// A resource acting as an external primary.
    ExternalPrimary = 5,
    /// For the rest of the categories.
    Other = 4,
}
impl SubResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUB_RESOURCE_TYPE_UNSPECIFIED",
            Self::Primary => "SUB_RESOURCE_TYPE_PRIMARY",
            Self::Secondary => "SUB_RESOURCE_TYPE_SECONDARY",
            Self::ReadReplica => "SUB_RESOURCE_TYPE_READ_REPLICA",
            Self::ExternalPrimary => "SUB_RESOURCE_TYPE_EXTERNAL_PRIMARY",
            Self::Other => "SUB_RESOURCE_TYPE_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUB_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SUB_RESOURCE_TYPE_PRIMARY" => Some(Self::Primary),
            "SUB_RESOURCE_TYPE_SECONDARY" => Some(Self::Secondary),
            "SUB_RESOURCE_TYPE_READ_REPLICA" => Some(Self::ReadReplica),
            "SUB_RESOURCE_TYPE_EXTERNAL_PRIMARY" => Some(Self::ExternalPrimary),
            "SUB_RESOURCE_TYPE_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// The management type of the resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ManagementType {
    /// Unspecified.
    Unspecified = 0,
    /// Google-managed resource.
    GcpManaged = 1,
    /// Self-managed resource.
    SelfManaged = 2,
}
impl ManagementType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MANAGEMENT_TYPE_UNSPECIFIED",
            Self::GcpManaged => "MANAGEMENT_TYPE_GCP_MANAGED",
            Self::SelfManaged => "MANAGEMENT_TYPE_SELF_MANAGED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MANAGEMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MANAGEMENT_TYPE_GCP_MANAGED" => Some(Self::GcpManaged),
            "MANAGEMENT_TYPE_SELF_MANAGED" => Some(Self::SelfManaged),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod database_center_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// DatabaseCenter contains methods to query fleet view for database resources.
    #[derive(Debug, Clone)]
    pub struct DatabaseCenterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DatabaseCenterClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DatabaseCenterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DatabaseCenterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DatabaseCenterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// QueryProducts provides a list of all possible products which can be used to
        /// filter database resources.
        pub async fn query_products(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryProductsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryProductsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.databasecenter.v1beta.DatabaseCenter/QueryProducts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.databasecenter.v1beta.DatabaseCenter",
                        "QueryProducts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AggregateFleet provides statistics about the fleet grouped by various
        /// fields.
        pub async fn aggregate_fleet(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregateFleetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AggregateFleetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.databasecenter.v1beta.DatabaseCenter/AggregateFleet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.databasecenter.v1beta.DatabaseCenter",
                        "AggregateFleet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// QueryDatabaseResourceGroups returns paginated results of database groups.
        pub async fn query_database_resource_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDatabaseResourceGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryDatabaseResourceGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.databasecenter.v1beta.DatabaseCenter/QueryDatabaseResourceGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.databasecenter.v1beta.DatabaseCenter",
                        "QueryDatabaseResourceGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// AggregateIssueStats provides database resource issues statistics.
        pub async fn aggregate_issue_stats(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregateIssueStatsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AggregateIssueStatsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.databasecenter.v1beta.DatabaseCenter/AggregateIssueStats",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.databasecenter.v1beta.DatabaseCenter",
                        "AggregateIssueStats",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
