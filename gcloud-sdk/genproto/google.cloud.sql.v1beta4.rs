// This file is @generated by prost-build.
/// An entry for an Access Control list.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AclEntry {
    /// The allowlisted value for the access control list.
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    /// The time when this access control entry expires in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "2")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. A label to identify this entry.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// This is always `sql#aclEntry`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
}
/// An Admin API warning message.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApiWarning {
    /// Code to uniquely identify the warning type.
    #[prost(enumeration = "api_warning::SqlApiWarningCode", tag = "1")]
    pub code: i32,
    /// The warning message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// The region name for REGION_UNREACHABLE warning.
    #[prost(string, tag = "3")]
    pub region: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ApiWarning`.
pub mod api_warning {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlApiWarningCode {
        /// An unknown or unset warning type from Cloud SQL API.
        Unspecified = 0,
        /// Warning when one or more regions are not reachable.  The returned result
        /// set may be incomplete.
        RegionUnreachable = 1,
        /// Warning when user provided maxResults parameter exceeds the limit.  The
        /// returned result set may be incomplete.
        MaxResultsExceedsLimit = 2,
        /// Warning when user tries to create/update a user with credentials that
        /// have previously been compromised by a public data breach.
        CompromisedCredentials = 3,
        /// Warning when the operation succeeds but some non-critical workflow state
        /// failed.
        InternalStateFailure = 4,
    }
    impl SqlApiWarningCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_API_WARNING_CODE_UNSPECIFIED",
                Self::RegionUnreachable => "REGION_UNREACHABLE",
                Self::MaxResultsExceedsLimit => "MAX_RESULTS_EXCEEDS_LIMIT",
                Self::CompromisedCredentials => "COMPROMISED_CREDENTIALS",
                Self::InternalStateFailure => "INTERNAL_STATE_FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_API_WARNING_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REGION_UNREACHABLE" => Some(Self::RegionUnreachable),
                "MAX_RESULTS_EXCEEDS_LIMIT" => Some(Self::MaxResultsExceedsLimit),
                "COMPROMISED_CREDENTIALS" => Some(Self::CompromisedCredentials),
                "INTERNAL_STATE_FAILURE" => Some(Self::InternalStateFailure),
                _ => None,
            }
        }
    }
}
/// We currently only support backup retention by specifying the number
/// of backups we will retain.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupRetentionSettings {
    /// The unit that 'retained_backups' represents.
    #[prost(enumeration = "backup_retention_settings::RetentionUnit", tag = "1")]
    pub retention_unit: i32,
    /// Depending on the value of retention_unit, this is used to determine
    /// if a backup needs to be deleted.  If retention_unit is 'COUNT', we will
    /// retain this many backups.
    #[prost(message, optional, tag = "2")]
    pub retained_backups: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BackupRetentionSettings`.
pub mod backup_retention_settings {
    /// The units that retained_backups specifies, we only support COUNT.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RetentionUnit {
        /// Backup retention unit is unspecified, will be treated as COUNT.
        Unspecified = 0,
        /// Retention will be by count, eg. "retain the most recent 7 backups".
        Count = 1,
    }
    impl RetentionUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RETENTION_UNIT_UNSPECIFIED",
                Self::Count => "COUNT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETENTION_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "COUNT" => Some(Self::Count),
                _ => None,
            }
        }
    }
}
/// Database instance backup configuration.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupConfiguration {
    /// Start time for the daily backup configuration in UTC timezone in the 24
    /// hour format - `HH:MM`.
    #[prost(string, tag = "1")]
    pub start_time: ::prost::alloc::string::String,
    /// Whether this configuration is enabled.
    #[prost(message, optional, tag = "2")]
    pub enabled: ::core::option::Option<bool>,
    /// This is always `sql#backupConfiguration`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// (MySQL only) Whether binary log is enabled. If backup configuration is
    /// disabled, binarylog must be disabled as well.
    #[prost(message, optional, tag = "4")]
    pub binary_log_enabled: ::core::option::Option<bool>,
    /// Reserved for future use.
    #[prost(message, optional, tag = "5")]
    pub replication_log_archiving_enabled: ::core::option::Option<bool>,
    /// Location of the backup
    #[prost(string, tag = "6")]
    pub location: ::prost::alloc::string::String,
    /// Whether point in time recovery is enabled.
    #[prost(message, optional, tag = "7")]
    pub point_in_time_recovery_enabled: ::core::option::Option<bool>,
    /// The number of days of transaction logs we retain for point in time
    /// restore, from 1-7.
    #[prost(message, optional, tag = "9")]
    pub transaction_log_retention_days: ::core::option::Option<i32>,
    /// Backup retention settings.
    #[prost(message, optional, tag = "10")]
    pub backup_retention_settings: ::core::option::Option<BackupRetentionSettings>,
    /// Output only. This value contains the storage location of transactional logs
    /// for the database for point-in-time recovery.
    #[prost(
        enumeration = "backup_configuration::TransactionalLogStorageState",
        optional,
        tag = "11"
    )]
    pub transactional_log_storage_state: ::core::option::Option<i32>,
    /// Output only. Backup tier that manages the backups for the instance.
    #[prost(enumeration = "backup_configuration::BackupTier", optional, tag = "12")]
    pub backup_tier: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BackupConfiguration`.
pub mod backup_configuration {
    /// This value contains the storage location of the transactional logs
    /// used to perform point-in-time recovery (PITR) for the database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionalLogStorageState {
        /// Unspecified.
        Unspecified = 0,
        /// The transaction logs used for PITR for the instance are stored
        /// on a data disk.
        Disk = 1,
        /// The transaction logs used for PITR for the instance are switching from
        /// being stored on a data disk to being stored in Cloud Storage.
        /// Only applicable to MySQL.
        SwitchingToCloudStorage = 2,
        /// The transaction logs used for PITR for the instance are now stored
        /// in Cloud Storage. Previously, they were stored on a data disk.
        /// Only applicable to MySQL.
        SwitchedToCloudStorage = 3,
        /// The transaction logs used for PITR for the instance are stored in
        /// Cloud Storage. Only applicable to MySQL and PostgreSQL.
        CloudStorage = 4,
    }
    impl TransactionalLogStorageState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED",
                Self::Disk => "DISK",
                Self::SwitchingToCloudStorage => "SWITCHING_TO_CLOUD_STORAGE",
                Self::SwitchedToCloudStorage => "SWITCHED_TO_CLOUD_STORAGE",
                Self::CloudStorage => "CLOUD_STORAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTIONAL_LOG_STORAGE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DISK" => Some(Self::Disk),
                "SWITCHING_TO_CLOUD_STORAGE" => Some(Self::SwitchingToCloudStorage),
                "SWITCHED_TO_CLOUD_STORAGE" => Some(Self::SwitchedToCloudStorage),
                "CLOUD_STORAGE" => Some(Self::CloudStorage),
                _ => None,
            }
        }
    }
    /// Backup tier that manages the backups for the instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupTier {
        /// Unspecified.
        Unspecified = 0,
        /// Instance is managed by Cloud SQL.
        Standard = 1,
        /// Deprecated: ADVANCED is deprecated. Please use ENHANCED instead.
        #[deprecated]
        Advanced = 2,
        /// Instance is managed by Google Cloud Backup and DR Service.
        Enhanced = 3,
    }
    impl BackupTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_TIER_UNSPECIFIED",
                Self::Standard => "STANDARD",
                #[allow(deprecated)]
                Self::Advanced => "ADVANCED",
                Self::Enhanced => "ENHANCED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "ADVANCED" => Some(#[allow(deprecated)] Self::Advanced),
                "ENHANCED" => Some(Self::Enhanced),
                _ => None,
            }
        }
    }
}
/// A BackupRun resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupRun {
    /// This is always `sql#backupRun`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The status of this run.
    #[prost(enumeration = "SqlBackupRunStatus", tag = "2")]
    pub status: i32,
    /// The time the run was enqueued in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "3")]
    pub enqueued_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The identifier for this backup run. Unique only for a specific Cloud SQL
    /// instance.
    #[prost(int64, tag = "4")]
    pub id: i64,
    /// The time the backup operation actually started in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the backup operation completed in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Information about why the backup operation failed. This is only present if
    /// the run has the FAILED status.
    #[prost(message, optional, tag = "7")]
    pub error: ::core::option::Option<OperationError>,
    /// The type of this run; can be either "AUTOMATED" or "ON_DEMAND" or "FINAL".
    /// This field defaults to "ON_DEMAND" and is ignored, when specified for
    /// insert requests.
    #[prost(enumeration = "SqlBackupRunType", tag = "8")]
    pub r#type: i32,
    /// The description of this run, only applicable to on-demand backups.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// The start time of the backup window during which this the backup was
    /// attempted in [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for
    /// example `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "10")]
    pub window_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Name of the database instance.
    #[prost(string, tag = "11")]
    pub instance: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "12")]
    pub self_link: ::prost::alloc::string::String,
    /// Location of the backups.
    #[prost(string, tag = "13")]
    pub location: ::prost::alloc::string::String,
    /// Output only. The instance database version at the time this backup was
    /// made.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "15")]
    pub database_version: i32,
    /// Encryption configuration specific to a backup.
    #[prost(message, optional, tag = "16")]
    pub disk_encryption_configuration: ::core::option::Option<
        DiskEncryptionConfiguration,
    >,
    /// Encryption status specific to a backup.
    #[prost(message, optional, tag = "17")]
    pub disk_encryption_status: ::core::option::Option<DiskEncryptionStatus>,
    /// Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    #[prost(enumeration = "SqlBackupKind", tag = "19")]
    pub backup_kind: i32,
    /// Backup time zone to prevent restores to an instance with
    /// a different time zone. Now relevant only for SQL Server.
    #[prost(string, tag = "23")]
    pub time_zone: ::prost::alloc::string::String,
    /// Output only. The maximum chargeable bytes for the backup.
    #[prost(int64, optional, tag = "24")]
    pub max_chargeable_bytes: ::core::option::Option<i64>,
}
/// A backup resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backup {
    /// Output only. The resource name of the backup.
    /// Format: projects/{project}/backups/{backup}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. This is always `sql#backup`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// Output only. The URI of this resource.
    #[prost(string, tag = "3")]
    pub self_link: ::prost::alloc::string::String,
    /// Output only. The type of this backup. The type can be "AUTOMATED",
    /// "ON_DEMAND", or “FINAL”.
    #[prost(enumeration = "backup::SqlBackupType", tag = "4")]
    pub r#type: i32,
    /// The description of this backup.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// The name of the database instance.
    #[prost(string, tag = "6")]
    pub instance: ::prost::alloc::string::String,
    /// The storage location of the backups. The location can be multi-regional.
    #[prost(string, tag = "7")]
    pub location: ::prost::alloc::string::String,
    /// Output only. This output contains the following values:
    /// start_time: All database writes up to this time are available.
    /// end_time: Any database writes after this time aren't available.
    #[prost(message, optional, tag = "8")]
    pub backup_interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// Output only. The state of this backup.
    #[prost(enumeration = "backup::SqlBackupState", tag = "9")]
    pub state: i32,
    /// Output only. Information about why the backup operation fails (for example,
    /// when the backup state fails).
    #[prost(message, optional, tag = "10")]
    pub error: ::core::option::Option<OperationError>,
    /// Output only. This output contains the encryption configuration for a backup
    /// and the resource name of the KMS key for disk encryption.
    #[prost(string, tag = "11")]
    pub kms_key: ::prost::alloc::string::String,
    /// Output only. This output contains the encryption status for a backup and
    /// the version of the KMS key that's used to encrypt the Cloud SQL instance.
    #[prost(string, tag = "12")]
    pub kms_key_version: ::prost::alloc::string::String,
    /// Output only. Specifies the kind of backup, PHYSICAL or DEFAULT_SNAPSHOT.
    #[prost(enumeration = "SqlBackupKind", tag = "13")]
    pub backup_kind: i32,
    /// Output only. This output contains a backup time zone. If a Cloud SQL for
    /// SQL Server instance has a different time zone from the backup's time zone,
    /// then the restore to the instance doesn't happen.
    #[prost(string, tag = "15")]
    pub time_zone: ::prost::alloc::string::String,
    /// Output only. The database version of the instance of at the time this
    /// backup was made.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "20")]
    pub database_version: i32,
    /// Output only. The maximum chargeable bytes for the backup.
    #[prost(int64, optional, tag = "23")]
    pub max_chargeable_bytes: ::core::option::Option<i64>,
    /// Optional. Output only. Timestamp in UTC of when the instance associated
    /// with this backup is deleted.
    #[prost(message, optional, tag = "24")]
    pub instance_deletion_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Output only. Instance setting of the source instance that's
    /// associated with this backup.
    #[prost(message, optional, tag = "25")]
    pub instance_settings: ::core::option::Option<DatabaseInstance>,
    /// Output only. The mapping to backup run resource used for IAM validations.
    #[prost(string, tag = "26")]
    pub backup_run: ::prost::alloc::string::String,
    /// Output only. This status indicates whether the backup satisfies PZS.
    ///
    /// The status is reserved for future use.
    #[prost(message, optional, tag = "27")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    /// Output only. This status indicates whether the backup satisfies PZI.
    ///
    /// The status is reserved for future use.
    #[prost(message, optional, tag = "28")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(oneof = "backup::Expiration", tags = "16, 17")]
    pub expiration: ::core::option::Option<backup::Expiration>,
}
/// Nested message and enum types in `Backup`.
pub mod backup {
    /// The backup type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlBackupType {
        /// This is an unknown backup type.
        Unspecified = 0,
        /// The backup schedule triggers a backup automatically.
        Automated = 1,
        /// The user triggers a backup manually.
        OnDemand = 2,
        /// The backup that's created when the instance is deleted.
        Final = 3,
    }
    impl SqlBackupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_BACKUP_TYPE_UNSPECIFIED",
                Self::Automated => "AUTOMATED",
                Self::OnDemand => "ON_DEMAND",
                Self::Final => "FINAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_BACKUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATED" => Some(Self::Automated),
                "ON_DEMAND" => Some(Self::OnDemand),
                "FINAL" => Some(Self::Final),
                _ => None,
            }
        }
    }
    /// The backup's state
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlBackupState {
        /// The state of the backup is unknown.
        Unspecified = 0,
        /// The backup that's added to a queue.
        Enqueued = 1,
        /// The backup is in progress.
        Running = 2,
        /// The backup failed.
        Failed = 3,
        /// The backup is successful.
        Successful = 4,
        /// The backup is being deleted.
        Deleting = 5,
        /// Deletion of the backup failed.
        DeletionFailed = 6,
    }
    impl SqlBackupState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_BACKUP_STATE_UNSPECIFIED",
                Self::Enqueued => "ENQUEUED",
                Self::Running => "RUNNING",
                Self::Failed => "FAILED",
                Self::Successful => "SUCCESSFUL",
                Self::Deleting => "DELETING",
                Self::DeletionFailed => "DELETION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_BACKUP_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENQUEUED" => Some(Self::Enqueued),
                "RUNNING" => Some(Self::Running),
                "FAILED" => Some(Self::Failed),
                "SUCCESSFUL" => Some(Self::Successful),
                "DELETING" => Some(Self::Deleting),
                "DELETION_FAILED" => Some(Self::DeletionFailed),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Expiration {
        /// Input only. The time-to-live (TTL) interval for this resource (in days).
        /// For example: ttlDays:7, means 7 days from the current time. The
        /// expiration time can't exceed 365 days from the time that the backup is
        /// created.
        #[prost(int64, tag = "16")]
        TtlDays(i64),
        /// Backup expiration time.
        /// A UTC timestamp of when this resource expired.
        #[prost(message, tag = "17")]
        ExpiryTime(::prost_types::Timestamp),
    }
}
/// Backup run list results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupRunsListResponse {
    /// This is always `sql#backupRunsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// A list of backup runs in reverse chronological order of the enqueued time.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<BackupRun>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Binary log coordinates.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BinLogCoordinates {
    /// Name of the binary log file for a Cloud SQL instance.
    #[prost(string, tag = "1")]
    pub bin_log_file_name: ::prost::alloc::string::String,
    /// Position (offset) within the binary log file.
    #[prost(int64, tag = "2")]
    pub bin_log_position: i64,
    /// This is always `sql#binLogCoordinates`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Backup context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupContext {
    /// The identifier of the backup.
    #[prost(int64, tag = "1")]
    pub backup_id: i64,
    /// This is always `sql#backupContext`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// The name of the backup.
    /// Format: projects/{project}/backups/{backup}
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
}
/// Database instance clone context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloneContext {
    /// This is always `sql#cloneContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Reserved for future use.
    #[prost(int64, tag = "2")]
    pub pitr_timestamp_ms: i64,
    /// Name of the Cloud SQL instance to be created as a clone.
    #[prost(string, tag = "3")]
    pub destination_instance_name: ::prost::alloc::string::String,
    /// Binary log coordinates, if specified, identify the position up to which the
    /// source instance is cloned. If not specified, the source instance is
    /// cloned up to the most recent binary log coordinates.
    #[prost(message, optional, tag = "4")]
    pub bin_log_coordinates: ::core::option::Option<BinLogCoordinates>,
    /// Timestamp, if specified, identifies the time to which the source instance
    /// is cloned.
    #[prost(message, optional, tag = "5")]
    pub point_in_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the cloned instance
    /// ip will be created in the allocated range. The range name must comply with
    /// [RFC 1035](<https://tools.ietf.org/html/rfc1035>). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// [a-z](\[-a-z0-9\]*[a-z0-9])?.
    /// Reserved for future use.
    #[prost(string, tag = "6")]
    pub allocated_ip_range: ::prost::alloc::string::String,
    /// (SQL Server only) Clone only the specified databases from the source
    /// instance. Clone all databases if empty.
    #[prost(string, repeated, tag = "9")]
    pub database_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Copy clone and point-in-time recovery clone of an instance to the
    /// specified zone. If no zone is specified, clone to the same primary zone as
    /// the source instance.
    #[prost(string, optional, tag = "10")]
    pub preferred_zone: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Copy clone and point-in-time recovery clone of a regional
    /// instance in the specified zones. If not specified, clone to the same
    /// secondary zone as the source instance. This value cannot be the same as the
    /// preferred_zone field.
    #[prost(string, optional, tag = "11")]
    pub preferred_secondary_zone: ::core::option::Option<::prost::alloc::string::String>,
    /// The timestamp used to identify the time when the source instance is
    /// deleted. If this instance is deleted, then you must set the timestamp.
    #[prost(message, optional, tag = "12")]
    pub source_instance_deletion_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Represents a SQL database on the Cloud SQL instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Database {
    /// This is always `sql#database`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The Cloud SQL charset value.
    #[prost(string, tag = "2")]
    pub charset: ::prost::alloc::string::String,
    /// The Cloud SQL collation value.
    #[prost(string, tag = "3")]
    pub collation: ::prost::alloc::string::String,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    /// The name of the database in the Cloud SQL instance. This does not include
    /// the project ID or instance name.
    #[prost(string, tag = "5")]
    pub name: ::prost::alloc::string::String,
    /// The name of the Cloud SQL instance. This does not include the project ID.
    #[prost(string, tag = "6")]
    pub instance: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "7")]
    pub self_link: ::prost::alloc::string::String,
    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable.
    #[prost(string, tag = "8")]
    pub project: ::prost::alloc::string::String,
    #[prost(oneof = "database::DatabaseDetails", tags = "9")]
    pub database_details: ::core::option::Option<database::DatabaseDetails>,
}
/// Nested message and enum types in `Database`.
pub mod database {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DatabaseDetails {
        #[prost(message, tag = "9")]
        SqlserverDatabaseDetails(super::SqlServerDatabaseDetails),
    }
}
/// Represents a Sql Server database on the Cloud SQL instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlServerDatabaseDetails {
    /// The version of SQL Server with which the database is to be made compatible
    #[prost(int32, tag = "1")]
    pub compatibility_level: i32,
    /// The recovery model of a SQL Server database
    #[prost(string, tag = "2")]
    pub recovery_model: ::prost::alloc::string::String,
}
/// Database flags for Cloud SQL instances.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseFlags {
    /// The name of the flag. These flags are passed at instance startup, so
    /// include both server options and system variables. Flags are
    /// specified with underscores, not hyphens. For more information, see
    /// [Configuring Database Flags](<https://cloud.google.com/sql/docs/mysql/flags>)
    /// in the Cloud SQL documentation.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The value of the flag. Boolean flags are set to `on` for true
    /// and `off` for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Initial sync flags for certain Cloud SQL APIs.
/// Currently used for the MySQL external server initial dump.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncFlags {
    /// The name of the flag.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The value of the flag. This field must be omitted if the flag
    /// doesn't take a value.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Reference to another Cloud SQL instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstanceReference {
    /// The name of the Cloud SQL instance being referenced.
    /// This does not include the project ID.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The region of the Cloud SQL instance being referenced.
    #[prost(string, tag = "2")]
    pub region: ::prost::alloc::string::String,
    /// The project ID of the Cloud SQL instance being referenced.
    /// The default is the same project ID as the instance references it.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
/// A Cloud SQL instance resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseInstance {
    /// This is always `sql#instance`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The current serving state of the Cloud SQL instance.
    #[prost(enumeration = "database_instance::SqlInstanceState", tag = "2")]
    pub state: i32,
    /// The database engine type and version. The `databaseVersion` field cannot
    /// be changed after instance creation.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "3")]
    pub database_version: i32,
    /// The user settings.
    #[prost(message, optional, tag = "4")]
    pub settings: ::core::option::Option<Settings>,
    /// This field is deprecated and will be removed from a future version of the
    /// API. Use the `settings.settingsVersion` field instead.
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    /// The name and status of the failover replica.
    #[prost(message, optional, tag = "6")]
    pub failover_replica: ::core::option::Option<database_instance::SqlFailoverReplica>,
    /// The name of the instance which will act as primary in the replication
    /// setup.
    #[prost(string, tag = "7")]
    pub master_instance_name: ::prost::alloc::string::String,
    /// The replicas of the instance.
    #[prost(string, repeated, tag = "8")]
    pub replica_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The maximum disk size of the instance in bytes.
    #[deprecated]
    #[prost(message, optional, tag = "9")]
    pub max_disk_size: ::core::option::Option<i64>,
    /// The current disk usage of the instance in bytes. This property has been
    /// deprecated. Use the
    /// "cloudsql.googleapis.com/database/disk/bytes_used" metric in Cloud
    /// Monitoring API instead. Please see [this
    /// announcement](<https://groups.google.com/d/msg/google-cloud-sql-announce/I_7-F9EBhT0/BtvFtdFeAgAJ>)
    /// for details.
    #[deprecated]
    #[prost(message, optional, tag = "10")]
    pub current_disk_size: ::core::option::Option<i64>,
    /// The assigned IP addresses for the instance.
    #[prost(message, repeated, tag = "11")]
    pub ip_addresses: ::prost::alloc::vec::Vec<IpMapping>,
    /// SSL configuration.
    #[prost(message, optional, tag = "12")]
    pub server_ca_cert: ::core::option::Option<SslCert>,
    /// The instance type.
    #[prost(enumeration = "SqlInstanceType", tag = "13")]
    pub instance_type: i32,
    /// The project ID of the project containing the Cloud SQL instance. The Google
    /// apps domain is prefixed if applicable.
    #[prost(string, tag = "14")]
    pub project: ::prost::alloc::string::String,
    /// The IPv6 address assigned to the instance.
    /// (Deprecated) This property was applicable only
    /// to First Generation instances.
    #[deprecated]
    #[prost(string, tag = "15")]
    pub ipv6_address: ::prost::alloc::string::String,
    /// The service account email address assigned to the instance. \This
    /// property is read-only.
    #[prost(string, tag = "16")]
    pub service_account_email_address: ::prost::alloc::string::String,
    /// Configuration specific to on-premises instances.
    #[prost(message, optional, tag = "17")]
    pub on_premises_configuration: ::core::option::Option<OnPremisesConfiguration>,
    /// Configuration specific to failover replicas and read replicas.
    #[prost(message, optional, tag = "18")]
    pub replica_configuration: ::core::option::Option<ReplicaConfiguration>,
    /// The backend type.
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    ///
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    #[prost(enumeration = "SqlBackendType", tag = "19")]
    pub backend_type: i32,
    /// The URI of this resource.
    #[prost(string, tag = "20")]
    pub self_link: ::prost::alloc::string::String,
    /// If the instance state is SUSPENDED, the reason for the suspension.
    #[prost(enumeration = "SqlSuspensionReason", repeated, tag = "21")]
    pub suspension_reason: ::prost::alloc::vec::Vec<i32>,
    /// Connection name of the Cloud SQL instance used in connection strings.
    #[prost(string, tag = "22")]
    pub connection_name: ::prost::alloc::string::String,
    /// Name of the Cloud SQL instance. This does not include the project ID.
    #[prost(string, tag = "23")]
    pub name: ::prost::alloc::string::String,
    /// The geographical region of the Cloud SQL instance.
    ///
    /// It can be one of the
    /// [regions](<https://cloud.google.com/sql/docs/mysql/locations#location-r>)
    /// where Cloud SQL operates:
    ///
    /// For example,  `asia-east1`, `europe-west1`, and  `us-central1`.
    /// The default value is `us-central1`.
    #[prost(string, tag = "24")]
    pub region: ::prost::alloc::string::String,
    /// The Compute Engine zone that the instance is currently serving from. This
    /// value could be different from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary zone. WARNING:
    /// Changing this might restart the instance.
    #[prost(string, tag = "25")]
    pub gce_zone: ::prost::alloc::string::String,
    /// The Compute Engine zone that the failover instance is currently serving
    /// from for a regional instance. This value could be different
    /// from the zone that was specified when the instance
    /// was created if the instance has failed over to its secondary/failover zone.
    #[prost(string, tag = "34")]
    pub secondary_gce_zone: ::prost::alloc::string::String,
    /// Disk encryption configuration specific to an instance.
    #[prost(message, optional, tag = "26")]
    pub disk_encryption_configuration: ::core::option::Option<
        DiskEncryptionConfiguration,
    >,
    /// Disk encryption status specific to an instance.
    #[prost(message, optional, tag = "27")]
    pub disk_encryption_status: ::core::option::Option<DiskEncryptionStatus>,
    /// Initial root password. Use only on creation. You must set root passwords
    /// before you can connect to PostgreSQL instances.
    #[prost(string, tag = "29")]
    pub root_password: ::prost::alloc::string::String,
    /// The start time of any upcoming scheduled maintenance for this instance.
    #[prost(message, optional, tag = "30")]
    pub scheduled_maintenance: ::core::option::Option<
        database_instance::SqlScheduledMaintenance,
    >,
    /// This status indicates whether the instance satisfies PZS.
    ///
    /// The status is reserved for future use.
    #[prost(message, optional, tag = "35")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    /// Output only. Stores the current database version running on the instance
    /// including minor version such as `MYSQL_8_0_18`.
    #[prost(string, tag = "40")]
    pub database_installed_version: ::prost::alloc::string::String,
    /// This field represents the report generated by the proactive database
    /// wellness job for OutOfDisk issues.
    ///
    /// * Writers:
    /// * the proactive database wellness job for OOD.
    /// * Readers:
    /// * the proactive database wellness job
    #[prost(message, optional, tag = "38")]
    pub out_of_disk_report: ::core::option::Option<
        database_instance::SqlOutOfDiskReport,
    >,
    /// Output only. The time when the instance was created in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "39")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. List all maintenance versions applicable on the instance
    #[prost(string, repeated, tag = "41")]
    pub available_maintenance_versions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The current software version on the instance.
    #[prost(string, tag = "42")]
    pub maintenance_version: ::prost::alloc::string::String,
    /// Output only. All database versions that are available for upgrade.
    #[prost(message, repeated, tag = "45")]
    pub upgradable_database_versions: ::prost::alloc::vec::Vec<AvailableDatabaseVersion>,
    /// The SQL network architecture for the instance.
    #[prost(
        enumeration = "database_instance::SqlNetworkArchitecture",
        optional,
        tag = "47"
    )]
    pub sql_network_architecture: ::core::option::Option<i32>,
    /// Output only. The link to service attachment of PSC instance.
    #[prost(string, optional, tag = "48")]
    pub psc_service_attachment_link: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Output only. The dns name of the instance.
    #[prost(string, optional, tag = "49")]
    pub dns_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. DEPRECATED: please use write_endpoint instead.
    #[deprecated]
    #[prost(string, optional, tag = "51")]
    pub primary_dns_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The dns name of the primary instance in a replication group.
    #[prost(string, optional, tag = "52")]
    pub write_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    /// A primary instance and disaster recovery (DR) replica pair.
    /// A DR replica is a cross-region replica that you designate
    /// for failover in the event that the primary instance
    /// experiences regional failure.
    /// Applicable to MySQL and PostgreSQL.
    #[prost(message, optional, tag = "54")]
    pub replication_cluster: ::core::option::Option<ReplicationCluster>,
    /// Gemini instance configuration.
    #[prost(message, optional, tag = "55")]
    pub gemini_config: ::core::option::Option<GeminiInstanceConfig>,
    /// Output only. This status indicates whether the instance satisfies PZI.
    ///
    /// The status is reserved for future use.
    #[prost(message, optional, tag = "56")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    /// Input only. Whether Cloud SQL is enabled to switch storing point-in-time
    /// recovery log files from a data disk to Cloud Storage.
    #[prost(message, optional, tag = "57")]
    pub switch_transaction_logs_to_cloud_storage_enabled: ::core::option::Option<bool>,
    /// Input only. Determines whether an in-place major version upgrade of
    /// replicas happens when an in-place major version upgrade of a primary
    /// instance is initiated.
    #[prost(message, optional, tag = "59")]
    pub include_replicas_for_major_version_upgrade: ::core::option::Option<bool>,
    /// Optional. Input only. Immutable. Tag keys and tag values that are bound to
    /// this instance. You must represent each item in the map as:
    /// `"<tag-key-namespaced-name>" : "<tag-value-short-name>"`.
    ///
    /// For example, a single resource can have the following tags:
    ///
    /// ```text,
    ///   "123/environment": "production",
    ///   "123/costCenter": "marketing",
    /// ```
    ///
    /// For more information on tag creation and management, see
    /// <https://cloud.google.com/resource-manager/docs/tags/tags-overview.>
    #[prost(map = "string, string", tag = "60")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The number of read pool nodes in a read pool.
    #[prost(int32, optional, tag = "63")]
    pub node_count: ::core::option::Option<i32>,
    /// Output only. Entries containing information about each read pool node of
    /// the read pool.
    #[prost(message, repeated, tag = "64")]
    pub nodes: ::prost::alloc::vec::Vec<database_instance::PoolNodeConfig>,
    /// Output only. The list of DNS names used by this instance.
    #[prost(message, repeated, tag = "67")]
    pub dns_names: ::prost::alloc::vec::Vec<DnsNameMapping>,
}
/// Nested message and enum types in `DatabaseInstance`.
pub mod database_instance {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlFailoverReplica {
        /// The name of the failover replica. If specified at instance creation, a
        /// failover replica is created for the instance. The name
        /// doesn't include the project ID.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// The availability status of the failover replica. A false status indicates
        /// that the failover replica is out of sync. The primary instance can only
        /// failover to the failover replica when the status is true.
        #[prost(message, optional, tag = "2")]
        pub available: ::core::option::Option<bool>,
    }
    /// Any scheduled maintenance for this instance.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlScheduledMaintenance {
        /// The start time of any upcoming scheduled maintenance for this instance.
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        #[deprecated]
        #[prost(bool, tag = "2")]
        pub can_defer: bool,
        /// If the scheduled maintenance can be rescheduled.
        #[prost(bool, tag = "3")]
        pub can_reschedule: bool,
        /// Maintenance cannot be rescheduled to start beyond this deadline.
        #[prost(message, optional, tag = "4")]
        pub schedule_deadline_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// This message wraps up the information written by out-of-disk detection job.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlOutOfDiskReport {
        /// This field represents the state generated by the proactive database
        /// wellness job for OutOfDisk issues.
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        /// * the proactive database wellness job
        #[prost(
            enumeration = "sql_out_of_disk_report::SqlOutOfDiskState",
            optional,
            tag = "1"
        )]
        pub sql_out_of_disk_state: ::core::option::Option<i32>,
        /// The minimum recommended increase size in GigaBytes
        /// This field is consumed by the frontend
        ///
        /// * Writers:
        /// * the proactive database wellness job for OOD.
        /// * Readers:
        #[prost(int32, optional, tag = "2")]
        pub sql_min_recommended_increase_size_gb: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `SqlOutOfDiskReport`.
    pub mod sql_out_of_disk_report {
        /// This enum lists all possible states regarding out-of-disk issues.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SqlOutOfDiskState {
            /// Unspecified state
            Unspecified = 0,
            /// The instance has plenty space on data disk
            Normal = 1,
            /// Data disk is almost used up. It is shutdown to prevent data
            /// corruption.
            SoftShutdown = 2,
        }
        impl SqlOutOfDiskState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SQL_OUT_OF_DISK_STATE_UNSPECIFIED",
                    Self::Normal => "NORMAL",
                    Self::SoftShutdown => "SOFT_SHUTDOWN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SQL_OUT_OF_DISK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "NORMAL" => Some(Self::Normal),
                    "SOFT_SHUTDOWN" => Some(Self::SoftShutdown),
                    _ => None,
                }
            }
        }
    }
    /// Details of a single read pool node of a read pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PoolNodeConfig {
        /// Output only. The name of the read pool node, to be used for retrieving
        /// metrics and logs.
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// Output only. The zone of the read pool node.
        #[prost(string, optional, tag = "2")]
        pub gce_zone: ::core::option::Option<::prost::alloc::string::String>,
        /// Output only. Mappings containing IP addresses that can be used to connect
        /// to the read pool node.
        #[prost(message, repeated, tag = "3")]
        pub ip_addresses: ::prost::alloc::vec::Vec<super::IpMapping>,
        /// Output only. The DNS name of the read pool node.
        #[prost(string, optional, tag = "4")]
        pub dns_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Output only. The current state of the read pool node.
        #[prost(enumeration = "SqlInstanceState", optional, tag = "5")]
        pub state: ::core::option::Option<i32>,
        /// Output only. The list of DNS names used by this read pool node.
        #[prost(message, repeated, tag = "6")]
        pub dns_names: ::prost::alloc::vec::Vec<super::DnsNameMapping>,
        /// Output only. The Private Service Connect (PSC) service attachment of the
        /// read pool node.
        #[prost(string, optional, tag = "7")]
        pub psc_service_attachment_link: ::core::option::Option<
            ::prost::alloc::string::String,
        >,
        /// Output only. The list of settings for requested automatically-setup
        /// Private Service Connect (PSC) consumer endpoints that can be used to
        /// connect to this read pool node.
        #[prost(message, repeated, tag = "8")]
        pub psc_auto_connections: ::prost::alloc::vec::Vec<
            super::PscAutoConnectionConfig,
        >,
    }
    /// The current serving state of the database instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlInstanceState {
        /// The state of the instance is unknown.
        Unspecified = 0,
        /// The instance is running, or has been stopped by owner.
        Runnable = 1,
        /// The instance is not available, for example due to problems with billing.
        Suspended = 2,
        /// The instance is being deleted.
        PendingDelete = 3,
        /// The instance is being created.
        PendingCreate = 4,
        /// The instance is down for maintenance.
        Maintenance = 5,
        /// The creation of the instance failed or a fatal error occurred during
        /// maintenance.
        Failed = 6,
        /// Deprecated
        #[deprecated]
        OnlineMaintenance = 7,
        /// (Applicable to read pool nodes only.) The read pool node needs to be
        /// repaired. The database might be unavailable.
        Repairing = 8,
    }
    impl SqlInstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_INSTANCE_STATE_UNSPECIFIED",
                Self::Runnable => "RUNNABLE",
                Self::Suspended => "SUSPENDED",
                Self::PendingDelete => "PENDING_DELETE",
                Self::PendingCreate => "PENDING_CREATE",
                Self::Maintenance => "MAINTENANCE",
                Self::Failed => "FAILED",
                #[allow(deprecated)]
                Self::OnlineMaintenance => "ONLINE_MAINTENANCE",
                Self::Repairing => "REPAIRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_INSTANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNABLE" => Some(Self::Runnable),
                "SUSPENDED" => Some(Self::Suspended),
                "PENDING_DELETE" => Some(Self::PendingDelete),
                "PENDING_CREATE" => Some(Self::PendingCreate),
                "MAINTENANCE" => Some(Self::Maintenance),
                "FAILED" => Some(Self::Failed),
                "ONLINE_MAINTENANCE" => {
                    Some(#[allow(deprecated)] Self::OnlineMaintenance)
                }
                "REPAIRING" => Some(Self::Repairing),
                _ => None,
            }
        }
    }
    /// The SQL network architecture for the instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlNetworkArchitecture {
        Unspecified = 0,
        /// The instance uses the new network architecture.
        NewNetworkArchitecture = 1,
        /// The instance uses the old network architecture.
        OldNetworkArchitecture = 2,
    }
    impl SqlNetworkArchitecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED",
                Self::NewNetworkArchitecture => "NEW_NETWORK_ARCHITECTURE",
                Self::OldNetworkArchitecture => "OLD_NETWORK_ARCHITECTURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_NETWORK_ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEW_NETWORK_ARCHITECTURE" => Some(Self::NewNetworkArchitecture),
                "OLD_NETWORK_ARCHITECTURE" => Some(Self::OldNetworkArchitecture),
                _ => None,
            }
        }
    }
}
/// DNS metadata.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DnsNameMapping {
    /// Output only. The DNS name.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The connection type of the DNS name.
    #[prost(enumeration = "dns_name_mapping::ConnectionType", tag = "2")]
    pub connection_type: i32,
    /// Output only. The scope that the DNS name applies to.
    #[prost(enumeration = "dns_name_mapping::DnsScope", tag = "3")]
    pub dns_scope: i32,
    /// Output only. The manager for this DNS record.
    #[prost(enumeration = "dns_name_mapping::RecordManager", tag = "4")]
    pub record_manager: i32,
}
/// Nested message and enum types in `DnsNameMapping`.
pub mod dns_name_mapping {
    /// The connection type of the DNS name.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectionType {
        /// Unknown connection type.
        Unspecified = 0,
        /// Public IP.
        Public = 1,
        /// Private services access (private IP).
        PrivateServicesAccess = 2,
        /// Private Service Connect.
        PrivateServiceConnect = 3,
    }
    impl ConnectionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONNECTION_TYPE_UNSPECIFIED",
                Self::Public => "PUBLIC",
                Self::PrivateServicesAccess => "PRIVATE_SERVICES_ACCESS",
                Self::PrivateServiceConnect => "PRIVATE_SERVICE_CONNECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PUBLIC" => Some(Self::Public),
                "PRIVATE_SERVICES_ACCESS" => Some(Self::PrivateServicesAccess),
                "PRIVATE_SERVICE_CONNECT" => Some(Self::PrivateServiceConnect),
                _ => None,
            }
        }
    }
    /// The scope that the DNS name applies to.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DnsScope {
        /// DNS scope not set. This value should not be used.
        Unspecified = 0,
        /// Indicates an instance-level DNS name.
        Instance = 1,
        /// Indicates a cluster-level DNS name.
        Cluster = 2,
    }
    impl DnsScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DNS_SCOPE_UNSPECIFIED",
                Self::Instance => "INSTANCE",
                Self::Cluster => "CLUSTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DNS_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INSTANCE" => Some(Self::Instance),
                "CLUSTER" => Some(Self::Cluster),
                _ => None,
            }
        }
    }
    /// The system responsible for managing the DNS record.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecordManager {
        /// Record manager not set. This value should not be used.
        Unspecified = 0,
        /// The record may be managed by the customer. It is not automatically
        /// managed by Cloud SQL automation.
        Customer = 1,
        /// The record is managed by Cloud SQL, which will create, update, and delete
        /// the DNS records for the zone automatically when the Cloud SQL database
        /// instance is created or updated.
        CloudSqlAutomation = 2,
    }
    impl RecordManager {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RECORD_MANAGER_UNSPECIFIED",
                Self::Customer => "CUSTOMER",
                Self::CloudSqlAutomation => "CLOUD_SQL_AUTOMATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECORD_MANAGER_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOMER" => Some(Self::Customer),
                "CLOUD_SQL_AUTOMATION" => Some(Self::CloudSqlAutomation),
                _ => None,
            }
        }
    }
}
/// Gemini instance configuration.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GeminiInstanceConfig {
    /// Output only. Whether Gemini is enabled.
    #[prost(bool, optional, tag = "1")]
    pub entitled: ::core::option::Option<bool>,
    /// Output only. Whether the vacuum management is enabled.
    #[prost(bool, optional, tag = "2")]
    pub google_vacuum_mgmt_enabled: ::core::option::Option<bool>,
    /// Output only. Whether canceling the out-of-memory (OOM) session is enabled.
    #[prost(bool, optional, tag = "3")]
    pub oom_session_cancel_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the active query is enabled.
    #[prost(bool, optional, tag = "4")]
    pub active_query_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the index advisor is enabled.
    #[prost(bool, optional, tag = "5")]
    pub index_advisor_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the flag recommender is enabled.
    #[prost(bool, optional, tag = "6")]
    pub flag_recommender_enabled: ::core::option::Option<bool>,
}
/// A primary instance and disaster recovery (DR) replica pair.
/// A DR replica is a cross-region replica that you designate for failover
/// in the event that the primary instance has regional failure.
/// Applicable to MySQL and PostgreSQL.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReplicationCluster {
    /// Output only. If set, this field indicates this instance has a private
    /// service access (PSA) DNS endpoint that is pointing to the primary instance
    /// of the cluster. If this instance is the primary, then the DNS endpoint
    /// points to this instance. After a switchover or replica failover operation,
    /// this DNS endpoint points to the promoted instance. This is a read-only
    /// field, returned to the user as information. This field can exist even if a
    /// standalone instance doesn't have a DR replica yet or the DR replica is
    /// deleted.
    #[prost(string, optional, tag = "1")]
    pub psa_write_endpoint: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. If the instance is a primary instance, then this field identifies
    /// the disaster recovery (DR) replica. A DR replica is an optional
    /// configuration for Enterprise Plus edition instances. If the instance is a
    /// read replica, then the field is not set. Set this field to a replica name
    /// to designate a DR replica for a primary instance. Remove the replica name
    /// to remove the DR replica designation.
    #[prost(string, optional, tag = "2")]
    pub failover_dr_replica_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Read-only field that indicates whether the replica is a DR
    /// replica. This field is not set if the instance is a primary instance.
    #[prost(bool, optional, tag = "4")]
    pub dr_replica: ::core::option::Option<bool>,
}
/// An available database version. It can be a major or a minor version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AvailableDatabaseVersion {
    /// The version's major version name.
    #[prost(string, optional, tag = "3")]
    pub major_version: ::core::option::Option<::prost::alloc::string::String>,
    /// The database version name. For MySQL 8.0, this string provides the database
    /// major and minor version.
    #[prost(string, optional, tag = "8")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// The database version's display name.
    #[prost(string, optional, tag = "9")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Database list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabasesListResponse {
    /// This is always `sql#databasesList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of database resources in the instance.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Database>,
}
/// Read-replica configuration for connecting to the on-premises primary
/// instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DemoteMasterConfiguration {
    /// This is always `sql#demoteMasterConfiguration`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[prost(message, optional, tag = "2")]
    pub mysql_replica_configuration: ::core::option::Option<
        DemoteMasterMySqlReplicaConfiguration,
    >,
}
/// Database instance demote primary instance context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DemoteMasterContext {
    /// This is always `sql#demoteMasterContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Verify the GTID consistency for demote operation. Default value:
    /// `True`. Setting this flag to `false` enables you to bypass the GTID
    /// consistency check between on-premises primary instance and Cloud SQL
    /// instance during the demotion operation but also exposes you to the risk of
    /// future replication failures. Change the value only if you know the reason
    /// for the GTID divergence and are confident that doing so will not cause any
    /// replication issues.
    #[prost(message, optional, tag = "2")]
    pub verify_gtid_consistency: ::core::option::Option<bool>,
    /// The name of the instance which will act as on-premises primary instance
    /// in the replication setup.
    #[prost(string, tag = "3")]
    pub master_instance_name: ::prost::alloc::string::String,
    /// Configuration specific to read-replicas replicating from the on-premises
    /// primary instance.
    #[prost(message, optional, tag = "4")]
    pub replica_configuration: ::core::option::Option<DemoteMasterConfiguration>,
    /// Flag to skip replication setup on the instance.
    #[prost(bool, tag = "5")]
    pub skip_replication_setup: bool,
}
/// Read-replica configuration specific to MySQL databases.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DemoteMasterMySqlReplicaConfiguration {
    /// This is always `sql#demoteMasterMysqlReplicaConfiguration`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The username for the replication connection.
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// The password for the replication connection.
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// PEM representation of the replica's private key. The corresponding public
    /// key is encoded in the client's certificate. The format of the replica's
    /// private key can be either PKCS #1 or PKCS #8.
    #[prost(string, tag = "4")]
    pub client_key: ::prost::alloc::string::String,
    /// PEM representation of the replica's x509 certificate.
    #[prost(string, tag = "5")]
    pub client_certificate: ::prost::alloc::string::String,
    /// PEM representation of the trusted CA's x509 certificate.
    #[prost(string, tag = "6")]
    pub ca_certificate: ::prost::alloc::string::String,
}
/// This context is used to demote an existing standalone instance to be
/// a Cloud SQL read replica for an external database server.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DemoteContext {
    /// This is always `sql#demoteContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Required. The name of the instance which acts as an on-premises primary
    /// instance in the replication setup.
    #[prost(string, tag = "2")]
    pub source_representative_instance_name: ::prost::alloc::string::String,
}
/// Database instance export context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExportContext {
    /// The path to the file in Google Cloud Storage where the export will be
    /// stored. The URI is in the form `gs://bucketName/fileName`. If the file
    /// already exists, the request succeeds, but the operation fails. If
    /// `fileType` is `SQL` and the filename ends with .gz,
    /// the contents are compressed.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Databases to be exported. <br /> `MySQL instances:` If
    /// `fileType` is `SQL` and no database is specified, all
    /// databases are exported, except for the `mysql` system database.
    /// If `fileType` is `CSV`, you can specify one database,
    /// either by using this property or by using the
    /// `csvExportOptions.selectQuery` property, which takes precedence
    /// over this property. <br /> `PostgreSQL instances:` If you don't specify a
    /// database by name, all user databases in the instance are
    /// exported. This excludes system databases and Cloud SQL databases used to
    /// manage internal operations. Exporting all user databases is only available
    /// for directory-formatted parallel export. If `fileType` is `CSV`,
    /// this database must match the one specified in the
    /// `csvExportOptions.selectQuery` property. <br /> `SQL Server  instances:` You must specify one database to be exported, and the
    /// `fileType` must be `BAK`.
    #[prost(string, repeated, tag = "2")]
    pub databases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// This is always `sql#exportContext`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// Options for exporting data as SQL statements.
    #[prost(message, optional, tag = "4")]
    pub sql_export_options: ::core::option::Option<export_context::SqlExportOptions>,
    /// Options for exporting data as CSV. `MySQL` and `PostgreSQL`
    /// instances only.
    #[prost(message, optional, tag = "5")]
    pub csv_export_options: ::core::option::Option<export_context::SqlCsvExportOptions>,
    /// The file type for the specified uri.
    #[prost(enumeration = "SqlFileType", tag = "6")]
    pub file_type: i32,
    /// Whether to perform a serverless export.
    #[prost(message, optional, tag = "8")]
    pub offload: ::core::option::Option<bool>,
    /// Options for exporting data as BAK files.
    #[prost(message, optional, tag = "9")]
    pub bak_export_options: ::core::option::Option<export_context::SqlBakExportOptions>,
    /// Optional. Export parameters specific to SQL Server TDE certificates
    #[prost(message, optional, tag = "10")]
    pub tde_export_options: ::core::option::Option<export_context::SqlTdeExportOptions>,
}
/// Nested message and enum types in `ExportContext`.
pub mod export_context {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlCsvExportOptions {
        /// The select query used to extract the data.
        #[prost(string, tag = "1")]
        pub select_query: ::prost::alloc::string::String,
        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[prost(string, tag = "2")]
        pub escape_character: ::prost::alloc::string::String,
        /// Specifies the quoting character to be used when a data value is quoted.
        #[prost(string, tag = "3")]
        pub quote_character: ::prost::alloc::string::String,
        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[prost(string, tag = "4")]
        pub fields_terminated_by: ::prost::alloc::string::String,
        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[prost(string, tag = "6")]
        pub lines_terminated_by: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlExportOptions {
        /// Tables to export, or that were exported, from the specified database. If
        /// you specify tables, specify one and only one database. For PostgreSQL
        /// instances, you can specify only one table.
        #[prost(string, repeated, tag = "1")]
        pub tables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Export only schemas.
        #[prost(message, optional, tag = "2")]
        pub schema_only: ::core::option::Option<bool>,
        #[prost(message, optional, tag = "3")]
        pub mysql_export_options: ::core::option::Option<
            sql_export_options::MysqlExportOptions,
        >,
        /// Optional. The number of threads to use for parallel export.
        #[prost(message, optional, tag = "4")]
        pub threads: ::core::option::Option<i32>,
        /// Optional. Whether or not the export should be parallel.
        #[prost(message, optional, tag = "5")]
        pub parallel: ::core::option::Option<bool>,
        /// Optional. Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[prost(message, optional, tag = "6")]
        pub postgres_export_options: ::core::option::Option<
            sql_export_options::PostgresExportOptions,
        >,
    }
    /// Nested message and enum types in `SqlExportOptions`.
    pub mod sql_export_options {
        /// Options for exporting from MySQL.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MysqlExportOptions {
            /// Option to include SQL statement required to set up replication. If set
            /// to `1`, the dump file includes a CHANGE MASTER TO statement with the
            /// binary log coordinates, and --set-gtid-purged is set to ON. If set to
            /// `2`, the CHANGE MASTER TO statement is written as a SQL comment and
            /// has no effect. If set to any value other than `1`, --set-gtid-purged
            /// is set to OFF.
            #[prost(message, optional, tag = "1")]
            pub master_data: ::core::option::Option<i32>,
        }
        /// Options for exporting from a Cloud SQL for PostgreSQL instance.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PostgresExportOptions {
            /// Optional. Use this option to include DROP <code>\<object\></code>
            /// SQL statements. Use these statements to delete database objects before
            /// running the import operation.
            #[prost(message, optional, tag = "1")]
            pub clean: ::core::option::Option<bool>,
            /// Optional. Option to include an IF EXISTS SQL statement with each DROP
            /// statement produced by clean.
            #[prost(message, optional, tag = "2")]
            pub if_exists: ::core::option::Option<bool>,
        }
    }
    /// Options for exporting BAK files (SQL Server-only)
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlBakExportOptions {
        /// Whether or not the export should be striped.
        #[prost(message, optional, tag = "1")]
        pub striped: ::core::option::Option<bool>,
        /// Option for specifying how many stripes to use for the export.
        /// If blank, and the value of the striped field is true,
        /// the number of stripes is automatically chosen.
        #[prost(message, optional, tag = "2")]
        pub stripe_count: ::core::option::Option<i32>,
        /// Type of this bak file will be export, FULL or DIFF, SQL Server only
        #[prost(enumeration = "super::BakType", tag = "4")]
        pub bak_type: i32,
        /// Deprecated: copy_only is deprecated. Use differential_base instead
        #[deprecated]
        #[prost(message, optional, tag = "5")]
        pub copy_only: ::core::option::Option<bool>,
        /// Whether or not the backup can be used as a differential base
        /// copy_only backup can not be served as differential base
        #[prost(message, optional, tag = "6")]
        pub differential_base: ::core::option::Option<bool>,
        /// Optional. The begin timestamp when transaction log will be included in
        /// the export operation. [RFC 3339](<https://tools.ietf.org/html/rfc3339>)
        /// format (for example, `2023-10-01T16:19:00.094`) in UTC. When omitted, all
        /// available logs from the beginning of retention period will be included.
        /// Only applied to Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "7")]
        pub export_log_start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. The end timestamp when transaction log will be included in the
        /// export operation. [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format
        /// (for example, `2023-10-01T16:19:00.094`) in UTC. When omitted, all
        /// available logs until current time will be included. Only applied to Cloud
        /// SQL for SQL Server.
        #[prost(message, optional, tag = "8")]
        pub export_log_end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlTdeExportOptions {
        /// Required. Path to the TDE certificate public key
        /// in the form gs://bucketName/fileName.
        /// The instance must have write access to the location.
        /// Applicable only for SQL Server instances.
        #[prost(string, tag = "1")]
        pub certificate_path: ::prost::alloc::string::String,
        /// Required. Path to the TDE certificate private key
        /// in the form gs://bucketName/fileName.
        /// The instance must have write access to the location.
        /// Applicable only for SQL Server instances.
        #[prost(string, tag = "2")]
        pub private_key_path: ::prost::alloc::string::String,
        /// Required. Password that encrypts the private key.
        #[prost(string, tag = "3")]
        pub private_key_password: ::prost::alloc::string::String,
        /// Required. Certificate name.
        /// Applicable only for SQL Server instances.
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
    }
}
/// Database instance failover context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailoverContext {
    /// The current settings version of this instance. Request will be rejected if
    /// this version doesn't match the current settings version.
    #[prost(int64, tag = "1")]
    pub settings_version: i64,
    /// This is always `sql#failoverContext`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// A flag resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Flag {
    /// This is the name of the flag. Flag names always use underscores, not
    /// hyphens, for example: `max_allowed_packet`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The type of the flag. Flags are typed to being `BOOLEAN`, `STRING`,
    /// `INTEGER` or `NONE`. `NONE` is used for flags which do not take a
    /// value, such as `skip_grant_tables`.
    #[prost(enumeration = "SqlFlagType", tag = "2")]
    pub r#type: i32,
    /// The database version this flag applies to. Can be
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_8_0_18`, `MYSQL_8_0_26`, `MYSQL_5_7`,
    /// or `MYSQL_5_6`. PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11` or `POSTGRES_12`. SQL Server instances:
    /// `SQLSERVER_2017_STANDARD`, `SQLSERVER_2017_ENTERPRISE`,
    /// `SQLSERVER_2017_EXPRESS`, `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    /// See [the complete
    /// list](/sql/docs/mysql/admin-api/rest/v1/SqlDatabaseVersion).
    #[prost(enumeration = "SqlDatabaseVersion", repeated, tag = "3")]
    pub applies_to: ::prost::alloc::vec::Vec<i32>,
    /// For `STRING` flags, a list of strings that the value can be set to.
    #[prost(string, repeated, tag = "4")]
    pub allowed_string_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// For `INTEGER` flags, the minimum allowed value.
    #[prost(message, optional, tag = "5")]
    pub min_value: ::core::option::Option<i64>,
    /// For `INTEGER` flags, the maximum allowed value.
    #[prost(message, optional, tag = "6")]
    pub max_value: ::core::option::Option<i64>,
    /// Indicates whether changing this flag will trigger a database restart. Only
    /// applicable to Second Generation instances.
    #[prost(message, optional, tag = "7")]
    pub requires_restart: ::core::option::Option<bool>,
    /// This is always `sql#flag`.
    #[prost(string, tag = "8")]
    pub kind: ::prost::alloc::string::String,
    /// Whether or not the flag is considered in beta.
    #[prost(message, optional, tag = "9")]
    pub in_beta: ::core::option::Option<bool>,
    /// Use this field if only certain integers are accepted. Can be combined
    /// with min_value and max_value to add additional values.
    #[prost(int64, repeated, tag = "10")]
    pub allowed_int_values: ::prost::alloc::vec::Vec<i64>,
    /// Scope of flag.
    #[prost(enumeration = "SqlFlagScope", tag = "15")]
    pub flag_scope: i32,
    /// Recommended flag value for UI display.
    #[prost(oneof = "flag::RecommendedValue", tags = "16, 17")]
    pub recommended_value: ::core::option::Option<flag::RecommendedValue>,
}
/// Nested message and enum types in `Flag`.
pub mod flag {
    /// Recommended flag value for UI display.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum RecommendedValue {
        /// Recommended flag value in string format for UI display.
        #[prost(string, tag = "16")]
        RecommendedStringValue(::prost::alloc::string::String),
        /// Recommended flag value in integer format for UI display.
        #[prost(message, tag = "17")]
        RecommendedIntValue(i64),
    }
}
/// Flags list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FlagsListResponse {
    /// This is always `sql#flagsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of flags.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Flag>,
}
/// Database instance import context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportContext {
    /// Path to the import file in Cloud Storage, in the form
    /// `gs://bucketName/fileName`. Compressed gzip files (.gz) are supported
    /// when `fileType` is `SQL`. The instance must have
    /// write permissions to the bucket and read access to the file.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// The target database for the import. If `fileType` is `SQL`, this field
    /// is required only if the import file does not specify a database, and is
    /// overridden by any database specification in the import file. For entire
    /// instance parallel import operations, the database is overridden by the
    /// database name stored in subdirectory name. If
    /// `fileType` is `CSV`, one database must be specified.
    #[prost(string, tag = "2")]
    pub database: ::prost::alloc::string::String,
    /// This is always `sql#importContext`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// The file type for the specified uri.
    ///
    /// * `SQL`: The file contains SQL statements.
    /// * `CSV`: The file contains CSV data.
    /// * `BAK`: The file contains backup data for a SQL Server instance.
    #[prost(enumeration = "SqlFileType", tag = "4")]
    pub file_type: i32,
    /// Options for importing data as CSV.
    #[prost(message, optional, tag = "5")]
    pub csv_import_options: ::core::option::Option<import_context::SqlCsvImportOptions>,
    /// The PostgreSQL user for this import operation. PostgreSQL instances only.
    #[prost(string, tag = "6")]
    pub import_user: ::prost::alloc::string::String,
    /// Import parameters specific to SQL Server .BAK files
    #[prost(message, optional, tag = "7")]
    pub bak_import_options: ::core::option::Option<import_context::SqlBakImportOptions>,
    /// Optional. Options for importing data from SQL statements.
    #[prost(message, optional, tag = "8")]
    pub sql_import_options: ::core::option::Option<import_context::SqlImportOptions>,
    /// Optional. Import parameters specific to SQL Server .TDE files
    /// Import parameters specific to SQL Server TDE certificates
    #[prost(message, optional, tag = "9")]
    pub tde_import_options: ::core::option::Option<import_context::SqlTdeImportOptions>,
}
/// Nested message and enum types in `ImportContext`.
pub mod import_context {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlImportOptions {
        /// Optional. The number of threads to use for parallel import.
        #[prost(message, optional, tag = "1")]
        pub threads: ::core::option::Option<i32>,
        /// Optional. Whether or not the import should be parallel.
        #[prost(message, optional, tag = "2")]
        pub parallel: ::core::option::Option<bool>,
        /// Optional. Options for importing from a Cloud SQL for PostgreSQL instance.
        #[prost(message, optional, tag = "3")]
        pub postgres_import_options: ::core::option::Option<
            sql_import_options::PostgresImportOptions,
        >,
    }
    /// Nested message and enum types in `SqlImportOptions`.
    pub mod sql_import_options {
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PostgresImportOptions {
            /// Optional. The --clean flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[prost(message, optional, tag = "1")]
            pub clean: ::core::option::Option<bool>,
            /// Optional. The --if-exists flag for the pg_restore utility. This flag
            /// applies only if you enabled Cloud SQL to import files in parallel.
            #[prost(message, optional, tag = "2")]
            pub if_exists: ::core::option::Option<bool>,
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlCsvImportOptions {
        /// The table to which CSV data is imported.
        #[prost(string, tag = "1")]
        pub table: ::prost::alloc::string::String,
        /// The columns to which CSV data is imported. If not specified, all columns
        /// of the database table are loaded with CSV data.
        #[prost(string, repeated, tag = "2")]
        pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// Specifies the character that should appear before a data character that
        /// needs to be escaped.
        #[prost(string, tag = "4")]
        pub escape_character: ::prost::alloc::string::String,
        /// Specifies the quoting character to be used when a data value is quoted.
        #[prost(string, tag = "5")]
        pub quote_character: ::prost::alloc::string::String,
        /// Specifies the character that separates columns within each row (line) of
        /// the file.
        #[prost(string, tag = "6")]
        pub fields_terminated_by: ::prost::alloc::string::String,
        /// This is used to separate lines. If a line does not contain all fields,
        /// the rest of the columns are set to their default values.
        #[prost(string, tag = "8")]
        pub lines_terminated_by: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlBakImportOptions {
        #[prost(message, optional, tag = "1")]
        pub encryption_options: ::core::option::Option<
            sql_bak_import_options::EncryptionOptions,
        >,
        /// Whether or not the backup set being restored is striped.
        /// Applies only to Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "2")]
        pub striped: ::core::option::Option<bool>,
        /// Whether or not the backup importing will restore database
        /// with NORECOVERY option.
        /// Applies only to Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "4")]
        pub no_recovery: ::core::option::Option<bool>,
        /// Whether or not the backup importing request will just bring database
        /// online without downloading Bak content only one of "no_recovery" and
        /// "recovery_only" can be true otherwise error will return. Applies only to
        /// Cloud SQL for SQL Server.
        #[prost(message, optional, tag = "5")]
        pub recovery_only: ::core::option::Option<bool>,
        /// Type of the bak content, FULL or DIFF.
        #[prost(enumeration = "super::BakType", tag = "6")]
        pub bak_type: i32,
        /// Optional. The timestamp when the import should stop. This timestamp is in
        /// the [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format (for example,
        /// `2023-10-01T16:19:00.094`). This field is equivalent to the STOPAT
        /// keyword and applies to Cloud SQL for SQL Server only.
        #[prost(message, optional, tag = "7")]
        pub stop_at: ::core::option::Option<::prost_types::Timestamp>,
        /// Optional. The marked transaction where the import should stop. This field
        /// is equivalent to the STOPATMARK keyword and applies to Cloud SQL for SQL
        /// Server only.
        #[prost(string, tag = "8")]
        pub stop_at_mark: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `SqlBakImportOptions`.
    pub mod sql_bak_import_options {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EncryptionOptions {
            /// Path to the Certificate (.cer) in Cloud Storage, in the form
            /// `gs://bucketName/fileName`. The instance must have write permissions
            /// to the bucket and read access to the file.
            #[prost(string, tag = "1")]
            pub cert_path: ::prost::alloc::string::String,
            /// Path to the Certificate Private Key (.pvk)  in Cloud Storage, in the
            /// form `gs://bucketName/fileName`. The instance must have write
            /// permissions to the bucket and read access to the file.
            #[prost(string, tag = "2")]
            pub pvk_path: ::prost::alloc::string::String,
            /// Password that encrypts the private key
            #[prost(string, tag = "3")]
            pub pvk_password: ::prost::alloc::string::String,
            /// Optional. Whether the imported file remains encrypted.
            #[prost(message, optional, tag = "5")]
            pub keep_encrypted: ::core::option::Option<bool>,
        }
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SqlTdeImportOptions {
        /// Required. Path to the TDE certificate public key
        /// in the form gs://bucketName/fileName.
        /// The instance must have read access to the file.
        /// Applicable only for SQL Server instances.
        #[prost(string, tag = "1")]
        pub certificate_path: ::prost::alloc::string::String,
        /// Required. Path to the TDE certificate private key
        /// in the form gs://bucketName/fileName.
        /// The instance must have read access to the file.
        /// Applicable only for SQL Server instances.
        #[prost(string, tag = "2")]
        pub private_key_path: ::prost::alloc::string::String,
        /// Required. Password that encrypts the private key.
        #[prost(string, tag = "3")]
        pub private_key_password: ::prost::alloc::string::String,
        /// Required. Certificate name.
        /// Applicable only for SQL Server instances.
        #[prost(string, tag = "5")]
        pub name: ::prost::alloc::string::String,
    }
}
/// Database instance clone request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesCloneRequest {
    /// Contains details about the clone operation.
    #[prost(message, optional, tag = "1")]
    pub clone_context: ::core::option::Option<CloneContext>,
}
/// Database demote primary instance request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesDemoteMasterRequest {
    /// Contains details about the demoteMaster operation.
    #[prost(message, optional, tag = "1")]
    pub demote_master_context: ::core::option::Option<DemoteMasterContext>,
}
/// This request is used to demote an existing standalone instance to be a
/// Cloud SQL read replica for an external database server.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesDemoteRequest {
    /// Required. This context is used to demote an existing standalone instance to
    /// be a Cloud SQL read replica for an external database server.
    #[prost(message, optional, tag = "1")]
    pub demote_context: ::core::option::Option<DemoteContext>,
}
/// Database instance export request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesExportRequest {
    /// Contains details about the export operation.
    #[prost(message, optional, tag = "1")]
    pub export_context: ::core::option::Option<ExportContext>,
}
/// Instance failover request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesFailoverRequest {
    /// Failover Context.
    #[prost(message, optional, tag = "1")]
    pub failover_context: ::core::option::Option<FailoverContext>,
}
/// Database instance import request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesImportRequest {
    /// Contains details about the import operation.
    #[prost(message, optional, tag = "1")]
    pub import_context: ::core::option::Option<ImportContext>,
}
/// Request for Pre-checks for MVU
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesPreCheckMajorVersionUpgradeRequest {
    /// Required. Contains details about the pre-check major version upgrade
    /// operation.
    #[prost(message, optional, tag = "1")]
    pub pre_check_major_version_upgrade_context: ::core::option::Option<
        PreCheckMajorVersionUpgradeContext,
    >,
}
/// MySQL-specific external server sync settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MySqlSyncConfig {
    /// Flags to use for the initial dump.
    #[prost(message, repeated, tag = "1")]
    pub initial_sync_flags: ::prost::alloc::vec::Vec<SyncFlags>,
}
/// Database instances list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesListResponse {
    /// This is always `sql#instancesList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of warnings that occurred while handling the request.
    #[prost(message, repeated, tag = "2")]
    pub warnings: ::prost::alloc::vec::Vec<ApiWarning>,
    /// List of database instance resources.
    #[prost(message, repeated, tag = "3")]
    pub items: ::prost::alloc::vec::Vec<DatabaseInstance>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[prost(string, tag = "4")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Instances ListServerCas response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesListServerCasResponse {
    /// List of server CA certificates for the instance.
    #[prost(message, repeated, tag = "1")]
    pub certs: ::prost::alloc::vec::Vec<SslCert>,
    #[prost(string, tag = "2")]
    pub active_version: ::prost::alloc::string::String,
    /// This is always `sql#instancesListServerCas`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Instances ListServerCertificatess response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesListServerCertificatesResponse {
    /// List of server CA certificates for the instance.
    #[prost(message, repeated, tag = "1")]
    pub ca_certs: ::prost::alloc::vec::Vec<SslCert>,
    /// List of server certificates for the instance, signed by the corresponding
    /// CA from the `ca_certs` list.
    #[prost(message, repeated, tag = "2")]
    pub server_certs: ::prost::alloc::vec::Vec<SslCert>,
    /// The `sha1_fingerprint` of the active certificate from `server_certs`.
    #[prost(string, tag = "3")]
    pub active_version: ::prost::alloc::string::String,
    /// This is always `sql#instancesListServerCertificates`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
}
/// Instances ListEntraIdCertificates response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesListEntraIdCertificatesResponse {
    /// List of Entra ID certificates for the instance.
    #[prost(message, repeated, tag = "1")]
    pub certs: ::prost::alloc::vec::Vec<SslCert>,
    /// The `sha1_fingerprint` of the active certificate from `certs`.
    #[prost(string, tag = "2")]
    pub active_version: ::prost::alloc::string::String,
    /// This is always `sql#instancesListEntraIdCertificates`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Database instance restore backup request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesRestoreBackupRequest {
    /// Parameters required to perform the restore backup operation.
    #[prost(message, optional, tag = "1")]
    pub restore_backup_context: ::core::option::Option<RestoreBackupContext>,
    /// The name of the backup that's used to restore a Cloud SQL instance:
    /// Format:  projects/{project-id}/backups/{backup-uid}. Only one of
    /// restore_backup_context, backup, backupdr_backup can be passed to the input.
    #[prost(string, tag = "2")]
    pub backup: ::prost::alloc::string::String,
    /// The name of the backup that's used to restore a Cloud SQL instance:
    /// Format:
    /// "projects/{project-id}/locations/{location}/backupVaults/{backupvault}/dataSources/{datasource}/backups/{backup-uid}".
    /// Only one of restore_backup_context, backup, backupdr_backup can be
    /// passed to the input.
    #[prost(string, tag = "4")]
    pub backupdr_backup: ::prost::alloc::string::String,
    /// Optional. By using this parameter, Cloud SQL overrides any instance
    /// settings stored in the backup you are restoring from. You can't change the
    /// instance's major database version and you can only increase the disk size.
    /// You can use this field to restore new instances only. This field is not
    /// applicable for restore to existing instances.
    #[prost(message, optional, tag = "3")]
    pub restore_instance_settings: ::core::option::Option<DatabaseInstance>,
    /// Optional. This field has the same purpose as restore_instance_settings,
    /// changes any instance settings stored in the backup you are restoring from.
    /// With the difference that these fields are cleared in the settings.
    #[prost(string, repeated, tag = "5")]
    pub restore_instance_clear_overrides_field_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Rotate Server CA request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesRotateServerCaRequest {
    /// Contains details about the rotate server CA operation.
    #[prost(message, optional, tag = "1")]
    pub rotate_server_ca_context: ::core::option::Option<RotateServerCaContext>,
}
/// Rotate Server Certificate request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesRotateServerCertificateRequest {
    /// Optional. Contains details about the rotate server CA operation.
    #[prost(message, optional, tag = "1")]
    pub rotate_server_certificate_context: ::core::option::Option<
        RotateServerCertificateContext,
    >,
}
/// Rotate Entra ID Certificate request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesRotateEntraIdCertificateRequest {
    /// Optional. Contains details about the rotate Entra ID certificate operation.
    #[prost(message, optional, tag = "1")]
    pub rotate_entra_id_certificate_context: ::core::option::Option<
        RotateEntraIdCertificateContext,
    >,
}
/// Instance truncate log request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesTruncateLogRequest {
    /// Contains details about the truncate log operation.
    #[prost(message, optional, tag = "1")]
    pub truncate_log_context: ::core::option::Option<TruncateLogContext>,
}
/// Request to acquire an SSRS lease for an instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesAcquireSsrsLeaseRequest {
    /// Contains details about the acquire SSRS lease operation.
    #[prost(message, optional, tag = "1")]
    pub acquire_ssrs_lease_context: ::core::option::Option<AcquireSsrsLeaseContext>,
}
/// Context to perform a point-in-time restore of an instance managed by
/// Backup and Disaster Recovery (DR) Service.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PointInTimeRestoreContext {
    /// The Backup and Disaster Recovery (DR) Service Datasource URI.
    /// Format:
    /// projects/{project}/locations/{region}/backupVaults/{backupvault}/dataSources/{datasource}.
    #[prost(string, optional, tag = "1")]
    pub datasource: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The date and time to which you want to restore the instance.
    #[prost(message, optional, tag = "2")]
    pub point_in_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Target instance name.
    #[prost(string, optional, tag = "3")]
    pub target_instance: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The resource link for the VPC network from which the Cloud SQL
    /// instance is accessible for private IP. For example,
    /// `/projects/myProject/global/networks/default`.
    #[prost(string, optional, tag = "4")]
    pub private_network: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The name of the allocated IP range for the internal IP Cloud SQL
    /// instance. For example: "google-managed-services-default". If you set this,
    /// then Cloud SQL creates the IP address for the cloned instance in the
    /// allocated range. This range must comply with [RFC
    /// 1035](<https://tools.ietf.org/html/rfc1035>) standards. Specifically, the
    /// name must be 1-63 characters long and match the regular expression
    /// [a-z](\[-a-z0-9\]*[a-z0-9])?. Reserved for future use.
    #[prost(string, optional, tag = "5")]
    pub allocated_ip_range: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Point-in-time recovery of an instance to the specified zone. If
    /// no zone is specified, then clone to the same primary zone as the source
    /// instance.
    #[prost(string, optional, tag = "6")]
    pub preferred_zone: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Point-in-time recovery of a regional instance in the specified
    /// zones. If not specified, clone to the same secondary zone as the source
    /// instance. This value cannot be the same as the preferred_zone field.
    #[prost(string, optional, tag = "9")]
    pub preferred_secondary_zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Perform disk shrink context.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PerformDiskShrinkContext {
    /// The target disk shrink size in GigaBytes.
    #[prost(int64, tag = "1")]
    pub target_size_gb: i64,
}
/// Structured PreCheckResponse containing message, type, and required
/// actions.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PreCheckResponse {
    /// The message to be displayed to the user.
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// The type of message whether it is an info, warning, or error.
    #[prost(enumeration = "pre_check_response::MessageType", optional, tag = "3")]
    pub message_type: ::core::option::Option<i32>,
    /// The actions that the user needs to take. Use repeated for multiple
    /// actions.
    #[prost(string, repeated, tag = "4")]
    pub actions_required: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PreCheckResponse`.
pub mod pre_check_response {
    /// The type of message which can be an info, a warning, or an error that
    /// requires user intervention.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageType {
        /// Default unspecified value to prevent unintended behavior changes.
        Unspecified = 0,
        /// General informational messages that don't require action.
        Info = 1,
        /// Warnings that might impact the upgrade but don't block it.
        Warning = 2,
        /// Errors that a user must resolve before proceeding with the upgrade.
        Error = 3,
    }
    impl MessageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MESSAGE_TYPE_UNSPECIFIED",
                Self::Info => "INFO",
                Self::Warning => "WARNING",
                Self::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MESSAGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INFO" => Some(Self::Info),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
/// Pre-check major version upgrade context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreCheckMajorVersionUpgradeContext {
    /// Required. The target database version to upgrade to.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "1")]
    pub target_database_version: i32,
    /// Output only. The responses from the precheck operation.
    #[prost(message, repeated, tag = "2")]
    pub pre_check_response: ::prost::alloc::vec::Vec<PreCheckResponse>,
    /// Optional. This is always `sql#preCheckMajorVersionUpgradeContext`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Instance get disk shrink config response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesGetDiskShrinkConfigResponse {
    /// This is always `sql#getDiskShrinkConfig`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The minimum size to which a disk can be shrunk in GigaBytes.
    #[prost(int64, tag = "2")]
    pub minimal_target_size_gb: i64,
    /// Additional message to customers.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Instance verify external sync settings response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesVerifyExternalSyncSettingsResponse {
    /// This is always `sql#migrationSettingErrorList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of migration violations.
    #[prost(message, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<SqlExternalSyncSettingError>,
    /// List of migration warnings.
    #[prost(message, repeated, tag = "3")]
    pub warnings: ::prost::alloc::vec::Vec<SqlExternalSyncSettingError>,
}
/// External primary instance migration setting error/warning.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlExternalSyncSettingError {
    /// Can be `sql#externalSyncSettingError` or
    /// `sql#externalSyncSettingWarning`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Identifies the specific error that occurred.
    #[prost(
        enumeration = "sql_external_sync_setting_error::SqlExternalSyncSettingErrorType",
        tag = "2"
    )]
    pub r#type: i32,
    /// Additional information about the error encountered.
    #[prost(string, tag = "3")]
    pub detail: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SqlExternalSyncSettingError`.
pub mod sql_external_sync_setting_error {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlExternalSyncSettingErrorType {
        Unspecified = 0,
        ConnectionFailure = 1,
        BinlogNotEnabled = 2,
        IncompatibleDatabaseVersion = 3,
        ReplicaAlreadySetup = 4,
        /// The replication user is missing privileges that are required.
        InsufficientPrivilege = 5,
        /// Unsupported migration type.
        UnsupportedMigrationType = 6,
        /// No pglogical extension installed on databases, applicable for postgres.
        NoPglogicalInstalled = 7,
        /// pglogical node already exists on databases, applicable for postgres.
        PglogicalNodeAlreadyExists = 8,
        /// The value of parameter wal_level is not set to logical.
        InvalidWalLevel = 9,
        /// The value of parameter shared_preload_libraries does not include
        /// pglogical.
        InvalidSharedPreloadLibrary = 10,
        /// The value of parameter max_replication_slots is not sufficient.
        InsufficientMaxReplicationSlots = 11,
        /// The value of parameter max_wal_senders is not sufficient.
        InsufficientMaxWalSenders = 12,
        /// The value of parameter max_worker_processes is not sufficient.
        InsufficientMaxWorkerProcesses = 13,
        /// Extensions installed are either not supported or having unsupported
        /// versions
        UnsupportedExtensions = 14,
        /// The value of parameter rds.logical_replication is not set to 1.
        InvalidRdsLogicalReplication = 15,
        /// The primary instance logging setup doesn't allow EM sync.
        InvalidLoggingSetup = 16,
        /// The primary instance database parameter setup doesn't allow EM sync.
        InvalidDbParam = 17,
        /// The gtid_mode is not supported, applicable for MySQL.
        UnsupportedGtidMode = 18,
        /// SQL Server Agent is not running.
        SqlserverAgentNotRunning = 19,
        /// The table definition is not support due to missing primary key or replica
        /// identity, applicable for postgres. Note that this is a warning and won't
        /// block the migration.
        UnsupportedTableDefinition = 20,
        /// The customer has a definer that will break EM setup.
        UnsupportedDefiner = 21,
        /// SQL Server @@SERVERNAME does not match actual host name.
        SqlserverServernameMismatch = 22,
        /// The primary instance has been setup and will fail the setup.
        PrimaryAlreadySetup = 23,
        /// The primary instance has unsupported binary log format.
        UnsupportedBinlogFormat = 24,
        /// The primary instance's binary log retention setting.
        BinlogRetentionSetting = 25,
        /// The primary instance has tables with unsupported storage engine.
        UnsupportedStorageEngine = 26,
        /// Source has tables with limited support
        /// eg: PostgreSQL tables without primary keys.
        LimitedSupportTables = 27,
        /// The replica instance contains existing data.
        ExistingDataInReplica = 28,
        /// The replication user is missing privileges that are optional.
        MissingOptionalPrivileges = 29,
        /// Additional BACKUP_ADMIN privilege is granted to the replication user
        /// which may lock source MySQL 8 instance for DDLs during initial sync.
        RiskyBackupAdminPrivilege = 30,
        /// The Cloud Storage bucket is missing necessary permissions.
        InsufficientGcsPermissions = 31,
        /// The Cloud Storage bucket has an error in the file or contains invalid
        /// file information.
        InvalidFileInfo = 32,
        /// The source instance has unsupported database settings for migration.
        UnsupportedDatabaseSettings = 33,
        /// The replication user is missing parallel import specific privileges.
        /// (e.g. LOCK TABLES) for MySQL.
        MysqlParallelImportInsufficientPrivilege = 34,
        /// The global variable local_infile is off on external server replica.
        LocalInfileOff = 35,
        /// This code instructs customers to turn on point-in-time recovery manually
        /// for the instance after promoting the Cloud SQL for PostgreSQL instance.
        TurnOnPitrAfterPromote = 36,
        /// The minor version of replica database is incompatible with the source.
        IncompatibleDatabaseMinorVersion = 37,
        /// This warning message indicates that Cloud SQL uses the maximum number of
        /// subscriptions to migrate data from the source to the destination.
        SourceMaxSubscriptions = 38,
        /// Unable to verify definers on the source for MySQL.
        UnableToVerifyDefiners = 39,
        /// If a time out occurs while the subscription counts are calculated, then
        /// this value is set to 1. Otherwise, this value is set to 2.
        SubscriptionCalculationStatus = 40,
        /// Count of subscriptions needed to sync source data for PostgreSQL
        /// database.
        PgSubscriptionCount = 41,
        /// Final parallel level that is used to do migration.
        PgSyncParallelLevel = 42,
        /// The disk size of the replica instance is smaller than the data size of
        /// the source instance.
        InsufficientDiskSize = 43,
        /// The data size of the source instance is greater than 1 TB, the number of
        /// cores of the replica instance is less than 8, and the memory of the
        /// replica is less than 32 GB.
        InsufficientMachineTier = 44,
        /// The warning message indicates the unsupported extensions will not be
        /// migrated to the destination.
        UnsupportedExtensionsNotMigrated = 45,
        /// The warning message indicates the pg_cron extension and settings will not
        /// be migrated to the destination.
        ExtensionsNotMigrated = 46,
        /// The error message indicates that pg_cron flags are enabled on the
        /// destination which is not supported during the migration.
        PgCronFlagEnabledInReplica = 47,
        /// This error message indicates that the specified extensions are not
        /// enabled on destination instance. For example, before you can migrate
        /// data to the destination instance, you must enable the PGAudit extension
        /// on the instance.
        ExtensionsNotEnabledInReplica = 48,
        /// The source database has generated columns that can't be migrated. Please
        /// change them to regular columns before migration.
        UnsupportedColumns = 49,
        /// The source database has users that aren't created in the replica.
        /// First, create all users, which are in the pg_user_mappings table
        /// of the source database, in the destination instance. Then, perform the
        /// migration.
        UsersNotCreatedInReplica = 50,
        /// The selected objects include system objects that aren't supported for
        /// migration.
        UnsupportedSystemObjects = 51,
        /// The source database has tables with the FULL or NOTHING replica identity.
        /// Before starting your migration, either remove the identity or change it
        /// to DEFAULT. Note that this is an error and will block the migration.
        UnsupportedTablesWithReplicaIdentity = 52,
        /// The selected objects don't exist on the source instance.
        SelectedObjectsNotExistOnSource = 53,
        /// PSC only destination instance does not have a network attachment URI.
        PscOnlyInstanceWithNoNetworkAttachmentUri = 54,
        /// Selected objects reference unselected objects. Based on their object type
        /// (foreign key constraint or view), selected objects will fail during
        /// migration.
        SelectedObjectsReferenceUnselectedObjects = 55,
        /// The migration will delete existing data in the replica; set
        /// \[replica_overwrite_enabled\]\[google.cloud.sql.v1beta4.SqlInstancesStartExternalSyncRequest.replica_overwrite_enabled\]
        /// in the request to acknowledge this. This is an error. MySQL only.
        PromptDeleteExisting = 56,
        /// The migration will delete existing data in the replica;
        /// \[replica_overwrite_enabled\]\[google.cloud.sql.v1beta4.SqlInstancesStartExternalSyncRequest.replica_overwrite_enabled\]
        /// was set in the request acknowledging this. This is a warning rather than
        /// an error. MySQL only.
        WillDeleteExisting = 57,
        /// The replication user is missing specific privileges to setup DDL
        /// replication. (e.g. CREATE EVENT TRIGGER, CREATE SCHEMA) for PostgreSQL.
        PgDdlReplicationInsufficientPrivilege = 58,
    }
    impl SqlExternalSyncSettingErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED",
                Self::ConnectionFailure => "CONNECTION_FAILURE",
                Self::BinlogNotEnabled => "BINLOG_NOT_ENABLED",
                Self::IncompatibleDatabaseVersion => "INCOMPATIBLE_DATABASE_VERSION",
                Self::ReplicaAlreadySetup => "REPLICA_ALREADY_SETUP",
                Self::InsufficientPrivilege => "INSUFFICIENT_PRIVILEGE",
                Self::UnsupportedMigrationType => "UNSUPPORTED_MIGRATION_TYPE",
                Self::NoPglogicalInstalled => "NO_PGLOGICAL_INSTALLED",
                Self::PglogicalNodeAlreadyExists => "PGLOGICAL_NODE_ALREADY_EXISTS",
                Self::InvalidWalLevel => "INVALID_WAL_LEVEL",
                Self::InvalidSharedPreloadLibrary => "INVALID_SHARED_PRELOAD_LIBRARY",
                Self::InsufficientMaxReplicationSlots => {
                    "INSUFFICIENT_MAX_REPLICATION_SLOTS"
                }
                Self::InsufficientMaxWalSenders => "INSUFFICIENT_MAX_WAL_SENDERS",
                Self::InsufficientMaxWorkerProcesses => {
                    "INSUFFICIENT_MAX_WORKER_PROCESSES"
                }
                Self::UnsupportedExtensions => "UNSUPPORTED_EXTENSIONS",
                Self::InvalidRdsLogicalReplication => "INVALID_RDS_LOGICAL_REPLICATION",
                Self::InvalidLoggingSetup => "INVALID_LOGGING_SETUP",
                Self::InvalidDbParam => "INVALID_DB_PARAM",
                Self::UnsupportedGtidMode => "UNSUPPORTED_GTID_MODE",
                Self::SqlserverAgentNotRunning => "SQLSERVER_AGENT_NOT_RUNNING",
                Self::UnsupportedTableDefinition => "UNSUPPORTED_TABLE_DEFINITION",
                Self::UnsupportedDefiner => "UNSUPPORTED_DEFINER",
                Self::SqlserverServernameMismatch => "SQLSERVER_SERVERNAME_MISMATCH",
                Self::PrimaryAlreadySetup => "PRIMARY_ALREADY_SETUP",
                Self::UnsupportedBinlogFormat => "UNSUPPORTED_BINLOG_FORMAT",
                Self::BinlogRetentionSetting => "BINLOG_RETENTION_SETTING",
                Self::UnsupportedStorageEngine => "UNSUPPORTED_STORAGE_ENGINE",
                Self::LimitedSupportTables => "LIMITED_SUPPORT_TABLES",
                Self::ExistingDataInReplica => "EXISTING_DATA_IN_REPLICA",
                Self::MissingOptionalPrivileges => "MISSING_OPTIONAL_PRIVILEGES",
                Self::RiskyBackupAdminPrivilege => "RISKY_BACKUP_ADMIN_PRIVILEGE",
                Self::InsufficientGcsPermissions => "INSUFFICIENT_GCS_PERMISSIONS",
                Self::InvalidFileInfo => "INVALID_FILE_INFO",
                Self::UnsupportedDatabaseSettings => "UNSUPPORTED_DATABASE_SETTINGS",
                Self::MysqlParallelImportInsufficientPrivilege => {
                    "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE"
                }
                Self::LocalInfileOff => "LOCAL_INFILE_OFF",
                Self::TurnOnPitrAfterPromote => "TURN_ON_PITR_AFTER_PROMOTE",
                Self::IncompatibleDatabaseMinorVersion => {
                    "INCOMPATIBLE_DATABASE_MINOR_VERSION"
                }
                Self::SourceMaxSubscriptions => "SOURCE_MAX_SUBSCRIPTIONS",
                Self::UnableToVerifyDefiners => "UNABLE_TO_VERIFY_DEFINERS",
                Self::SubscriptionCalculationStatus => "SUBSCRIPTION_CALCULATION_STATUS",
                Self::PgSubscriptionCount => "PG_SUBSCRIPTION_COUNT",
                Self::PgSyncParallelLevel => "PG_SYNC_PARALLEL_LEVEL",
                Self::InsufficientDiskSize => "INSUFFICIENT_DISK_SIZE",
                Self::InsufficientMachineTier => "INSUFFICIENT_MACHINE_TIER",
                Self::UnsupportedExtensionsNotMigrated => {
                    "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED"
                }
                Self::ExtensionsNotMigrated => "EXTENSIONS_NOT_MIGRATED",
                Self::PgCronFlagEnabledInReplica => "PG_CRON_FLAG_ENABLED_IN_REPLICA",
                Self::ExtensionsNotEnabledInReplica => {
                    "EXTENSIONS_NOT_ENABLED_IN_REPLICA"
                }
                Self::UnsupportedColumns => "UNSUPPORTED_COLUMNS",
                Self::UsersNotCreatedInReplica => "USERS_NOT_CREATED_IN_REPLICA",
                Self::UnsupportedSystemObjects => "UNSUPPORTED_SYSTEM_OBJECTS",
                Self::UnsupportedTablesWithReplicaIdentity => {
                    "UNSUPPORTED_TABLES_WITH_REPLICA_IDENTITY"
                }
                Self::SelectedObjectsNotExistOnSource => {
                    "SELECTED_OBJECTS_NOT_EXIST_ON_SOURCE"
                }
                Self::PscOnlyInstanceWithNoNetworkAttachmentUri => {
                    "PSC_ONLY_INSTANCE_WITH_NO_NETWORK_ATTACHMENT_URI"
                }
                Self::SelectedObjectsReferenceUnselectedObjects => {
                    "SELECTED_OBJECTS_REFERENCE_UNSELECTED_OBJECTS"
                }
                Self::PromptDeleteExisting => "PROMPT_DELETE_EXISTING",
                Self::WillDeleteExisting => "WILL_DELETE_EXISTING",
                Self::PgDdlReplicationInsufficientPrivilege => {
                    "PG_DDL_REPLICATION_INSUFFICIENT_PRIVILEGE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_EXTERNAL_SYNC_SETTING_ERROR_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "CONNECTION_FAILURE" => Some(Self::ConnectionFailure),
                "BINLOG_NOT_ENABLED" => Some(Self::BinlogNotEnabled),
                "INCOMPATIBLE_DATABASE_VERSION" => {
                    Some(Self::IncompatibleDatabaseVersion)
                }
                "REPLICA_ALREADY_SETUP" => Some(Self::ReplicaAlreadySetup),
                "INSUFFICIENT_PRIVILEGE" => Some(Self::InsufficientPrivilege),
                "UNSUPPORTED_MIGRATION_TYPE" => Some(Self::UnsupportedMigrationType),
                "NO_PGLOGICAL_INSTALLED" => Some(Self::NoPglogicalInstalled),
                "PGLOGICAL_NODE_ALREADY_EXISTS" => Some(Self::PglogicalNodeAlreadyExists),
                "INVALID_WAL_LEVEL" => Some(Self::InvalidWalLevel),
                "INVALID_SHARED_PRELOAD_LIBRARY" => {
                    Some(Self::InvalidSharedPreloadLibrary)
                }
                "INSUFFICIENT_MAX_REPLICATION_SLOTS" => {
                    Some(Self::InsufficientMaxReplicationSlots)
                }
                "INSUFFICIENT_MAX_WAL_SENDERS" => Some(Self::InsufficientMaxWalSenders),
                "INSUFFICIENT_MAX_WORKER_PROCESSES" => {
                    Some(Self::InsufficientMaxWorkerProcesses)
                }
                "UNSUPPORTED_EXTENSIONS" => Some(Self::UnsupportedExtensions),
                "INVALID_RDS_LOGICAL_REPLICATION" => {
                    Some(Self::InvalidRdsLogicalReplication)
                }
                "INVALID_LOGGING_SETUP" => Some(Self::InvalidLoggingSetup),
                "INVALID_DB_PARAM" => Some(Self::InvalidDbParam),
                "UNSUPPORTED_GTID_MODE" => Some(Self::UnsupportedGtidMode),
                "SQLSERVER_AGENT_NOT_RUNNING" => Some(Self::SqlserverAgentNotRunning),
                "UNSUPPORTED_TABLE_DEFINITION" => Some(Self::UnsupportedTableDefinition),
                "UNSUPPORTED_DEFINER" => Some(Self::UnsupportedDefiner),
                "SQLSERVER_SERVERNAME_MISMATCH" => {
                    Some(Self::SqlserverServernameMismatch)
                }
                "PRIMARY_ALREADY_SETUP" => Some(Self::PrimaryAlreadySetup),
                "UNSUPPORTED_BINLOG_FORMAT" => Some(Self::UnsupportedBinlogFormat),
                "BINLOG_RETENTION_SETTING" => Some(Self::BinlogRetentionSetting),
                "UNSUPPORTED_STORAGE_ENGINE" => Some(Self::UnsupportedStorageEngine),
                "LIMITED_SUPPORT_TABLES" => Some(Self::LimitedSupportTables),
                "EXISTING_DATA_IN_REPLICA" => Some(Self::ExistingDataInReplica),
                "MISSING_OPTIONAL_PRIVILEGES" => Some(Self::MissingOptionalPrivileges),
                "RISKY_BACKUP_ADMIN_PRIVILEGE" => Some(Self::RiskyBackupAdminPrivilege),
                "INSUFFICIENT_GCS_PERMISSIONS" => Some(Self::InsufficientGcsPermissions),
                "INVALID_FILE_INFO" => Some(Self::InvalidFileInfo),
                "UNSUPPORTED_DATABASE_SETTINGS" => {
                    Some(Self::UnsupportedDatabaseSettings)
                }
                "MYSQL_PARALLEL_IMPORT_INSUFFICIENT_PRIVILEGE" => {
                    Some(Self::MysqlParallelImportInsufficientPrivilege)
                }
                "LOCAL_INFILE_OFF" => Some(Self::LocalInfileOff),
                "TURN_ON_PITR_AFTER_PROMOTE" => Some(Self::TurnOnPitrAfterPromote),
                "INCOMPATIBLE_DATABASE_MINOR_VERSION" => {
                    Some(Self::IncompatibleDatabaseMinorVersion)
                }
                "SOURCE_MAX_SUBSCRIPTIONS" => Some(Self::SourceMaxSubscriptions),
                "UNABLE_TO_VERIFY_DEFINERS" => Some(Self::UnableToVerifyDefiners),
                "SUBSCRIPTION_CALCULATION_STATUS" => {
                    Some(Self::SubscriptionCalculationStatus)
                }
                "PG_SUBSCRIPTION_COUNT" => Some(Self::PgSubscriptionCount),
                "PG_SYNC_PARALLEL_LEVEL" => Some(Self::PgSyncParallelLevel),
                "INSUFFICIENT_DISK_SIZE" => Some(Self::InsufficientDiskSize),
                "INSUFFICIENT_MACHINE_TIER" => Some(Self::InsufficientMachineTier),
                "UNSUPPORTED_EXTENSIONS_NOT_MIGRATED" => {
                    Some(Self::UnsupportedExtensionsNotMigrated)
                }
                "EXTENSIONS_NOT_MIGRATED" => Some(Self::ExtensionsNotMigrated),
                "PG_CRON_FLAG_ENABLED_IN_REPLICA" => {
                    Some(Self::PgCronFlagEnabledInReplica)
                }
                "EXTENSIONS_NOT_ENABLED_IN_REPLICA" => {
                    Some(Self::ExtensionsNotEnabledInReplica)
                }
                "UNSUPPORTED_COLUMNS" => Some(Self::UnsupportedColumns),
                "USERS_NOT_CREATED_IN_REPLICA" => Some(Self::UsersNotCreatedInReplica),
                "UNSUPPORTED_SYSTEM_OBJECTS" => Some(Self::UnsupportedSystemObjects),
                "UNSUPPORTED_TABLES_WITH_REPLICA_IDENTITY" => {
                    Some(Self::UnsupportedTablesWithReplicaIdentity)
                }
                "SELECTED_OBJECTS_NOT_EXIST_ON_SOURCE" => {
                    Some(Self::SelectedObjectsNotExistOnSource)
                }
                "PSC_ONLY_INSTANCE_WITH_NO_NETWORK_ATTACHMENT_URI" => {
                    Some(Self::PscOnlyInstanceWithNoNetworkAttachmentUri)
                }
                "SELECTED_OBJECTS_REFERENCE_UNSELECTED_OBJECTS" => {
                    Some(Self::SelectedObjectsReferenceUnselectedObjects)
                }
                "PROMPT_DELETE_EXISTING" => Some(Self::PromptDeleteExisting),
                "WILL_DELETE_EXISTING" => Some(Self::WillDeleteExisting),
                "PG_DDL_REPLICATION_INSUFFICIENT_PRIVILEGE" => {
                    Some(Self::PgDdlReplicationInsufficientPrivilege)
                }
                _ => None,
            }
        }
    }
}
/// IP Management configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IpConfiguration {
    /// Whether the instance is assigned a public IP address or not.
    #[prost(message, optional, tag = "1")]
    pub ipv4_enabled: ::core::option::Option<bool>,
    /// The resource link for the VPC network from which the Cloud SQL instance is
    /// accessible for private IP. For example,
    /// `/projects/myProject/global/networks/default`. This setting can
    /// be updated, but it cannot be removed after it is set.
    #[prost(string, tag = "2")]
    pub private_network: ::prost::alloc::string::String,
    /// Use `ssl_mode` instead.
    ///
    /// Whether SSL/TLS connections over IP are enforced.
    /// If set to false, then allow both non-SSL/non-TLS and SSL/TLS connections.
    /// For SSL/TLS connections, the client certificate won't be verified. If
    /// set to true, then only allow connections encrypted with SSL/TLS and with
    /// valid client certificates. If you want to enforce SSL/TLS without enforcing
    /// the requirement for valid client certificates, then use the `ssl_mode` flag
    /// instead of the legacy `require_ssl` flag.
    #[prost(message, optional, tag = "3")]
    pub require_ssl: ::core::option::Option<bool>,
    /// The list of external networks that are allowed to connect to the instance
    /// using the IP. In 'CIDR' notation, also known as 'slash' notation (for
    /// example: `157.197.200.0/24`).
    #[prost(message, repeated, tag = "4")]
    pub authorized_networks: ::prost::alloc::vec::Vec<AclEntry>,
    /// The name of the allocated ip range for the private ip Cloud SQL instance.
    /// For example: "google-managed-services-default". If set, the instance ip
    /// will be created in the allocated range. The range name must comply with
    /// [RFC 1035](<https://tools.ietf.org/html/rfc1035>). Specifically, the name
    /// must be 1-63 characters long and match the regular expression
    /// `[a-z](\[-a-z0-9\]*[a-z0-9])?.`
    #[prost(string, tag = "6")]
    pub allocated_ip_range: ::prost::alloc::string::String,
    /// Controls connectivity to private IP instances from Google services,
    /// such as BigQuery.
    #[prost(message, optional, tag = "7")]
    pub enable_private_path_for_google_cloud_services: ::core::option::Option<bool>,
    /// Specify how SSL/TLS is enforced in database connections. If you must use
    /// the `require_ssl` flag for backward compatibility, then only the following
    /// value pairs are valid:
    ///
    /// For PostgreSQL and MySQL:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=false`
    /// * `ssl_mode=TRUSTED_CLIENT_CERTIFICATE_REQUIRED` and `require_ssl=true`
    ///
    /// For SQL Server:
    ///
    /// * `ssl_mode=ALLOW_UNENCRYPTED_AND_ENCRYPTED` and `require_ssl=false`
    /// * `ssl_mode=ENCRYPTED_ONLY` and `require_ssl=true`
    ///
    /// The value of `ssl_mode` has priority over the value of `require_ssl`.
    ///
    /// For example, for the pair `ssl_mode=ENCRYPTED_ONLY` and
    /// `require_ssl=false`, `ssl_mode=ENCRYPTED_ONLY` means accept only SSL
    /// connections, while `require_ssl=false` means accept both non-SSL
    /// and SSL connections. In this case, MySQL and PostgreSQL databases respect
    /// `ssl_mode` and accepts only SSL connections.
    #[prost(enumeration = "ip_configuration::SslMode", tag = "8")]
    pub ssl_mode: i32,
    /// PSC settings for this instance.
    #[prost(message, optional, tag = "9")]
    pub psc_config: ::core::option::Option<PscConfig>,
    /// Specify what type of CA is used for the server certificate.
    #[prost(enumeration = "ip_configuration::CaMode", optional, tag = "10")]
    pub server_ca_mode: ::core::option::Option<i32>,
    /// Optional. Custom Subject Alternative Name(SAN)s for a Cloud SQL instance.
    #[prost(string, repeated, tag = "11")]
    pub custom_subject_alternative_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. The resource name of the server CA pool for an instance with
    /// `CUSTOMER_MANAGED_CAS_CA` as the `server_ca_mode`.
    /// Format: projects/{PROJECT}/locations/{REGION}/caPools/{CA_POOL_ID}
    #[prost(string, optional, tag = "12")]
    pub server_ca_pool: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Controls the automatic server certificate rotation feature. This
    /// feature is disabled by default. When enabled, the server certificate will
    /// be automatically rotated during Cloud SQL scheduled maintenance or
    /// self-service maintenance updates up to six months before it expires. This
    /// setting can only be set if server_ca_mode is either GOOGLE_MANAGED_CAS_CA
    /// or CUSTOMER_MANAGED_CAS_CA.
    #[prost(
        enumeration = "ip_configuration::ServerCertificateRotationMode",
        optional,
        tag = "16"
    )]
    pub server_certificate_rotation_mode: ::core::option::Option<i32>,
}
/// Nested message and enum types in `IpConfiguration`.
pub mod ip_configuration {
    /// The SSL options for database connections.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SslMode {
        /// The SSL mode is unknown.
        Unspecified = 0,
        /// Allow non-SSL/non-TLS and SSL/TLS connections.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        AllowUnencryptedAndEncrypted = 1,
        /// Only allow connections encrypted with SSL/TLS.
        /// For SSL connections to MySQL and PostgreSQL, the client certificate
        /// isn't verified.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be false or
        /// cleared to avoid a conflict between the values of the two flags.
        EncryptedOnly = 2,
        /// Only allow connections encrypted with SSL/TLS and with valid
        /// client certificates.
        ///
        /// When this value is used, the legacy `require_ssl` flag must be true or
        /// cleared to avoid the conflict between values of two flags.
        /// PostgreSQL clients or users that connect using IAM database
        /// authentication must use either the
        /// [Cloud SQL Auth
        /// Proxy](<https://cloud.google.com/sql/docs/postgres/connect-auth-proxy>) or
        /// [Cloud SQL
        /// Connectors](<https://cloud.google.com/sql/docs/postgres/connect-connectors>)
        /// to enforce client identity verification.
        ///
        /// Only applicable to MySQL and PostgreSQL. Not applicable to SQL Server.
        TrustedClientCertificateRequired = 3,
    }
    impl SslMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SSL_MODE_UNSPECIFIED",
                Self::AllowUnencryptedAndEncrypted => "ALLOW_UNENCRYPTED_AND_ENCRYPTED",
                Self::EncryptedOnly => "ENCRYPTED_ONLY",
                Self::TrustedClientCertificateRequired => {
                    "TRUSTED_CLIENT_CERTIFICATE_REQUIRED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW_UNENCRYPTED_AND_ENCRYPTED" => {
                    Some(Self::AllowUnencryptedAndEncrypted)
                }
                "ENCRYPTED_ONLY" => Some(Self::EncryptedOnly),
                "TRUSTED_CLIENT_CERTIFICATE_REQUIRED" => {
                    Some(Self::TrustedClientCertificateRequired)
                }
                _ => None,
            }
        }
    }
    /// Various Certificate Authority (CA) modes for certificate signing.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CaMode {
        /// CA mode is unspecified. It is effectively the same as
        /// `GOOGLE_MANAGED_INTERNAL_CA`.
        Unspecified = 0,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa = 1,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa = 2,
        /// Customer-managed CA hosted on Google Cloud's Certificate Authority
        /// Service (CAS).
        CustomerManagedCasCa = 3,
    }
    impl CaMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CA_MODE_UNSPECIFIED",
                Self::GoogleManagedInternalCa => "GOOGLE_MANAGED_INTERNAL_CA",
                Self::GoogleManagedCasCa => "GOOGLE_MANAGED_CAS_CA",
                Self::CustomerManagedCasCa => "CUSTOMER_MANAGED_CAS_CA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CA_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_MANAGED_INTERNAL_CA" => Some(Self::GoogleManagedInternalCa),
                "GOOGLE_MANAGED_CAS_CA" => Some(Self::GoogleManagedCasCa),
                "CUSTOMER_MANAGED_CAS_CA" => Some(Self::CustomerManagedCasCa),
                _ => None,
            }
        }
    }
    /// Settings for automatic server certificate rotation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServerCertificateRotationMode {
        /// Unspecified: no automatic server certificate rotation.
        Unspecified = 0,
        /// No automatic server certificate rotation. The user must [manage server
        /// certificate
        /// rotation](/sql/docs/mysql/manage-ssl-instance#rotate-server-certificate-cas)
        /// on their side.
        NoAutomaticRotation = 1,
        /// Automatic server certificate rotation during Cloud SQL scheduled
        /// maintenance or self-service maintenance updates. Requires
        /// `server_ca_mode` to be `GOOGLE_MANAGED_CAS_CA` or
        /// `CUSTOMER_MANAGED_CAS_CA`.
        AutomaticRotationDuringMaintenance = 2,
    }
    impl ServerCertificateRotationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SERVER_CERTIFICATE_ROTATION_MODE_UNSPECIFIED",
                Self::NoAutomaticRotation => "NO_AUTOMATIC_ROTATION",
                Self::AutomaticRotationDuringMaintenance => {
                    "AUTOMATIC_ROTATION_DURING_MAINTENANCE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SERVER_CERTIFICATE_ROTATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_AUTOMATIC_ROTATION" => Some(Self::NoAutomaticRotation),
                "AUTOMATIC_ROTATION_DURING_MAINTENANCE" => {
                    Some(Self::AutomaticRotationDuringMaintenance)
                }
                _ => None,
            }
        }
    }
}
/// PSC settings for a Cloud SQL instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PscConfig {
    /// Whether PSC connectivity is enabled for this instance.
    #[prost(bool, optional, tag = "1")]
    pub psc_enabled: ::core::option::Option<bool>,
    /// Optional. The list of consumer projects that are allow-listed for PSC
    /// connections to this instance. This instance can be connected to with PSC
    /// from any network in these projects.
    ///
    /// Each consumer project in this list may be represented by a project number
    /// (numeric) or by a project id (alphanumeric).
    #[prost(string, repeated, tag = "2")]
    pub allowed_consumer_projects: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. The list of settings for requested Private Service Connect
    /// consumer endpoints that can be used to connect to this Cloud SQL instance.
    #[prost(message, repeated, tag = "3")]
    pub psc_auto_connections: ::prost::alloc::vec::Vec<PscAutoConnectionConfig>,
    /// Optional. The network attachment of the consumer network that the
    /// Private Service Connect enabled Cloud SQL instance is
    /// authorized to connect via PSC interface.
    /// format: projects/PROJECT/regions/REGION/networkAttachments/ID
    #[prost(string, tag = "4")]
    pub network_attachment_uri: ::prost::alloc::string::String,
}
/// Settings for an automatically-setup Private Service Connect consumer endpoint
/// that is used to connect to a Cloud SQL instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PscAutoConnectionConfig {
    /// Optional. This is the project ID of consumer service project of this
    /// consumer endpoint.
    ///
    /// Optional. This is only applicable if consumer_network is a shared vpc
    /// network.
    #[prost(string, tag = "1")]
    pub consumer_project: ::prost::alloc::string::String,
    /// Optional. The consumer network of this consumer endpoint. This must be a
    /// resource path that includes both the host project and the network name.
    ///
    /// For example, `projects/project1/global/networks/network1`.
    ///
    /// The consumer host project of this network might be different from the
    /// consumer service project.
    #[prost(string, tag = "2")]
    pub consumer_network: ::prost::alloc::string::String,
    /// The IP address of the consumer endpoint.
    #[prost(string, optional, tag = "3")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    /// The connection status of the consumer endpoint.
    #[prost(string, optional, tag = "4")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    /// The connection policy status of the consumer network.
    #[prost(string, optional, tag = "5")]
    pub consumer_network_status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Database instance IP mapping
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IpMapping {
    /// The type of this IP address. A `PRIMARY` address is a public address that
    /// can accept incoming connections. A `PRIVATE` address is a private address
    /// that can accept incoming connections. An `OUTGOING` address is the source
    /// address of connections originating from the instance, if supported.
    #[prost(enumeration = "SqlIpAddressType", tag = "1")]
    pub r#type: i32,
    /// The IP address assigned.
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
    /// The due time for this IP to be retired in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`. This field is only available when
    /// the IP is scheduled to be retired.
    #[prost(message, optional, tag = "3")]
    pub time_to_retire: ::core::option::Option<::prost_types::Timestamp>,
}
/// Preferred location. This specifies where a Cloud SQL instance is located.
/// Note that if the preferred location is not available, the instance will be
/// located as close as possible within the region. Only one location may be
/// specified.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LocationPreference {
    /// The App Engine application to follow, it must be in the same region as the
    /// Cloud SQL instance. WARNING: Changing this might restart the instance.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub follow_gae_application: ::prost::alloc::string::String,
    /// The preferred Compute Engine zone (for example: us-central1-a,
    /// us-central1-b, etc.). WARNING: Changing this might restart the instance.
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// The preferred Compute Engine zone for the secondary/failover
    /// (for example: us-central1-a, us-central1-b, etc.).
    /// To disable this field, set it to 'no_secondary_zone'.
    #[prost(string, tag = "4")]
    pub secondary_zone: ::prost::alloc::string::String,
    /// This is always `sql#locationPreference`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
}
/// Maintenance window. This specifies when a Cloud SQL instance
/// is restarted for system maintenance purposes.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MaintenanceWindow {
    /// Hour of day - 0 to 23. Specify in the UTC time zone.
    #[prost(message, optional, tag = "1")]
    pub hour: ::core::option::Option<i32>,
    /// Day of week - `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`,
    /// `SATURDAY`, or `SUNDAY`. Specify in the UTC time zone.
    /// Returned in output as an integer, 1 to 7, where `1` equals Monday.
    #[prost(message, optional, tag = "2")]
    pub day: ::core::option::Option<i32>,
    /// Maintenance timing settings: `canary`, `stable`, or `week5`.
    /// For more information, see [About maintenance on Cloud SQL
    /// instances](<https://cloud.google.com/sql/docs/mysql/maintenance>).
    #[prost(enumeration = "SqlUpdateTrack", tag = "3")]
    pub update_track: i32,
    /// This is always `sql#maintenanceWindow`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
}
/// Deny Maintenance Periods. This specifies a date range during when all CSA
/// rollout will be denied.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DenyMaintenancePeriod {
    /// "deny maintenance period" start date. If the year of the start date is
    /// empty, the year of the end date also must be empty. In this case, it means
    /// the deny maintenance period recurs every year. The date is in format
    /// yyyy-mm-dd i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[prost(string, tag = "1")]
    pub start_date: ::prost::alloc::string::String,
    /// "deny maintenance period" end date. If the year of the end date is empty,
    /// the year of the start date also must be empty. In this case, it means the
    /// deny maintenance period recurs every year. The date is in format yyyy-mm-dd
    /// i.e., 2020-11-01, or mm-dd, i.e., 11-01
    #[prost(string, tag = "2")]
    pub end_date: ::prost::alloc::string::String,
    /// Time in UTC when the "deny maintenance period" starts on start_date and
    /// ends on end_date. The time is in format: HH:mm:SS, i.e., 00:00:00
    #[prost(string, tag = "3")]
    pub time: ::prost::alloc::string::String,
}
/// Insights configuration. This specifies when Cloud SQL Insights feature is
/// enabled and optional configuration.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InsightsConfig {
    /// Whether Query Insights feature is enabled.
    #[prost(bool, tag = "1")]
    pub query_insights_enabled: bool,
    /// Whether Query Insights will record client address when enabled.
    #[prost(bool, tag = "2")]
    pub record_client_address: bool,
    /// Whether Query Insights will record application tags from query when
    /// enabled.
    #[prost(bool, tag = "3")]
    pub record_application_tags: bool,
    /// Maximum query length stored in bytes. Default value: 1024 bytes.
    /// Range: 256-4500 bytes. Query lengths greater than this field value will be
    /// truncated to this value. When unset, query length will be the default
    /// value. Changing query length will restart the database.
    #[prost(message, optional, tag = "4")]
    pub query_string_length: ::core::option::Option<i32>,
    /// Number of query execution plans captured by Insights per minute
    /// for all queries combined. Default is 5.
    #[prost(message, optional, tag = "5")]
    pub query_plans_per_minute: ::core::option::Option<i32>,
    /// Optional. Whether enhanced query insights feature is enabled.
    #[prost(message, optional, tag = "8")]
    pub enhanced_query_insights_enabled: ::core::option::Option<bool>,
}
/// Read-replica configuration specific to MySQL databases.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MySqlReplicaConfiguration {
    /// Path to a SQL dump file in Google Cloud Storage from which the replica
    /// instance is to be created. The URI is in the form gs://bucketName/fileName.
    /// Compressed gzip files (.gz) are also supported.
    /// Dumps have the binlog co-ordinates from which replication
    /// begins. This can be accomplished by setting --master-data to 1 when using
    /// mysqldump.
    #[prost(string, tag = "1")]
    pub dump_file_path: ::prost::alloc::string::String,
    /// The username for the replication connection.
    #[prost(string, tag = "2")]
    pub username: ::prost::alloc::string::String,
    /// The password for the replication connection.
    #[prost(string, tag = "3")]
    pub password: ::prost::alloc::string::String,
    /// Seconds to wait between connect retries. MySQL's default is 60 seconds.
    #[prost(message, optional, tag = "4")]
    pub connect_retry_interval: ::core::option::Option<i32>,
    /// Interval in milliseconds between replication heartbeats.
    #[prost(message, optional, tag = "5")]
    pub master_heartbeat_period: ::core::option::Option<i64>,
    /// PEM representation of the trusted CA's x509 certificate.
    #[prost(string, tag = "6")]
    pub ca_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's x509 certificate.
    #[prost(string, tag = "7")]
    pub client_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's private key. The corresponding public
    /// key is encoded in the client's certificate.
    #[prost(string, tag = "8")]
    pub client_key: ::prost::alloc::string::String,
    /// A list of permissible ciphers to use for SSL encryption.
    #[prost(string, tag = "9")]
    pub ssl_cipher: ::prost::alloc::string::String,
    /// Whether or not to check the primary instance's Common Name value in the
    /// certificate that it sends during the SSL handshake.
    #[prost(message, optional, tag = "10")]
    pub verify_server_certificate: ::core::option::Option<bool>,
    /// This is always `sql#mysqlReplicaConfiguration`.
    #[prost(string, tag = "11")]
    pub kind: ::prost::alloc::string::String,
}
/// A list of objects that the user selects for replication from an external
/// source instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SelectedObjects {
    /// Required. The name of the database to migrate.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
/// On-premises instance configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnPremisesConfiguration {
    /// The host and port of the on-premises instance in host:port format
    #[prost(string, tag = "1")]
    pub host_port: ::prost::alloc::string::String,
    /// This is always `sql#onPremisesConfiguration`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// The username for connecting to on-premises instance.
    #[prost(string, tag = "3")]
    pub username: ::prost::alloc::string::String,
    /// The password for connecting to on-premises instance.
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
    /// PEM representation of the trusted CA's x509 certificate.
    #[prost(string, tag = "5")]
    pub ca_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's x509 certificate.
    #[prost(string, tag = "6")]
    pub client_certificate: ::prost::alloc::string::String,
    /// PEM representation of the replica's private key. The corresponding public
    /// key is encoded in the client's certificate.
    #[prost(string, tag = "7")]
    pub client_key: ::prost::alloc::string::String,
    /// The dump file to create the Cloud SQL replica.
    #[prost(string, tag = "8")]
    pub dump_file_path: ::prost::alloc::string::String,
    /// The reference to Cloud SQL instance if the source is Cloud SQL.
    #[prost(message, optional, tag = "15")]
    pub source_instance: ::core::option::Option<InstanceReference>,
    /// Optional. A list of objects that the user selects for replication from an
    /// external source instance.
    #[prost(message, repeated, tag = "16")]
    pub selected_objects: ::prost::alloc::vec::Vec<SelectedObjects>,
    /// Optional. SslOption for replica connection to the on-premises source.
    #[prost(enumeration = "on_premises_configuration::SslOption", tag = "18")]
    pub ssl_option: i32,
}
/// Nested message and enum types in `OnPremisesConfiguration`.
pub mod on_premises_configuration {
    /// SslOption defines the SSL mode to be used for replica connection to the
    /// on-premises source.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SslOption {
        /// Unknown SSL option i.e. SSL option not specified by user.
        Unspecified = 0,
        /// SSL is disabled for replica connection to the on-premises source.
        Disable = 1,
        /// SSL is required for replica connection to the on-premises source.
        Require = 2,
        /// Verify CA is required for replica connection to the on-premises source.
        VerifyCa = 3,
    }
    impl SslOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SSL_OPTION_UNSPECIFIED",
                Self::Disable => "DISABLE",
                Self::Require => "REQUIRE",
                Self::VerifyCa => "VERIFY_CA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SSL_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
                "DISABLE" => Some(Self::Disable),
                "REQUIRE" => Some(Self::Require),
                "VERIFY_CA" => Some(Self::VerifyCa),
                _ => None,
            }
        }
    }
}
/// Disk encryption configuration for an instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiskEncryptionConfiguration {
    /// Resource name of KMS key for disk encryption
    #[prost(string, tag = "1")]
    pub kms_key_name: ::prost::alloc::string::String,
    /// This is always `sql#diskEncryptionConfiguration`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// Disk encryption status for an instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DiskEncryptionStatus {
    /// KMS key version used to encrypt the Cloud SQL instance resource
    #[prost(string, tag = "1")]
    pub kms_key_version_name: ::prost::alloc::string::String,
    /// This is always `sql#diskEncryptionStatus`.
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
}
/// The sub operation type based on the operation type.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlSubOperationType {
    /// Sub operation details corresponding to the operation type.
    #[prost(oneof = "sql_sub_operation_type::SubOperationDetails", tags = "1")]
    pub sub_operation_details: ::core::option::Option<
        sql_sub_operation_type::SubOperationDetails,
    >,
}
/// Nested message and enum types in `SqlSubOperationType`.
pub mod sql_sub_operation_type {
    /// Sub operation details corresponding to the operation type.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SubOperationDetails {
        /// The type of maintenance to be performed on the instance.
        #[prost(enumeration = "super::SqlMaintenanceType", tag = "1")]
        MaintenanceType(i32),
    }
}
/// An Operation resource. For successful operations that return an
/// Operation resource, only the fields relevant to the operation are populated
/// in the resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    /// This is always `sql#operation`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub target_link: ::prost::alloc::string::String,
    /// The status of an operation.
    #[prost(enumeration = "operation::SqlOperationStatus", tag = "3")]
    pub status: i32,
    /// The email address of the user who initiated this operation.
    #[prost(string, tag = "4")]
    pub user: ::prost::alloc::string::String,
    /// The time this operation was enqueued in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "5")]
    pub insert_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time this operation actually started in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "6")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time this operation finished in UTC timezone in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "7")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// If errors occurred during processing of this operation, this field will be
    /// populated.
    #[prost(message, optional, tag = "8")]
    pub error: ::core::option::Option<OperationErrors>,
    /// An Admin API warning message.
    #[prost(message, optional, tag = "19")]
    pub api_warning: ::core::option::Option<ApiWarning>,
    /// The type of the operation. Valid values are:
    ///
    /// * `CREATE`
    /// * `DELETE`
    /// * `UPDATE`
    /// * `RESTART`
    /// * `IMPORT`
    /// * `EXPORT`
    /// * `BACKUP_VOLUME`
    /// * `RESTORE_VOLUME`
    /// * `CREATE_USER`
    /// * `DELETE_USER`
    /// * `CREATE_DATABASE`
    /// * `DELETE_DATABASE`
    #[prost(enumeration = "operation::SqlOperationType", tag = "9")]
    pub operation_type: i32,
    /// The context for import operation, if applicable.
    #[prost(message, optional, tag = "10")]
    pub import_context: ::core::option::Option<ImportContext>,
    /// The context for export operation, if applicable.
    #[prost(message, optional, tag = "11")]
    pub export_context: ::core::option::Option<ExportContext>,
    /// The context for backup operation, if applicable.
    #[prost(message, optional, tag = "17")]
    pub backup_context: ::core::option::Option<BackupContext>,
    /// The context for pre-check major version upgrade operation, if applicable.
    /// This field is only populated when the operation_type is
    /// PRE_CHECK_MAJOR_VERSION_UPGRADE.
    /// The PreCheckMajorVersionUpgradeContext message itself contains the details
    /// for that pre-check, such as the target database version for the upgrade
    /// and the results of the check (including any warnings or errors found).
    #[prost(message, optional, tag = "50")]
    pub pre_check_major_version_upgrade_context: ::core::option::Option<
        PreCheckMajorVersionUpgradeContext,
    >,
    /// An identifier that uniquely identifies the operation. You can use this
    /// identifier to retrieve the Operations resource that has information about
    /// the operation.
    #[prost(string, tag = "12")]
    pub name: ::prost::alloc::string::String,
    /// Name of the resource on which this operation runs.
    #[prost(string, tag = "13")]
    pub target_id: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "14")]
    pub self_link: ::prost::alloc::string::String,
    /// The project ID of the target instance related to this operation.
    #[prost(string, tag = "15")]
    pub target_project: ::prost::alloc::string::String,
    /// The context for acquire SSRS lease operation, if applicable.
    #[prost(message, optional, tag = "20")]
    pub acquire_ssrs_lease_context: ::core::option::Option<AcquireSsrsLeaseContext>,
    /// Optional. The sub operation based on the operation type.
    #[prost(message, optional, tag = "48")]
    pub sub_operation_type: ::core::option::Option<SqlSubOperationType>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    /// The type of Cloud SQL operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlOperationType {
        /// Unknown operation type.
        Unspecified = 0,
        /// Imports data into a Cloud SQL instance.
        Import = 1,
        /// Exports data from a Cloud SQL instance to a Cloud Storage
        /// bucket.
        Export = 2,
        /// Creates a new Cloud SQL instance.
        Create = 3,
        /// Updates the settings of a Cloud SQL instance.
        Update = 4,
        /// Deletes a Cloud SQL instance.
        Delete = 5,
        /// Restarts the Cloud SQL instance.
        Restart = 6,
        #[deprecated]
        Backup = 7,
        #[deprecated]
        Snapshot = 8,
        /// Performs instance backup.
        BackupVolume = 9,
        /// Deletes an instance backup.
        DeleteVolume = 10,
        /// Restores an instance backup.
        RestoreVolume = 11,
        /// Injects a privileged user in mysql for MOB instances.
        InjectUser = 12,
        /// Clones a Cloud SQL instance.
        Clone = 14,
        /// Stops replication on a Cloud SQL read replica instance.
        StopReplica = 15,
        /// Starts replication on a Cloud SQL read replica instance.
        StartReplica = 16,
        /// Promotes a Cloud SQL replica instance.
        PromoteReplica = 17,
        /// Creates a Cloud SQL replica instance.
        CreateReplica = 18,
        /// Creates a new user in a Cloud SQL instance.
        CreateUser = 19,
        /// Deletes a user from a Cloud SQL instance.
        DeleteUser = 20,
        /// Updates an existing user in a Cloud SQL instance. If a user with the
        /// specified username doesn't exist, a new user is created.
        UpdateUser = 21,
        /// Creates a database in the Cloud SQL instance.
        CreateDatabase = 22,
        /// Deletes a database in the Cloud SQL instance.
        DeleteDatabase = 23,
        /// Updates a database in the Cloud SQL instance.
        UpdateDatabase = 24,
        /// Performs failover of an HA-enabled Cloud SQL
        /// failover replica.
        Failover = 25,
        /// Deletes the backup taken by a backup run.
        DeleteBackup = 26,
        RecreateReplica = 27,
        /// Truncates a general or slow log table in MySQL.
        TruncateLog = 28,
        /// Demotes the stand-alone instance to be a Cloud SQL
        /// read replica for an external database server.
        DemoteMaster = 29,
        /// Indicates that the instance is currently in maintenance. Maintenance
        /// typically causes the instance to be unavailable for 1-3 minutes.
        Maintenance = 30,
        /// This field is deprecated, and will be removed in future version of API.
        #[deprecated]
        EnablePrivateIp = 31,
        #[deprecated]
        DeferMaintenance = 32,
        /// Creates clone instance.
        #[deprecated]
        CreateClone = 33,
        /// Reschedule maintenance to another time.
        RescheduleMaintenance = 34,
        /// Starts external sync of a Cloud SQL EM replica to an external primary
        /// instance.
        StartExternalSync = 35,
        /// Recovers logs from an instance's old data disk.
        LogCleanup = 36,
        /// Performs auto-restart of an HA-enabled Cloud SQL database for auto
        /// recovery.
        AutoRestart = 37,
        /// Re-encrypts CMEK instances with latest key version.
        Reencrypt = 38,
        /// Switches the roles of the primary and replica pair. The target instance
        /// should be the replica.
        Switchover = 39,
        /// Update a backup.
        UpdateBackup = 40,
        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        AcquireSsrsLease = 42,
        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        ReleaseSsrsLease = 43,
        /// Reconfigures old primary after a promote replica operation. Effect of a
        /// promote operation to the old primary is executed in this operation,
        /// asynchronously from the promote replica operation executed to the
        /// replica.
        ReconfigureOldPrimary = 44,
        /// Indicates that the instance, its read replicas, and its cascading
        /// replicas are in maintenance. Maintenance typically gets initiated on
        /// groups of replicas first, followed by the primary instance. For each
        /// instance, maintenance typically causes the instance to be unavailable for
        /// 1-3 minutes.
        #[deprecated]
        ClusterMaintenance = 45,
        /// Indicates that the instance (and any of its replicas) are currently in
        /// maintenance. This is initiated as a self-service request by using SSM.
        /// Maintenance typically causes the instance to be unavailable for 1-3
        /// minutes.
        #[deprecated]
        SelfServiceMaintenance = 46,
        /// Switches a primary instance to a replica. This operation runs as part of
        /// a switchover operation to the original primary instance.
        SwitchoverToReplica = 47,
        /// Updates the major version of a Cloud SQL instance.
        MajorVersionUpgrade = 48,
        /// Deprecated: ADVANCED_BACKUP is deprecated. Use ENHANCED_BACKUP instead.
        #[deprecated]
        AdvancedBackup = 49,
        /// Changes the BackupTier of a Cloud SQL instance.
        ManageBackup = 50,
        /// Creates a backup for an Enhanced BackupTier Cloud SQL instance.
        EnhancedBackup = 51,
        /// Repairs entire read pool or specified read pool nodes in the read pool.
        RepairReadPool = 52,
        /// Creates a Cloud SQL read pool instance.
        CreateReadPool = 53,
    }
    impl SqlOperationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_OPERATION_TYPE_UNSPECIFIED",
                Self::Import => "IMPORT",
                Self::Export => "EXPORT",
                Self::Create => "CREATE",
                Self::Update => "UPDATE",
                Self::Delete => "DELETE",
                Self::Restart => "RESTART",
                #[allow(deprecated)]
                Self::Backup => "BACKUP",
                #[allow(deprecated)]
                Self::Snapshot => "SNAPSHOT",
                Self::BackupVolume => "BACKUP_VOLUME",
                Self::DeleteVolume => "DELETE_VOLUME",
                Self::RestoreVolume => "RESTORE_VOLUME",
                Self::InjectUser => "INJECT_USER",
                Self::Clone => "CLONE",
                Self::StopReplica => "STOP_REPLICA",
                Self::StartReplica => "START_REPLICA",
                Self::PromoteReplica => "PROMOTE_REPLICA",
                Self::CreateReplica => "CREATE_REPLICA",
                Self::CreateUser => "CREATE_USER",
                Self::DeleteUser => "DELETE_USER",
                Self::UpdateUser => "UPDATE_USER",
                Self::CreateDatabase => "CREATE_DATABASE",
                Self::DeleteDatabase => "DELETE_DATABASE",
                Self::UpdateDatabase => "UPDATE_DATABASE",
                Self::Failover => "FAILOVER",
                Self::DeleteBackup => "DELETE_BACKUP",
                Self::RecreateReplica => "RECREATE_REPLICA",
                Self::TruncateLog => "TRUNCATE_LOG",
                Self::DemoteMaster => "DEMOTE_MASTER",
                Self::Maintenance => "MAINTENANCE",
                #[allow(deprecated)]
                Self::EnablePrivateIp => "ENABLE_PRIVATE_IP",
                #[allow(deprecated)]
                Self::DeferMaintenance => "DEFER_MAINTENANCE",
                #[allow(deprecated)]
                Self::CreateClone => "CREATE_CLONE",
                Self::RescheduleMaintenance => "RESCHEDULE_MAINTENANCE",
                Self::StartExternalSync => "START_EXTERNAL_SYNC",
                Self::LogCleanup => "LOG_CLEANUP",
                Self::AutoRestart => "AUTO_RESTART",
                Self::Reencrypt => "REENCRYPT",
                Self::Switchover => "SWITCHOVER",
                Self::UpdateBackup => "UPDATE_BACKUP",
                Self::AcquireSsrsLease => "ACQUIRE_SSRS_LEASE",
                Self::ReleaseSsrsLease => "RELEASE_SSRS_LEASE",
                Self::ReconfigureOldPrimary => "RECONFIGURE_OLD_PRIMARY",
                #[allow(deprecated)]
                Self::ClusterMaintenance => "CLUSTER_MAINTENANCE",
                #[allow(deprecated)]
                Self::SelfServiceMaintenance => "SELF_SERVICE_MAINTENANCE",
                Self::SwitchoverToReplica => "SWITCHOVER_TO_REPLICA",
                Self::MajorVersionUpgrade => "MAJOR_VERSION_UPGRADE",
                #[allow(deprecated)]
                Self::AdvancedBackup => "ADVANCED_BACKUP",
                Self::ManageBackup => "MANAGE_BACKUP",
                Self::EnhancedBackup => "ENHANCED_BACKUP",
                Self::RepairReadPool => "REPAIR_READ_POOL",
                Self::CreateReadPool => "CREATE_READ_POOL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_OPERATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPORT" => Some(Self::Import),
                "EXPORT" => Some(Self::Export),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "DELETE" => Some(Self::Delete),
                "RESTART" => Some(Self::Restart),
                "BACKUP" => Some(#[allow(deprecated)] Self::Backup),
                "SNAPSHOT" => Some(#[allow(deprecated)] Self::Snapshot),
                "BACKUP_VOLUME" => Some(Self::BackupVolume),
                "DELETE_VOLUME" => Some(Self::DeleteVolume),
                "RESTORE_VOLUME" => Some(Self::RestoreVolume),
                "INJECT_USER" => Some(Self::InjectUser),
                "CLONE" => Some(Self::Clone),
                "STOP_REPLICA" => Some(Self::StopReplica),
                "START_REPLICA" => Some(Self::StartReplica),
                "PROMOTE_REPLICA" => Some(Self::PromoteReplica),
                "CREATE_REPLICA" => Some(Self::CreateReplica),
                "CREATE_USER" => Some(Self::CreateUser),
                "DELETE_USER" => Some(Self::DeleteUser),
                "UPDATE_USER" => Some(Self::UpdateUser),
                "CREATE_DATABASE" => Some(Self::CreateDatabase),
                "DELETE_DATABASE" => Some(Self::DeleteDatabase),
                "UPDATE_DATABASE" => Some(Self::UpdateDatabase),
                "FAILOVER" => Some(Self::Failover),
                "DELETE_BACKUP" => Some(Self::DeleteBackup),
                "RECREATE_REPLICA" => Some(Self::RecreateReplica),
                "TRUNCATE_LOG" => Some(Self::TruncateLog),
                "DEMOTE_MASTER" => Some(Self::DemoteMaster),
                "MAINTENANCE" => Some(Self::Maintenance),
                "ENABLE_PRIVATE_IP" => Some(#[allow(deprecated)] Self::EnablePrivateIp),
                "DEFER_MAINTENANCE" => Some(#[allow(deprecated)] Self::DeferMaintenance),
                "CREATE_CLONE" => Some(#[allow(deprecated)] Self::CreateClone),
                "RESCHEDULE_MAINTENANCE" => Some(Self::RescheduleMaintenance),
                "START_EXTERNAL_SYNC" => Some(Self::StartExternalSync),
                "LOG_CLEANUP" => Some(Self::LogCleanup),
                "AUTO_RESTART" => Some(Self::AutoRestart),
                "REENCRYPT" => Some(Self::Reencrypt),
                "SWITCHOVER" => Some(Self::Switchover),
                "UPDATE_BACKUP" => Some(Self::UpdateBackup),
                "ACQUIRE_SSRS_LEASE" => Some(Self::AcquireSsrsLease),
                "RELEASE_SSRS_LEASE" => Some(Self::ReleaseSsrsLease),
                "RECONFIGURE_OLD_PRIMARY" => Some(Self::ReconfigureOldPrimary),
                "CLUSTER_MAINTENANCE" => {
                    Some(#[allow(deprecated)] Self::ClusterMaintenance)
                }
                "SELF_SERVICE_MAINTENANCE" => {
                    Some(#[allow(deprecated)] Self::SelfServiceMaintenance)
                }
                "SWITCHOVER_TO_REPLICA" => Some(Self::SwitchoverToReplica),
                "MAJOR_VERSION_UPGRADE" => Some(Self::MajorVersionUpgrade),
                "ADVANCED_BACKUP" => Some(#[allow(deprecated)] Self::AdvancedBackup),
                "MANAGE_BACKUP" => Some(Self::ManageBackup),
                "ENHANCED_BACKUP" => Some(Self::EnhancedBackup),
                "REPAIR_READ_POOL" => Some(Self::RepairReadPool),
                "CREATE_READ_POOL" => Some(Self::CreateReadPool),
                _ => None,
            }
        }
    }
    /// The status of an operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlOperationStatus {
        /// The state of the operation is unknown.
        Unspecified = 0,
        /// The operation has been queued, but has not started yet.
        Pending = 1,
        /// The operation is running.
        Running = 2,
        /// The operation completed.
        Done = 3,
    }
    impl SqlOperationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_OPERATION_STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Running => "RUNNING",
                Self::Done => "DONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_OPERATION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                _ => None,
            }
        }
    }
}
/// Database instance operation error.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationError {
    /// This is always `sql#operationError`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Identifies the specific error that occurred.
    #[prost(string, tag = "2")]
    pub code: ::prost::alloc::string::String,
    /// Additional information about the error encountered.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Database instance operation errors list wrapper.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationErrors {
    /// This is always `sql#operationErrors`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The list of errors encountered while processing this operation.
    #[prost(message, repeated, tag = "2")]
    pub errors: ::prost::alloc::vec::Vec<OperationError>,
}
/// Database instance local user password validation policy.
/// This message defines the password policy for local database users.
/// When enabled, it enforces constraints on password complexity, length,
/// and reuse. Keep this policy enabled to help prevent unauthorized access.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PasswordValidationPolicy {
    /// Minimum number of characters allowed.
    #[prost(message, optional, tag = "1")]
    pub min_length: ::core::option::Option<i32>,
    /// The complexity of the password.
    #[prost(enumeration = "password_validation_policy::Complexity", tag = "2")]
    pub complexity: i32,
    /// Number of previous passwords that cannot be reused.
    #[prost(message, optional, tag = "3")]
    pub reuse_interval: ::core::option::Option<i32>,
    /// Disallow username as a part of the password.
    #[prost(message, optional, tag = "4")]
    pub disallow_username_substring: ::core::option::Option<bool>,
    /// Minimum interval after which the password can be changed. This flag is only
    /// supported for PostgreSQL.
    #[prost(message, optional, tag = "5")]
    pub password_change_interval: ::core::option::Option<::prost_types::Duration>,
    /// Whether to enable the password policy or not. When enabled, passwords must
    /// meet complexity requirements. Keep this policy enabled to help prevent
    /// unauthorized access. Disabling this policy allows weak passwords.
    #[prost(message, optional, tag = "6")]
    pub enable_password_policy: ::core::option::Option<bool>,
    /// This field is deprecated and will be removed in a future version of the
    /// API.
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub disallow_compromised_credentials: ::core::option::Option<bool>,
}
/// Nested message and enum types in `PasswordValidationPolicy`.
pub mod password_validation_policy {
    /// The complexity choices of the password.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Complexity {
        /// Complexity check is not specified.
        Unspecified = 0,
        /// A combination of lowercase, uppercase, numeric, and non-alphanumeric
        /// characters.
        Default = 1,
    }
    impl Complexity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPLEXITY_UNSPECIFIED",
                Self::Default => "COMPLEXITY_DEFAULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPLEXITY_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLEXITY_DEFAULT" => Some(Self::Default),
                _ => None,
            }
        }
    }
}
/// Operations list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationsListResponse {
    /// This is always `sql#operationsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of operation resources.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Operation>,
    /// The continuation token, used to page through large result sets. Provide
    /// this value in a subsequent request to return the next page of results.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Read-replica configuration for connecting to the primary instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReplicaConfiguration {
    /// This is always `sql#replicaConfiguration`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// MySQL specific configuration when replicating from a MySQL on-premises
    /// primary instance. Replication configuration information such as the
    /// username, password, certificates, and keys are not stored in the instance
    /// metadata. The configuration information is used only to set up the
    /// replication connection and is stored by MySQL in a file named
    /// `master.info` in the data directory.
    #[prost(message, optional, tag = "2")]
    pub mysql_replica_configuration: ::core::option::Option<MySqlReplicaConfiguration>,
    /// Specifies if the replica is the failover target. If the field is set to
    /// `true` the replica will be designated as a failover replica. In case the
    /// primary instance fails, the replica instance will be promoted as the new
    /// primary instance. Only one replica can be specified as failover target, and
    /// the replica has to be in different zone with the primary instance.
    #[prost(message, optional, tag = "3")]
    pub failover_target: ::core::option::Option<bool>,
    /// Optional. Specifies if a SQL Server replica is a cascadable replica. A
    /// cascadable replica is a SQL Server cross region replica that supports
    /// replica(s) under it.
    #[prost(message, optional, tag = "5")]
    pub cascadable_replica: ::core::option::Option<bool>,
}
/// Database instance restore from backup context.
/// Backup context contains source instance id and project id.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreBackupContext {
    /// This is always `sql#restoreBackupContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The ID of the backup run to restore from.
    #[prost(int64, tag = "2")]
    pub backup_run_id: i64,
    /// The ID of the instance that the backup was taken from.
    #[prost(string, tag = "3")]
    pub instance_id: ::prost::alloc::string::String,
    /// The full project ID of the source instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// Instance rotate server CA context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RotateServerCaContext {
    /// This is always `sql#rotateServerCaContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The fingerprint of the next version to be rotated to. If left unspecified,
    /// will be rotated to the most recently added server CA version.
    #[prost(string, tag = "2")]
    pub next_version: ::prost::alloc::string::String,
}
/// Instance rotate server certificate context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RotateServerCertificateContext {
    /// Optional. This is always `sql#rotateServerCertificateContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Optional. The fingerprint of the next version to be rotated to. If left
    /// unspecified, will be rotated to the most recently added server certificate
    /// version.
    #[prost(string, tag = "2")]
    pub next_version: ::prost::alloc::string::String,
}
/// Instance rotate Entra ID certificate context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RotateEntraIdCertificateContext {
    /// Optional. This is always `sql#rotateEntraIdCertificateContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Optional. The fingerprint of the next version to be rotated to. If left
    /// unspecified, will be rotated to the most recently added Entra ID
    /// certificate version.
    #[prost(string, tag = "2")]
    pub next_version: ::prost::alloc::string::String,
}
/// Data cache configurations.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataCacheConfig {
    /// Whether data cache is enabled for the instance.
    #[prost(bool, tag = "1")]
    pub data_cache_enabled: bool,
}
/// Config used to determine the final backup settings for the instance.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FinalBackupConfig {
    /// Whether the final backup is enabled for the instance.
    #[prost(bool, optional, tag = "1")]
    pub enabled: ::core::option::Option<bool>,
    /// The number of days to retain the final backup after the instance deletion.
    /// The final backup will be purged at (time_of_instance_deletion +
    /// retention_days).
    #[prost(int32, optional, tag = "3")]
    pub retention_days: ::core::option::Option<i32>,
}
/// Database instance settings.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Settings {
    /// The version of instance settings. This is a required field for update
    /// method to make sure concurrent updates are handled properly. During update,
    /// use the most recent settingsVersion value for this instance and do not try
    /// to update this value.
    #[prost(message, optional, tag = "1")]
    pub settings_version: ::core::option::Option<i64>,
    /// The App Engine app IDs that can access this instance.
    /// (Deprecated) Applied to First Generation instances only.
    #[deprecated]
    #[prost(string, repeated, tag = "2")]
    pub authorized_gae_applications: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// The tier (or machine type) for this instance, for example
    /// `db-custom-1-3840`. WARNING: Changing this restarts the instance.
    #[prost(string, tag = "3")]
    pub tier: ::prost::alloc::string::String,
    /// This is always `sql#settings`.
    #[prost(string, tag = "4")]
    pub kind: ::prost::alloc::string::String,
    /// User-provided labels, represented as a dictionary where each label is a
    /// single key value pair.
    #[prost(map = "string, string", tag = "5")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Availability type. Potential values:
    ///
    /// * `ZONAL`: The instance serves data from only one zone. Outages in that
    ///   zone affect data accessibility.
    /// * `REGIONAL`: The instance can serve data from more than one zone in a
    ///   region (it is highly available)./
    ///
    /// For more information, see [Overview of the High Availability
    /// Configuration](<https://cloud.google.com/sql/docs/mysql/high-availability>).
    #[prost(enumeration = "SqlAvailabilityType", tag = "6")]
    pub availability_type: i32,
    /// The pricing plan for this instance. This can be either `PER_USE` or
    /// `PACKAGE`. Only `PER_USE` is supported for Second Generation instances.
    #[prost(enumeration = "SqlPricingPlan", tag = "7")]
    pub pricing_plan: i32,
    /// The type of replication this instance uses. This can be either
    /// `ASYNCHRONOUS` or `SYNCHRONOUS`. (Deprecated) This property was only
    /// applicable to First Generation instances.
    #[deprecated]
    #[prost(enumeration = "SqlReplicationType", tag = "8")]
    pub replication_type: i32,
    /// The maximum size to which storage capacity can be automatically increased.
    /// The default value is 0, which specifies that there is no limit.
    #[prost(message, optional, tag = "9")]
    pub storage_auto_resize_limit: ::core::option::Option<i64>,
    /// The activation policy specifies when the instance is activated; it is
    /// applicable only when the instance state is RUNNABLE. Valid values:
    ///
    /// * `ALWAYS`: The instance is on, and remains so even in the absence of
    ///   connection requests.
    /// * `NEVER`: The instance is off; it is not activated, even if a
    ///   connection request arrives.
    #[prost(enumeration = "settings::SqlActivationPolicy", tag = "10")]
    pub activation_policy: i32,
    /// The settings for IP Management. This allows to enable or disable the
    /// instance IP and manage which external networks can connect to the instance.
    /// The IPv4 address cannot be disabled for Second Generation instances.
    #[prost(message, optional, tag = "11")]
    pub ip_configuration: ::core::option::Option<IpConfiguration>,
    /// Configuration to increase storage size automatically. The default value is
    /// true.
    #[prost(message, optional, tag = "12")]
    pub storage_auto_resize: ::core::option::Option<bool>,
    /// The location preference settings. This allows the instance to be located as
    /// near as possible to either an App Engine app or Compute Engine zone for
    /// better performance. App Engine co-location was only applicable to First
    /// Generation instances.
    #[prost(message, optional, tag = "13")]
    pub location_preference: ::core::option::Option<LocationPreference>,
    /// The database flags passed to the instance at startup.
    #[prost(message, repeated, tag = "14")]
    pub database_flags: ::prost::alloc::vec::Vec<DatabaseFlags>,
    /// The type of data disk: `PD_SSD` (default) or `PD_HDD`. Not used for
    /// First Generation instances.
    #[prost(enumeration = "SqlDataDiskType", tag = "15")]
    pub data_disk_type: i32,
    /// The maintenance window for this instance. This specifies when the instance
    /// can be restarted for maintenance purposes.
    #[prost(message, optional, tag = "16")]
    pub maintenance_window: ::core::option::Option<MaintenanceWindow>,
    /// The daily backup configuration for the instance.
    #[prost(message, optional, tag = "17")]
    pub backup_configuration: ::core::option::Option<BackupConfiguration>,
    /// Configuration specific to read replica instances. Indicates whether
    /// replication is enabled or not. WARNING: Changing this restarts the
    /// instance.
    #[prost(message, optional, tag = "18")]
    pub database_replication_enabled: ::core::option::Option<bool>,
    /// Configuration specific to read replica instances. Indicates whether
    /// database flags for crash-safe replication are enabled. This property was
    /// only applicable to First Generation instances.
    #[deprecated]
    #[prost(message, optional, tag = "19")]
    pub crash_safe_replication_enabled: ::core::option::Option<bool>,
    /// The size of data disk, in GB. The data disk size minimum is 10GB.
    #[prost(message, optional, tag = "20")]
    pub data_disk_size_gb: ::core::option::Option<i64>,
    /// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
    #[prost(message, optional, tag = "22")]
    pub active_directory_config: ::core::option::Option<SqlActiveDirectoryConfig>,
    /// The name of server Instance collation.
    #[prost(string, tag = "23")]
    pub collation: ::prost::alloc::string::String,
    /// Deny maintenance periods
    #[prost(message, repeated, tag = "24")]
    pub deny_maintenance_periods: ::prost::alloc::vec::Vec<DenyMaintenancePeriod>,
    /// Insights configuration, for now relevant only for Postgres.
    #[prost(message, optional, tag = "25")]
    pub insights_config: ::core::option::Option<InsightsConfig>,
    /// The local user password validation policy of the instance.
    #[prost(message, optional, tag = "27")]
    pub password_validation_policy: ::core::option::Option<PasswordValidationPolicy>,
    /// SQL Server specific audit configuration.
    #[prost(message, optional, tag = "29")]
    pub sql_server_audit_config: ::core::option::Option<SqlServerAuditConfig>,
    /// Optional. The edition of the instance.
    #[prost(enumeration = "settings::Edition", tag = "38")]
    pub edition: i32,
    /// Specifies if connections must use Cloud SQL connectors.
    /// Option values include the following: `NOT_REQUIRED` (Cloud SQL instances
    /// can be connected without Cloud SQL
    /// Connectors) and `REQUIRED` (Only allow connections that use Cloud SQL
    /// Connectors)
    ///
    /// Note that using REQUIRED disables all existing authorized networks. If
    /// this field is not specified when creating a new instance, NOT_REQUIRED is
    /// used. If this field is not specified when patching or updating an existing
    /// instance, it is left unchanged in the instance.
    #[prost(enumeration = "settings::ConnectorEnforcement", tag = "32")]
    pub connector_enforcement: i32,
    /// Configuration to protect against accidental instance deletion.
    #[prost(message, optional, tag = "33")]
    pub deletion_protection_enabled: ::core::option::Option<bool>,
    /// Server timezone, relevant only for Cloud SQL for SQL Server.
    #[prost(string, tag = "34")]
    pub time_zone: ::prost::alloc::string::String,
    /// Specifies advanced machine configuration for the instances relevant only
    /// for SQL Server.
    #[prost(message, optional, tag = "35")]
    pub advanced_machine_features: ::core::option::Option<AdvancedMachineFeatures>,
    /// Configuration for data cache.
    #[prost(message, optional, tag = "37")]
    pub data_cache_config: ::core::option::Option<DataCacheConfig>,
    /// Optional. Configuration value for recreation of replica after certain
    /// replication lag.
    #[prost(message, optional, tag = "39")]
    pub replication_lag_max_seconds: ::core::option::Option<i32>,
    /// Optional. When this parameter is set to true, Cloud SQL instances can
    /// connect to Vertex AI to pass requests for real-time predictions and
    /// insights to the AI. The default value is false. This applies only to Cloud
    /// SQL for MySQL and Cloud SQL for PostgreSQL instances.
    #[prost(message, optional, tag = "40")]
    pub enable_google_ml_integration: ::core::option::Option<bool>,
    /// Optional. By default, Cloud SQL instances have schema extraction disabled
    /// for Dataplex. When this parameter is set to true, schema extraction for
    /// Dataplex on Cloud SQL instances is activated.
    #[prost(message, optional, tag = "41")]
    pub enable_dataplex_integration: ::core::option::Option<bool>,
    /// Optional. When this parameter is set to true, Cloud SQL retains backups of
    /// the instance even after the instance is deleted. The ON_DEMAND backup will
    /// be retained until customer deletes the backup or the project. The AUTOMATED
    /// backup will be retained based on the backups retention setting.
    #[prost(message, optional, tag = "42")]
    pub retain_backups_on_delete: ::core::option::Option<bool>,
    /// Optional. Provisioned number of I/O operations per second for the data
    /// disk. This field is only used for hyperdisk-balanced disk types.
    #[prost(int64, optional, tag = "43")]
    pub data_disk_provisioned_iops: ::core::option::Option<i64>,
    /// Optional. Provisioned throughput measured in MiB per second for the data
    /// disk. This field is only used for hyperdisk-balanced disk types.
    #[prost(int64, optional, tag = "44")]
    pub data_disk_provisioned_throughput: ::core::option::Option<i64>,
    /// Optional. The managed connection pooling configuration for the instance.
    #[prost(message, optional, tag = "45")]
    pub connection_pool_config: ::core::option::Option<ConnectionPoolConfig>,
    /// Optional. The final backup configuration for the instance.
    #[prost(message, optional, tag = "47")]
    pub final_backup_config: ::core::option::Option<FinalBackupConfig>,
    /// Optional. The read pool auto-scale configuration for the instance.
    #[prost(message, optional, tag = "48")]
    pub read_pool_auto_scale_config: ::core::option::Option<ReadPoolAutoScaleConfig>,
    /// Optional. Cloud SQL for MySQL auto-upgrade configuration. When this
    /// parameter is set to true, auto-upgrade is enabled for MySQL 8.0 minor
    /// versions. The MySQL version must be 8.0.35 or higher.
    #[prost(bool, optional, tag = "50")]
    pub auto_upgrade_enabled: ::core::option::Option<bool>,
    /// Optional. The Microsoft Entra ID configuration for the SQL Server instance.
    #[prost(message, optional, tag = "52")]
    pub entraid_config: ::core::option::Option<SqlServerEntraIdConfig>,
    /// This parameter controls whether to allow using ExecuteSql API to connect to
    /// the instance. Not allowed by default.
    #[prost(enumeration = "settings::DataApiAccess", optional, tag = "53")]
    pub data_api_access: ::core::option::Option<i32>,
    /// Optional. Configuration for Performance Capture, provides diagnostic
    /// metrics during high load situations.
    #[prost(message, optional, tag = "54")]
    pub performance_capture_config: ::core::option::Option<PerformanceCaptureConfig>,
}
/// Nested message and enum types in `Settings`.
pub mod settings {
    /// Specifies when the instance is activated.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlActivationPolicy {
        /// Unknown activation plan.
        Unspecified = 0,
        /// The instance is always up and running.
        Always = 1,
        /// The instance never starts.
        Never = 2,
        /// The instance starts upon receiving requests.
        #[deprecated]
        OnDemand = 3,
    }
    impl SqlActivationPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SQL_ACTIVATION_POLICY_UNSPECIFIED",
                Self::Always => "ALWAYS",
                Self::Never => "NEVER",
                #[allow(deprecated)]
                Self::OnDemand => "ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SQL_ACTIVATION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "ALWAYS" => Some(Self::Always),
                "NEVER" => Some(Self::Never),
                "ON_DEMAND" => Some(#[allow(deprecated)] Self::OnDemand),
                _ => None,
            }
        }
    }
    /// The edition of the instance, can be ENTERPRISE or ENTERPRISE_PLUS.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Edition {
        /// The instance did not specify the edition.
        Unspecified = 0,
        /// The instance is an enterprise edition.
        Enterprise = 2,
        /// The instance is an Enterprise Plus edition.
        EnterprisePlus = 3,
    }
    impl Edition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EDITION_UNSPECIFIED",
                Self::Enterprise => "ENTERPRISE",
                Self::EnterprisePlus => "ENTERPRISE_PLUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "ENTERPRISE" => Some(Self::Enterprise),
                "ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
                _ => None,
            }
        }
    }
    /// The options for enforcing Cloud SQL connectors in the instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectorEnforcement {
        /// The requirement for Cloud SQL connectors is unknown.
        Unspecified = 0,
        /// Do not require Cloud SQL connectors.
        NotRequired = 1,
        /// Require all connections to use Cloud SQL connectors, including the
        /// Cloud SQL Auth Proxy and Cloud SQL Java, Python, and Go connectors.
        /// Note: This disables all existing authorized networks.
        Required = 2,
    }
    impl ConnectorEnforcement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONNECTOR_ENFORCEMENT_UNSPECIFIED",
                Self::NotRequired => "NOT_REQUIRED",
                Self::Required => "REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTOR_ENFORCEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_REQUIRED" => Some(Self::NotRequired),
                "REQUIRED" => Some(Self::Required),
                _ => None,
            }
        }
    }
    /// ExecuteSql API's access to the instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataApiAccess {
        /// Unspecified, effectively the same as `DISALLOW_DATA_API`.
        Unspecified = 0,
        /// Disallow using ExecuteSql API to connect to the instance.
        DisallowDataApi = 1,
        /// Allow using ExecuteSql API to connect to the instance. For private IP
        /// instances, this allows authorized users to access the instance from
        /// the public internet using ExecuteSql API.
        AllowDataApi = 2,
    }
    impl DataApiAccess {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_API_ACCESS_UNSPECIFIED",
                Self::DisallowDataApi => "DISALLOW_DATA_API",
                Self::AllowDataApi => "ALLOW_DATA_API",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_API_ACCESS_UNSPECIFIED" => Some(Self::Unspecified),
                "DISALLOW_DATA_API" => Some(Self::DisallowDataApi),
                "ALLOW_DATA_API" => Some(Self::AllowDataApi),
                _ => None,
            }
        }
    }
}
/// Performance Capture configuration.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PerformanceCaptureConfig {
    /// Optional. Enable or disable the Performance Capture.
    #[prost(bool, optional, tag = "1")]
    pub enabled: ::core::option::Option<bool>,
    /// Optional. The time interval in seconds between any two probes.
    #[prost(int32, optional, tag = "2")]
    pub probing_interval_seconds: ::core::option::Option<i32>,
    /// Optional. The minimum number of consecutive readings above threshold that
    /// triggers instance state capture.
    #[prost(int32, optional, tag = "3")]
    pub probe_threshold: ::core::option::Option<i32>,
    /// Optional. The minimum number of server threads running to trigger the
    /// capture on primary.
    #[prost(int32, optional, tag = "4")]
    pub running_threads_threshold: ::core::option::Option<i32>,
    /// Optional. The minimum number of seconds replica must be lagging behind
    /// primary to trigger capture on replica.
    #[prost(int32, optional, tag = "5")]
    pub seconds_behind_source_threshold: ::core::option::Option<i32>,
    /// Optional. The amount of time in seconds that a transaction needs to have
    /// been open before the watcher starts recording it.
    #[prost(int32, optional, tag = "8")]
    pub transaction_duration_threshold: ::core::option::Option<i32>,
}
/// Specifies options for controlling advanced machine features.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvancedMachineFeatures {
    /// The number of threads per physical core.
    #[prost(int32, tag = "1")]
    pub threads_per_core: i32,
}
/// SslCerts Resource
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SslCert {
    /// This is always `sql#sslCert`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Serial number, as extracted from the certificate.
    #[prost(string, tag = "2")]
    pub cert_serial_number: ::prost::alloc::string::String,
    /// PEM representation.
    #[prost(string, tag = "3")]
    pub cert: ::prost::alloc::string::String,
    /// The time when the certificate was created in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// User supplied name.  Constrained to \[a-zA-Z.-\_ \]+.
    #[prost(string, tag = "5")]
    pub common_name: ::prost::alloc::string::String,
    /// The time when the certificate expires in
    /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
    /// `2012-11-15T16:19:00.094Z`.
    #[prost(message, optional, tag = "6")]
    pub expiration_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Sha1 Fingerprint.
    #[prost(string, tag = "7")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
    /// Name of the database instance.
    #[prost(string, tag = "8")]
    pub instance: ::prost::alloc::string::String,
    /// The URI of this resource.
    #[prost(string, tag = "9")]
    pub self_link: ::prost::alloc::string::String,
}
/// SslCertDetail.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SslCertDetail {
    /// The public information about the cert.
    #[prost(message, optional, tag = "1")]
    pub cert_info: ::core::option::Option<SslCert>,
    /// The private key for the client cert, in pem format.  Keep private in order
    /// to protect your security.
    #[prost(string, tag = "2")]
    pub cert_private_key: ::prost::alloc::string::String,
}
/// SslCerts create ephemeral certificate request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SslCertsCreateEphemeralRequest {
    /// PEM encoded public key to include in the signed certificate.
    #[prost(string, tag = "1")]
    pub public_key: ::prost::alloc::string::String,
    /// Access token to include in the signed certificate.
    #[prost(string, tag = "2")]
    pub access_token: ::prost::alloc::string::String,
}
/// SslCerts insert request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SslCertsInsertRequest {
    /// User supplied name.  Must be a distinct name from the other certificates
    /// for this instance.
    #[prost(string, tag = "1")]
    pub common_name: ::prost::alloc::string::String,
}
/// Reschedule options for maintenance windows.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesRescheduleMaintenanceRequestBody {
    /// Required. The type of the reschedule the user wants.
    #[prost(message, optional, tag = "3")]
    pub reschedule: ::core::option::Option<
        sql_instances_reschedule_maintenance_request_body::Reschedule,
    >,
}
/// Nested message and enum types in `SqlInstancesRescheduleMaintenanceRequestBody`.
pub mod sql_instances_reschedule_maintenance_request_body {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Reschedule {
        /// Required. The type of the reschedule.
        #[prost(enumeration = "RescheduleType", tag = "1")]
        pub reschedule_type: i32,
        /// Optional. Timestamp when the maintenance shall be rescheduled to if
        /// reschedule_type=SPECIFIC_TIME, in
        /// [RFC 3339](<https://tools.ietf.org/html/rfc3339>) format, for example
        /// `2012-11-15T16:19:00.094Z`.
        #[prost(message, optional, tag = "2")]
        pub schedule_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RescheduleType {
        Unspecified = 0,
        /// Reschedules maintenance to happen now (within 5 minutes).
        Immediate = 1,
        /// Reschedules maintenance to occur within one week from the originally
        /// scheduled day and time.
        NextAvailableWindow = 2,
        /// Reschedules maintenance to a specific time and day.
        SpecificTime = 3,
    }
    impl RescheduleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESCHEDULE_TYPE_UNSPECIFIED",
                Self::Immediate => "IMMEDIATE",
                Self::NextAvailableWindow => "NEXT_AVAILABLE_WINDOW",
                Self::SpecificTime => "SPECIFIC_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESCHEDULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMMEDIATE" => Some(Self::Immediate),
                "NEXT_AVAILABLE_WINDOW" => Some(Self::NextAvailableWindow),
                "SPECIFIC_TIME" => Some(Self::SpecificTime),
                _ => None,
            }
        }
    }
}
/// SslCert insert response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertsInsertResponse {
    /// This is always `sql#sslCertsInsert`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The operation to track the ssl certs insert request.
    #[prost(message, optional, tag = "2")]
    pub operation: ::core::option::Option<Operation>,
    /// The server Certificate Authority's certificate.  If this is missing you can
    /// force a new one to be generated by calling resetSslConfig method on
    /// instances resource.
    #[prost(message, optional, tag = "3")]
    pub server_ca_cert: ::core::option::Option<SslCert>,
    /// The new client certificate and private key.
    #[prost(message, optional, tag = "4")]
    pub client_cert: ::core::option::Option<SslCertDetail>,
}
/// SslCerts list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertsListResponse {
    /// This is always `sql#sslCertsList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of client certificates for the instance.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<SslCert>,
}
/// Database Instance truncate log context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TruncateLogContext {
    /// This is always `sql#truncateLogContext`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The type of log to truncate. Valid values are `MYSQL_GENERAL_TABLE` and
    /// `MYSQL_SLOW_TABLE`.
    #[prost(string, tag = "2")]
    pub log_type: ::prost::alloc::string::String,
}
/// Active Directory configuration, relevant only for Cloud SQL for SQL Server.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlActiveDirectoryConfig {
    /// This is always sql#activeDirectoryConfig.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The name of the domain (e.g., mydomain.com).
    #[prost(string, tag = "2")]
    pub domain: ::prost::alloc::string::String,
    /// Optional. The mode of the Active Directory configuration.
    #[prost(enumeration = "sql_active_directory_config::ActiveDirectoryMode", tag = "3")]
    pub mode: i32,
    /// Optional. Domain controller IPv4 addresses used to bootstrap Active
    /// Directory.
    #[prost(string, repeated, tag = "4")]
    pub dns_servers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The secret manager key storing the administrator credential.
    /// (e.g., projects/{project}/secrets/{secret}).
    #[prost(string, tag = "5")]
    pub admin_credential_secret_name: ::prost::alloc::string::String,
    /// Optional. The organizational unit distinguished name. This is the full
    /// hierarchical path to the organizational unit.
    #[prost(string, tag = "6")]
    pub organizational_unit: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SqlActiveDirectoryConfig`.
pub mod sql_active_directory_config {
    /// The modes of Active Directory configuration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ActiveDirectoryMode {
        /// Unspecified mode.
        Unspecified = 0,
        /// Managed Active Directory mode. This is the fallback option to maintain
        /// backward compatibility.
        ManagedActiveDirectory = 1,
        /// Deprecated: Use CUSTOMER_MANAGED_ACTIVE_DIRECTORY instead.
        #[deprecated]
        SelfManagedActiveDirectory = 2,
        /// Customer-managed Active Directory mode.
        CustomerManagedActiveDirectory = 3,
    }
    impl ActiveDirectoryMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTIVE_DIRECTORY_MODE_UNSPECIFIED",
                Self::ManagedActiveDirectory => "MANAGED_ACTIVE_DIRECTORY",
                #[allow(deprecated)]
                Self::SelfManagedActiveDirectory => "SELF_MANAGED_ACTIVE_DIRECTORY",
                Self::CustomerManagedActiveDirectory => {
                    "CUSTOMER_MANAGED_ACTIVE_DIRECTORY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTIVE_DIRECTORY_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MANAGED_ACTIVE_DIRECTORY" => Some(Self::ManagedActiveDirectory),
                "SELF_MANAGED_ACTIVE_DIRECTORY" => {
                    Some(#[allow(deprecated)] Self::SelfManagedActiveDirectory)
                }
                "CUSTOMER_MANAGED_ACTIVE_DIRECTORY" => {
                    Some(Self::CustomerManagedActiveDirectory)
                }
                _ => None,
            }
        }
    }
}
/// SQL Server specific audit configuration.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlServerAuditConfig {
    /// This is always sql#sqlServerAuditConfig
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The name of the destination bucket (e.g., gs://mybucket).
    #[prost(string, tag = "2")]
    pub bucket: ::prost::alloc::string::String,
    /// How long to keep generated audit files.
    #[prost(message, optional, tag = "3")]
    pub retention_interval: ::core::option::Option<::prost_types::Duration>,
    /// How often to upload generated audit files.
    #[prost(message, optional, tag = "4")]
    pub upload_interval: ::core::option::Option<::prost_types::Duration>,
}
/// SQL Server Entra ID configuration.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlServerEntraIdConfig {
    /// Output only. This is always sql#sqlServerEntraIdConfig
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Optional. The tenant ID for the Entra ID configuration.
    #[prost(string, tag = "2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Optional. The application ID for the Entra ID configuration.
    #[prost(string, tag = "3")]
    pub application_id: ::prost::alloc::string::String,
}
/// Connection pool flags for Cloud SQL instances managed connection pool
/// configuration.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConnectionPoolFlags {
    /// Required. The name of the flag.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The value of the flag. Boolean flags are set to `on` for true
    /// and `off` for false. This field must be omitted if the flag
    /// doesn't take a value.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// The read pool auto-scale configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadPoolAutoScaleConfig {
    /// Indicates whether read pool auto scaling is enabled.
    #[prost(bool, optional, tag = "1")]
    pub enabled: ::core::option::Option<bool>,
    /// Minimum number of read pool nodes to be maintained.
    #[prost(int32, optional, tag = "2")]
    pub min_node_count: ::core::option::Option<i32>,
    /// Maximum number of read pool nodes to be maintained.
    #[prost(int32, optional, tag = "3")]
    pub max_node_count: ::core::option::Option<i32>,
    /// Optional. Target metrics for read pool auto scaling.
    #[prost(message, repeated, tag = "4")]
    pub target_metrics: ::prost::alloc::vec::Vec<
        read_pool_auto_scale_config::TargetMetric,
    >,
    /// Indicates whether read pool auto scaling supports scale in operations
    /// (removing nodes).
    #[prost(bool, optional, tag = "5")]
    pub disable_scale_in: ::core::option::Option<bool>,
    /// The cooldown period for scale in operations.
    #[prost(int32, optional, tag = "6")]
    pub scale_in_cooldown_seconds: ::core::option::Option<i32>,
    /// The cooldown period for scale out operations.
    #[prost(int32, optional, tag = "7")]
    pub scale_out_cooldown_seconds: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ReadPoolAutoScaleConfig`.
pub mod read_pool_auto_scale_config {
    /// Target metric for read pool auto scaling.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TargetMetric {
        /// The metric name to be used for auto scaling.
        #[prost(string, optional, tag = "1")]
        pub metric: ::core::option::Option<::prost::alloc::string::String>,
        /// The target value for the metric.
        #[prost(float, optional, tag = "2")]
        pub target_value: ::core::option::Option<f32>,
    }
}
/// The managed connection pooling configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectionPoolConfig {
    /// Whether managed connection pooling is enabled.
    #[prost(bool, optional, tag = "1")]
    pub connection_pooling_enabled: ::core::option::Option<bool>,
    /// Optional. List of connection pool configuration flags.
    #[prost(message, repeated, tag = "8")]
    pub flags: ::prost::alloc::vec::Vec<ConnectionPoolFlags>,
    /// Output only. Number of connection poolers.
    #[prost(int32, optional, tag = "9")]
    pub pooler_count: ::core::option::Option<i32>,
}
/// Acquire SSRS lease context.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AcquireSsrsLeaseContext {
    /// The username to be used as the setup login to connect to the database
    /// server for SSRS setup.
    #[prost(string, optional, tag = "1")]
    pub setup_login: ::core::option::Option<::prost::alloc::string::String>,
    /// The username to be used as the service login to connect to the report
    /// database for SSRS setup.
    #[prost(string, optional, tag = "2")]
    pub service_login: ::core::option::Option<::prost::alloc::string::String>,
    /// The report database to be used for the SSRS setup.
    #[prost(string, optional, tag = "3")]
    pub report_database: ::core::option::Option<::prost::alloc::string::String>,
    /// Lease duration needed for the SSRS setup.
    #[prost(message, optional, tag = "4")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlFileType {
    /// Unknown file type.
    Unspecified = 0,
    /// File containing SQL statements.
    Sql = 1,
    /// File in CSV format.
    Csv = 2,
    Bak = 4,
    /// TDE certificate.
    Tde = 8,
}
impl SqlFileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_FILE_TYPE_UNSPECIFIED",
            Self::Sql => "SQL",
            Self::Csv => "CSV",
            Self::Bak => "BAK",
            Self::Tde => "TDE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_FILE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SQL" => Some(Self::Sql),
            "CSV" => Some(Self::Csv),
            "BAK" => Some(Self::Bak),
            "TDE" => Some(Self::Tde),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BakType {
    /// Default type.
    Unspecified = 0,
    /// Full backup.
    Full = 1,
    /// Differential backup.
    Diff = 2,
    /// SQL Server Transaction Log
    Tlog = 3,
}
impl BakType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "BAK_TYPE_UNSPECIFIED",
            Self::Full => "FULL",
            Self::Diff => "DIFF",
            Self::Tlog => "TLOG",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BAK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FULL" => Some(Self::Full),
            "DIFF" => Some(Self::Diff),
            "TLOG" => Some(Self::Tlog),
            _ => None,
        }
    }
}
/// The type of maintenance to be performed on the instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlMaintenanceType {
    /// Maintenance type is unspecified.
    Unspecified = 0,
    /// Indicates that a standalone instance is undergoing maintenance. The
    /// instance can be either a primary instance or a replica.
    InstanceMaintenance = 1,
    /// Indicates that the primary instance and all of its replicas, including
    /// cascading replicas, are undergoing maintenance. Maintenance is performed on
    /// groups of replicas first, followed by the primary instance.
    ReplicaIncludedMaintenance = 2,
    /// Indicates that the standalone instance is undergoing maintenance, initiated
    /// by self-service. The instance can be either a primary instance or a
    /// replica.
    InstanceSelfServiceMaintenance = 3,
    /// Indicates that the primary instance and all of its replicas are undergoing
    /// maintenance, initiated by self-service. Maintenance is performed on groups
    /// of replicas first, followed by the primary instance.
    ReplicaIncludedSelfServiceMaintenance = 4,
}
impl SqlMaintenanceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_MAINTENANCE_TYPE_UNSPECIFIED",
            Self::InstanceMaintenance => "INSTANCE_MAINTENANCE",
            Self::ReplicaIncludedMaintenance => "REPLICA_INCLUDED_MAINTENANCE",
            Self::InstanceSelfServiceMaintenance => "INSTANCE_SELF_SERVICE_MAINTENANCE",
            Self::ReplicaIncludedSelfServiceMaintenance => {
                "REPLICA_INCLUDED_SELF_SERVICE_MAINTENANCE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_MAINTENANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INSTANCE_MAINTENANCE" => Some(Self::InstanceMaintenance),
            "REPLICA_INCLUDED_MAINTENANCE" => Some(Self::ReplicaIncludedMaintenance),
            "INSTANCE_SELF_SERVICE_MAINTENANCE" => {
                Some(Self::InstanceSelfServiceMaintenance)
            }
            "REPLICA_INCLUDED_SELF_SERVICE_MAINTENANCE" => {
                Some(Self::ReplicaIncludedSelfServiceMaintenance)
            }
            _ => None,
        }
    }
}
/// The status of a backup run.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackupRunStatus {
    /// The status of the run is unknown.
    Unspecified = 0,
    /// The backup operation was enqueued.
    Enqueued = 1,
    /// The backup is overdue across a given backup window. Indicates a
    /// problem. Example: Long-running operation in progress during
    /// the whole window.
    Overdue = 2,
    /// The backup is in progress.
    Running = 3,
    /// The backup failed.
    Failed = 4,
    /// The backup was successful.
    Successful = 5,
    /// The backup was skipped (without problems) for a given backup
    /// window. Example: Instance was idle.
    Skipped = 6,
    /// The backup is about to be deleted.
    DeletionPending = 7,
    /// The backup deletion failed.
    DeletionFailed = 8,
    /// The backup has been deleted.
    Deleted = 9,
}
impl SqlBackupRunStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKUP_RUN_STATUS_UNSPECIFIED",
            Self::Enqueued => "ENQUEUED",
            Self::Overdue => "OVERDUE",
            Self::Running => "RUNNING",
            Self::Failed => "FAILED",
            Self::Successful => "SUCCESSFUL",
            Self::Skipped => "SKIPPED",
            Self::DeletionPending => "DELETION_PENDING",
            Self::DeletionFailed => "DELETION_FAILED",
            Self::Deleted => "DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKUP_RUN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ENQUEUED" => Some(Self::Enqueued),
            "OVERDUE" => Some(Self::Overdue),
            "RUNNING" => Some(Self::Running),
            "FAILED" => Some(Self::Failed),
            "SUCCESSFUL" => Some(Self::Successful),
            "SKIPPED" => Some(Self::Skipped),
            "DELETION_PENDING" => Some(Self::DeletionPending),
            "DELETION_FAILED" => Some(Self::DeletionFailed),
            "DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackupRunType {
    /// This is an unknown BackupRun type.
    Unspecified = 0,
    /// The backup schedule automatically triggers a backup.
    Automated = 1,
    /// The user manually triggers a backup.
    OnDemand = 2,
}
impl SqlBackupRunType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKUP_RUN_TYPE_UNSPECIFIED",
            Self::Automated => "AUTOMATED",
            Self::OnDemand => "ON_DEMAND",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKUP_RUN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AUTOMATED" => Some(Self::Automated),
            "ON_DEMAND" => Some(Self::OnDemand),
            _ => None,
        }
    }
}
/// Defines the supported backup kinds
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackupKind {
    /// This is an unknown BackupKind.
    Unspecified = 0,
    /// Snapshot-based backups.
    Snapshot = 1,
    /// Physical backups.
    Physical = 2,
}
impl SqlBackupKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKUP_KIND_UNSPECIFIED",
            Self::Snapshot => "SNAPSHOT",
            Self::Physical => "PHYSICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKUP_KIND_UNSPECIFIED" => Some(Self::Unspecified),
            "SNAPSHOT" => Some(Self::Snapshot),
            "PHYSICAL" => Some(Self::Physical),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlBackendType {
    /// This is an unknown backend type for instance.
    Unspecified = 0,
    /// V1 speckle instance.
    #[deprecated]
    FirstGen = 1,
    /// V2 speckle instance.
    SecondGen = 2,
    /// On premises instance.
    External = 3,
}
impl SqlBackendType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_BACKEND_TYPE_UNSPECIFIED",
            #[allow(deprecated)]
            Self::FirstGen => "FIRST_GEN",
            Self::SecondGen => "SECOND_GEN",
            Self::External => "EXTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_BACKEND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FIRST_GEN" => Some(#[allow(deprecated)] Self::FirstGen),
            "SECOND_GEN" => Some(Self::SecondGen),
            "EXTERNAL" => Some(Self::External),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlIpAddressType {
    /// This is an unknown IP address type.
    Unspecified = 0,
    /// IP address the customer is supposed to connect to. Usually this is the
    /// load balancer's IP address
    Primary = 1,
    /// Source IP address of the connection a read replica establishes to its
    /// external primary instance. This IP address can be allowlisted by the
    /// customer in case it has a firewall that filters incoming connection to its
    /// on premises primary instance.
    Outgoing = 2,
    /// Private IP used when using private IPs and network peering.
    Private = 3,
    /// V1 IP of a migrated instance. We want the user to
    /// decommission this IP as soon as the migration is complete.
    /// Note: V1 instances with V1 ip addresses will be counted as PRIMARY.
    Migrated1stGen = 4,
}
impl SqlIpAddressType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_IP_ADDRESS_TYPE_UNSPECIFIED",
            Self::Primary => "PRIMARY",
            Self::Outgoing => "OUTGOING",
            Self::Private => "PRIVATE",
            Self::Migrated1stGen => "MIGRATED_1ST_GEN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_IP_ADDRESS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRIMARY" => Some(Self::Primary),
            "OUTGOING" => Some(Self::Outgoing),
            "PRIVATE" => Some(Self::Private),
            "MIGRATED_1ST_GEN" => Some(Self::Migrated1stGen),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlInstanceType {
    /// This is an unknown Cloud SQL instance type.
    Unspecified = 0,
    /// A regular Cloud SQL instance that is not replicating from a primary
    /// instance.
    CloudSqlInstance = 1,
    /// An instance running on the customer's premises that is not managed by
    /// Cloud SQL.
    OnPremisesInstance = 2,
    /// A Cloud SQL instance acting as a read-replica.
    ReadReplicaInstance = 3,
    /// A Cloud SQL read pool.
    ReadPoolInstance = 5,
}
impl SqlInstanceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_INSTANCE_TYPE_UNSPECIFIED",
            Self::CloudSqlInstance => "CLOUD_SQL_INSTANCE",
            Self::OnPremisesInstance => "ON_PREMISES_INSTANCE",
            Self::ReadReplicaInstance => "READ_REPLICA_INSTANCE",
            Self::ReadPoolInstance => "READ_POOL_INSTANCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_INSTANCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CLOUD_SQL_INSTANCE" => Some(Self::CloudSqlInstance),
            "ON_PREMISES_INSTANCE" => Some(Self::OnPremisesInstance),
            "READ_REPLICA_INSTANCE" => Some(Self::ReadReplicaInstance),
            "READ_POOL_INSTANCE" => Some(Self::ReadPoolInstance),
            _ => None,
        }
    }
}
/// The database engine type and version.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlDatabaseVersion {
    /// This is an unknown database version.
    Unspecified = 0,
    /// The database version is MySQL 5.1.
    #[deprecated]
    Mysql51 = 2,
    /// The database version is MySQL 5.5.
    #[deprecated]
    Mysql55 = 3,
    /// The database version is MySQL 5.6.
    Mysql56 = 5,
    /// The database version is MySQL 5.7.
    Mysql57 = 6,
    /// The database version is MySQL 8.
    Mysql80 = 20,
    /// The database major version is MySQL 8.0 and the minor version is 18.
    Mysql8018 = 41,
    /// The database major version is MySQL 8.0 and the minor version is 26.
    Mysql8026 = 85,
    /// The database major version is MySQL 8.0 and the minor version is 27.
    Mysql8027 = 111,
    /// The database major version is MySQL 8.0 and the minor version is 28.
    Mysql8028 = 132,
    /// The database major version is MySQL 8.0 and the minor version is 29.
    #[deprecated]
    Mysql8029 = 148,
    /// The database major version is MySQL 8.0 and the minor version is 30.
    Mysql8030 = 174,
    /// The database major version is MySQL 8.0 and the minor version is 31.
    Mysql8031 = 197,
    /// The database major version is MySQL 8.0 and the minor version is 32.
    Mysql8032 = 213,
    /// The database major version is MySQL 8.0 and the minor version is 33.
    Mysql8033 = 238,
    /// The database major version is MySQL 8.0 and the minor version is 34.
    Mysql8034 = 239,
    /// The database major version is MySQL 8.0 and the minor version is 35.
    Mysql8035 = 240,
    /// The database major version is MySQL 8.0 and the minor version is 36.
    Mysql8036 = 241,
    /// The database major version is MySQL 8.0 and the minor version is 37.
    Mysql8037 = 355,
    /// The database major version is MySQL 8.0 and the minor version is 39.
    Mysql8039 = 357,
    /// The database major version is MySQL 8.0 and the minor version is 40.
    Mysql8040 = 358,
    /// The database major version is MySQL 8.0 and the minor version is 41.
    Mysql8041 = 488,
    /// The database major version is MySQL 8.0 and the minor version is 42.
    Mysql8042 = 489,
    /// The database major version is MySQL 8.0 and the minor version is 43.
    Mysql8043 = 553,
    /// The database major version is MySQL 8.0 and the minor version is 44.
    Mysql8044 = 554,
    /// The database major version is MySQL 8.0 and the minor version is 45.
    Mysql8045 = 555,
    /// The database major version is MySQL 8.0 and the minor version is 46.
    Mysql8046 = 556,
    /// The database version is MySQL 8.4.
    Mysql84 = 398,
    /// The database version is MySQL 9.7.
    Mysql97 = 654,
    /// The database version is SQL Server 2017 Standard.
    Sqlserver2017Standard = 11,
    /// The database version is SQL Server 2017 Enterprise.
    Sqlserver2017Enterprise = 14,
    /// The database version is SQL Server 2017 Express.
    Sqlserver2017Express = 15,
    /// The database version is SQL Server 2017 Web.
    Sqlserver2017Web = 16,
    /// The database version is PostgreSQL 9.6.
    Postgres96 = 9,
    /// The database version is PostgreSQL 10.
    Postgres10 = 18,
    /// The database version is PostgreSQL 11.
    Postgres11 = 10,
    /// The database version is PostgreSQL 12.
    Postgres12 = 19,
    /// The database version is PostgreSQL 13.
    Postgres13 = 23,
    /// The database version is PostgreSQL 14.
    Postgres14 = 110,
    /// The database version is PostgreSQL 15.
    Postgres15 = 172,
    /// The database version is PostgreSQL 16.
    Postgres16 = 272,
    /// The database version is PostgreSQL 17.
    Postgres17 = 408,
    /// The database version is PostgreSQL 18.
    Postgres18 = 557,
    /// The database version is SQL Server 2019 Standard.
    Sqlserver2019Standard = 26,
    /// The database version is SQL Server 2019 Enterprise.
    Sqlserver2019Enterprise = 27,
    /// The database version is SQL Server 2019 Express.
    Sqlserver2019Express = 28,
    /// The database version is SQL Server 2019 Web.
    Sqlserver2019Web = 29,
    /// The database version is SQL Server 2022 Standard.
    Sqlserver2022Standard = 199,
    /// The database version is SQL Server 2022 Enterprise.
    Sqlserver2022Enterprise = 200,
    /// The database version is SQL Server 2022 Express.
    Sqlserver2022Express = 201,
    /// The database version is SQL Server 2022 Web.
    Sqlserver2022Web = 202,
}
impl SqlDatabaseVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_DATABASE_VERSION_UNSPECIFIED",
            #[allow(deprecated)]
            Self::Mysql51 => "MYSQL_5_1",
            #[allow(deprecated)]
            Self::Mysql55 => "MYSQL_5_5",
            Self::Mysql56 => "MYSQL_5_6",
            Self::Mysql57 => "MYSQL_5_7",
            Self::Mysql80 => "MYSQL_8_0",
            Self::Mysql8018 => "MYSQL_8_0_18",
            Self::Mysql8026 => "MYSQL_8_0_26",
            Self::Mysql8027 => "MYSQL_8_0_27",
            Self::Mysql8028 => "MYSQL_8_0_28",
            #[allow(deprecated)]
            Self::Mysql8029 => "MYSQL_8_0_29",
            Self::Mysql8030 => "MYSQL_8_0_30",
            Self::Mysql8031 => "MYSQL_8_0_31",
            Self::Mysql8032 => "MYSQL_8_0_32",
            Self::Mysql8033 => "MYSQL_8_0_33",
            Self::Mysql8034 => "MYSQL_8_0_34",
            Self::Mysql8035 => "MYSQL_8_0_35",
            Self::Mysql8036 => "MYSQL_8_0_36",
            Self::Mysql8037 => "MYSQL_8_0_37",
            Self::Mysql8039 => "MYSQL_8_0_39",
            Self::Mysql8040 => "MYSQL_8_0_40",
            Self::Mysql8041 => "MYSQL_8_0_41",
            Self::Mysql8042 => "MYSQL_8_0_42",
            Self::Mysql8043 => "MYSQL_8_0_43",
            Self::Mysql8044 => "MYSQL_8_0_44",
            Self::Mysql8045 => "MYSQL_8_0_45",
            Self::Mysql8046 => "MYSQL_8_0_46",
            Self::Mysql84 => "MYSQL_8_4",
            Self::Mysql97 => "MYSQL_9_7",
            Self::Sqlserver2017Standard => "SQLSERVER_2017_STANDARD",
            Self::Sqlserver2017Enterprise => "SQLSERVER_2017_ENTERPRISE",
            Self::Sqlserver2017Express => "SQLSERVER_2017_EXPRESS",
            Self::Sqlserver2017Web => "SQLSERVER_2017_WEB",
            Self::Postgres96 => "POSTGRES_9_6",
            Self::Postgres10 => "POSTGRES_10",
            Self::Postgres11 => "POSTGRES_11",
            Self::Postgres12 => "POSTGRES_12",
            Self::Postgres13 => "POSTGRES_13",
            Self::Postgres14 => "POSTGRES_14",
            Self::Postgres15 => "POSTGRES_15",
            Self::Postgres16 => "POSTGRES_16",
            Self::Postgres17 => "POSTGRES_17",
            Self::Postgres18 => "POSTGRES_18",
            Self::Sqlserver2019Standard => "SQLSERVER_2019_STANDARD",
            Self::Sqlserver2019Enterprise => "SQLSERVER_2019_ENTERPRISE",
            Self::Sqlserver2019Express => "SQLSERVER_2019_EXPRESS",
            Self::Sqlserver2019Web => "SQLSERVER_2019_WEB",
            Self::Sqlserver2022Standard => "SQLSERVER_2022_STANDARD",
            Self::Sqlserver2022Enterprise => "SQLSERVER_2022_ENTERPRISE",
            Self::Sqlserver2022Express => "SQLSERVER_2022_EXPRESS",
            Self::Sqlserver2022Web => "SQLSERVER_2022_WEB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_DATABASE_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "MYSQL_5_1" => Some(#[allow(deprecated)] Self::Mysql51),
            "MYSQL_5_5" => Some(#[allow(deprecated)] Self::Mysql55),
            "MYSQL_5_6" => Some(Self::Mysql56),
            "MYSQL_5_7" => Some(Self::Mysql57),
            "MYSQL_8_0" => Some(Self::Mysql80),
            "MYSQL_8_0_18" => Some(Self::Mysql8018),
            "MYSQL_8_0_26" => Some(Self::Mysql8026),
            "MYSQL_8_0_27" => Some(Self::Mysql8027),
            "MYSQL_8_0_28" => Some(Self::Mysql8028),
            "MYSQL_8_0_29" => Some(#[allow(deprecated)] Self::Mysql8029),
            "MYSQL_8_0_30" => Some(Self::Mysql8030),
            "MYSQL_8_0_31" => Some(Self::Mysql8031),
            "MYSQL_8_0_32" => Some(Self::Mysql8032),
            "MYSQL_8_0_33" => Some(Self::Mysql8033),
            "MYSQL_8_0_34" => Some(Self::Mysql8034),
            "MYSQL_8_0_35" => Some(Self::Mysql8035),
            "MYSQL_8_0_36" => Some(Self::Mysql8036),
            "MYSQL_8_0_37" => Some(Self::Mysql8037),
            "MYSQL_8_0_39" => Some(Self::Mysql8039),
            "MYSQL_8_0_40" => Some(Self::Mysql8040),
            "MYSQL_8_0_41" => Some(Self::Mysql8041),
            "MYSQL_8_0_42" => Some(Self::Mysql8042),
            "MYSQL_8_0_43" => Some(Self::Mysql8043),
            "MYSQL_8_0_44" => Some(Self::Mysql8044),
            "MYSQL_8_0_45" => Some(Self::Mysql8045),
            "MYSQL_8_0_46" => Some(Self::Mysql8046),
            "MYSQL_8_4" => Some(Self::Mysql84),
            "MYSQL_9_7" => Some(Self::Mysql97),
            "SQLSERVER_2017_STANDARD" => Some(Self::Sqlserver2017Standard),
            "SQLSERVER_2017_ENTERPRISE" => Some(Self::Sqlserver2017Enterprise),
            "SQLSERVER_2017_EXPRESS" => Some(Self::Sqlserver2017Express),
            "SQLSERVER_2017_WEB" => Some(Self::Sqlserver2017Web),
            "POSTGRES_9_6" => Some(Self::Postgres96),
            "POSTGRES_10" => Some(Self::Postgres10),
            "POSTGRES_11" => Some(Self::Postgres11),
            "POSTGRES_12" => Some(Self::Postgres12),
            "POSTGRES_13" => Some(Self::Postgres13),
            "POSTGRES_14" => Some(Self::Postgres14),
            "POSTGRES_15" => Some(Self::Postgres15),
            "POSTGRES_16" => Some(Self::Postgres16),
            "POSTGRES_17" => Some(Self::Postgres17),
            "POSTGRES_18" => Some(Self::Postgres18),
            "SQLSERVER_2019_STANDARD" => Some(Self::Sqlserver2019Standard),
            "SQLSERVER_2019_ENTERPRISE" => Some(Self::Sqlserver2019Enterprise),
            "SQLSERVER_2019_EXPRESS" => Some(Self::Sqlserver2019Express),
            "SQLSERVER_2019_WEB" => Some(Self::Sqlserver2019Web),
            "SQLSERVER_2022_STANDARD" => Some(Self::Sqlserver2022Standard),
            "SQLSERVER_2022_ENTERPRISE" => Some(Self::Sqlserver2022Enterprise),
            "SQLSERVER_2022_EXPRESS" => Some(Self::Sqlserver2022Express),
            "SQLSERVER_2022_WEB" => Some(Self::Sqlserver2022Web),
            _ => None,
        }
    }
}
/// The suspension reason of the database instance if the state is SUSPENDED.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlSuspensionReason {
    /// This is an unknown suspension reason.
    Unspecified = 0,
    /// The instance is suspended due to billing issues (for example:, account
    /// issue)
    BillingIssue = 2,
    /// The instance is suspended due to illegal content (for example:, child
    /// pornography, copyrighted material, etc.).
    LegalIssue = 3,
    /// The instance is causing operational issues (for example:, causing the
    /// database to crash).
    OperationalIssue = 4,
    /// The KMS key used by the instance is either revoked or denied access to
    KmsKeyIssue = 5,
}
impl SqlSuspensionReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_SUSPENSION_REASON_UNSPECIFIED",
            Self::BillingIssue => "BILLING_ISSUE",
            Self::LegalIssue => "LEGAL_ISSUE",
            Self::OperationalIssue => "OPERATIONAL_ISSUE",
            Self::KmsKeyIssue => "KMS_KEY_ISSUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_SUSPENSION_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "BILLING_ISSUE" => Some(Self::BillingIssue),
            "LEGAL_ISSUE" => Some(Self::LegalIssue),
            "OPERATIONAL_ISSUE" => Some(Self::OperationalIssue),
            "KMS_KEY_ISSUE" => Some(Self::KmsKeyIssue),
            _ => None,
        }
    }
}
/// The pricing plan for this instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlPricingPlan {
    /// This is an unknown pricing plan for this instance.
    Unspecified = 0,
    /// The instance is billed at a monthly flat rate.
    Package = 1,
    /// The instance is billed per usage.
    PerUse = 2,
}
impl SqlPricingPlan {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_PRICING_PLAN_UNSPECIFIED",
            Self::Package => "PACKAGE",
            Self::PerUse => "PER_USE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_PRICING_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
            "PACKAGE" => Some(Self::Package),
            "PER_USE" => Some(Self::PerUse),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlReplicationType {
    /// This is an unknown replication type for a Cloud SQL instance.
    Unspecified = 0,
    /// The synchronous replication mode for First Generation instances. It is the
    /// default value.
    Synchronous = 1,
    /// The asynchronous replication mode for First Generation instances. It
    /// provides a slight performance gain, but if an outage occurs while this
    /// option is set to asynchronous, you can lose up to a few seconds of updates
    /// to your data.
    Asynchronous = 2,
}
impl SqlReplicationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_REPLICATION_TYPE_UNSPECIFIED",
            Self::Synchronous => "SYNCHRONOUS",
            Self::Asynchronous => "ASYNCHRONOUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_REPLICATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SYNCHRONOUS" => Some(Self::Synchronous),
            "ASYNCHRONOUS" => Some(Self::Asynchronous),
            _ => None,
        }
    }
}
/// The type of disk that is used for a v2 instance to use.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlDataDiskType {
    /// This is an unknown data disk type.
    Unspecified = 0,
    /// An SSD data disk.
    PdSsd = 1,
    /// An HDD data disk.
    PdHdd = 2,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[deprecated]
    ObsoleteLocalSsd = 3,
    /// A Hyperdisk Balanced data disk.
    HyperdiskBalanced = 4,
}
impl SqlDataDiskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_DATA_DISK_TYPE_UNSPECIFIED",
            Self::PdSsd => "PD_SSD",
            Self::PdHdd => "PD_HDD",
            #[allow(deprecated)]
            Self::ObsoleteLocalSsd => "OBSOLETE_LOCAL_SSD",
            Self::HyperdiskBalanced => "HYPERDISK_BALANCED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_DATA_DISK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PD_SSD" => Some(Self::PdSsd),
            "PD_HDD" => Some(Self::PdHdd),
            "OBSOLETE_LOCAL_SSD" => Some(#[allow(deprecated)] Self::ObsoleteLocalSsd),
            "HYPERDISK_BALANCED" => Some(Self::HyperdiskBalanced),
            _ => None,
        }
    }
}
/// The availability type of the given Cloud SQL instance.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlAvailabilityType {
    /// This is an unknown Availability type.
    Unspecified = 0,
    /// Zonal available instance.
    Zonal = 1,
    /// Regional available instance.
    Regional = 2,
}
impl SqlAvailabilityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_AVAILABILITY_TYPE_UNSPECIFIED",
            Self::Zonal => "ZONAL",
            Self::Regional => "REGIONAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_AVAILABILITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ZONAL" => Some(Self::Zonal),
            "REGIONAL" => Some(Self::Regional),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlUpdateTrack {
    /// This is an unknown maintenance timing preference.
    Unspecified = 0,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 7 to 14 days
    /// after the notification is sent out. Also referred to as `Week 1` (Console)
    /// and `preview` (gcloud CLI).
    Canary = 1,
    /// For an instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 15 to 21 days
    /// after the notification is sent out. Also referred to as `Week 2` (Console)
    /// and `production` (gcloud CLI).
    Stable = 2,
    /// For instance with a scheduled maintenance window, this maintenance
    /// timing indicates that the maintenance update is scheduled 35 to 42 days
    /// after the notification is sent out.
    Week5 = 3,
}
impl SqlUpdateTrack {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_UPDATE_TRACK_UNSPECIFIED",
            Self::Canary => "canary",
            Self::Stable => "stable",
            Self::Week5 => "week5",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_UPDATE_TRACK_UNSPECIFIED" => Some(Self::Unspecified),
            "canary" => Some(Self::Canary),
            "stable" => Some(Self::Stable),
            "week5" => Some(Self::Week5),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlFlagType {
    /// This is an unknown flag type.
    Unspecified = 0,
    /// Boolean type flag.
    Boolean = 1,
    /// String type flag.
    String = 2,
    /// Integer type flag.
    Integer = 3,
    /// Flag type used for a server startup option.
    None = 4,
    /// Type introduced specially for MySQL TimeZone offset. Accept a string value
    /// with the format \[-12:59, 13:00\].
    MysqlTimezoneOffset = 5,
    /// Float type flag.
    Float = 6,
    /// Comma-separated list of the strings in a SqlFlagType enum.
    RepeatedString = 7,
}
impl SqlFlagType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_FLAG_TYPE_UNSPECIFIED",
            Self::Boolean => "BOOLEAN",
            Self::String => "STRING",
            Self::Integer => "INTEGER",
            Self::None => "NONE",
            Self::MysqlTimezoneOffset => "MYSQL_TIMEZONE_OFFSET",
            Self::Float => "FLOAT",
            Self::RepeatedString => "REPEATED_STRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_FLAG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BOOLEAN" => Some(Self::Boolean),
            "STRING" => Some(Self::String),
            "INTEGER" => Some(Self::Integer),
            "NONE" => Some(Self::None),
            "MYSQL_TIMEZONE_OFFSET" => Some(Self::MysqlTimezoneOffset),
            "FLOAT" => Some(Self::Float),
            "REPEATED_STRING" => Some(Self::RepeatedString),
            _ => None,
        }
    }
}
/// Scopes of a flag describe where the flag is used.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SqlFlagScope {
    /// Assume database flags if unspecified
    Unspecified = 0,
    /// database flags
    Database = 1,
    /// connection pool configuration flags
    ConnectionPool = 2,
}
impl SqlFlagScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SQL_FLAG_SCOPE_UNSPECIFIED",
            Self::Database => "SQL_FLAG_SCOPE_DATABASE",
            Self::ConnectionPool => "SQL_FLAG_SCOPE_CONNECTION_POOL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SQL_FLAG_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SQL_FLAG_SCOPE_DATABASE" => Some(Self::Database),
            "SQL_FLAG_SCOPE_CONNECTION_POOL" => Some(Self::ConnectionPool),
            _ => None,
        }
    }
}
/// The request payload to create the backup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackupRequest {
    /// Required. The parent resource where this backup is created.
    /// Format: projects/{project}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The Backup to create.
    #[prost(message, optional, tag = "2")]
    pub backup: ::core::option::Option<Backup>,
}
/// The request payload to get the backup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBackupRequest {
    /// Required. The name of the backup to retrieve.
    /// Format: projects/{project}/backups/{backup}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request payload to list the backups.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBackupsRequest {
    /// Required. The parent that owns this collection of backups.
    /// Format: projects/{project}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of backups to return per response. The service might
    /// return fewer backups than this value. If a value for this parameter isn't
    /// specified, then, at most, 500 backups are returned. The maximum value is
    /// 2,000. Any values that you set, which are greater than 2,000, are changed
    /// to 2,000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListBackups` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListBackups` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Multiple filter queries are separated by spaces. For example,
    /// 'instance:abc AND type:FINAL, 'location:us',
    /// 'backupInterval.startTime>=1950-01-01T01:01:25.771Z'. You can filter by
    /// type, instance, backupInterval.startTime (creation time), or location.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response payload containing a list of the backups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackupsResponse {
    /// A list of backups.
    #[prost(message, repeated, tag = "1")]
    pub backups: ::prost::alloc::vec::Vec<Backup>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, then there aren't subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// If a region isn't unavailable or if an unknown error occurs, then a warning
    /// message is returned.
    #[prost(message, repeated, tag = "3")]
    pub warnings: ::prost::alloc::vec::Vec<ApiWarning>,
}
/// The request payload to update the backup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackupRequest {
    /// Required. The backup to update.
    /// The backup’s `name` field is used to identify the backup to update.
    /// Format: projects/{project}/backups/{backup}
    #[prost(message, optional, tag = "1")]
    pub backup: ::core::option::Option<Backup>,
    /// The list of fields that you can update. You can update only the description
    /// and retention period of the final backup.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request payload to delete the backup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteBackupRequest {
    /// Required. The name of the backup to delete.
    /// Format: projects/{project}/backups/{backup}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlBackupRunsDeleteRequest {
    /// The ID of the backup run to delete. To find a backup run ID, use the
    /// [list](<https://cloud.google.com/sql/docs/mysql/admin-api/rest/v1beta4/backupRuns/list>)
    /// method.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlBackupRunsGetRequest {
    /// The ID of this backup run.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlBackupRunsInsertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<BackupRun>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlBackupRunsListRequest {
    /// Cloud SQL instance ID, or "-" for all instances. This does not include
    /// the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Maximum number of backup runs per response.
    #[prost(int32, tag = "2")]
    pub max_results: i32,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlDatabasesDeleteRequest {
    /// Name of the database to be deleted in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlDatabasesGetRequest {
    /// Name of the database in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlDatabasesInsertRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<Database>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlDatabasesListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlDatabasesUpdateRequest {
    /// Name of the database to be updated in the instance.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<Database>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlFlagsListRequest {
    /// Database type and version you want to retrieve flags for. By default, this
    /// method returns flags for all database types and versions.
    #[prost(string, tag = "1")]
    pub database_version: ::prost::alloc::string::String,
    /// Optional. Specify the scope of flags to be returned by SqlFlagsListService.
    /// Return list of database flags if unspecified.
    #[prost(enumeration = "SqlFlagScope", optional, tag = "3")]
    pub flag_scope: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesAddServerCaRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Request for AddServerCertificate RPC.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesAddServerCertificateRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Request for AddEntraIdCertificate RPC.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesAddEntraIdCertificateRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesCloneRequest {
    /// The ID of the Cloud SQL instance to be cloned (source). This does not
    /// include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the source as well as the clone Cloud SQL instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesCloneRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesDeleteRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance to be deleted.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Flag to opt-in for final backup. By default, it is turned off.
    #[prost(bool, optional, tag = "7")]
    pub enable_final_backup: ::core::option::Option<bool>,
    /// Optional. The description of the final backup.
    #[prost(string, tag = "5")]
    pub final_backup_description: ::prost::alloc::string::String,
    #[prost(oneof = "sql_instances_delete_request::Expiration", tags = "4, 6")]
    pub expiration: ::core::option::Option<sql_instances_delete_request::Expiration>,
}
/// Nested message and enum types in `SqlInstancesDeleteRequest`.
pub mod sql_instances_delete_request {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Expiration {
        /// Optional. Retention period of the final backup.
        #[prost(int64, tag = "4")]
        FinalBackupTtlDays(i64),
        /// Optional. Final Backup expiration time.
        /// Timestamp in UTC of when this resource is considered expired.
        #[prost(message, tag = "6")]
        FinalBackupExpiryTime(::prost_types::Timestamp),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesDemoteMasterRequest {
    /// Cloud SQL instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesDemoteMasterRequest>,
}
/// Instance demote request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesDemoteRequest {
    /// Required. The name of the Cloud SQL instance.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. The project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The request body.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesDemoteRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesExportRequest {
    /// The Cloud SQL instance ID. This doesn't include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance to be exported.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesExportRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesFailoverRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesFailoverRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesGetRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesImportRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesImportRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesInsertRequest {
    /// Project ID of the project to which the newly created Cloud SQL instances
    /// should belong.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<DatabaseInstance>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesListRequest {
    /// A filter expression that filters resources listed in the response.
    /// The expression is in the form of field:value. For example,
    /// 'instanceType:CLOUD_SQL_INSTANCE'. Fields can be nested as needed as per
    /// their JSON representation, such as 'settings.userLabels.auto_start:true'.
    ///
    /// Multiple filter queries are space-separated. For example.
    /// 'state:RUNNABLE instanceType:CLOUD_SQL_INSTANCE'. By default, each
    /// expression is an AND expression. However, you can include AND and OR
    /// expressions explicitly.
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    /// The maximum number of instances to return. The service may return fewer
    /// than this value.
    /// If unspecified, at most 500 instances are returned.
    /// The maximum value is 1000; values above 1000 are coerced to 1000.
    #[prost(uint32, tag = "2")]
    pub max_results: u32,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Project ID of the project for which to list Cloud SQL instances.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesListServerCasRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesListServerCertificatesRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Request message for SqlInstancesService.ListEntraIdCertificates.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesListEntraIdCertificatesRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesPatchRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<DatabaseInstance>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesPromoteReplicaRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Set to true to invoke a replica failover to the DR replica.
    /// As part of replica failover, the promote operation attempts
    /// to add the original primary instance as a replica of the promoted
    /// DR replica when the original primary instance comes back online.
    /// If set to false or not specified, then the original primary
    /// instance becomes an independent Cloud SQL primary instance.
    #[prost(bool, tag = "3")]
    pub failover: bool,
}
/// Instance switchover request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesSwitchoverRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Optional. (MySQL and PostgreSQL only) Cloud SQL instance operations
    /// timeout, which is a sum of all database operations. Default value is 10
    /// minutes and can be modified to a maximum value of 24 hours.
    #[prost(message, optional, tag = "3")]
    pub db_timeout: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesResetSslConfigRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Optional. Reset SSL mode to use.
    #[prost(
        enumeration = "sql_instances_reset_ssl_config_request::ResetSslMode",
        tag = "3"
    )]
    pub mode: i32,
}
/// Nested message and enum types in `SqlInstancesResetSslConfigRequest`.
pub mod sql_instances_reset_ssl_config_request {
    /// Reset SSL mode to selectively refresh the SSL materials.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResetSslMode {
        /// Reset SSL mode is not specified.
        Unspecified = 0,
        /// Refresh all TLS configs. This is the default behaviour.
        All = 1,
        /// Refreshes the replication-related TLS configuration settings provided by
        /// the primary instance.
        /// Not applicable to on-premises replication instances.
        SyncFromPrimary = 2,
    }
    impl ResetSslMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESET_SSL_MODE_UNSPECIFIED",
                Self::All => "ALL",
                Self::SyncFromPrimary => "SYNC_FROM_PRIMARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESET_SSL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL" => Some(Self::All),
                "SYNC_FROM_PRIMARY" => Some(Self::SyncFromPrimary),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesRestartRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance to be restarted.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesRestoreBackupRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesRestoreBackupRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesRotateServerCaRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesRotateServerCaRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesRotateServerCertificateRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Required. Rotate server certificate request body.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesRotateServerCertificateRequest>,
}
/// Request message for SqlInstancesService.RotateEntraIdCertificate.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesRotateEntraIdCertificateRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Required. Rotate Entra ID certificate request body.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesRotateEntraIdCertificateRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesStartReplicaRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesStopReplicaRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesTruncateLogRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the Cloud SQL project.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesTruncateLogRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesUpdateRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<DatabaseInstance>,
}
/// Instance reencrypt request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesReencryptRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Reencrypt body that users request
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<InstancesReencryptRequest>,
}
/// Database Instance reencrypt request.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InstancesReencryptRequest {
    /// Configuration specific to backup re-encryption
    #[prost(message, optional, tag = "1")]
    pub backup_reencryption_config: ::core::option::Option<BackupReencryptionConfig>,
}
/// Backup Reencryption Config
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BackupReencryptionConfig {
    /// Backup re-encryption limit
    #[prost(int32, optional, tag = "1")]
    pub backup_limit: ::core::option::Option<i32>,
    /// Type of backups users want to re-encrypt.
    #[prost(enumeration = "backup_reencryption_config::BackupType", optional, tag = "2")]
    pub backup_type: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BackupReencryptionConfig`.
pub mod backup_reencryption_config {
    /// Backup type for re-encryption
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupType {
        /// Unknown backup type, will be defaulted to AUTOMATIC backup type
        Unspecified = 0,
        /// Reencrypt automatic backups
        Automated = 1,
        /// Reencrypt on-demand backups
        OnDemand = 2,
    }
    impl BackupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_TYPE_UNSPECIFIED",
                Self::Automated => "AUTOMATED",
                Self::OnDemand => "ON_DEMAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATED" => Some(Self::Automated),
                "ON_DEMAND" => Some(Self::OnDemand),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesRescheduleMaintenanceRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<SqlInstancesRescheduleMaintenanceRequestBody>,
}
/// Instance perform disk shrink request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesPerformDiskShrinkRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Perform disk shrink context.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<PerformDiskShrinkContext>,
}
/// The selected object that Cloud SQL migrates.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExternalSyncSelectedObject {
    /// The name of the database that Cloud SQL migrates.
    #[prost(string, tag = "1")]
    pub database: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesVerifyExternalSyncSettingsRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Flag to enable verifying connection only
    #[prost(bool, tag = "3")]
    pub verify_connection_only: bool,
    /// External sync mode
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::ExternalSyncMode",
        tag = "4"
    )]
    pub sync_mode: i32,
    /// Optional. Flag to verify settings required by replication setup only
    #[prost(bool, tag = "5")]
    pub verify_replication_only: bool,
    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::MigrationType",
        tag = "7"
    )]
    pub migration_type: i32,
    /// Optional. Parallel level for initial data sync. Only applicable for
    /// PostgreSQL.
    #[prost(enumeration = "ExternalSyncParallelLevel", tag = "8")]
    pub sync_parallel_level: i32,
    /// Optional. Migrate only the specified objects from the source instance. If
    /// this field is empty, then migrate all objects.
    #[prost(message, repeated, tag = "9")]
    pub selected_objects: ::prost::alloc::vec::Vec<ExternalSyncSelectedObject>,
    #[prost(
        oneof = "sql_instances_verify_external_sync_settings_request::SyncConfig",
        tags = "6"
    )]
    pub sync_config: ::core::option::Option<
        sql_instances_verify_external_sync_settings_request::SyncConfig,
    >,
}
/// Nested message and enum types in `SqlInstancesVerifyExternalSyncSettingsRequest`.
pub mod sql_instances_verify_external_sync_settings_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExternalSyncMode {
        /// Unknown external sync mode, will be defaulted to ONLINE mode
        Unspecified = 0,
        /// Online external sync will set up replication after initial data external
        /// sync
        Online = 1,
        /// Offline external sync only dumps and loads a one-time snapshot of
        /// the primary instance's data
        Offline = 2,
    }
    impl ExternalSyncMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXTERNAL_SYNC_MODE_UNSPECIFIED",
                Self::Online => "ONLINE",
                Self::Offline => "OFFLINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXTERNAL_SYNC_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ONLINE" => Some(Self::Online),
                "OFFLINE" => Some(Self::Offline),
                _ => None,
            }
        }
    }
    /// MigrationType determines whether the migration is a physical file-based
    /// migration or a logical dump file-based migration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MigrationType {
        /// Default value is a logical dump file-based migration
        Unspecified = 0,
        /// Logical dump file-based migration
        Logical = 1,
        /// Physical file-based migration
        Physical = 2,
    }
    impl MigrationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MIGRATION_TYPE_UNSPECIFIED",
                Self::Logical => "LOGICAL",
                Self::Physical => "PHYSICAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MIGRATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LOGICAL" => Some(Self::Logical),
                "PHYSICAL" => Some(Self::Physical),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SyncConfig {
        /// Optional. MySQL-specific settings for start external sync.
        #[prost(message, tag = "6")]
        MysqlSyncConfig(super::MySqlSyncConfig),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesStartExternalSyncRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// External sync mode.
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::ExternalSyncMode",
        tag = "3"
    )]
    pub sync_mode: i32,
    /// Whether to skip the verification step (VESS).
    #[prost(bool, tag = "4")]
    pub skip_verification: bool,
    /// Optional. Parallel level for initial data sync. Currently only applicable
    /// for MySQL.
    #[prost(enumeration = "ExternalSyncParallelLevel", tag = "7")]
    pub sync_parallel_level: i32,
    /// Optional. MigrationType configures the migration to use physical files or
    /// logical dump files. If not set, then the logical dump file configuration is
    /// used. Valid values are `LOGICAL` or `PHYSICAL`. Only applicable to MySQL.
    #[prost(
        enumeration = "sql_instances_verify_external_sync_settings_request::MigrationType",
        tag = "8"
    )]
    pub migration_type: i32,
    /// Optional. MySQL only. True if end-user has confirmed that this SES call
    /// will wipe replica databases overlapping with the proposed selected_objects.
    /// If this field is not set and there are both overlapping and additional
    /// databases proposed, an error will be returned.
    #[prost(bool, tag = "9")]
    pub replica_overwrite_enabled: bool,
    #[prost(oneof = "sql_instances_start_external_sync_request::SyncConfig", tags = "6")]
    pub sync_config: ::core::option::Option<
        sql_instances_start_external_sync_request::SyncConfig,
    >,
}
/// Nested message and enum types in `SqlInstancesStartExternalSyncRequest`.
pub mod sql_instances_start_external_sync_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SyncConfig {
        /// MySQL-specific settings for start external sync.
        #[prost(message, tag = "6")]
        MysqlSyncConfig(super::MySqlSyncConfig),
    }
}
/// Instance reset replica size request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesResetReplicaSizeRequest {
    /// Cloud SQL read replica instance name.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// ID of the project that contains the read replica.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlOperationsGetRequest {
    /// Instance operation ID.
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlOperationsListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Maximum number of operations per response.
    #[prost(uint32, tag = "2")]
    pub max_results: u32,
    /// A previously-returned page token representing part of the larger set of
    /// results to view.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// The request payload to cancel an operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlOperationsCancelRequest {
    /// Instance operation ID.
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesCreateEphemeralCertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the Cloud SQL project.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<SslCertsCreateEphemeralRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlSslCertsDeleteRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Sha1 FingerPrint.
    #[prost(string, tag = "3")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlSslCertsGetRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Sha1 FingerPrint.
    #[prost(string, tag = "3")]
    pub sha1_fingerprint: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlSslCertsInsertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<SslCertsInsertRequest>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlSslCertsListRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance get disk shrink config request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesGetDiskShrinkConfigRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// Instance get latest recovery time request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesGetLatestRecoveryTimeRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The timestamp used to identify the time when the source instance is
    /// deleted. If this instance is deleted, then you must set the timestamp.
    #[prost(message, optional, tag = "3")]
    pub source_instance_deletion_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Instance get latest recovery time response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesGetLatestRecoveryTimeResponse {
    /// This is always `sql#getLatestRecoveryTime`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// Timestamp, identifies the latest recovery time of the source instance.
    #[prost(message, optional, tag = "2")]
    pub latest_recovery_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Timestamp, identifies the earliest recovery time of the source instance.
    #[prost(message, optional, tag = "3")]
    pub earliest_recovery_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Execute SQL statements request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesExecuteSqlRequest {
    /// Required. Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The request body.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<ExecuteSqlPayload>,
}
/// Request to release a lease for SSRS.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesReleaseSsrsLeaseRequest {
    /// Required. The Cloud SQL instance ID. This doesn't include the project ID.
    /// It's composed of lowercase letters, numbers, and hyphens, and it must start
    /// with a letter. The total length must be 98 characters or less (Example:
    /// instance-id).
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. The ID of the project that contains the instance (Example:
    /// project-id).
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
/// The response for the release of the SSRS lease.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesReleaseSsrsLeaseResponse {
    /// The operation ID.
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
}
/// The request payload used to execute SQL statements.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecuteSqlPayload {
    /// Optional. The name of an existing database user to connect to the database.
    /// When `auto_iam_authn` is set to true, this field is ignored and the API
    /// caller's IAM user is used.
    #[prost(string, tag = "1")]
    pub user: ::prost::alloc::string::String,
    /// Required. SQL statements to run on the database. It can be a single
    /// statement or a sequence of statements separated by semicolons.
    #[prost(string, tag = "2")]
    pub sql_statement: ::prost::alloc::string::String,
    /// Optional. Name of the database on which the statement will be executed.
    #[prost(string, tag = "3")]
    pub database: ::prost::alloc::string::String,
    /// Optional. The maximum number of rows returned per SQL statement.
    #[prost(int64, tag = "10")]
    pub row_limit: i64,
    /// Optional. Controls how the API should respond when the SQL execution result
    /// is incomplete due to the size limit or another error. The default mode is
    /// to throw an error.
    #[prost(enumeration = "execute_sql_payload::PartialResultMode", tag = "13")]
    pub partial_result_mode: i32,
    /// Optional. Specifies the name of the application that is making the request.
    /// This field is used for telemetry. Only alphanumeric characters, dashes, and
    /// underscores are allowed. The maximum length is 32 characters.
    #[prost(string, tag = "16")]
    pub application: ::prost::alloc::string::String,
    /// Credentials for the database connection.
    #[prost(oneof = "execute_sql_payload::UserPassword", tags = "11")]
    pub user_password: ::core::option::Option<execute_sql_payload::UserPassword>,
}
/// Nested message and enum types in `ExecuteSqlPayload`.
pub mod execute_sql_payload {
    /// Controls how the API should respond when the SQL execution result exceeds
    /// 10 MB.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartialResultMode {
        /// Unspecified mode, effectively the same as `FAIL_PARTIAL_RESULT`.
        Unspecified = 0,
        /// Throw an error if the result exceeds 10 MB or if only a partial result
        /// can be retrieved. Don't return the result.
        FailPartialResult = 1,
        /// Return a truncated result and set `partial_result` to true if the result
        /// exceeds 10 MB or if only a partial result can be retrieved due to error.
        /// Don't throw an error.
        AllowPartialResult = 2,
    }
    impl PartialResultMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PARTIAL_RESULT_MODE_UNSPECIFIED",
                Self::FailPartialResult => "FAIL_PARTIAL_RESULT",
                Self::AllowPartialResult => "ALLOW_PARTIAL_RESULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARTIAL_RESULT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "FAIL_PARTIAL_RESULT" => Some(Self::FailPartialResult),
                "ALLOW_PARTIAL_RESULT" => Some(Self::AllowPartialResult),
                _ => None,
            }
        }
    }
    /// Credentials for the database connection.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum UserPassword {
        /// Optional. When set to true, the API caller identity associated with the
        /// request is used for database authentication. The API caller must be an
        /// IAM user in the database.
        #[prost(bool, tag = "11")]
        AutoIamAuthn(bool),
    }
}
/// Execute SQL statements response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesExecuteSqlResponse {
    /// A list of notices and warnings generated during query execution.
    /// For PostgreSQL, this includes all notices and warnings.
    /// For MySQL, this includes warnings generated by the last executed statement.
    /// To retrieve all warnings for a multi-statement query, `SHOW WARNINGS` must
    /// be executed after each statement.
    #[prost(message, repeated, tag = "9")]
    pub messages: ::prost::alloc::vec::Vec<sql_instances_execute_sql_response::Message>,
    /// The additional metadata information regarding the execution of the SQL
    /// statements.
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<Metadata>,
    /// The list of results after executing all the SQL statements.
    #[prost(message, repeated, tag = "7")]
    pub results: ::prost::alloc::vec::Vec<QueryResult>,
    /// Contains the error from the database if the SQL execution failed.
    #[prost(message, optional, tag = "8")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
}
/// Nested message and enum types in `SqlInstancesExecuteSqlResponse`.
pub mod sql_instances_execute_sql_response {
    /// Represents a notice or warning message from the database.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Message {
        /// The full message string.
        /// For PostgreSQL, this is a formatted string that may include severity,
        /// code, and the notice/warning message.
        /// For MySQL, this contains the warning message.
        #[prost(string, optional, tag = "1")]
        pub message: ::core::option::Option<::prost::alloc::string::String>,
        /// The severity of the message (e.g., "NOTICE" for PostgreSQL, "WARNING" for
        /// MySQL).
        #[prost(string, optional, tag = "2")]
        pub severity: ::core::option::Option<::prost::alloc::string::String>,
    }
}
/// QueryResult contains the result of executing a single SQL statement.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryResult {
    /// List of columns included in the result. This also includes the data type
    /// of the column.
    #[prost(message, repeated, tag = "1")]
    pub columns: ::prost::alloc::vec::Vec<Column>,
    /// Rows returned by the SQL statement.
    #[prost(message, repeated, tag = "2")]
    pub rows: ::prost::alloc::vec::Vec<Row>,
    /// Message related to the SQL execution result.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// Set to true if the SQL execution's result is truncated due to size limits
    /// or an error retrieving results.
    #[prost(bool, tag = "4")]
    pub partial_result: bool,
    /// If results were truncated due to an error, details of that error.
    #[prost(message, optional, tag = "8")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
}
/// Contains the name and datatype of a column.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Column {
    /// Name of the column.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Datatype of the column.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
}
/// Contains the values for a row.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Row {
    /// The values for the row.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
/// The cell value of the table.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Value {
    /// The cell value represented in string format.
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
    /// If cell value is null, then this flag will be set to true.
    #[prost(bool, tag = "2")]
    pub null_value: bool,
}
/// The additional metadata information regarding the execution of the SQL
/// statements.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Metadata {
    /// The time taken to execute the SQL statements.
    #[prost(message, optional, tag = "1")]
    pub sql_statement_execution_time: ::core::option::Option<::prost_types::Duration>,
}
/// Request to acquire a lease for SSRS.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesAcquireSsrsLeaseRequest {
    /// Required. Cloud SQL instance ID. This doesn't include the project ID. It's
    /// composed of lowercase letters, numbers, and hyphens, and it must start with
    /// a letter. The total length must be 98 characters or less (Example:
    /// instance-id).
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. ID of the project that contains the instance (Example:
    /// project-id).
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// The body for request to acquire an SSRS lease.
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<InstancesAcquireSsrsLeaseRequest>,
}
/// Request for Pre-checks for MVU
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SqlInstancesPreCheckMajorVersionUpgradeRequest {
    /// Required. Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Required. Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Required. The context for request to perform the pre-check major version
    /// upgrade operation.
    #[prost(message, optional, tag = "3")]
    pub body: ::core::option::Option<InstancesPreCheckMajorVersionUpgradeRequest>,
}
/// Acquire SSRS lease response.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesAcquireSsrsLeaseResponse {
    /// The unique identifier for this operation.
    #[prost(string, optional, tag = "1")]
    pub operation_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request to perform a point in time restore on a Google Cloud Backup and
/// Disaster Recovery managed instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlInstancesPointInTimeRestoreRequest {
    /// Required. The parent resource where you created this instance.
    /// Format: projects/{project}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The context for request to perform a PITR on a Google Cloud
    /// Backup and Disaster Recovery managed instance.
    #[prost(message, optional, tag = "100")]
    pub context: ::core::option::Option<PointInTimeRestoreContext>,
}
/// External Sync parallel level.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ExternalSyncParallelLevel {
    /// Unknown sync parallel level. Will be defaulted to OPTIMAL.
    Unspecified = 0,
    /// Minimal parallel level.
    Min = 1,
    /// Optimal parallel level.
    Optimal = 2,
    /// Maximum parallel level.
    Max = 3,
}
impl ExternalSyncParallelLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED",
            Self::Min => "MIN",
            Self::Optimal => "OPTIMAL",
            Self::Max => "MAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EXTERNAL_SYNC_PARALLEL_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "MIN" => Some(Self::Min),
            "OPTIMAL" => Some(Self::Optimal),
            "MAX" => Some(Self::Max),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod sql_backup_runs_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlBackupRunsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlBackupRunsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlBackupRunsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlBackupRunsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlBackupRunsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the backup taken by a backup run.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupRunsService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupRunsService",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a backup run.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsGetRequest>,
        ) -> std::result::Result<tonic::Response<super::BackupRun>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupRunsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupRunsService",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new backup run on demand.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupRunsService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupRunsService",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all backup runs associated with the project or a given instance and
        /// configuration in the reverse chronological order of the backup initiation
        /// time.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlBackupRunsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackupRunsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupRunsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupRunsService",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_databases_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlDatabasesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlDatabasesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlDatabasesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlDatabasesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlDatabasesServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes a database from a Cloud SQL instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlDatabasesService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlDatabasesService",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a database inside a Cloud
        /// SQL instance.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesGetRequest>,
        ) -> std::result::Result<tonic::Response<super::Database>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlDatabasesService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlDatabasesService",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a resource containing information about a database inside a Cloud
        /// SQL instance.
        ///
        /// **Note:** You can't modify the default character set and collation.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlDatabasesService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlDatabasesService",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists databases in the specified Cloud SQL instance.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DatabasesListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlDatabasesService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlDatabasesService",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Partially updates a resource containing information about a database inside
        /// a Cloud SQL instance. This method supports patch semantics.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlDatabasesService/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlDatabasesService",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a resource containing information about a database inside a Cloud
        /// SQL instance.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlDatabasesUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlDatabasesService/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlDatabasesService",
                        "Update",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_flags_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlFlagsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlFlagsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlFlagsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlFlagsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlFlagsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all available database flags for Cloud SQL instances.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlFlagsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FlagsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlFlagsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlFlagsService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_instances_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlInstancesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlInstancesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlInstancesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlInstancesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlInstancesServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Add a new trusted Certificate Authority (CA) version for the specified
        /// instance. Required to prepare for a certificate rotation. If a CA version
        /// was previously added but never used in a certificate rotation, this
        /// operation replaces that version. There cannot be more than one CA version
        /// waiting to be rotated in. For instances that have enabled Certificate
        /// Authority Service (CAS) based server CA, use AddServerCertificate to add a
        /// new server certificate.
        pub async fn add_server_ca(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesAddServerCaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/AddServerCa",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "AddServerCa",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a new trusted server certificate version for the specified instance
        /// using Certificate Authority Service (CAS) server CA. Required to prepare
        /// for a certificate rotation. If a server certificate version was previously
        /// added but never used in a certificate rotation, this operation replaces
        /// that version. There cannot be more than one certificate version waiting to
        /// be rotated in. For instances not using CAS server CA, use AddServerCa
        /// instead.
        pub async fn add_server_certificate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesAddServerCertificateRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/AddServerCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "AddServerCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds a new Entra ID certificate for the specified instance. If an Entra ID
        /// certificate was previously added but never used in a certificate rotation,
        /// this operation replaces that version.
        pub async fn add_entra_id_certificate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesAddEntraIdCertificateRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/AddEntraIdCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "AddEntraIdCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Cloud SQL instance as a clone of the source instance. Using this
        /// operation might cause your instance to restart.
        pub async fn clone(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesCloneRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Clone",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Clone",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Cloud SQL instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Demotes the stand-alone instance to be a Cloud SQL read replica for an
        /// external database server.
        pub async fn demote_master(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesDemoteMasterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/DemoteMaster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "DemoteMaster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Demotes an existing standalone instance to be a Cloud SQL read replica
        /// for an external database server.
        pub async fn demote(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesDemoteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Demote",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Demote",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL
        /// dump or CSV file.
        pub async fn export(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesExportRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Export",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Export",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a manual failover of a high availability (HA) primary instance
        /// to a standby instance, which becomes the primary instance. Users are
        /// then rerouted to the new primary. For more information, see the
        /// [Overview of high
        /// availability](https://cloud.google.com/sql/docs/mysql/high-availability)
        /// page in the Cloud SQL documentation.
        /// If using Legacy HA (MySQL only), this causes the instance to failover to
        /// its failover replica instance.
        pub async fn failover(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesFailoverRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Failover",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Failover",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reencrypt CMEK instance with latest key version.
        pub async fn reencrypt(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesReencryptRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Reencrypt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Reencrypt",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a Cloud SQL instance.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesGetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DatabaseInstance>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports data into a Cloud SQL instance from a SQL dump  or CSV file in
        /// Cloud Storage.
        pub async fn import(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesImportRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Import",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Import",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Cloud SQL instance.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists instances under a given project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstancesListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the trusted Certificate Authorities (CAs) for the specified
        /// instance. There can be up to three CAs listed: the CA that was used to sign
        /// the certificate that is currently in use, a CA that has been added but not
        /// yet used to sign a certificate, and a CA used to sign a certificate that
        /// has previously rotated out.
        pub async fn list_server_cas(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesListServerCasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstancesListServerCasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ListServerCas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ListServerCas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all versions of server certificates and certificate authorities (CAs)
        /// for the specified instance. There can be up to three sets of certs listed:
        /// the certificate that is currently in use, a future that has been added but
        /// not yet used to sign a certificate, and a certificate that has been rotated
        /// out. For instances not using Certificate Authority Service (CAS) server CA,
        /// use ListServerCas instead.
        pub async fn list_server_certificates(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesListServerCertificatesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstancesListServerCertificatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ListServerCertificates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ListServerCertificates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all versions of EntraID certificates for the specified instance.
        /// There can be up to three sets of certificates listed: the certificate that
        /// is currently in use, a future that has been added but not yet used to sign
        /// a certificate, and a certificate that has been rotated out.
        pub async fn list_entra_id_certificates(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesListEntraIdCertificatesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstancesListEntraIdCertificatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ListEntraIdCertificates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ListEntraIdCertificates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Partially updates settings of a Cloud SQL instance by merging the request
        /// with the current configuration. This method supports patch semantics.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesPatchRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Promotes the read replica instance to be an independent Cloud SQL
        /// primary instance.
        /// Using this operation might cause your instance to restart.
        pub async fn promote_replica(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesPromoteReplicaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/PromoteReplica",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "PromoteReplica",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Switches over from the primary instance to the DR replica
        /// instance.
        pub async fn switchover(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesSwitchoverRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Switchover",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Switchover",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes all client certificates and generates a new server SSL certificate
        /// for the instance.
        pub async fn reset_ssl_config(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesResetSslConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ResetSslConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ResetSslConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restarts a Cloud SQL instance.
        pub async fn restart(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesRestartRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Restart",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Restart",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restores a backup of a Cloud SQL instance. Using this operation might cause
        /// your instance to restart.
        pub async fn restore_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesRestoreBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/RestoreBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "RestoreBackup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rotates the server certificate to one signed by the Certificate Authority
        /// (CA) version previously added with the addServerCA method. For instances
        /// that have enabled Certificate Authority Service (CAS) based server CA,
        /// use RotateServerCertificate to rotate the server certificate.
        pub async fn rotate_server_ca(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesRotateServerCaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/RotateServerCa",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "RotateServerCa",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rotates the server certificate version to one previously added with the
        /// addServerCertificate method. For instances not using Certificate Authority
        /// Service (CAS) server CA, use RotateServerCa instead.
        pub async fn rotate_server_certificate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesRotateServerCertificateRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/RotateServerCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "RotateServerCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rotates the Entra Id certificate version to one previously added with the
        /// addEntraIdCertificate method.
        pub async fn rotate_entra_id_certificate(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesRotateEntraIdCertificateRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/RotateEntraIdCertificate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "RotateEntraIdCertificate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts the replication in the read replica instance.
        pub async fn start_replica(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesStartReplicaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/StartReplica",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "StartReplica",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops the replication in the read replica instance.
        pub async fn stop_replica(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesStopReplicaRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/StopReplica",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "StopReplica",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Truncate MySQL general and slow query log tables
        /// MySQL only.
        pub async fn truncate_log(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesTruncateLogRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/TruncateLog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "TruncateLog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates settings of a Cloud SQL instance. Using this operation might cause
        /// your instance to restart.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "Update",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a short-lived X509 certificate containing the provided public key
        /// and signed by a private key specific to the target instance. Users may use
        /// the certificate to authenticate as themselves when connecting to the
        /// database.
        pub async fn create_ephemeral(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesCreateEphemeralCertRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::SslCert>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/CreateEphemeral",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "CreateEphemeral",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reschedules the maintenance on the given instance.
        pub async fn reschedule_maintenance(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesRescheduleMaintenanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/RescheduleMaintenance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "RescheduleMaintenance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Verify External primary instance external sync settings.
        pub async fn verify_external_sync_settings(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesVerifyExternalSyncSettingsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesVerifyExternalSyncSettingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/VerifyExternalSyncSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "VerifyExternalSyncSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Start External primary instance migration.
        pub async fn start_external_sync(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesStartExternalSyncRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/StartExternalSync",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "StartExternalSync",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Perform Disk Shrink on primary instance.
        pub async fn perform_disk_shrink(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesPerformDiskShrinkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/PerformDiskShrink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "PerformDiskShrink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get Disk Shrink Config for a given instance.
        pub async fn get_disk_shrink_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesGetDiskShrinkConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesGetDiskShrinkConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/GetDiskShrinkConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "GetDiskShrinkConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Reset Replica Size to primary instance disk size.
        pub async fn reset_replica_size(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesResetReplicaSizeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ResetReplicaSize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ResetReplicaSize",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get Latest Recovery Time for a given instance.
        pub async fn get_latest_recovery_time(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesGetLatestRecoveryTimeRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesGetLatestRecoveryTimeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/GetLatestRecoveryTime",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "GetLatestRecoveryTime",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Execute SQL statements.
        pub async fn execute_sql(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesExecuteSqlRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesExecuteSqlResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ExecuteSql",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ExecuteSql",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Acquire a lease for the setup of SQL Server Reporting Services (SSRS).
        pub async fn acquire_ssrs_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesAcquireSsrsLeaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesAcquireSsrsLeaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/AcquireSsrsLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "AcquireSsrsLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Release a lease for the setup of SQL Server Reporting Services (SSRS).
        pub async fn release_ssrs_lease(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlInstancesReleaseSsrsLeaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SqlInstancesReleaseSsrsLeaseResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/ReleaseSsrsLease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "ReleaseSsrsLease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Execute MVU Pre-checks
        pub async fn pre_check_major_version_upgrade(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesPreCheckMajorVersionUpgradeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/PreCheckMajorVersionUpgrade",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "PreCheckMajorVersionUpgrade",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Point in time restore for an instance managed by Google Cloud Backup and
        /// Disaster Recovery.
        pub async fn point_in_time_restore(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SqlInstancesPointInTimeRestoreRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlInstancesService/PointInTimeRestore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlInstancesService",
                        "PointInTimeRestore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_operations_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlOperationsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlOperationsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlOperationsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlOperationsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlOperationsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an instance operation that has been performed on an instance.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlOperationsGetRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlOperationsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlOperationsService",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all instance operations that have been performed on the given Cloud
        /// SQL instance in the reverse chronological order of the start time.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlOperationsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OperationsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlOperationsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlOperationsService",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels an instance operation that has been performed on an instance.
        /// Ordinarily, this method name should be `CancelSqlOperation`.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlOperationsCancelRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlOperationsService/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlOperationsService",
                        "Cancel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_ssl_certs_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlSslCertsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlSslCertsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlSslCertsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlSslCertsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlSslCertsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the SSL certificate. For First Generation instances, the
        /// certificate remains valid until the instance is restarted.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlSslCertsService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlSslCertsService",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a particular SSL certificate.  Does not include the private key
        /// (required for usage).  The private key must be saved from the response to
        /// initial creation.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsGetRequest>,
        ) -> std::result::Result<tonic::Response<super::SslCert>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlSslCertsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlSslCertsService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an SSL certificate and returns it along with the private key and
        /// server certificate authority.  The new certificate will not be usable until
        /// the instance is restarted.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsInsertRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertsInsertResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlSslCertsService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlSslCertsService",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the current SSL certificates for the instance.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlSslCertsListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlSslCertsService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlSslCertsService",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_backups_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlBackupsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlBackupsServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlBackupsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlBackupsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlBackupsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a backup for a Cloud SQL instance. This API can be used only to
        /// create on-demand backups.
        pub async fn create_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupsService/CreateBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupsService",
                        "CreateBackup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a backup.
        pub async fn get_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Backup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupsService/GetBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupsService",
                        "GetBackup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all backups associated with the project.
        pub async fn list_backups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBackupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupsService/ListBackups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupsService",
                        "ListBackups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the retention period and the description of the backup. You can use
        /// this API to update final backups only.
        pub async fn update_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupsService/UpdateBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupsService",
                        "UpdateBackup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the backup.
        pub async fn delete_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlBackupsService/DeleteBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlBackupsService",
                        "DeleteBackup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Connect settings retrieval request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConnectSettingsRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[prost(message, optional, tag = "7")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Connect settings retrieval response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectSettings {
    /// This is always `sql#connectSettings`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// SSL configuration.
    #[prost(message, optional, tag = "2")]
    pub server_ca_cert: ::core::option::Option<SslCert>,
    /// The assigned IP addresses for the instance.
    #[prost(message, repeated, tag = "3")]
    pub ip_addresses: ::prost::alloc::vec::Vec<IpMapping>,
    /// The cloud region for the instance. e.g. `us-central1`, `europe-west1`.
    /// The region cannot be changed after instance creation.
    #[prost(string, tag = "4")]
    pub region: ::prost::alloc::string::String,
    /// The database engine type and version. The `databaseVersion`
    /// field cannot be changed after instance creation.
    /// MySQL instances: `MYSQL_8_0`, `MYSQL_5_7` (default),
    /// or `MYSQL_5_6`.
    /// PostgreSQL instances: `POSTGRES_9_6`, `POSTGRES_10`,
    /// `POSTGRES_11` or `POSTGRES_12` (default), `POSTGRES_13`, or `POSTGRES_14`.
    /// SQL Server instances: `SQLSERVER_2017_STANDARD` (default),
    /// `SQLSERVER_2017_ENTERPRISE`, `SQLSERVER_2017_EXPRESS`,
    /// `SQLSERVER_2017_WEB`, `SQLSERVER_2019_STANDARD`,
    /// `SQLSERVER_2019_ENTERPRISE`, `SQLSERVER_2019_EXPRESS`, or
    /// `SQLSERVER_2019_WEB`.
    #[prost(enumeration = "SqlDatabaseVersion", tag = "31")]
    pub database_version: i32,
    /// `SECOND_GEN`: Cloud SQL database instance.
    /// `EXTERNAL`: A database server that is not managed by Google.
    /// This property is read-only; use the `tier` property in the `settings`
    /// object to determine the database type.
    #[prost(enumeration = "SqlBackendType", tag = "32")]
    pub backend_type: i32,
    /// Whether PSC connectivity is enabled for this instance.
    #[prost(bool, tag = "33")]
    pub psc_enabled: bool,
    /// The dns name of the instance.
    #[prost(string, tag = "34")]
    pub dns_name: ::prost::alloc::string::String,
    /// Specify what type of CA is used for the server certificate.
    #[prost(enumeration = "connect_settings::CaMode", tag = "35")]
    pub server_ca_mode: i32,
    /// Custom subject alternative names for the server certificate.
    #[prost(string, repeated, tag = "37")]
    pub custom_subject_alternative_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The list of DNS names used by this instance.
    #[prost(message, repeated, tag = "38")]
    pub dns_names: ::prost::alloc::vec::Vec<DnsNameMapping>,
    /// The number of read pool nodes in a read pool.
    #[prost(int32, optional, tag = "63")]
    pub node_count: ::core::option::Option<i32>,
    /// Output only. Entries containing information about each read pool node of
    /// the read pool.
    #[prost(message, repeated, tag = "64")]
    pub nodes: ::prost::alloc::vec::Vec<connect_settings::ConnectPoolNodeConfig>,
    /// Optional. Output only. mdx_protocol_support controls how the client uses
    /// metadata exchange when connecting to the instance. The values in the list
    /// representing parts of the MDX protocol that are supported by this instance.
    /// When the list is empty, the instance does not support MDX, so the client
    /// must not send an MDX request. The default is empty.
    #[prost(
        enumeration = "connect_settings::MdxProtocolSupport",
        repeated,
        packed = "false",
        tag = "39"
    )]
    pub mdx_protocol_support: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `ConnectSettings`.
pub mod connect_settings {
    /// Details of a single read pool node of a read pool.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConnectPoolNodeConfig {
        /// Output only. The name of the read pool node. Doesn't include the project
        /// ID.
        #[prost(string, optional, tag = "1")]
        pub name: ::core::option::Option<::prost::alloc::string::String>,
        /// Output only. Mappings containing IP addresses that can be used to connect
        /// to the read pool node.
        #[prost(message, repeated, tag = "2")]
        pub ip_addresses: ::prost::alloc::vec::Vec<super::IpMapping>,
        /// Output only. The DNS name of the read pool node.
        #[prost(string, optional, tag = "3")]
        pub dns_name: ::core::option::Option<::prost::alloc::string::String>,
        /// Output only. The list of DNS names used by this read pool node.
        #[prost(message, repeated, tag = "4")]
        pub dns_names: ::prost::alloc::vec::Vec<super::DnsNameMapping>,
    }
    /// Various Certificate Authority (CA) modes for certificate signing.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CaMode {
        /// CA mode is unspecified. It is effectively the same as
        /// `GOOGLE_MANAGED_INTERNAL_CA`.
        Unspecified = 0,
        /// Google-managed self-signed internal CA.
        GoogleManagedInternalCa = 1,
        /// Google-managed regional CA part of root CA hierarchy hosted on Google
        /// Cloud's Certificate Authority Service (CAS).
        GoogleManagedCasCa = 2,
        /// Customer-managed CA hosted on Google Cloud's Certificate Authority
        /// Service (CAS).
        CustomerManagedCasCa = 3,
    }
    impl CaMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CA_MODE_UNSPECIFIED",
                Self::GoogleManagedInternalCa => "GOOGLE_MANAGED_INTERNAL_CA",
                Self::GoogleManagedCasCa => "GOOGLE_MANAGED_CAS_CA",
                Self::CustomerManagedCasCa => "CUSTOMER_MANAGED_CAS_CA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CA_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_MANAGED_INTERNAL_CA" => Some(Self::GoogleManagedInternalCa),
                "GOOGLE_MANAGED_CAS_CA" => Some(Self::GoogleManagedCasCa),
                "CUSTOMER_MANAGED_CAS_CA" => Some(Self::CustomerManagedCasCa),
                _ => None,
            }
        }
    }
    /// MdxProtocolSupport describes parts of the MDX protocol supported by this
    /// instance.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MdxProtocolSupport {
        /// Not specified.
        Unspecified = 0,
        /// Client should send the client protocol type in the MDX request.
        ClientProtocolType = 1,
    }
    impl MdxProtocolSupport {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MDX_PROTOCOL_SUPPORT_UNSPECIFIED",
                Self::ClientProtocolType => "CLIENT_PROTOCOL_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MDX_PROTOCOL_SUPPORT_UNSPECIFIED" => Some(Self::Unspecified),
                "CLIENT_PROTOCOL_TYPE" => Some(Self::ClientProtocolType),
                _ => None,
            }
        }
    }
}
/// Ephemeral certificate creation request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateEphemeralCertRequest {
    /// Cloud SQL instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    /// PEM encoded public key to include in the signed certificate.
    #[prost(string, tag = "3")]
    pub public_key: ::prost::alloc::string::String,
    /// Optional. Access token to include in the signed certificate.
    #[prost(string, tag = "4")]
    pub access_token: ::prost::alloc::string::String,
    /// Optional. Optional snapshot read timestamp to trade freshness for
    /// performance.
    #[prost(message, optional, tag = "7")]
    pub read_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. If set, it will contain the cert valid duration.
    #[prost(message, optional, tag = "12")]
    pub valid_duration: ::core::option::Option<::prost_types::Duration>,
}
/// Ephemeral certificate creation request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateEphemeralCertResponse {
    /// Generated cert
    #[prost(message, optional, tag = "1")]
    pub ephemeral_cert: ::core::option::Option<SslCert>,
}
/// Generated client implementations.
pub mod sql_connect_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Cloud SQL connect service.
    #[derive(Debug, Clone)]
    pub struct SqlConnectServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlConnectServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlConnectServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlConnectServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlConnectServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves connect settings about a Cloud SQL instance.
        pub async fn get_connect_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlConnectService/GetConnectSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlConnectService",
                        "GetConnectSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a short-lived X509 certificate containing the provided public key
        /// and signed by a private key specific to the target instance. Users may use
        /// the certificate to authenticate as themselves when connecting to the
        /// database.
        pub async fn generate_ephemeral_cert(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateEphemeralCertRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateEphemeralCertResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlConnectService/GenerateEphemeralCert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.sql.v1beta4.SqlConnectService",
                        "GenerateEphemeralCert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod sql_iam_policies_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for providing IAM Meta APIs for Cloud SQL.
    #[derive(Debug, Clone)]
    pub struct SqlIamPoliciesServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlIamPoliciesServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlIamPoliciesServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlIamPoliciesServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlIamPoliciesServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlTiersListRequest {
    /// Project ID of the project for which to list tiers.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
}
/// Tiers list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TiersListResponse {
    /// This is always `sql#tiersList`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of tiers.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<Tier>,
}
/// A Google Cloud SQL service tier resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tier {
    /// An identifier for the machine type, for example, `db-custom-1-3840`. For
    /// related information, see [Pricing](/sql/pricing).
    #[prost(string, tag = "1")]
    pub tier: ::prost::alloc::string::String,
    /// The maximum RAM usage of this tier in bytes.
    #[prost(int64, tag = "2")]
    pub ram: i64,
    /// This is always `sql#tier`.
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    /// The maximum disk size of this tier in bytes.
    #[prost(int64, tag = "4")]
    pub disk_quota: i64,
    /// The applicable regions for this tier.
    #[prost(string, repeated, tag = "5")]
    pub region: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod sql_tiers_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for providing machine types (tiers) for Cloud SQL.
    #[derive(Debug, Clone)]
    pub struct SqlTiersServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlTiersServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlTiersServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlTiersServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlTiersServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all available machine types (tiers) for Cloud SQL, for example,
        /// `db-custom-1-3840`. For related information, see [Pricing](/sql/pricing).
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlTiersListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TiersListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlTiersService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlTiersService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlUsersDeleteRequest {
    /// Host of the user in the instance.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Name of the user in the instance.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
}
/// Request message for Users Get RPC
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlUsersGetRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// User of the instance.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "3")]
    pub project: ::prost::alloc::string::String,
    /// Host of a user of the instance.
    #[prost(string, tag = "4")]
    pub host: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlUsersInsertRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<User>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlUsersListRequest {
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlUsersUpdateRequest {
    /// Optional. Host of the user in the instance.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// Database instance ID. This does not include the project ID.
    #[prost(string, tag = "2")]
    pub instance: ::prost::alloc::string::String,
    /// Name of the user in the instance.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Project ID of the project that contains the instance.
    #[prost(string, tag = "4")]
    pub project: ::prost::alloc::string::String,
    /// Optional. List of database roles to grant to the user. body.database_roles
    /// will be ignored for update request.
    #[prost(string, repeated, tag = "5")]
    pub database_roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. revoke the existing roles granted to the user.
    #[prost(bool, optional, tag = "6")]
    pub revoke_existing_roles: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "100")]
    pub body: ::core::option::Option<User>,
}
/// User level password validation policy.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserPasswordValidationPolicy {
    /// Number of failed login attempts allowed before user get locked.
    #[prost(int32, tag = "1")]
    pub allowed_failed_attempts: i32,
    /// Expiration duration after password is updated.
    #[prost(message, optional, tag = "2")]
    pub password_expiration_duration: ::core::option::Option<::prost_types::Duration>,
    /// If true, failed login attempts check will be enabled.
    #[prost(bool, tag = "3")]
    pub enable_failed_attempts_check: bool,
    /// Output only. Read-only password status.
    #[prost(message, optional, tag = "4")]
    pub status: ::core::option::Option<PasswordStatus>,
    /// If true, the user must specify the current password before changing the
    /// password. This flag is supported only for MySQL.
    #[prost(bool, tag = "5")]
    pub enable_password_verification: bool,
}
/// Read-only password status.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PasswordStatus {
    /// If true, user does not have login privileges.
    #[prost(bool, tag = "1")]
    pub locked: bool,
    /// The expiration time of the current password.
    #[prost(message, optional, tag = "2")]
    pub password_expiration_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A Cloud SQL user resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    /// This is always `sql#user`.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// The password for the user.
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    /// This field is deprecated and will be removed from a future version of the
    /// API.
    #[prost(string, tag = "3")]
    pub etag: ::prost::alloc::string::String,
    /// The name of the user in the Cloud SQL instance. Can be omitted for
    /// `update` because it is already specified in the URL.
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The host from which the user can connect. For `insert`
    /// operations, host defaults to an empty string. For `update`
    /// operations, host is specified as part of the request URL. The host name
    /// cannot be updated after insertion.  For a MySQL instance, it's required;
    /// for a PostgreSQL or SQL Server instance, it's optional.
    #[prost(string, tag = "5")]
    pub host: ::prost::alloc::string::String,
    /// The name of the Cloud SQL instance. This does not include the project ID.
    /// Can be omitted for <b>update</b> because it is already specified on the
    /// URL.
    #[prost(string, tag = "6")]
    pub instance: ::prost::alloc::string::String,
    /// The project ID of the project containing the Cloud SQL database. The Google
    /// apps domain is prefixed if applicable. Can be omitted for
    /// <b>update</b> because it is already specified on the URL.
    #[prost(string, tag = "7")]
    pub project: ::prost::alloc::string::String,
    /// The user type. It determines the method to authenticate the user during
    /// login. The default is the database's built-in user type.
    #[prost(enumeration = "user::SqlUserType", tag = "8")]
    pub r#type: i32,
    /// Optional. The full email for an IAM user. For normal database users, this
    /// will not be filled. Only applicable to MySQL database users.
    #[prost(string, tag = "11")]
    pub iam_email: ::prost::alloc::string::String,
    /// User level password validation policy.
    #[prost(message, optional, tag = "12")]
    pub password_policy: ::core::option::Option<UserPasswordValidationPolicy>,
    /// Dual password status for the user.
    #[prost(enumeration = "user::DualPasswordType", optional, tag = "13")]
    pub dual_password_type: ::core::option::Option<i32>,
    /// Indicates if a group is active or inactive for IAM database authentication.
    #[prost(enumeration = "user::IamStatus", optional, tag = "14")]
    pub iam_status: ::core::option::Option<i32>,
    /// Optional. Role memberships of the user
    #[prost(string, repeated, tag = "15")]
    pub database_roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// User details for specific database type
    #[prost(oneof = "user::UserDetails", tags = "9")]
    pub user_details: ::core::option::Option<user::UserDetails>,
}
/// Nested message and enum types in `User`.
pub mod user {
    /// The user type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SqlUserType {
        /// The database's built-in user type.
        BuiltIn = 0,
        /// Cloud IAM user.
        CloudIamUser = 1,
        /// Cloud IAM service account.
        CloudIamServiceAccount = 2,
        /// Cloud IAM group. Not used for login.
        CloudIamGroup = 3,
        /// Read-only. Login for a user that belongs to the Cloud IAM group.
        CloudIamGroupUser = 4,
        /// Read-only. Login for a service account that belongs to the
        /// Cloud IAM group.
        CloudIamGroupServiceAccount = 5,
        /// Microsoft Entra ID user.
        EntraidUser = 7,
    }
    impl SqlUserType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::BuiltIn => "BUILT_IN",
                Self::CloudIamUser => "CLOUD_IAM_USER",
                Self::CloudIamServiceAccount => "CLOUD_IAM_SERVICE_ACCOUNT",
                Self::CloudIamGroup => "CLOUD_IAM_GROUP",
                Self::CloudIamGroupUser => "CLOUD_IAM_GROUP_USER",
                Self::CloudIamGroupServiceAccount => "CLOUD_IAM_GROUP_SERVICE_ACCOUNT",
                Self::EntraidUser => "ENTRAID_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BUILT_IN" => Some(Self::BuiltIn),
                "CLOUD_IAM_USER" => Some(Self::CloudIamUser),
                "CLOUD_IAM_SERVICE_ACCOUNT" => Some(Self::CloudIamServiceAccount),
                "CLOUD_IAM_GROUP" => Some(Self::CloudIamGroup),
                "CLOUD_IAM_GROUP_USER" => Some(Self::CloudIamGroupUser),
                "CLOUD_IAM_GROUP_SERVICE_ACCOUNT" => {
                    Some(Self::CloudIamGroupServiceAccount)
                }
                "ENTRAID_USER" => Some(Self::EntraidUser),
                _ => None,
            }
        }
    }
    /// The type of retained password.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DualPasswordType {
        /// The default value.
        Unspecified = 0,
        /// Do not update the user's dual password status.
        NoModifyDualPassword = 1,
        /// No dual password usable for connecting using this user.
        NoDualPassword = 2,
        /// Dual password usable for connecting using this user.
        DualPassword = 3,
    }
    impl DualPasswordType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DUAL_PASSWORD_TYPE_UNSPECIFIED",
                Self::NoModifyDualPassword => "NO_MODIFY_DUAL_PASSWORD",
                Self::NoDualPassword => "NO_DUAL_PASSWORD",
                Self::DualPassword => "DUAL_PASSWORD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DUAL_PASSWORD_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_MODIFY_DUAL_PASSWORD" => Some(Self::NoModifyDualPassword),
                "NO_DUAL_PASSWORD" => Some(Self::NoDualPassword),
                "DUAL_PASSWORD" => Some(Self::DualPassword),
                _ => None,
            }
        }
    }
    /// Indicates if a group is available for IAM database authentication.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IamStatus {
        /// The default value for users that are not of type CLOUD_IAM_GROUP.
        /// Only CLOUD_IAM_GROUP users will be inactive or active.
        /// Users with an IamStatus of IAM_STATUS_UNSPECIFIED will not
        /// display whether they are active or inactive as that is not applicable to
        /// them.
        Unspecified = 0,
        /// INACTIVE indicates a group is not available for IAM database
        /// authentication.
        Inactive = 1,
        /// ACTIVE indicates a group is available for IAM database authentication.
        Active = 2,
    }
    impl IamStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "IAM_STATUS_UNSPECIFIED",
                Self::Inactive => "INACTIVE",
                Self::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IAM_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
    /// User details for specific database type
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum UserDetails {
        #[prost(message, tag = "9")]
        SqlserverUserDetails(super::SqlServerUserDetails),
    }
}
/// Represents a Sql Server user on the Cloud SQL instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SqlServerUserDetails {
    /// If the user has been disabled
    #[prost(bool, tag = "1")]
    pub disabled: bool,
    /// The server roles for this user
    #[prost(string, repeated, tag = "2")]
    pub server_roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// User list response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsersListResponse {
    /// This is always <b>sql#usersList</b>.
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    /// List of user resources in the instance.
    #[prost(message, repeated, tag = "2")]
    pub items: ::prost::alloc::vec::Vec<User>,
    /// Unused.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sql_users_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct SqlUsersServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SqlUsersServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SqlUsersServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SqlUsersServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SqlUsersServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes a user from a Cloud SQL instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersDeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlUsersService/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlUsersService", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a resource containing information about a user.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersGetRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlUsersService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlUsersService", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new user in a Cloud SQL instance.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersInsertRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlUsersService/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlUsersService", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists users in the specified Cloud SQL instance.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UsersListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlUsersService/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlUsersService", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing user in a Cloud SQL instance.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::SqlUsersUpdateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.sql.v1beta4.SqlUsersService/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.sql.v1beta4.SqlUsersService", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
