// This file is @generated by prost-build.
/// AuthorizationPolicy is a resource that specifies how a server
/// should authorize incoming connections. This resource in itself does
/// not change the configuration unless it's attached to a target https
/// proxy or endpoint config selector resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationPolicy {
    /// Required. Name of the AuthorizationPolicy resource. It matches pattern
    /// `projects/{project}/locations/{location}/authorizationPolicies/<authorization_policy>`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Set of label tags associated with the AuthorizationPolicy
    /// resource.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. The action to take when a rule match is found. Possible values
    /// are "ALLOW" or "DENY".
    #[prost(enumeration = "authorization_policy::Action", tag = "6")]
    pub action: i32,
    /// Optional. List of rules to match. Note that at least one of the rules must
    /// match in order for the action specified in the 'action' field to be taken.
    /// A rule is a match if there is a matching source and destination. If left
    /// blank, the action specified in the `action` field will be applied on every
    /// request.
    #[prost(message, repeated, tag = "7")]
    pub rules: ::prost::alloc::vec::Vec<authorization_policy::Rule>,
}
/// Nested message and enum types in `AuthorizationPolicy`.
pub mod authorization_policy {
    /// Specification of rules.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Rule {
        /// Optional. List of attributes for the traffic source. All of the sources
        /// must match. A source is a match if both principals and ip_blocks match.
        /// If not set, the action specified in the 'action' field will be applied
        /// without any rule checks for the source.
        #[prost(message, repeated, tag = "1")]
        pub sources: ::prost::alloc::vec::Vec<rule::Source>,
        /// Optional. List of attributes for the traffic destination. All of the
        /// destinations must match. A destination is a match if a request matches
        /// all the specified hosts, ports, methods and headers. If not set, the
        /// action specified in the 'action' field will be applied without any rule
        /// checks for the destination.
        #[prost(message, repeated, tag = "2")]
        pub destinations: ::prost::alloc::vec::Vec<rule::Destination>,
    }
    /// Nested message and enum types in `Rule`.
    pub mod rule {
        /// Specification of traffic source attributes.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Source {
            /// Optional. List of peer identities to match for authorization. At least
            /// one principal should match. Each peer can be an exact match, or a
            /// prefix match (example, "namespace/*") or a suffix match (example,
            /// "*/service-account") or a presence match "\*". Authorization based on
            /// the principal name without certificate validation (configured by
            /// ServerTlsPolicy resource) is considered insecure.
            #[prost(string, repeated, tag = "1")]
            pub principals: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. List of CIDR ranges to match based on source IP address. At
            /// least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR
            /// (e.g., "1.2.3.0/24") are supported. Authorization based on source IP
            /// alone should be avoided. The IP addresses of any load balancers or
            /// proxies should be considered untrusted.
            #[prost(string, repeated, tag = "2")]
            pub ip_blocks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
        /// Specification of traffic destination attributes.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Destination {
            /// Required. List of host names to match. Matched against the ":authority"
            /// header in http requests. At least one host should match. Each host can
            /// be an exact match, or a prefix match (example "mydomain.*") or a suffix
            /// match (example "*.myorg.com") or a presence (any) match "\*".
            #[prost(string, repeated, tag = "1")]
            pub hosts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Required. List of destination ports to match. At least one port should
            /// match.
            #[prost(uint32, repeated, packed = "false", tag = "2")]
            pub ports: ::prost::alloc::vec::Vec<u32>,
            /// Optional. A list of HTTP methods to match. At least one method should
            /// match. Should not be set for gRPC services.
            #[prost(string, repeated, tag = "4")]
            pub methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Optional. Match against key:value pair in http header. Provides a
            /// flexible match based on HTTP headers, for potentially advanced use
            /// cases. At least one header should match. Avoid using header matches to
            /// make authorization decisions unless there is a strong guarantee that
            /// requests arrive through a trusted client or proxy.
            #[prost(message, optional, tag = "5")]
            pub http_header_match: ::core::option::Option<destination::HttpHeaderMatch>,
        }
        /// Nested message and enum types in `Destination`.
        pub mod destination {
            /// Specification of HTTP header match attributes.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct HttpHeaderMatch {
                /// Required. The name of the HTTP header to match. For matching
                /// against the HTTP request's authority, use a headerMatch
                /// with the header name ":authority". For matching a
                /// request's method, use the headerName ":method".
                #[prost(string, tag = "1")]
                pub header_name: ::prost::alloc::string::String,
                #[prost(oneof = "http_header_match::Type", tags = "2")]
                pub r#type: ::core::option::Option<http_header_match::Type>,
            }
            /// Nested message and enum types in `HttpHeaderMatch`.
            pub mod http_header_match {
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
                pub enum Type {
                    /// Required. The value of the header must match the regular expression
                    /// specified in regexMatch. For regular expression grammar,
                    /// please see: en.cppreference.com/w/cpp/regex/ecmascript
                    /// For matching against a port specified in the HTTP
                    /// request, use a headerMatch with headerName set to Host
                    /// and a regular expression that satisfies the RFC2616 Host
                    /// header's port specifier.
                    #[prost(string, tag = "2")]
                    RegexMatch(::prost::alloc::string::String),
                }
            }
        }
    }
    /// Possible values that define what action to take.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// Default value.
        Unspecified = 0,
        /// Grant access.
        Allow = 1,
        /// Deny access.
        /// Deny rules should be avoided unless they are used to provide a default
        /// "deny all" fallback.
        Deny = 2,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_UNSPECIFIED",
                Self::Allow => "ALLOW",
                Self::Deny => "DENY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                _ => None,
            }
        }
    }
}
/// Request used with the ListAuthorizationPolicies method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAuthorizationPoliciesRequest {
    /// Required. The project and location from which the AuthorizationPolicies
    /// should be listed, specified in the format
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of AuthorizationPolicies to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last
    /// `ListAuthorizationPoliciesResponse` Indicates that this is a
    /// continuation of a prior `ListAuthorizationPolicies` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListAuthorizationPolicies method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuthorizationPoliciesResponse {
    /// List of AuthorizationPolicies resources.
    #[prost(message, repeated, tag = "1")]
    pub authorization_policies: ::prost::alloc::vec::Vec<AuthorizationPolicy>,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request used by the GetAuthorizationPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAuthorizationPolicyRequest {
    /// Required. A name of the AuthorizationPolicy to get. Must be in the format
    /// `projects/{project}/locations/{location}/authorizationPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateAuthorizationPolicy method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAuthorizationPolicyRequest {
    /// Required. The parent resource of the AuthorizationPolicy. Must be in the
    /// format `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the AuthorizationPolicy resource to be created.
    /// This value should be 1-63 characters long, containing only
    /// letters, numbers, hyphens, and underscores, and should not start
    /// with a number. E.g. "authz_policy".
    #[prost(string, tag = "2")]
    pub authorization_policy_id: ::prost::alloc::string::String,
    /// Required. AuthorizationPolicy resource to be created.
    #[prost(message, optional, tag = "3")]
    pub authorization_policy: ::core::option::Option<AuthorizationPolicy>,
}
/// Request used by the UpdateAuthorizationPolicy method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAuthorizationPolicyRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// AuthorizationPolicy resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated AuthorizationPolicy resource.
    #[prost(message, optional, tag = "2")]
    pub authorization_policy: ::core::option::Option<AuthorizationPolicy>,
}
/// Request used by the DeleteAuthorizationPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAuthorizationPolicyRequest {
    /// Required. A name of the AuthorizationPolicy to delete. Must be in the
    /// format `projects/{project}/locations/{location}/authorizationPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `AuthzPolicy` is a resource that allows to forward traffic to a
/// callout backend designed to scan the traffic for security purposes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthzPolicy {
    /// Required. Identifier. Name of the `AuthzPolicy` resource in the following
    /// format:
    /// `projects/{project}/locations/{location}/authzPolicies/{authz_policy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. A human-readable description of the resource.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Set of labels associated with the `AuthzPolicy` resource.
    ///
    /// The format must comply with [the following
    /// requirements](/compute/docs/labeling-resources#requirements).
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Specifies the set of resources to which this policy should be
    /// applied to.
    #[prost(message, optional, tag = "6")]
    pub target: ::core::option::Option<authz_policy::Target>,
    /// Optional. A list of authorization HTTP rules to match against the incoming
    /// request. A policy match occurs when at least one HTTP rule matches the
    /// request or when no HTTP rules are specified in the policy.
    /// At least one HTTP Rule is required for Allow or Deny Action. Limited
    /// to 5 rules.
    #[prost(message, repeated, tag = "7")]
    pub http_rules: ::prost::alloc::vec::Vec<authz_policy::AuthzRule>,
    /// Required. Can be one of `ALLOW`, `DENY`, `CUSTOM`.
    ///
    /// When the action is `CUSTOM`, `customProvider` must be specified.
    ///
    /// When the action is `ALLOW`, only requests matching the policy will
    /// be allowed.
    ///
    /// When the action is `DENY`, only requests matching the policy will be
    /// denied.
    ///
    /// When a request arrives, the policies are evaluated in the following order:
    ///
    /// 1. If there is a `CUSTOM` policy that matches the request, the `CUSTOM`
    ///    policy is evaluated using the custom authorization providers and the
    ///    request is denied if the provider rejects the request.
    ///
    /// 1. If there are any `DENY` policies that match the request, the request
    ///    is denied.
    ///
    /// 1. If there are no `ALLOW` policies for the resource or if any of the
    ///    `ALLOW` policies match the request, the request is allowed.
    ///
    /// 1. Else the request is denied by default if none of the configured
    ///    AuthzPolicies with `ALLOW` action match the request.
    #[prost(enumeration = "authz_policy::AuthzAction", tag = "8")]
    pub action: i32,
    /// Optional. Required if the action is `CUSTOM`. Allows delegating
    /// authorization decisions to Cloud IAP or to Service Extensions. One of
    /// `cloudIap` or `authzExtension` must be specified.
    #[prost(message, optional, tag = "10")]
    pub custom_provider: ::core::option::Option<authz_policy::CustomProvider>,
}
/// Nested message and enum types in `AuthzPolicy`.
pub mod authz_policy {
    /// Specifies the set of targets to which this policy should be applied to.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Target {
        /// Required. All gateways and forwarding rules referenced by this policy and
        /// extensions must share the same load balancing scheme. Supported values:
        /// `INTERNAL_MANAGED` and `EXTERNAL_MANAGED`. For more information, refer
        /// to [Backend services
        /// overview](<https://cloud.google.com/load-balancing/docs/backend-service>).
        #[prost(enumeration = "LoadBalancingScheme", tag = "8")]
        pub load_balancing_scheme: i32,
        /// Required. A list of references to the Forwarding Rules on which this
        /// policy will be applied.
        #[prost(string, repeated, tag = "1")]
        pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Conditions to match against the incoming request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AuthzRule {
        /// Optional. Describes properties of a source of a request.
        #[prost(message, optional, tag = "1")]
        pub from: ::core::option::Option<authz_rule::From>,
        /// Optional. Describes properties of a target of a request.
        #[prost(message, optional, tag = "2")]
        pub to: ::core::option::Option<authz_rule::To>,
        /// Optional. CEL expression that describes the conditions to be satisfied
        /// for the action. The result of the CEL expression is ANDed with the from
        /// and to. Refer to the CEL language reference for a list of available
        /// attributes.
        #[prost(string, tag = "3")]
        pub when: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `AuthzRule`.
    pub mod authz_rule {
        /// Determines how a string value should be matched.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct StringMatch {
            /// If true, indicates the exact/prefix/suffix/contains matching should be
            /// case insensitive. For example, the matcher `data` will match both
            /// input string `Data` and `data` if set to true.
            #[prost(bool, tag = "5")]
            pub ignore_case: bool,
            #[prost(oneof = "string_match::MatchPattern", tags = "1, 2, 3, 4")]
            pub match_pattern: ::core::option::Option<string_match::MatchPattern>,
        }
        /// Nested message and enum types in `StringMatch`.
        pub mod string_match {
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum MatchPattern {
                /// The input string must match exactly the string specified here.
                ///
                /// Examples:
                ///
                /// * `abc` only matches the value `abc`.
                #[prost(string, tag = "1")]
                Exact(::prost::alloc::string::String),
                /// The input string must have the prefix specified here.
                /// Note: empty prefix is not allowed, please use regex instead.
                ///
                /// Examples:
                ///
                /// * `abc` matches the value `abc.xyz`
                #[prost(string, tag = "2")]
                Prefix(::prost::alloc::string::String),
                /// The input string must have the suffix specified here.
                /// Note: empty prefix is not allowed, please use regex instead.
                ///
                /// Examples:
                ///
                /// * `abc` matches the value `xyz.abc`
                #[prost(string, tag = "3")]
                Suffix(::prost::alloc::string::String),
                /// The input string must have the substring specified here.
                /// Note: empty contains match is not allowed, please use regex instead.
                ///
                /// Examples:
                ///
                /// * `abc` matches the value `xyz.abc.def`
                #[prost(string, tag = "4")]
                Contains(::prost::alloc::string::String),
            }
        }
        /// Represents a range of IP Addresses.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct IpBlock {
            /// Required. The address prefix.
            #[prost(string, tag = "1")]
            pub prefix: ::prost::alloc::string::String,
            /// Required. The length of the address range.
            #[prost(int32, tag = "2")]
            pub length: i32,
        }
        /// Describes the properties of a client VM resource accessing the internal
        /// application load balancers.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RequestResource {
            /// Optional. A list of resource tag value permanent IDs to match against
            /// the resource manager tags value associated with the source VM of a
            /// request.
            #[prost(message, optional, tag = "1")]
            pub tag_value_id_set: ::core::option::Option<
                request_resource::TagValueIdSet,
            >,
            /// Optional. An IAM service account to match against the source
            /// service account of the VM sending the request.
            #[prost(message, optional, tag = "2")]
            pub iam_service_account: ::core::option::Option<StringMatch>,
        }
        /// Nested message and enum types in `RequestResource`.
        pub mod request_resource {
            /// Describes a set of resource tag value permanent IDs to match against
            /// the resource manager tags value associated with the source VM of a
            /// request.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct TagValueIdSet {
                /// Required. A list of resource tag value permanent IDs to match against
                /// the resource manager tags value associated with the source VM of a
                /// request. The match follows AND semantics which means all
                /// the ids must match. Limited to 5 ids in the Tag value id set.
                #[prost(int64, repeated, packed = "false", tag = "1")]
                pub ids: ::prost::alloc::vec::Vec<i64>,
            }
        }
        /// Determines how a HTTP header should be matched.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct HeaderMatch {
            /// Optional. Specifies the name of the header in the request.
            #[prost(string, tag = "1")]
            pub name: ::prost::alloc::string::String,
            /// Optional. Specifies how the header match will be performed.
            #[prost(message, optional, tag = "2")]
            pub value: ::core::option::Option<StringMatch>,
        }
        /// Describes the properties of a principal to be matched against.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Principal {
            /// Optional. An enum to decide what principal value the principal rule
            /// will match against. If not specified, the PrincipalSelector is
            /// CLIENT_CERT_URI_SAN.
            #[prost(enumeration = "principal::PrincipalSelector", tag = "1")]
            pub principal_selector: i32,
            /// Required. A non-empty string whose value is matched against the
            /// principal value based on the principal_selector. Only exact match can
            /// be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN,
            /// CLIENT_CERT_COMMON_NAME selectors.
            #[prost(message, optional, tag = "2")]
            pub principal: ::core::option::Option<StringMatch>,
        }
        /// Nested message and enum types in `Principal`.
        pub mod principal {
            /// The principal value the principal rule will match against.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum PrincipalSelector {
                /// Unspecified principal selector. It will be treated as
                /// CLIENT_CERT_URI_SAN by default.
                Unspecified = 0,
                /// The principal rule is matched against a list of URI SANs in the
                /// validated client's certificate. A match happens when there is any
                /// exact URI SAN value match. This is the default principal selector.
                ClientCertUriSan = 1,
                /// The principal rule is matched against a list of DNS Name SANs in the
                /// validated client's certificate. A match happens when there is any
                /// exact DNS Name SAN value match.
                /// This is only applicable for Application Load Balancers
                /// except for classic Global External Application load balancer.
                /// CLIENT_CERT_DNS_NAME_SAN is not supported for INTERNAL_SELF_MANAGED
                /// load balancing scheme.
                ClientCertDnsNameSan = 2,
                /// The principal rule is matched against the common name in the client's
                /// certificate. Authorization against multiple common names in the
                /// client certificate is not supported. Requests with multiple common
                /// names in the client certificate will be rejected if
                /// CLIENT_CERT_COMMON_NAME is set as the principal selector. A match
                /// happens when there is an exact common name value match.
                /// This is only applicable for Application Load Balancers
                /// except for global external Application Load Balancer and
                /// classic Application Load Balancer.
                /// CLIENT_CERT_COMMON_NAME is not supported for INTERNAL_SELF_MANAGED
                /// load balancing scheme.
                ClientCertCommonName = 3,
            }
            impl PrincipalSelector {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "PRINCIPAL_SELECTOR_UNSPECIFIED",
                        Self::ClientCertUriSan => "CLIENT_CERT_URI_SAN",
                        Self::ClientCertDnsNameSan => "CLIENT_CERT_DNS_NAME_SAN",
                        Self::ClientCertCommonName => "CLIENT_CERT_COMMON_NAME",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "PRINCIPAL_SELECTOR_UNSPECIFIED" => Some(Self::Unspecified),
                        "CLIENT_CERT_URI_SAN" => Some(Self::ClientCertUriSan),
                        "CLIENT_CERT_DNS_NAME_SAN" => Some(Self::ClientCertDnsNameSan),
                        "CLIENT_CERT_COMMON_NAME" => Some(Self::ClientCertCommonName),
                        _ => None,
                    }
                }
            }
        }
        /// Describes properties of one or more sources of a request.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct From {
            /// Optional. Describes the properties of a request's sources. At least one
            /// of sources or notSources must be specified. Limited to 1 source.
            /// A match occurs when ANY source (in sources or notSources) matches the
            /// request. Within a single source, the match follows AND semantics
            /// across fields and OR semantics within a single field, i.e. a match
            /// occurs when ANY principal matches AND ANY ipBlocks match.
            #[prost(message, repeated, tag = "1")]
            pub sources: ::prost::alloc::vec::Vec<from::RequestSource>,
            /// Optional. Describes the negated properties of request sources. Matches
            /// requests from sources that do not match the criteria specified in this
            /// field. At least one of sources or notSources must be specified.
            #[prost(message, repeated, tag = "2")]
            pub not_sources: ::prost::alloc::vec::Vec<from::RequestSource>,
        }
        /// Nested message and enum types in `From`.
        pub mod from {
            /// Describes the properties of a single source.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RequestSource {
                /// Optional. A list of identities derived from the client's certificate.
                /// This field will not match on a request unless frontend mutual TLS is
                /// enabled for the forwarding rule or Gateway and the client certificate
                /// has been successfully validated by mTLS.
                /// Each identity is a string whose value is matched against a list of
                /// URI SANs, DNS Name SANs, or the common name in the client's
                /// certificate. A match happens when any principal matches with the
                /// rule. Limited to 50 principals per Authorization Policy for regional
                /// internal Application Load Balancers, regional external Application
                /// Load Balancers, cross-region internal Application Load Balancers, and
                /// Cloud Service Mesh. This field is not supported for global external
                /// Application Load Balancers.
                #[prost(message, repeated, tag = "1")]
                pub principals: ::prost::alloc::vec::Vec<super::Principal>,
                /// Optional. A list of IP addresses or IP address ranges to match
                /// against the source IP address of the request. Limited to 10 ip_blocks
                /// per Authorization Policy
                #[prost(message, repeated, tag = "2")]
                pub ip_blocks: ::prost::alloc::vec::Vec<super::IpBlock>,
                /// Optional. A list of resources to match against the resource of the
                /// source VM of a request. Limited to 10 resources per Authorization
                /// Policy.
                #[prost(message, repeated, tag = "3")]
                pub resources: ::prost::alloc::vec::Vec<super::RequestResource>,
            }
        }
        /// Describes properties of one or more targets of a request.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct To {
            /// Optional. Describes properties of one or more targets of a request. At
            /// least one of operations or notOperations must be specified. Limited to
            /// 1 operation. A match occurs when ANY operation (in operations or
            /// notOperations) matches. Within an operation, the match follows AND
            /// semantics across fields and OR semantics within a field, i.e. a match
            /// occurs when ANY path matches AND ANY header matches and ANY method
            /// matches.
            #[prost(message, repeated, tag = "1")]
            pub operations: ::prost::alloc::vec::Vec<to::RequestOperation>,
            /// Optional. Describes the negated properties of the targets of a request.
            /// Matches requests for operations that do not match the criteria
            /// specified in this field. At least one of operations or notOperations
            /// must be specified.
            #[prost(message, repeated, tag = "2")]
            pub not_operations: ::prost::alloc::vec::Vec<to::RequestOperation>,
        }
        /// Nested message and enum types in `To`.
        pub mod to {
            /// Describes properties of one or more targets of a request.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct RequestOperation {
                /// Optional. A list of headers to match against in http header.
                #[prost(message, optional, tag = "1")]
                pub header_set: ::core::option::Option<request_operation::HeaderSet>,
                /// Optional. A list of HTTP Hosts to match against. The match can be one
                /// of exact, prefix, suffix, or contains (substring match). Matches are
                /// always case sensitive unless the ignoreCase is set. Limited to 10
                /// hosts per Authorization Policy.
                #[prost(message, repeated, tag = "2")]
                pub hosts: ::prost::alloc::vec::Vec<super::StringMatch>,
                /// Optional. A list of paths to match against. The match can be one of
                /// exact, prefix, suffix, or contains (substring match). Matches are
                /// always case sensitive unless the ignoreCase is set. Limited to 10
                /// paths per Authorization Policy.
                /// Note that this path match includes the query parameters. For gRPC
                /// services, this should be a fully-qualified name of the form
                /// /package.service/method.
                #[prost(message, repeated, tag = "3")]
                pub paths: ::prost::alloc::vec::Vec<super::StringMatch>,
                /// Optional. A list of HTTP methods to match against. Each entry must be
                /// a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE,
                /// OPTIONS). It only allows exact match and is always case sensitive.
                /// Limited to 10 methods per Authorization Policy.
                #[prost(string, repeated, tag = "4")]
                pub methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            }
            /// Nested message and enum types in `RequestOperation`.
            pub mod request_operation {
                /// Describes a set of HTTP headers to match against.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct HeaderSet {
                    /// Required. A list of headers to match against in http header.
                    /// The match can be one of exact, prefix, suffix, or contains
                    /// (substring match). The match follows AND semantics which means all
                    /// the headers must match. Matches are always case sensitive unless
                    /// the ignoreCase is set. Limited to 10 headers per Authorization
                    /// Policy.
                    #[prost(message, repeated, tag = "1")]
                    pub headers: ::prost::alloc::vec::Vec<super::super::HeaderMatch>,
                }
            }
        }
    }
    /// Allows delegating authorization decisions to Cloud IAP or to
    /// Service Extensions.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CustomProvider {
        /// Optional. Delegates authorization decisions to Cloud IAP. Applicable
        /// only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy
        /// level is not compatible with Cloud IAP settings in the BackendService.
        /// Enabling IAP in both places will result in request failure. Ensure that
        /// IAP is enabled in either the AuthzPolicy or the BackendService but not in
        /// both places.
        #[prost(message, optional, tag = "1")]
        pub cloud_iap: ::core::option::Option<custom_provider::CloudIap>,
        /// Optional. Delegate authorization decision to user authored Service
        /// Extension. Only one of cloudIap or authzExtension can be specified.
        #[prost(message, optional, tag = "2")]
        pub authz_extension: ::core::option::Option<custom_provider::AuthzExtension>,
    }
    /// Nested message and enum types in `CustomProvider`.
    pub mod custom_provider {
        /// Optional. Delegates authorization decisions to Cloud IAP. Applicable
        /// only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy
        /// level is not compatible with Cloud IAP settings in the BackendService.
        /// Enabling IAP in both places will result in request failure. Ensure that
        /// IAP is enabled in either the AuthzPolicy or the BackendService but not in
        /// both places.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CloudIap {}
        /// Optional. Delegate authorization decision to user authored extension.
        /// Only one of cloudIap or authzExtension can be specified.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AuthzExtension {
            /// Required. A list of references to authorization
            /// extensions that will be invoked for requests matching this policy.
            /// Limited to 1 custom provider.
            #[prost(string, repeated, tag = "1")]
            pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        }
    }
    /// Load balancing schemes supported by the `AuthzPolicy` resource. The valid
    /// values are `INTERNAL_MANAGED` and
    /// `EXTERNAL_MANAGED`. For more information, refer to [Backend services
    /// overview](<https://cloud.google.com/load-balancing/docs/backend-service>).
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoadBalancingScheme {
        /// Default value. Do not use.
        Unspecified = 0,
        /// Signifies that this is used for Regional internal or Cross-region
        /// internal Application Load Balancing.
        InternalManaged = 1,
        /// Signifies that this is used for Global external or Regional external
        /// Application Load Balancing.
        ExternalManaged = 2,
        /// Signifies that this is used for Cloud Service Mesh. Meant for use by
        /// CSM GKE controller only.
        InternalSelfManaged = 3,
    }
    impl LoadBalancingScheme {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOAD_BALANCING_SCHEME_UNSPECIFIED",
                Self::InternalManaged => "INTERNAL_MANAGED",
                Self::ExternalManaged => "EXTERNAL_MANAGED",
                Self::InternalSelfManaged => "INTERNAL_SELF_MANAGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOAD_BALANCING_SCHEME_UNSPECIFIED" => Some(Self::Unspecified),
                "INTERNAL_MANAGED" => Some(Self::InternalManaged),
                "EXTERNAL_MANAGED" => Some(Self::ExternalManaged),
                "INTERNAL_SELF_MANAGED" => Some(Self::InternalSelfManaged),
                _ => None,
            }
        }
    }
    /// The action to be applied to this policy. Valid values are
    /// `ALLOW`, `DENY`, `CUSTOM`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthzAction {
        /// Unspecified action.
        Unspecified = 0,
        /// Allow request to pass through to the backend.
        Allow = 1,
        /// Deny the request and return a HTTP 404 to the client.
        Deny = 2,
        /// Delegate the authorization decision to an external authorization engine.
        Custom = 3,
    }
    impl AuthzAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AUTHZ_ACTION_UNSPECIFIED",
                Self::Allow => "ALLOW",
                Self::Deny => "DENY",
                Self::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUTHZ_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// Message for creating an `AuthzPolicy` resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAuthzPolicyRequest {
    /// Required. The parent resource of the `AuthzPolicy` resource. Must be in
    /// the format `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. User-provided ID of the `AuthzPolicy` resource to be created.
    #[prost(string, tag = "2")]
    pub authz_policy_id: ::prost::alloc::string::String,
    /// Required. `AuthzPolicy` resource to be created.
    #[prost(message, optional, tag = "3")]
    pub authz_policy: ::core::option::Option<AuthzPolicy>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server can ignore
    /// the request if it has already been completed. The server guarantees
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for requesting list of `AuthzPolicy` resources.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAuthzPoliciesRequest {
    /// Required. The project and location from which the `AuthzPolicy` resources
    /// are listed, specified in the following format:
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. The server might return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results that the server returns.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing `AuthzPolicy` resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuthzPoliciesResponse {
    /// The list of `AuthzPolicy` resources.
    #[prost(message, repeated, tag = "1")]
    pub authz_policies: ::prost::alloc::vec::Vec<AuthzPolicy>,
    /// A token identifying a page of results that the server returns.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a `AuthzPolicy` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAuthzPolicyRequest {
    /// Required. A name of the `AuthzPolicy` resource to get. Must be in the
    /// format
    /// `projects/{project}/locations/{location}/authzPolicies/{authz_policy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for updating an `AuthzPolicy` resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAuthzPolicyRequest {
    /// Required. Used to specify the fields to be overwritten in the
    /// `AuthzPolicy` resource by the update.
    /// The fields specified in the `update_mask` are relative to the resource, not
    /// the full request. A field is overwritten if it is in the mask. If the
    /// user does not specify a mask, then all fields are overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. `AuthzPolicy` resource being updated.
    #[prost(message, optional, tag = "2")]
    pub authz_policy: ::core::option::Option<AuthzPolicy>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server can ignore
    /// the request if it has already been completed. The server guarantees
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting an `AuthzPolicy` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAuthzPolicyRequest {
    /// Required. The name of the `AuthzPolicy` resource to delete. Must be in
    /// the format
    /// `projects/{project}/locations/{location}/authzPolicies/{authz_policy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server can ignore
    /// the request if it has already been completed. The server guarantees
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// BackendAuthenticationConfig message groups the TrustConfig together with
/// other settings that control how the load balancer authenticates, and
/// expresses its identity to, the backend:
///
/// * `trustConfig` is the attached TrustConfig.
///
/// * `wellKnownRoots` indicates whether the load balance should trust backend
///   server certificates that are issued by public certificate authorities, in
///   addition to certificates trusted by the TrustConfig.
///
/// * `clientCertificate` is a client certificate that the load balancer uses to
///   express its identity to the backend, if the connection to the backend uses
///   mTLS.
///
/// You can attach the BackendAuthenticationConfig to the load balancer's
/// BackendService directly determining how that BackendService negotiates TLS.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendAuthenticationConfig {
    /// Required. Name of the BackendAuthenticationConfig resource. It matches the
    /// pattern
    /// `projects/*/locations/{location}/backendAuthenticationConfigs/{backend_authentication_config}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Set of label tags associated with the resource.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. A reference to a certificatemanager.googleapis.com.Certificate
    /// resource. This is a relative resource path following the form
    /// "projects/{project}/locations/{location}/certificates/{certificate}".
    ///
    /// Used by a BackendService to negotiate mTLS when the backend connection uses
    /// TLS and the backend requests a client certificate. Must have a CLIENT_AUTH
    /// scope.
    #[prost(string, tag = "6")]
    pub client_certificate: ::prost::alloc::string::String,
    /// Optional. A reference to a TrustConfig resource from the
    /// certificatemanager.googleapis.com namespace. This is a relative resource
    /// path following the form
    /// "projects/{project}/locations/{location}/trustConfigs/{trust_config}".
    ///
    /// A BackendService uses the chain of trust represented by this TrustConfig,
    /// if specified, to validate the server certificates presented by the backend.
    /// Required unless wellKnownRoots is set to PUBLIC_ROOTS.
    #[prost(string, tag = "7")]
    pub trust_config: ::prost::alloc::string::String,
    /// Well known roots to use for server certificate validation.
    #[prost(enumeration = "backend_authentication_config::WellKnownRoots", tag = "8")]
    pub well_known_roots: i32,
    /// Output only. Etag of the resource.
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BackendAuthenticationConfig`.
pub mod backend_authentication_config {
    /// Enum to specify the well known roots to use for server certificate
    /// validation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WellKnownRoots {
        /// Equivalent to NONE.
        Unspecified = 0,
        /// The BackendService will only validate server certificates against roots
        /// specified in TrustConfig.
        None = 1,
        /// The BackendService uses a set of well-known public roots, in addition to
        /// any roots specified in the trustConfig field, when validating the server
        /// certificates presented by the backend. Validation with these roots is
        /// only considered when the TlsSettings.sni field in the BackendService is
        /// set.
        ///
        /// The well-known roots are a set of root CAs managed by Google. CAs in this
        /// set can be added or removed without notice.
        PublicRoots = 2,
    }
    impl WellKnownRoots {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WELL_KNOWN_ROOTS_UNSPECIFIED",
                Self::None => "NONE",
                Self::PublicRoots => "PUBLIC_ROOTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WELL_KNOWN_ROOTS_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "PUBLIC_ROOTS" => Some(Self::PublicRoots),
                _ => None,
            }
        }
    }
}
/// Request used by the ListBackendAuthenticationConfigs method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBackendAuthenticationConfigsRequest {
    /// Required. The project and location from which the
    /// BackendAuthenticationConfigs should be listed, specified in the format
    /// `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of BackendAuthenticationConfigs to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListBackendAuthenticationConfigsResponse`
    /// Indicates that this is a continuation of a prior
    /// `ListBackendAuthenticationConfigs` call, and that the system
    /// should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListBackendAuthenticationConfigs method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackendAuthenticationConfigsResponse {
    /// List of BackendAuthenticationConfig resources.
    #[prost(message, repeated, tag = "1")]
    pub backend_authentication_configs: ::prost::alloc::vec::Vec<
        BackendAuthenticationConfig,
    >,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the GetBackendAuthenticationConfig method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBackendAuthenticationConfigRequest {
    /// Required. A name of the BackendAuthenticationConfig to get. Must be in the
    /// format `projects/*/locations/{location}/backendAuthenticationConfigs/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateBackendAuthenticationConfig method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBackendAuthenticationConfigRequest {
    /// Required. The parent resource of the BackendAuthenticationConfig. Must be
    /// in the format `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the BackendAuthenticationConfig resource to be
    /// created. This value should be 1-63 characters long, containing only
    /// letters, numbers, hyphens, and underscores, and should not start with a
    /// number. E.g. "backend-auth-config".
    #[prost(string, tag = "2")]
    pub backend_authentication_config_id: ::prost::alloc::string::String,
    /// Required. BackendAuthenticationConfig resource to be created.
    #[prost(message, optional, tag = "3")]
    pub backend_authentication_config: ::core::option::Option<
        BackendAuthenticationConfig,
    >,
}
/// Request used by UpdateBackendAuthenticationConfig method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackendAuthenticationConfigRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// BackendAuthenticationConfig resource by the update.  The fields
    /// specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the
    /// mask. If the user does not provide a mask then all fields will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated BackendAuthenticationConfig resource.
    #[prost(message, optional, tag = "2")]
    pub backend_authentication_config: ::core::option::Option<
        BackendAuthenticationConfig,
    >,
}
/// Request used by the DeleteBackendAuthenticationConfig method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteBackendAuthenticationConfigRequest {
    /// Required. A name of the BackendAuthenticationConfig to delete. Must be in
    /// the format
    /// `projects/*/locations/{location}/backendAuthenticationConfigs/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Etag of the resource.
    /// If this is provided, it must match the server's etag.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Specification of the GRPC Endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GrpcEndpoint {
    /// Required. The target URI of the gRPC endpoint. Only UDS path is supported,
    /// and should start with "unix:".
    #[prost(string, tag = "1")]
    pub target_uri: ::prost::alloc::string::String,
}
/// Specification of ValidationCA. Defines the mechanism to obtain the
/// Certificate Authority certificate to validate the peer certificate.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ValidationCa {
    /// The type of certificate provider which provides the CA certificate.
    #[prost(oneof = "validation_ca::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<validation_ca::Type>,
}
/// Nested message and enum types in `ValidationCA`.
pub mod validation_ca {
    /// The type of certificate provider which provides the CA certificate.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        /// The path to the file holding the CA certificate to validate the client or
        /// server certificate.
        #[prost(string, tag = "1")]
        CaCertPath(::prost::alloc::string::String),
        /// gRPC specific configuration to access the gRPC server to
        /// obtain the CA certificate.
        #[prost(message, tag = "2")]
        GrpcEndpoint(super::GrpcEndpoint),
        /// The certificate provider instance specification that will be passed to
        /// the data plane, which will be used to load necessary credential
        /// information.
        #[prost(message, tag = "3")]
        CertificateProviderInstance(super::CertificateProviderInstance),
    }
}
/// Specification of a TLS certificate provider instance. Workloads may have one
/// or more CertificateProvider instances (plugins) and one of them is enabled
/// and configured by specifying this message. Workloads use the values from this
/// message to locate and load the CertificateProvider instance configuration.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CertificateProviderInstance {
    /// Required. Plugin instance name, used to locate and load CertificateProvider
    /// instance configuration. Set to "google_cloud_private_spiffe" to use
    /// Certificate Authority Service certificate provider instance.
    #[prost(string, tag = "1")]
    pub plugin_instance: ::prost::alloc::string::String,
}
/// Specification of certificate provider. Defines the mechanism to obtain the
/// certificate and private key for peer to peer authentication.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CertificateProvider {
    /// The type of certificate provider which provides the certificates and
    /// private keys.
    #[prost(oneof = "certificate_provider::Type", tags = "1, 2, 3")]
    pub r#type: ::core::option::Option<certificate_provider::Type>,
}
/// Nested message and enum types in `CertificateProvider`.
pub mod certificate_provider {
    /// Specification of TLS certificate files.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TlsCertificateFiles {
        /// Required. The path to the file that has the certificate containing public
        /// key.
        #[prost(string, tag = "1")]
        pub certificate_path: ::prost::alloc::string::String,
        /// Required. The path to the file that has the private key.
        #[prost(string, tag = "2")]
        pub private_key_path: ::prost::alloc::string::String,
    }
    /// The type of certificate provider which provides the certificates and
    /// private keys.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        /// Obtain certificates and private key from a locally mounted
        /// filesystem path.
        #[prost(message, tag = "1")]
        LocalFilepath(TlsCertificateFiles),
        /// gRPC specific configuration to access the gRPC server to
        /// obtain the cert and private key.
        #[prost(message, tag = "2")]
        GrpcEndpoint(super::GrpcEndpoint),
        /// The certificate provider instance specification that will be passed to
        /// the data plane, which will be used to load necessary credential
        /// information.
        #[prost(message, tag = "3")]
        CertificateProviderInstance(super::CertificateProviderInstance),
    }
}
/// ClientTlsPolicy is a resource that specifies how a client should authenticate
/// connections to backends of a service. This resource itself does not affect
/// configuration unless it is attached to a backend service resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientTlsPolicy {
    /// Required. Name of the ClientTlsPolicy resource. It matches the pattern
    /// `projects/{project}/locations/{location}/clientTlsPolicies/{client_tls_policy}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Set of label tags associated with the resource.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Server Name Indication string to present to the server during TLS
    /// handshake. E.g: "secure.example.com".
    #[prost(string, tag = "6")]
    pub sni: ::prost::alloc::string::String,
    /// Optional. Defines a mechanism to provision client identity (public and
    /// private keys) for peer to peer authentication. The presence of this
    /// dictates mTLS.
    #[prost(message, optional, tag = "7")]
    pub client_certificate: ::core::option::Option<CertificateProvider>,
    /// Optional. Defines the mechanism to obtain the Certificate Authority
    /// certificate to validate the server certificate. If empty, client does not
    /// validate the server certificate.
    #[prost(message, repeated, tag = "8")]
    pub server_validation_ca: ::prost::alloc::vec::Vec<ValidationCa>,
}
/// Request used by the ListClientTlsPolicies method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListClientTlsPoliciesRequest {
    /// Required. The project and location from which the ClientTlsPolicies should
    /// be listed, specified in the format `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of ClientTlsPolicies to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListClientTlsPoliciesResponse`
    /// Indicates that this is a continuation of a prior
    /// `ListClientTlsPolicies` call, and that the system
    /// should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListClientTlsPolicies method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClientTlsPoliciesResponse {
    /// List of ClientTlsPolicy resources.
    #[prost(message, repeated, tag = "1")]
    pub client_tls_policies: ::prost::alloc::vec::Vec<ClientTlsPolicy>,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request used by the GetClientTlsPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClientTlsPolicyRequest {
    /// Required. A name of the ClientTlsPolicy to get. Must be in the format
    /// `projects/*/locations/{location}/clientTlsPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateClientTlsPolicy method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClientTlsPolicyRequest {
    /// Required. The parent resource of the ClientTlsPolicy. Must be in
    /// the format `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the ClientTlsPolicy resource to be created. This
    /// value should be 1-63 characters long, containing only letters, numbers,
    /// hyphens, and underscores, and should not start with a number. E.g.
    /// "client_mtls_policy".
    #[prost(string, tag = "2")]
    pub client_tls_policy_id: ::prost::alloc::string::String,
    /// Required. ClientTlsPolicy resource to be created.
    #[prost(message, optional, tag = "3")]
    pub client_tls_policy: ::core::option::Option<ClientTlsPolicy>,
}
/// Request used by UpdateClientTlsPolicy method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClientTlsPolicyRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// ClientTlsPolicy resource by the update.  The fields
    /// specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the
    /// mask. If the user does not provide a mask then all fields will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated ClientTlsPolicy resource.
    #[prost(message, optional, tag = "2")]
    pub client_tls_policy: ::core::option::Option<ClientTlsPolicy>,
}
/// Request used by the DeleteClientTlsPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteClientTlsPolicyRequest {
    /// Required. A name of the ClientTlsPolicy to delete. Must be in
    /// the format `projects/*/locations/{location}/clientTlsPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have \[Operation.error\]\[\] value with a
    /// \[google.rpc.Status.code\]\[google.rpc.Status.code\] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// A DNS threat detector sends DNS query logs to a *provider* that then
/// analyzes the logs to identify threat events in the DNS queries.
/// By default, all VPC networks in your projects are included. You can exclude
/// specific networks by supplying `excluded_networks`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DnsThreatDetector {
    /// Immutable. Identifier. Name of the DnsThreatDetector resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Create time stamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time stamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Any labels associated with the DnsThreatDetector, listed as key
    /// value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of network resource names which aren't monitored by this
    /// DnsThreatDetector.
    ///
    /// Example:
    /// `projects/PROJECT_ID/global/networks/NETWORK_NAME`.
    #[prost(string, repeated, tag = "5")]
    pub excluded_networks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. The provider used for DNS threat analysis.
    #[prost(enumeration = "dns_threat_detector::Provider", tag = "6")]
    pub provider: i32,
}
/// Nested message and enum types in `DnsThreatDetector`.
pub mod dns_threat_detector {
    /// Name of the provider used for DNS threat analysis.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Provider {
        /// An unspecified provider.
        Unspecified = 0,
        /// The Infoblox DNS threat detector provider.
        Infoblox = 1,
    }
    impl Provider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVIDER_UNSPECIFIED",
                Self::Infoblox => "INFOBLOX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
                "INFOBLOX" => Some(Self::Infoblox),
                _ => None,
            }
        }
    }
}
/// The message for requesting a list of DnsThreatDetectors in the project.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDnsThreatDetectorsRequest {
    /// Required. The parent value for `ListDnsThreatDetectorsRequest`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The requested page size. The server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token received from a previous
    /// `ListDnsThreatDetectorsRequest` call. Provide this to retrieve the
    /// subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message to requesting a list of DnsThreatDetectors.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDnsThreatDetectorsResponse {
    /// The list of DnsThreatDetector resources.
    #[prost(message, repeated, tag = "1")]
    pub dns_threat_detectors: ::prost::alloc::vec::Vec<DnsThreatDetector>,
    /// A token, which can be sent as `page_token`, to retrieve the next page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Unreachable `DnsThreatDetector` resources.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The message sent to get a DnsThreatDetector.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDnsThreatDetectorRequest {
    /// Required. Name of the DnsThreatDetector resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The message to create a DnsThreatDetector.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDnsThreatDetectorRequest {
    /// Required. The value for the parent of the DnsThreatDetector resource.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID of the requesting DnsThreatDetector object.
    /// If this field is not supplied, the service generates an identifier.
    #[prost(string, tag = "2")]
    pub dns_threat_detector_id: ::prost::alloc::string::String,
    /// Required. The `DnsThreatDetector` resource to create.
    #[prost(message, optional, tag = "3")]
    pub dns_threat_detector: ::core::option::Option<DnsThreatDetector>,
}
/// The message for updating a DnsThreatDetector.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDnsThreatDetectorRequest {
    /// Optional. The field mask is used to specify the fields to be overwritten in
    /// the DnsThreatDetector resource by the update. The fields specified in the
    /// update_mask are relative to the resource, not the full request. A field
    /// will be overwritten if it is in the mask. If the mask is not provided then
    /// all fields present in the request will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The DnsThreatDetector resource being updated.
    #[prost(message, optional, tag = "2")]
    pub dns_threat_detector: ::core::option::Option<DnsThreatDetector>,
}
/// The message for deleting a DnsThreatDetector.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDnsThreatDetectorRequest {
    /// Required. Name of the DnsThreatDetector resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod dns_threat_detector_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Network Security API for DNS Threat Detectors.
    #[derive(Debug, Clone)]
    pub struct DnsThreatDetectorServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DnsThreatDetectorServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DnsThreatDetectorServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DnsThreatDetectorServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DnsThreatDetectorServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists DnsThreatDetectors in a given project and location.
        pub async fn list_dns_threat_detectors(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDnsThreatDetectorsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDnsThreatDetectorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService/ListDnsThreatDetectors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService",
                        "ListDnsThreatDetectors",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a single DnsThreatDetector.
        pub async fn get_dns_threat_detector(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDnsThreatDetectorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DnsThreatDetector>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService/GetDnsThreatDetector",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService",
                        "GetDnsThreatDetector",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new DnsThreatDetector in a given project and location.
        pub async fn create_dns_threat_detector(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDnsThreatDetectorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DnsThreatDetector>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService/CreateDnsThreatDetector",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService",
                        "CreateDnsThreatDetector",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single DnsThreatDetector.
        pub async fn update_dns_threat_detector(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDnsThreatDetectorRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DnsThreatDetector>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService/UpdateDnsThreatDetector",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService",
                        "UpdateDnsThreatDetector",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single DnsThreatDetector.
        pub async fn delete_dns_threat_detector(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDnsThreatDetectorRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService/DeleteDnsThreatDetector",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.DnsThreatDetectorService",
                        "DeleteDnsThreatDetector",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Message describing Endpoint object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallEndpoint {
    /// Immutable. Identifier. Name of resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Description of the firewall endpoint. Max length 2048
    /// characters.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Create time stamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Current state of the endpoint.
    #[prost(enumeration = "firewall_endpoint::State", tag = "5")]
    pub state: i32,
    /// Output only. Whether reconciling is in progress, recommended per
    /// <https://google.aip.dev/128.>
    #[prost(bool, tag = "6")]
    pub reconciling: bool,
    /// Output only. List of networks that are associated with this endpoint in the
    /// local zone. This is a projection of the FirewallEndpointAssociations
    /// pointing at this endpoint. A network will only appear in this list after
    /// traffic routing is fully configured. Format:
    /// projects/{project}/global/networks/{name}.
    #[deprecated]
    #[prost(string, repeated, tag = "7")]
    pub associated_networks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. List of FirewallEndpointAssociations that are associated to
    /// this endpoint. An association will only appear in this list after traffic
    /// routing is fully configured.
    #[prost(message, repeated, tag = "13")]
    pub associations: ::prost::alloc::vec::Vec<firewall_endpoint::AssociationReference>,
    /// Output only. \[Output Only\] Reserved for future use.
    #[prost(bool, optional, tag = "14")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    /// Output only. \[Output Only\] Reserved for future use.
    #[prost(bool, optional, tag = "15")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    /// Required. Project to bill on endpoint uptime usage.
    #[prost(string, tag = "8")]
    pub billing_project_id: ::prost::alloc::string::String,
    /// Optional. Settings for the endpoint.
    #[prost(message, optional, tag = "19")]
    pub endpoint_settings: ::core::option::Option<firewall_endpoint::EndpointSettings>,
}
/// Nested message and enum types in `FirewallEndpoint`.
pub mod firewall_endpoint {
    /// This is a subset of the FirewallEndpointAssociation message, containing
    /// fields to be used by the consumer.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AssociationReference {
        /// Output only. The resource name of the FirewallEndpointAssociation.
        /// Format:
        /// projects/{project}/locations/{location}/firewallEndpointAssociations/{id}
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. The VPC network associated. Format:
        /// projects/{project}/global/networks/{name}.
        #[prost(string, tag = "2")]
        pub network: ::prost::alloc::string::String,
    }
    /// Settings for the endpoint.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EndpointSettings {
        /// Optional. Immutable. Indicates whether Jumbo Frames are enabled.
        /// Default value is false.
        #[prost(bool, tag = "1")]
        pub jumbo_frames_enabled: bool,
    }
    /// Endpoint state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Not set.
        Unspecified = 0,
        /// Being created.
        Creating = 1,
        /// Processing configuration updates.
        Active = 2,
        /// Being deleted.
        Deleting = 3,
        /// Down or in an error state.
        Inactive = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Message for requesting list of Endpoints
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFirewallEndpointsRequest {
    /// Required. Parent value for ListEndpointsRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Endpoints
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallEndpointsResponse {
    /// The list of Endpoint
    #[prost(message, repeated, tag = "1")]
    pub firewall_endpoints: ::prost::alloc::vec::Vec<FirewallEndpoint>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Endpoint
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFirewallEndpointRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Endpoint
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFirewallEndpointRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object.
    /// If auto-generating Id server-side, remove this field and
    /// firewall_endpoint_id from the method_signature of Create RPC.
    #[prost(string, tag = "2")]
    pub firewall_endpoint_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub firewall_endpoint: ::core::option::Option<FirewallEndpoint>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a Endpoint
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFirewallEndpointRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Endpoint resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub firewall_endpoint: ::core::option::Option<FirewallEndpoint>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Endpoint
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFirewallEndpointRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message describing Association object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallEndpointAssociation {
    /// Immutable. Identifier. name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Current state of the association.
    #[prost(enumeration = "firewall_endpoint_association::State", tag = "5")]
    pub state: i32,
    /// Required. The URL of the network that is being associated.
    #[prost(string, tag = "6")]
    pub network: ::prost::alloc::string::String,
    /// Required. The URL of the FirewallEndpoint that is being associated.
    #[prost(string, tag = "7")]
    pub firewall_endpoint: ::prost::alloc::string::String,
    /// Optional. The URL of the TlsInspectionPolicy that is being associated.
    #[prost(string, tag = "8")]
    pub tls_inspection_policy: ::prost::alloc::string::String,
    /// Output only. Whether reconciling is in progress, recommended per
    /// <https://google.aip.dev/128.>
    #[prost(bool, tag = "9")]
    pub reconciling: bool,
    /// Optional. Whether the association is disabled.
    /// True indicates that traffic won't be intercepted
    #[prost(bool, tag = "10")]
    pub disabled: bool,
}
/// Nested message and enum types in `FirewallEndpointAssociation`.
pub mod firewall_endpoint_association {
    /// Association state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Not set.
        Unspecified = 0,
        /// Being created.
        Creating = 1,
        /// Active and ready for traffic.
        Active = 2,
        /// Being deleted.
        Deleting = 3,
        /// Down or in an error state.
        Inactive = 4,
        /// The project that housed the association has been deleted.
        Orphan = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Inactive => "INACTIVE",
                Self::Orphan => "ORPHAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "INACTIVE" => Some(Self::Inactive),
                "ORPHAN" => Some(Self::Orphan),
                _ => None,
            }
        }
    }
}
/// Message for requesting list of Associations
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFirewallEndpointAssociationsRequest {
    /// Required. Parent value for ListAssociationsRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Associations
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallEndpointAssociationsResponse {
    /// The list of Association
    #[prost(message, repeated, tag = "1")]
    pub firewall_endpoint_associations: ::prost::alloc::vec::Vec<
        FirewallEndpointAssociation,
    >,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Association
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFirewallEndpointAssociationRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Association
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFirewallEndpointAssociationRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Id of the requesting object.
    /// If auto-generating Id server-side, remove this field and
    /// firewall_endpoint_association_id from the method_signature of Create RPC.
    #[prost(string, tag = "2")]
    pub firewall_endpoint_association_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub firewall_endpoint_association: ::core::option::Option<
        FirewallEndpointAssociation,
    >,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Association
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFirewallEndpointAssociationRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating an Association
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFirewallEndpointAssociationRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Association resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub firewall_endpoint_association: ::core::option::Option<
        FirewallEndpointAssociation,
    >,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod firewall_activation_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing Firewall Endpoints and Associations.
    #[derive(Debug, Clone)]
    pub struct FirewallActivationClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FirewallActivationClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FirewallActivationClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FirewallActivationClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FirewallActivationClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists FirewallEndpoints in a given project and location.
        pub async fn list_firewall_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFirewallEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFirewallEndpointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/ListFirewallEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "ListFirewallEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Endpoint.
        pub async fn get_firewall_endpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallEndpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FirewallEndpoint>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/GetFirewallEndpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "GetFirewallEndpoint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new FirewallEndpoint in a given project and location.
        pub async fn create_firewall_endpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFirewallEndpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/CreateFirewallEndpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "CreateFirewallEndpoint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Endpoint.
        pub async fn delete_firewall_endpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirewallEndpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/DeleteFirewallEndpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "DeleteFirewallEndpoint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single Endpoint.
        pub async fn update_firewall_endpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFirewallEndpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/UpdateFirewallEndpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "UpdateFirewallEndpoint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Associations in a given project and location.
        pub async fn list_firewall_endpoint_associations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListFirewallEndpointAssociationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListFirewallEndpointAssociationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/ListFirewallEndpointAssociations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "ListFirewallEndpointAssociations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single FirewallEndpointAssociation.
        pub async fn get_firewall_endpoint_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetFirewallEndpointAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FirewallEndpointAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/GetFirewallEndpointAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "GetFirewallEndpointAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new FirewallEndpointAssociation in a given project and location.
        pub async fn create_firewall_endpoint_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateFirewallEndpointAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/CreateFirewallEndpointAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "CreateFirewallEndpointAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single FirewallEndpointAssociation.
        pub async fn delete_firewall_endpoint_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteFirewallEndpointAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/DeleteFirewallEndpointAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "DeleteFirewallEndpointAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single FirewallEndpointAssociation.
        pub async fn update_firewall_endpoint_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateFirewallEndpointAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.FirewallActivation/UpdateFirewallEndpointAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.FirewallActivation",
                        "UpdateFirewallEndpointAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The GatewaySecurityPolicy resource contains a collection of
/// GatewaySecurityPolicyRules and associated metadata.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GatewaySecurityPolicy {
    /// Required. Name of the resource. Name is of the form
    /// projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_security_policy}
    /// gateway_security_policy should match the
    /// pattern:(^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Name of a TLS Inspection Policy resource that defines how TLS
    /// inspection will be performed for any rule(s) which enables it.
    #[prost(string, tag = "5")]
    pub tls_inspection_policy: ::prost::alloc::string::String,
}
/// Request used by the CreateGatewaySecurityPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateGatewaySecurityPolicyRequest {
    /// Required. The parent resource of the GatewaySecurityPolicy. Must be in the
    /// format `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the GatewaySecurityPolicy resource to be created.
    /// This value should be 1-63 characters long, containing only
    /// letters, numbers, hyphens, and underscores, and should not start
    /// with a number. E.g. "gateway_security_policy1".
    #[prost(string, tag = "2")]
    pub gateway_security_policy_id: ::prost::alloc::string::String,
    /// Required. GatewaySecurityPolicy resource to be created.
    #[prost(message, optional, tag = "3")]
    pub gateway_security_policy: ::core::option::Option<GatewaySecurityPolicy>,
}
/// Request used with the ListGatewaySecurityPolicies method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListGatewaySecurityPoliciesRequest {
    /// Required. The project and location from which the GatewaySecurityPolicies
    /// should be listed, specified in the format
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of GatewaySecurityPolicies to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last
    /// 'ListGatewaySecurityPoliciesResponse' Indicates that this is a
    /// continuation of a prior 'ListGatewaySecurityPolicies' call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListGatewaySecurityPolicies method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGatewaySecurityPoliciesResponse {
    /// List of GatewaySecurityPolicies resources.
    #[prost(message, repeated, tag = "1")]
    pub gateway_security_policies: ::prost::alloc::vec::Vec<GatewaySecurityPolicy>,
    /// If there might be more results than those appearing in this response, then
    /// 'next_page_token' is included. To get the next set of results, call this
    /// method again using the value of 'next_page_token' as 'page_token'.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the GetGatewaySecurityPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGatewaySecurityPolicyRequest {
    /// Required. A name of the GatewaySecurityPolicy to get. Must be in the format
    /// `projects/{project}/locations/{location}/gatewaySecurityPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the DeleteGatewaySecurityPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteGatewaySecurityPolicyRequest {
    /// Required. A name of the GatewaySecurityPolicy to delete. Must be in the
    /// format `projects/{project}/locations/{location}/gatewaySecurityPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the UpdateGatewaySecurityPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateGatewaySecurityPolicyRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// GatewaySecurityPolicy resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated GatewaySecurityPolicy resource.
    #[prost(message, optional, tag = "2")]
    pub gateway_security_policy: ::core::option::Option<GatewaySecurityPolicy>,
}
/// The GatewaySecurityPolicyRule resource is in a nested collection within a
/// GatewaySecurityPolicy and represents a traffic matching condition and
/// associated action to perform.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GatewaySecurityPolicyRule {
    /// Required. Immutable. Name of the resource. ame is the full resource name so
    /// projects/{project}/locations/{location}/gatewaySecurityPolicies/{gateway_security_policy}/rules/{rule}
    /// rule should match the
    /// pattern: (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the rule was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the rule was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. Whether the rule is enforced.
    #[prost(bool, tag = "4")]
    pub enabled: bool,
    /// Required. Priority of the rule.
    /// Lower number corresponds to higher precedence.
    #[prost(int32, tag = "5")]
    pub priority: i32,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Required. CEL expression for matching on session criteria.
    #[prost(string, tag = "7")]
    pub session_matcher: ::prost::alloc::string::String,
    /// Optional. CEL expression for matching on L7/application level criteria.
    #[prost(string, tag = "8")]
    pub application_matcher: ::prost::alloc::string::String,
    /// Optional. Flag to enable TLS inspection of traffic matching on
    /// \<session_matcher>, can only be true if the parent GatewaySecurityPolicy
    /// references a TLSInspectionConfig.
    #[prost(bool, tag = "10")]
    pub tls_inspection_enabled: bool,
    #[prost(oneof = "gateway_security_policy_rule::Profile", tags = "9")]
    pub profile: ::core::option::Option<gateway_security_policy_rule::Profile>,
}
/// Nested message and enum types in `GatewaySecurityPolicyRule`.
pub mod gateway_security_policy_rule {
    /// enum to define the primitive action.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BasicProfile {
        /// If there is not a mentioned action for the target.
        Unspecified = 0,
        /// Allow the matched traffic.
        Allow = 1,
        /// Deny the matched traffic.
        Deny = 2,
    }
    impl BasicProfile {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BASIC_PROFILE_UNSPECIFIED",
                Self::Allow => "ALLOW",
                Self::Deny => "DENY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BASIC_PROFILE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                _ => None,
            }
        }
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Profile {
        /// Required. Profile which tells what the primitive action should be.
        #[prost(enumeration = "BasicProfile", tag = "9")]
        BasicProfile(i32),
    }
}
/// Methods for GatewaySecurityPolicy RULES/GatewaySecurityPolicyRules.
/// Request used by the CreateGatewaySecurityPolicyRule method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateGatewaySecurityPolicyRuleRequest {
    /// Required. The parent where this rule will be created.
    /// Format :
    /// projects/{project}/location/{location}/gatewaySecurityPolicies/\*
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The rule to be created.
    #[prost(message, optional, tag = "2")]
    pub gateway_security_policy_rule: ::core::option::Option<GatewaySecurityPolicyRule>,
    /// The ID to use for the rule, which will become the final component of
    /// the rule's resource name.
    /// This value should be 4-63 characters, and valid characters
    /// are /\[a-z\]\[0-9\]-/.
    #[prost(string, tag = "3")]
    pub gateway_security_policy_rule_id: ::prost::alloc::string::String,
}
/// Request used by the GetGatewaySecurityPolicyRule method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGatewaySecurityPolicyRuleRequest {
    /// Required. The name of the GatewaySecurityPolicyRule to retrieve.
    /// Format:
    /// projects/{project}/location/{location}/gatewaySecurityPolicies/*/rules/*
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the UpdateGatewaySecurityPolicyRule method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateGatewaySecurityPolicyRuleRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// GatewaySecurityPolicy resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated GatewaySecurityPolicyRule resource.
    #[prost(message, optional, tag = "2")]
    pub gateway_security_policy_rule: ::core::option::Option<GatewaySecurityPolicyRule>,
}
/// Request used with the ListGatewaySecurityPolicyRules method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListGatewaySecurityPolicyRulesRequest {
    /// Required. The project, location and GatewaySecurityPolicy from which the
    /// GatewaySecurityPolicyRules should be listed, specified in the format
    /// `projects/{project}/locations/{location}/gatewaySecurityPolicies/{gatewaySecurityPolicy}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of GatewaySecurityPolicyRules to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last
    /// 'ListGatewaySecurityPolicyRulesResponse' Indicates that this is a
    /// continuation of a prior 'ListGatewaySecurityPolicyRules' call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListGatewaySecurityPolicyRules method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGatewaySecurityPolicyRulesResponse {
    /// List of GatewaySecurityPolicyRule resources.
    #[prost(message, repeated, tag = "1")]
    pub gateway_security_policy_rules: ::prost::alloc::vec::Vec<
        GatewaySecurityPolicyRule,
    >,
    /// If there might be more results than those appearing in this response, then
    /// 'next_page_token' is included. To get the next set of results, call this
    /// method again using the value of 'next_page_token' as 'page_token'.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the DeleteGatewaySecurityPolicyRule method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteGatewaySecurityPolicyRuleRequest {
    /// Required. A name of the GatewaySecurityPolicyRule to delete. Must be in the
    /// format
    /// `projects/{project}/locations/{location}/gatewaySecurityPolicies/{gatewaySecurityPolicy}/rules/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// An endpoint group is a consumer frontend for a deployment group (backend).
/// In order to configure intercept for a network, consumers must create:
///
/// * An association between their network and the endpoint group.
/// * A security profile that points to the endpoint group.
/// * A firewall rule that references the security profile (group).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptEndpointGroup {
    /// Immutable. Identifier. The resource name of this endpoint group, for
    /// example:
    /// `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. The deployment group that this endpoint group is
    /// connected to, for example:
    /// `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub intercept_deployment_group: ::prost::alloc::string::String,
    /// Output only. Details about the connected deployment group to this endpoint
    /// group.
    #[prost(message, optional, tag = "11")]
    pub connected_deployment_group: ::core::option::Option<
        intercept_endpoint_group::ConnectedDeploymentGroup,
    >,
    /// Output only. The current state of the endpoint group.
    /// See <https://google.aip.dev/216.>
    #[prost(enumeration = "intercept_endpoint_group::State", tag = "7")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This is part
    /// of the normal operation (e.g. adding a new association to the group). See
    /// <https://google.aip.dev/128.>
    #[prost(bool, tag = "8")]
    pub reconciling: bool,
    /// Output only. List of associations to this endpoint group.
    #[prost(message, repeated, tag = "9")]
    pub associations: ::prost::alloc::vec::Vec<
        intercept_endpoint_group::AssociationDetails,
    >,
    /// Optional. User-provided description of the endpoint group.
    /// Used as additional context for the endpoint group.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `InterceptEndpointGroup`.
pub mod intercept_endpoint_group {
    /// The endpoint group's view of a connected deployment group.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConnectedDeploymentGroup {
        /// Output only. The connected deployment group's resource name, for example:
        /// `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. The list of locations where the deployment group is present.
        #[prost(message, repeated, tag = "2")]
        pub locations: ::prost::alloc::vec::Vec<super::InterceptLocation>,
    }
    /// The endpoint group's view of a connected association.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AssociationDetails {
        /// Output only. The connected association's resource name, for example:
        /// `projects/123456789/locations/global/interceptEndpointGroupAssociations/my-ega`.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. The associated network, for example:
        /// projects/123456789/global/networks/my-network.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "2")]
        pub network: ::prost::alloc::string::String,
        /// Output only. Most recent known state of the association.
        #[prost(
            enumeration = "super::intercept_endpoint_group_association::State",
            tag = "3"
        )]
        pub state: i32,
    }
    /// Endpoint group state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The endpoint group is ready and in sync with the target deployment group.
        Active = 1,
        /// The deployment group backing this endpoint group has been force-deleted.
        /// This endpoint group cannot be used and interception is effectively
        /// disabled.
        Closed = 2,
        /// The endpoint group is being created.
        Creating = 3,
        /// The endpoint group is being deleted.
        Deleting = 4,
        /// The endpoint group is out of sync with the backing deployment group.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. an inaccessible location) and the system is expected to recover
        /// automatically. See the associations field for details per network and
        /// location.
        OutOfSync = 5,
        /// An attempt to delete the endpoint group has failed. This is a terminal
        /// state and the endpoint group is not expected to recover.
        /// The only permitted operation is to retry deleting the endpoint group.
        DeleteFailed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Closed => "CLOSED",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::OutOfSync => "OUT_OF_SYNC",
                Self::DeleteFailed => "DELETE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CLOSED" => Some(Self::Closed),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                _ => None,
            }
        }
    }
}
/// Request message for ListInterceptEndpointGroups.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListInterceptEndpointGroupsRequest {
    /// Required. The parent, which owns this collection of endpoint groups.
    /// Example: `projects/123456789/locations/global`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListInterceptEndpointGroups` call. Provide this to retrieve the subsequent
    /// page. When paginating, all other parameters provided to
    /// `ListInterceptEndpointGroups` must match the call that provided the page
    /// token.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListInterceptEndpointGroups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterceptEndpointGroupsResponse {
    /// The endpoint groups from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub intercept_endpoint_groups: ::prost::alloc::vec::Vec<InterceptEndpointGroup>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetInterceptEndpointGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetInterceptEndpointGroupRequest {
    /// Required. The name of the endpoint group to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/interceptEndpointGroups/{intercept_endpoint_group}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateInterceptEndpointGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInterceptEndpointGroupRequest {
    /// Required. The parent resource where this endpoint group will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the endpoint group, which will become the final
    /// component of the endpoint group's resource name.
    #[prost(string, tag = "2")]
    pub intercept_endpoint_group_id: ::prost::alloc::string::String,
    /// Required. The endpoint group to create.
    #[prost(message, optional, tag = "3")]
    pub intercept_endpoint_group: ::core::option::Option<InterceptEndpointGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateInterceptEndpointGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInterceptEndpointGroupRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the endpoint group
    /// (e.g. `description`; *not* `intercept_endpoint_group.description`).
    /// See <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The endpoint group to update.
    #[prost(message, optional, tag = "2")]
    pub intercept_endpoint_group: ::core::option::Option<InterceptEndpointGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteInterceptEndpointGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteInterceptEndpointGroupRequest {
    /// Required. The endpoint group to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// An endpoint group association represents a link between a network and an
/// endpoint group in the organization.
///
/// Creating an association creates the networking infrastructure linking the
/// network to the endpoint group, but does not enable intercept by itself.
/// To enable intercept, the user must also create a network firewall policy
/// containing intercept rules and associate it with the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptEndpointGroupAssociation {
    /// Immutable. Identifier. The resource name of this endpoint group
    /// association, for example:
    /// `projects/123456789/locations/global/interceptEndpointGroupAssociations/my-eg-association`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. The endpoint group that this association is connected
    /// to, for example:
    /// `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub intercept_endpoint_group: ::prost::alloc::string::String,
    /// Required. Immutable. The VPC network that is associated. for example:
    /// `projects/123456789/global/networks/my-network`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "6")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The list of locations where the association is present. This
    /// information is retrieved from the linked endpoint group, and not configured
    /// as part of the association itself.
    #[deprecated]
    #[prost(message, repeated, tag = "7")]
    pub locations_details: ::prost::alloc::vec::Vec<
        intercept_endpoint_group_association::LocationDetails,
    >,
    /// Output only. Current state of the endpoint group association.
    #[prost(enumeration = "intercept_endpoint_group_association::State", tag = "8")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This part of
    /// the normal operation (e.g. adding a new location to the target deployment
    /// group). See <https://google.aip.dev/128.>
    #[prost(bool, tag = "9")]
    pub reconciling: bool,
    /// Output only. The list of locations where the association is configured.
    /// This information is retrieved from the linked endpoint group.
    #[prost(message, repeated, tag = "10")]
    pub locations: ::prost::alloc::vec::Vec<InterceptLocation>,
}
/// Nested message and enum types in `InterceptEndpointGroupAssociation`.
pub mod intercept_endpoint_group_association {
    /// Contains details about the state of an association in a specific cloud
    /// location.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LocationDetails {
        /// Output only. The cloud location, e.g. "us-central1-a" or "asia-south1".
        #[prost(string, tag = "1")]
        pub location: ::prost::alloc::string::String,
        /// Output only. The current state of the association in this location.
        #[prost(enumeration = "location_details::State", tag = "2")]
        pub state: i32,
    }
    /// Nested message and enum types in `LocationDetails`.
    pub mod location_details {
        /// The state of association.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Not set.
            Unspecified = 0,
            /// The association is ready and in sync with the linked endpoint group.
            Active = 1,
            /// The association is out of sync with the linked endpoint group.
            /// In most cases, this is a result of a transient issue within the system
            /// (e.g. an inaccessible location) and the system is expected to recover
            /// automatically.
            OutOfSync = 2,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::OutOfSync => "OUT_OF_SYNC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "OUT_OF_SYNC" => Some(Self::OutOfSync),
                    _ => None,
                }
            }
        }
    }
    /// The state of the association.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Not set.
        Unspecified = 0,
        /// The association is ready and in sync with the linked endpoint group.
        Active = 1,
        /// The association is being created.
        Creating = 2,
        /// The association is being deleted.
        Deleting = 3,
        /// The association is disabled due to a breaking change in another resource.
        Closed = 4,
        /// The association is out of sync with the linked endpoint group.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. an inaccessible location) and the system is expected to recover
        /// automatically. Check the `locations_details` field for more details.
        OutOfSync = 5,
        /// An attempt to delete the association has failed. This is a terminal state
        /// and the association is not expected to be usable as some of its resources
        /// have been deleted.
        /// The only permitted operation is to retry deleting the association.
        DeleteFailed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::Closed => "CLOSED",
                Self::OutOfSync => "OUT_OF_SYNC",
                Self::DeleteFailed => "DELETE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "CLOSED" => Some(Self::Closed),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                _ => None,
            }
        }
    }
}
/// Request message for ListInterceptEndpointGroupAssociations.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListInterceptEndpointGroupAssociationsRequest {
    /// Required. The parent, which owns this collection of associations.
    /// Example: `projects/123456789/locations/global`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListInterceptEndpointGroups` call. Provide this to retrieve the subsequent
    /// page. When paginating, all other parameters provided to
    /// `ListInterceptEndpointGroups` must match the call that provided the page
    /// token. See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListInterceptEndpointGroupAssociations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterceptEndpointGroupAssociationsResponse {
    /// The associations from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub intercept_endpoint_group_associations: ::prost::alloc::vec::Vec<
        InterceptEndpointGroupAssociation,
    >,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetInterceptEndpointGroupAssociation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetInterceptEndpointGroupAssociationRequest {
    /// Required. The name of the association to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/interceptEndpointGroupAssociations/{intercept_endpoint_group_association}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateInterceptEndpointGroupAssociation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInterceptEndpointGroupAssociationRequest {
    /// Required. The parent resource where this association will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the new association, which will become the
    /// final component of the endpoint group's resource name. If not provided, the
    /// server will generate a unique ID.
    #[prost(string, tag = "2")]
    pub intercept_endpoint_group_association_id: ::prost::alloc::string::String,
    /// Required. The association to create.
    #[prost(message, optional, tag = "3")]
    pub intercept_endpoint_group_association: ::core::option::Option<
        InterceptEndpointGroupAssociation,
    >,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateInterceptEndpointGroupAssociation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInterceptEndpointGroupAssociationRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the association
    /// (e.g. `description`; *not*
    /// `intercept_endpoint_group_association.description`). See
    /// <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The association to update.
    #[prost(message, optional, tag = "2")]
    pub intercept_endpoint_group_association: ::core::option::Option<
        InterceptEndpointGroupAssociation,
    >,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteInterceptEndpointGroupAssociation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteInterceptEndpointGroupAssociationRequest {
    /// Required. The association to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A deployment group aggregates many zonal intercept backends (deployments)
/// into a single global intercept service. Consumers can connect this service
/// using an endpoint group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptDeploymentGroup {
    /// Immutable. Identifier. The resource name of this deployment group, for
    /// example:
    /// `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. The network that will be used for all child
    /// deployments, for example: `projects/{project}/global/networks/{network}`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The list of endpoint groups that are connected to this
    /// resource.
    #[prost(message, repeated, tag = "6")]
    pub connected_endpoint_groups: ::prost::alloc::vec::Vec<
        intercept_deployment_group::ConnectedEndpointGroup,
    >,
    /// Output only. The list of Intercept Deployments that belong to this group.
    #[deprecated]
    #[prost(message, repeated, tag = "10")]
    pub nested_deployments: ::prost::alloc::vec::Vec<
        intercept_deployment_group::Deployment,
    >,
    /// Output only. The current state of the deployment group.
    /// See <https://google.aip.dev/216.>
    #[prost(enumeration = "intercept_deployment_group::State", tag = "7")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This is part
    /// of the normal operation (e.g. adding a new deployment to the group) See
    /// <https://google.aip.dev/128.>
    #[prost(bool, tag = "8")]
    pub reconciling: bool,
    /// Optional. User-provided description of the deployment group.
    /// Used as additional context for the deployment group.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The list of locations where the deployment group is present.
    #[prost(message, repeated, tag = "11")]
    pub locations: ::prost::alloc::vec::Vec<InterceptLocation>,
}
/// Nested message and enum types in `InterceptDeploymentGroup`.
pub mod intercept_deployment_group {
    /// An endpoint group connected to this deployment group.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ConnectedEndpointGroup {
        /// Output only. The connected endpoint group's resource name, for example:
        /// `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// A deployment belonging to this deployment group.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Deployment {
        /// Output only. The name of the Intercept Deployment, in the format:
        /// `projects/{project}/locations/{location}/interceptDeployments/{intercept_deployment}`.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. Most recent known state of the deployment.
        #[prost(enumeration = "super::intercept_deployment::State", tag = "2")]
        pub state: i32,
    }
    /// The current state of the deployment group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The deployment group is ready.
        Active = 1,
        /// The deployment group is being created.
        Creating = 2,
        /// The deployment group is being deleted.
        Deleting = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Request message for ListInterceptDeploymentGroups.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListInterceptDeploymentGroupsRequest {
    /// Required. The parent, which owns this collection of deployment groups.
    /// Example: `projects/123456789/locations/global`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListInterceptDeploymentGroups` call. Provide this to retrieve the
    /// subsequent page. When paginating, all other parameters provided to
    /// `ListInterceptDeploymentGroups` must match the call that provided the page
    /// token. See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListInterceptDeploymentGroups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterceptDeploymentGroupsResponse {
    /// The deployment groups from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub intercept_deployment_groups: ::prost::alloc::vec::Vec<InterceptDeploymentGroup>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetInterceptDeploymentGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetInterceptDeploymentGroupRequest {
    /// Required. The name of the deployment group to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/interceptDeploymentGroups/{intercept_deployment_group}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateInterceptDeploymentGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInterceptDeploymentGroupRequest {
    /// Required. The parent resource where this deployment group will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the new deployment group, which will become the
    /// final component of the deployment group's resource name.
    #[prost(string, tag = "2")]
    pub intercept_deployment_group_id: ::prost::alloc::string::String,
    /// Required. The deployment group to create.
    #[prost(message, optional, tag = "3")]
    pub intercept_deployment_group: ::core::option::Option<InterceptDeploymentGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateInterceptDeploymentGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInterceptDeploymentGroupRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the deployment group
    /// (e.g. `description`; *not*
    /// `intercept_deployment_group.description`). See
    /// <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The deployment group to update.
    #[prost(message, optional, tag = "2")]
    pub intercept_deployment_group: ::core::option::Option<InterceptDeploymentGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteInterceptDeploymentGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteInterceptDeploymentGroupRequest {
    /// Required. The deployment group to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A deployment represents a zonal intercept backend ready to accept
/// GENEVE-encapsulated traffic, e.g. a zonal instance group fronted by an
/// internal passthrough load balancer. Deployments are always part of a
/// global deployment group which represents a global intercept service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterceptDeployment {
    /// Immutable. Identifier. The resource name of this deployment, for example:
    /// `projects/123456789/locations/us-central1-a/interceptDeployments/my-dep`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. The regional forwarding rule that fronts the
    /// interceptors, for example:
    /// `projects/123456789/regions/us-central1/forwardingRules/my-rule`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub forwarding_rule: ::prost::alloc::string::String,
    /// Required. Immutable. The deployment group that this deployment is a part
    /// of, for example:
    /// `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "6")]
    pub intercept_deployment_group: ::prost::alloc::string::String,
    /// Output only. The current state of the deployment.
    /// See <https://google.aip.dev/216.>
    #[prost(enumeration = "intercept_deployment::State", tag = "7")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This part of
    /// the normal operation (e.g. linking a new association to the parent group).
    /// See <https://google.aip.dev/128.>
    #[prost(bool, tag = "8")]
    pub reconciling: bool,
    /// Optional. User-provided description of the deployment.
    /// Used as additional context for the deployment.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `InterceptDeployment`.
pub mod intercept_deployment {
    /// The current state of the deployment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The deployment is ready and in sync with the parent group.
        Active = 1,
        /// The deployment is being created.
        Creating = 2,
        /// The deployment is being deleted.
        Deleting = 3,
        /// The deployment is out of sync with the parent group.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. a delayed data-path config) and the system is expected to recover
        /// automatically. See the parent deployment group's state for more details.
        OutOfSync = 4,
        /// An attempt to delete the deployment has failed. This is a terminal state
        /// and the deployment is not expected to recover. The only permitted
        /// operation is to retry deleting the deployment.
        DeleteFailed = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::OutOfSync => "OUT_OF_SYNC",
                Self::DeleteFailed => "DELETE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                _ => None,
            }
        }
    }
}
/// Request message for ListInterceptDeployments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListInterceptDeploymentsRequest {
    /// Required. The parent, which owns this collection of deployments.
    /// Example: `projects/123456789/locations/us-central1-a`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListInterceptDeployments`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `ListInterceptDeployments` must match the call
    /// that provided the page token. See <https://google.aip.dev/158> for more
    /// details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListInterceptDeployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterceptDeploymentsResponse {
    /// The deployments from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub intercept_deployments: ::prost::alloc::vec::Vec<InterceptDeployment>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for GetInterceptDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetInterceptDeploymentRequest {
    /// Required. The name of the deployment to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/interceptDeployments/{intercept_deployment}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateInterceptDeployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInterceptDeploymentRequest {
    /// Required. The parent resource where this deployment will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the new deployment, which will become the final
    /// component of the deployment's resource name.
    #[prost(string, tag = "2")]
    pub intercept_deployment_id: ::prost::alloc::string::String,
    /// Required. The deployment to create.
    #[prost(message, optional, tag = "3")]
    pub intercept_deployment: ::core::option::Option<InterceptDeployment>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateInterceptDeployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInterceptDeploymentRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the deployment
    /// (e.g. `description`; *not* `intercept_deployment.description`).
    /// See <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The deployment to update.
    #[prost(message, optional, tag = "2")]
    pub intercept_deployment: ::core::option::Option<InterceptDeployment>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteInterceptDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteInterceptDeploymentRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Details about intercept in a specific cloud location.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InterceptLocation {
    /// Output only. The cloud location, e.g. "us-central1-a" or "asia-south1".
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// Output only. The current state of the association in this location.
    #[prost(enumeration = "intercept_location::State", tag = "2")]
    pub state: i32,
}
/// Nested message and enum types in `InterceptLocation`.
pub mod intercept_location {
    /// The current state of a resource in the location.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The resource is ready and in sync in the location.
        Active = 1,
        /// The resource is out of sync in the location.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. an inaccessible location) and the system is expected to recover
        /// automatically.
        OutOfSync = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::OutOfSync => "OUT_OF_SYNC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod intercept_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for Third-Party Packet Intercept (TPPI).
    /// TPPI is the "in-band" flavor of the Network Security Integrations product.
    #[derive(Debug, Clone)]
    pub struct InterceptClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl InterceptClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> InterceptClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            InterceptClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists endpoint groups in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_intercept_endpoint_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInterceptEndpointGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInterceptEndpointGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/ListInterceptEndpointGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "ListInterceptEndpointGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific endpoint group.
        /// See https://google.aip.dev/131.
        pub async fn get_intercept_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterceptEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterceptEndpointGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/GetInterceptEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "GetInterceptEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an endpoint group in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_intercept_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInterceptEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/CreateInterceptEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "CreateInterceptEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an endpoint group.
        /// See https://google.aip.dev/134.
        pub async fn update_intercept_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInterceptEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/UpdateInterceptEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "UpdateInterceptEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an endpoint group.
        /// See https://google.aip.dev/135.
        pub async fn delete_intercept_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInterceptEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/DeleteInterceptEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "DeleteInterceptEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists associations in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_intercept_endpoint_group_associations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListInterceptEndpointGroupAssociationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListInterceptEndpointGroupAssociationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/ListInterceptEndpointGroupAssociations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "ListInterceptEndpointGroupAssociations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific association.
        /// See https://google.aip.dev/131.
        pub async fn get_intercept_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetInterceptEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InterceptEndpointGroupAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/GetInterceptEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "GetInterceptEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an association in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_intercept_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateInterceptEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/CreateInterceptEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "CreateInterceptEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an association.
        /// See https://google.aip.dev/134.
        pub async fn update_intercept_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateInterceptEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/UpdateInterceptEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "UpdateInterceptEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an association.
        /// See https://google.aip.dev/135.
        pub async fn delete_intercept_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteInterceptEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/DeleteInterceptEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "DeleteInterceptEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists deployment groups in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_intercept_deployment_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInterceptDeploymentGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInterceptDeploymentGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/ListInterceptDeploymentGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "ListInterceptDeploymentGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific deployment group.
        /// See https://google.aip.dev/131.
        pub async fn get_intercept_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterceptDeploymentGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterceptDeploymentGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/GetInterceptDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "GetInterceptDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a deployment group in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_intercept_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateInterceptDeploymentGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/CreateInterceptDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "CreateInterceptDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a deployment group.
        /// See https://google.aip.dev/134.
        pub async fn update_intercept_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateInterceptDeploymentGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/UpdateInterceptDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "UpdateInterceptDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a deployment group.
        /// See https://google.aip.dev/135.
        pub async fn delete_intercept_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteInterceptDeploymentGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/DeleteInterceptDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "DeleteInterceptDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists deployments in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_intercept_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInterceptDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInterceptDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/ListInterceptDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "ListInterceptDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific deployment.
        /// See https://google.aip.dev/131.
        pub async fn get_intercept_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterceptDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterceptDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/GetInterceptDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "GetInterceptDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a deployment in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_intercept_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInterceptDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/CreateInterceptDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "CreateInterceptDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a deployment.
        /// See https://google.aip.dev/134.
        pub async fn update_intercept_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInterceptDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/UpdateInterceptDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "UpdateInterceptDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a deployment.
        /// See https://google.aip.dev/135.
        pub async fn delete_intercept_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInterceptDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Intercept/DeleteInterceptDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Intercept",
                        "DeleteInterceptDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// An endpoint group is a consumer frontend for a deployment group (backend).
/// In order to configure mirroring for a network, consumers must create:
///
/// * An association between their network and the endpoint group.
/// * A security profile that points to the endpoint group.
/// * A mirroring rule that references the security profile (group).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MirroringEndpointGroup {
    /// Immutable. Identifier. The resource name of this endpoint group, for
    /// example:
    /// `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. The deployment group that this DIRECT endpoint group is
    /// connected to, for example:
    /// `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub mirroring_deployment_group: ::prost::alloc::string::String,
    /// Output only. List of details about the connected deployment groups to this
    /// endpoint group.
    #[prost(message, repeated, tag = "13")]
    pub connected_deployment_groups: ::prost::alloc::vec::Vec<
        mirroring_endpoint_group::ConnectedDeploymentGroup,
    >,
    /// Output only. The current state of the endpoint group.
    /// See <https://google.aip.dev/216.>
    #[prost(enumeration = "mirroring_endpoint_group::State", tag = "7")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This is part
    /// of the normal operation (e.g. adding a new association to the group). See
    /// <https://google.aip.dev/128.>
    #[prost(bool, tag = "8")]
    pub reconciling: bool,
    /// Immutable. The type of the endpoint group.
    /// If left unspecified, defaults to DIRECT.
    #[prost(enumeration = "mirroring_endpoint_group::Type", tag = "11")]
    pub r#type: i32,
    /// Output only. List of associations to this endpoint group.
    #[prost(message, repeated, tag = "9")]
    pub associations: ::prost::alloc::vec::Vec<
        mirroring_endpoint_group::AssociationDetails,
    >,
    /// Optional. User-provided description of the endpoint group.
    /// Used as additional context for the endpoint group.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MirroringEndpointGroup`.
pub mod mirroring_endpoint_group {
    /// The endpoint group's view of a connected deployment group.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ConnectedDeploymentGroup {
        /// Output only. The connected deployment group's resource name, for example:
        /// `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. The list of locations where the deployment group is present.
        #[prost(message, repeated, tag = "2")]
        pub locations: ::prost::alloc::vec::Vec<super::MirroringLocation>,
    }
    /// The endpoint group's view of a connected association.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AssociationDetails {
        /// Output only. The connected association's resource name, for example:
        /// `projects/123456789/locations/global/mirroringEndpointGroupAssociations/my-ega`.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. The associated network, for example:
        /// projects/123456789/global/networks/my-network.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "2")]
        pub network: ::prost::alloc::string::String,
        /// Output only. Most recent known state of the association.
        #[prost(
            enumeration = "super::mirroring_endpoint_group_association::State",
            tag = "3"
        )]
        pub state: i32,
    }
    /// The current state of the endpoint group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The endpoint group is ready and in sync with the target deployment group.
        Active = 1,
        /// The deployment group backing this endpoint group has been force-deleted.
        /// This endpoint group cannot be used and mirroring is effectively disabled.
        Closed = 2,
        /// The endpoint group is being created.
        Creating = 3,
        /// The endpoint group is being deleted.
        Deleting = 4,
        /// The endpoint group is out of sync with the backing deployment group.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. an inaccessible location) and the system is expected to recover
        /// automatically. See the associations field for details per network and
        /// location.
        OutOfSync = 5,
        /// An attempt to delete the endpoint group has failed. This is a terminal
        /// state and the endpoint group is not expected to recover.
        /// The only permitted operation is to retry deleting the endpoint group.
        DeleteFailed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Closed => "CLOSED",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::OutOfSync => "OUT_OF_SYNC",
                Self::DeleteFailed => "DELETE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CLOSED" => Some(Self::Closed),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                _ => None,
            }
        }
    }
    /// The type of the endpoint group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Not set.
        Unspecified = 0,
        /// An endpoint group that sends packets to a single deployment group.
        Direct = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Direct => "DIRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DIRECT" => Some(Self::Direct),
                _ => None,
            }
        }
    }
}
/// Request message for ListMirroringEndpointGroups.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMirroringEndpointGroupsRequest {
    /// Required. The parent, which owns this collection of endpoint groups.
    /// Example: `projects/123456789/locations/global`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListMirroringEndpointGroups` call. Provide this to retrieve the subsequent
    /// page. When paginating, all other parameters provided to
    /// `ListMirroringEndpointGroups` must match the call that provided the page
    /// token.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListMirroringEndpointGroups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMirroringEndpointGroupsResponse {
    /// The endpoint groups from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub mirroring_endpoint_groups: ::prost::alloc::vec::Vec<MirroringEndpointGroup>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetMirroringEndpointGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMirroringEndpointGroupRequest {
    /// Required. The name of the endpoint group to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/mirroringEndpointGroups/{mirroring_endpoint_group}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateMirroringEndpointGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMirroringEndpointGroupRequest {
    /// Required. The parent resource where this endpoint group will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the endpoint group, which will become the final
    /// component of the endpoint group's resource name.
    #[prost(string, tag = "2")]
    pub mirroring_endpoint_group_id: ::prost::alloc::string::String,
    /// Required. The endpoint group to create.
    #[prost(message, optional, tag = "3")]
    pub mirroring_endpoint_group: ::core::option::Option<MirroringEndpointGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateMirroringEndpointGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMirroringEndpointGroupRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the endpoint group
    /// (e.g. `description`; *not* `mirroring_endpoint_group.description`).
    /// See <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The endpoint group to update.
    #[prost(message, optional, tag = "2")]
    pub mirroring_endpoint_group: ::core::option::Option<MirroringEndpointGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteMirroringEndpointGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteMirroringEndpointGroupRequest {
    /// Required. The endpoint group to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// An endpoint group association represents a link between a network and an
/// endpoint group in the organization.
///
/// Creating an association creates the networking infrastructure linking the
/// network to the endpoint group, but does not enable mirroring by itself.
/// To enable mirroring, the user must also create a network firewall policy
/// containing mirroring rules and associate it with the network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MirroringEndpointGroupAssociation {
    /// Immutable. Identifier. The resource name of this endpoint group
    /// association, for example:
    /// `projects/123456789/locations/global/mirroringEndpointGroupAssociations/my-eg-association`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. The endpoint group that this association is connected to, for
    /// example:
    /// `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub mirroring_endpoint_group: ::prost::alloc::string::String,
    /// Immutable. The VPC network that is associated. for example:
    /// `projects/123456789/global/networks/my-network`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "6")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The list of locations where the association is present. This
    /// information is retrieved from the linked endpoint group, and not configured
    /// as part of the association itself.
    #[deprecated]
    #[prost(message, repeated, tag = "7")]
    pub locations_details: ::prost::alloc::vec::Vec<
        mirroring_endpoint_group_association::LocationDetails,
    >,
    /// Output only. Current state of the endpoint group association.
    #[prost(enumeration = "mirroring_endpoint_group_association::State", tag = "8")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This part of
    /// the normal operation (e.g. adding a new location to the target deployment
    /// group). See <https://google.aip.dev/128.>
    #[prost(bool, tag = "9")]
    pub reconciling: bool,
    /// Output only. The list of locations where the association is configured.
    /// This information is retrieved from the linked endpoint group.
    #[prost(message, repeated, tag = "10")]
    pub locations: ::prost::alloc::vec::Vec<MirroringLocation>,
}
/// Nested message and enum types in `MirroringEndpointGroupAssociation`.
pub mod mirroring_endpoint_group_association {
    /// Contains details about the state of an association in a specific cloud
    /// location.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LocationDetails {
        /// Output only. The cloud location, e.g. "us-central1-a" or "asia-south1".
        #[prost(string, tag = "1")]
        pub location: ::prost::alloc::string::String,
        /// Output only. The current state of the association in this location.
        #[prost(enumeration = "location_details::State", tag = "2")]
        pub state: i32,
    }
    /// Nested message and enum types in `LocationDetails`.
    pub mod location_details {
        /// The state of association.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Not set.
            Unspecified = 0,
            /// The association is ready and in sync with the linked endpoint group.
            Active = 1,
            /// The association is out of sync with the linked endpoint group.
            /// In most cases, this is a result of a transient issue within the system
            /// (e.g. an inaccessible location) and the system is expected to recover
            /// automatically.
            OutOfSync = 2,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::OutOfSync => "OUT_OF_SYNC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "OUT_OF_SYNC" => Some(Self::OutOfSync),
                    _ => None,
                }
            }
        }
    }
    /// The state of the association.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Not set.
        Unspecified = 0,
        /// The association is ready and in sync with the linked endpoint group.
        Active = 1,
        /// The association is being created.
        Creating = 3,
        /// The association is being deleted.
        Deleting = 4,
        /// The association is disabled due to a breaking change in another resource.
        Closed = 5,
        /// The association is out of sync with the linked endpoint group.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. an inaccessible location) and the system is expected to recover
        /// automatically. Check the `locations_details` field for more details.
        OutOfSync = 6,
        /// An attempt to delete the association has failed. This is a terminal state
        /// and the association is not expected to be usable as some of its resources
        /// have been deleted.
        /// The only permitted operation is to retry deleting the association.
        DeleteFailed = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::Closed => "CLOSED",
                Self::OutOfSync => "OUT_OF_SYNC",
                Self::DeleteFailed => "DELETE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "CLOSED" => Some(Self::Closed),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                _ => None,
            }
        }
    }
}
/// Request message for ListMirroringEndpointGroupAssociations.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMirroringEndpointGroupAssociationsRequest {
    /// Required. The parent, which owns this collection of associations.
    /// Example: `projects/123456789/locations/global`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListMirroringEndpointGroups` call. Provide this to retrieve the subsequent
    /// page. When paginating, all other parameters provided to
    /// `ListMirroringEndpointGroups` must match the call that provided the page
    /// token. See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListMirroringEndpointGroupAssociations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMirroringEndpointGroupAssociationsResponse {
    /// The associations from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub mirroring_endpoint_group_associations: ::prost::alloc::vec::Vec<
        MirroringEndpointGroupAssociation,
    >,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetMirroringEndpointGroupAssociation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMirroringEndpointGroupAssociationRequest {
    /// Required. The name of the association to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/mirroringEndpointGroupAssociations/{mirroring_endpoint_group_association}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateMirroringEndpointGroupAssociation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMirroringEndpointGroupAssociationRequest {
    /// Required. The parent resource where this association will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the new association, which will become the
    /// final component of the endpoint group's resource name. If not provided, the
    /// server will generate a unique ID.
    #[prost(string, tag = "2")]
    pub mirroring_endpoint_group_association_id: ::prost::alloc::string::String,
    /// Required. The association to create.
    #[prost(message, optional, tag = "3")]
    pub mirroring_endpoint_group_association: ::core::option::Option<
        MirroringEndpointGroupAssociation,
    >,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateMirroringEndpointGroupAssociation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMirroringEndpointGroupAssociationRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the association
    /// (e.g. `description`; *not*
    /// `mirroring_endpoint_group_association.description`). See
    /// <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The association to update.
    #[prost(message, optional, tag = "2")]
    pub mirroring_endpoint_group_association: ::core::option::Option<
        MirroringEndpointGroupAssociation,
    >,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteMirroringEndpointGroupAssociation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteMirroringEndpointGroupAssociationRequest {
    /// Required. The association to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A deployment group aggregates many zonal mirroring backends (deployments)
/// into a single global mirroring service. Consumers can connect this service
/// using an endpoint group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MirroringDeploymentGroup {
    /// Immutable. Identifier. The resource name of this deployment group, for
    /// example:
    /// `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. The network that will be used for all child
    /// deployments, for example: `projects/{project}/global/networks/{network}`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The list of endpoint groups that are connected to this
    /// resource.
    #[prost(message, repeated, tag = "6")]
    pub connected_endpoint_groups: ::prost::alloc::vec::Vec<
        mirroring_deployment_group::ConnectedEndpointGroup,
    >,
    /// Output only. The list of Mirroring Deployments that belong to this group.
    #[deprecated]
    #[prost(message, repeated, tag = "10")]
    pub nested_deployments: ::prost::alloc::vec::Vec<
        mirroring_deployment_group::Deployment,
    >,
    /// Output only. The current state of the deployment group.
    /// See <https://google.aip.dev/216.>
    #[prost(enumeration = "mirroring_deployment_group::State", tag = "7")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This is part
    /// of the normal operation (e.g. adding a new deployment to the group) See
    /// <https://google.aip.dev/128.>
    #[prost(bool, tag = "8")]
    pub reconciling: bool,
    /// Optional. User-provided description of the deployment group.
    /// Used as additional context for the deployment group.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The list of locations where the deployment group is present.
    #[prost(message, repeated, tag = "11")]
    pub locations: ::prost::alloc::vec::Vec<MirroringLocation>,
}
/// Nested message and enum types in `MirroringDeploymentGroup`.
pub mod mirroring_deployment_group {
    /// An endpoint group connected to this deployment group.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ConnectedEndpointGroup {
        /// Output only. The connected endpoint group's resource name, for example:
        /// `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
        /// See <https://google.aip.dev/124.>
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// A deployment belonging to this deployment group.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Deployment {
        /// Output only. The name of the Mirroring Deployment, in the format:
        /// `projects/{project}/locations/{location}/mirroringDeployments/{mirroring_deployment}`.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Output only. Most recent known state of the deployment.
        #[prost(enumeration = "super::mirroring_deployment::State", tag = "2")]
        pub state: i32,
    }
    /// The current state of the deployment group.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The deployment group is ready.
        Active = 1,
        /// The deployment group is being created.
        Creating = 2,
        /// The deployment group is being deleted.
        Deleting = 3,
        /// The deployment group is being wiped out (project deleted).
        Closed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
/// Request message for ListMirroringDeploymentGroups.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMirroringDeploymentGroupsRequest {
    /// Required. The parent, which owns this collection of deployment groups.
    /// Example: `projects/123456789/locations/global`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListMirroringDeploymentGroups` call. Provide this to retrieve the
    /// subsequent page. When paginating, all other parameters provided to
    /// `ListMirroringDeploymentGroups` must match the call that provided the page
    /// token. See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListMirroringDeploymentGroups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMirroringDeploymentGroupsResponse {
    /// The deployment groups from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub mirroring_deployment_groups: ::prost::alloc::vec::Vec<MirroringDeploymentGroup>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetMirroringDeploymentGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMirroringDeploymentGroupRequest {
    /// Required. The name of the deployment group to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/mirroringDeploymentGroups/{mirroring_deployment_group}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateMirroringDeploymentGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMirroringDeploymentGroupRequest {
    /// Required. The parent resource where this deployment group will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the new deployment group, which will become the
    /// final component of the deployment group's resource name.
    #[prost(string, tag = "2")]
    pub mirroring_deployment_group_id: ::prost::alloc::string::String,
    /// Required. The deployment group to create.
    #[prost(message, optional, tag = "3")]
    pub mirroring_deployment_group: ::core::option::Option<MirroringDeploymentGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateMirroringDeploymentGroup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMirroringDeploymentGroupRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the deployment group
    /// (e.g. `description`; *not*
    /// `mirroring_deployment_group.description`). See
    /// <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The deployment group to update.
    #[prost(message, optional, tag = "2")]
    pub mirroring_deployment_group: ::core::option::Option<MirroringDeploymentGroup>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteMirroringDeploymentGroup.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteMirroringDeploymentGroupRequest {
    /// Required. The deployment group to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A deployment represents a zonal mirroring backend ready to accept
/// GENEVE-encapsulated replica traffic, e.g. a zonal instance group fronted by
/// an internal passthrough load balancer. Deployments are always part of a
/// global deployment group which represents a global mirroring service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MirroringDeployment {
    /// Immutable. Identifier. The resource name of this deployment, for example:
    /// `projects/123456789/locations/us-central1-a/mirroringDeployments/my-dep`.
    /// See <https://google.aip.dev/122> for more details.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was most recently updated.
    /// See <https://google.aip.dev/148#timestamps.>
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are key/value pairs that help to organize and filter
    /// resources.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. The regional forwarding rule that fronts the mirroring
    /// collectors, for example:
    /// `projects/123456789/regions/us-central1/forwardingRules/my-rule`. See
    /// <https://google.aip.dev/124.>
    #[prost(string, tag = "5")]
    pub forwarding_rule: ::prost::alloc::string::String,
    /// Required. Immutable. The deployment group that this deployment is a part
    /// of, for example:
    /// `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
    /// See <https://google.aip.dev/124.>
    #[prost(string, tag = "6")]
    pub mirroring_deployment_group: ::prost::alloc::string::String,
    /// Output only. The current state of the deployment.
    /// See <https://google.aip.dev/216.>
    #[prost(enumeration = "mirroring_deployment::State", tag = "7")]
    pub state: i32,
    /// Output only. The current state of the resource does not match the user's
    /// intended state, and the system is working to reconcile them. This part of
    /// the normal operation (e.g. linking a new association to the parent group).
    /// See <https://google.aip.dev/128.>
    #[prost(bool, tag = "8")]
    pub reconciling: bool,
    /// Optional. User-provided description of the deployment.
    /// Used as additional context for the deployment.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MirroringDeployment`.
pub mod mirroring_deployment {
    /// The current state of the deployment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The deployment is ready and in sync with the parent group.
        Active = 1,
        /// The deployment is being created.
        Creating = 2,
        /// The deployment is being deleted.
        Deleting = 3,
        /// The deployment is out of sync with the parent group.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. a delayed data-path config) and the system is expected to recover
        /// automatically. See the parent deployment group's state for more details.
        OutOfSync = 4,
        /// An attempt to delete the deployment has failed. This is a terminal state
        /// and the deployment is not expected to recover. The only permitted
        /// operation is to retry deleting the deployment.
        DeleteFailed = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Creating => "CREATING",
                Self::Deleting => "DELETING",
                Self::OutOfSync => "OUT_OF_SYNC",
                Self::DeleteFailed => "DELETE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                _ => None,
            }
        }
    }
}
/// Request message for ListMirroringDeployments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMirroringDeploymentsRequest {
    /// Required. The parent, which owns this collection of deployments.
    /// Example: `projects/123456789/locations/us-central1-a`.
    /// See <https://google.aip.dev/132> for more details.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default. See
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListMirroringDeployments`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `ListMirroringDeployments` must match the call
    /// that provided the page token. See <https://google.aip.dev/158> for more
    /// details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression.
    /// See <https://google.aip.dev/160#filtering> for more details.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort expression.
    /// See <https://google.aip.dev/132#ordering> for more details.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListMirroringDeployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMirroringDeploymentsResponse {
    /// The deployments from the specified parent.
    #[prost(message, repeated, tag = "1")]
    pub mirroring_deployments: ::prost::alloc::vec::Vec<MirroringDeployment>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    /// See <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for GetMirroringDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMirroringDeploymentRequest {
    /// Required. The name of the deployment to retrieve.
    /// Format:
    /// projects/{project}/locations/{location}/mirroringDeployments/{mirroring_deployment}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for CreateMirroringDeployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMirroringDeploymentRequest {
    /// Required. The parent resource where this deployment will be created.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID to use for the new deployment, which will become the final
    /// component of the deployment's resource name.
    #[prost(string, tag = "2")]
    pub mirroring_deployment_id: ::prost::alloc::string::String,
    /// Required. The deployment to create.
    #[prost(message, optional, tag = "3")]
    pub mirroring_deployment: ::core::option::Option<MirroringDeployment>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for UpdateMirroringDeployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMirroringDeploymentRequest {
    /// Optional. The list of fields to update.
    /// Fields are specified relative to the deployment
    /// (e.g. `description`; *not* `mirroring_deployment.description`).
    /// See <https://google.aip.dev/161> for more details.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The deployment to update.
    #[prost(message, optional, tag = "2")]
    pub mirroring_deployment: ::core::option::Option<MirroringDeployment>,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for DeleteMirroringDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteMirroringDeploymentRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. Must be a UUID4.
    /// This request is only idempotent if a `request_id` is provided.
    /// See <https://google.aip.dev/155> for more details.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Details about mirroring in a specific cloud location.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MirroringLocation {
    /// Output only. The cloud location, e.g. "us-central1-a" or "asia-south1".
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// Output only. The current state of the association in this location.
    #[prost(enumeration = "mirroring_location::State", tag = "2")]
    pub state: i32,
}
/// Nested message and enum types in `MirroringLocation`.
pub mod mirroring_location {
    /// The current state of a resource in the location.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State not set (this is not a valid state).
        Unspecified = 0,
        /// The resource is ready and in sync in the location.
        Active = 1,
        /// The resource is out of sync in the location.
        /// In most cases, this is a result of a transient issue within the system
        /// (e.g. an inaccessible location) and the system is expected to recover
        /// automatically.
        OutOfSync = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::OutOfSync => "OUT_OF_SYNC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "OUT_OF_SYNC" => Some(Self::OutOfSync),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod mirroring_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// PM2 is the "out-of-band" flavor of the Network Security Integrations product.
    #[derive(Debug, Clone)]
    pub struct MirroringClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MirroringClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MirroringClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MirroringClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MirroringClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists endpoint groups in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_mirroring_endpoint_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMirroringEndpointGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMirroringEndpointGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/ListMirroringEndpointGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "ListMirroringEndpointGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific endpoint group.
        /// See https://google.aip.dev/131.
        pub async fn get_mirroring_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMirroringEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MirroringEndpointGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/GetMirroringEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "GetMirroringEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an endpoint group in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_mirroring_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMirroringEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/CreateMirroringEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "CreateMirroringEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an endpoint group.
        /// See https://google.aip.dev/134.
        pub async fn update_mirroring_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMirroringEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/UpdateMirroringEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "UpdateMirroringEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an endpoint group.
        /// See https://google.aip.dev/135.
        pub async fn delete_mirroring_endpoint_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMirroringEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/DeleteMirroringEndpointGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "DeleteMirroringEndpointGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists associations in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_mirroring_endpoint_group_associations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListMirroringEndpointGroupAssociationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListMirroringEndpointGroupAssociationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/ListMirroringEndpointGroupAssociations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "ListMirroringEndpointGroupAssociations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific association.
        /// See https://google.aip.dev/131.
        pub async fn get_mirroring_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetMirroringEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::MirroringEndpointGroupAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/GetMirroringEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "GetMirroringEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an association in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_mirroring_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateMirroringEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/CreateMirroringEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "CreateMirroringEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an association.
        /// See https://google.aip.dev/134.
        pub async fn update_mirroring_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateMirroringEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/UpdateMirroringEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "UpdateMirroringEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an association.
        /// See https://google.aip.dev/135.
        pub async fn delete_mirroring_endpoint_group_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteMirroringEndpointGroupAssociationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/DeleteMirroringEndpointGroupAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "DeleteMirroringEndpointGroupAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists deployment groups in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_mirroring_deployment_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMirroringDeploymentGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMirroringDeploymentGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/ListMirroringDeploymentGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "ListMirroringDeploymentGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific deployment group.
        /// See https://google.aip.dev/131.
        pub async fn get_mirroring_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMirroringDeploymentGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MirroringDeploymentGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/GetMirroringDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "GetMirroringDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a deployment group in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_mirroring_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateMirroringDeploymentGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/CreateMirroringDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "CreateMirroringDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a deployment group.
        /// See https://google.aip.dev/134.
        pub async fn update_mirroring_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateMirroringDeploymentGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/UpdateMirroringDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "UpdateMirroringDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a deployment group.
        /// See https://google.aip.dev/135.
        pub async fn delete_mirroring_deployment_group(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteMirroringDeploymentGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/DeleteMirroringDeploymentGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "DeleteMirroringDeploymentGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists deployments in a given project and location.
        /// See https://google.aip.dev/132.
        pub async fn list_mirroring_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMirroringDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMirroringDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/ListMirroringDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "ListMirroringDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specific deployment.
        /// See https://google.aip.dev/131.
        pub async fn get_mirroring_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMirroringDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MirroringDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/GetMirroringDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "GetMirroringDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a deployment in a given project and location.
        /// See https://google.aip.dev/133.
        pub async fn create_mirroring_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMirroringDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/CreateMirroringDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "CreateMirroringDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a deployment.
        /// See https://google.aip.dev/134.
        pub async fn update_mirroring_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMirroringDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/UpdateMirroringDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "UpdateMirroringDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a deployment.
        /// See https://google.aip.dev/135.
        pub async fn delete_mirroring_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMirroringDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.Mirroring/DeleteMirroringDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.Mirroring",
                        "DeleteMirroringDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// ServerTlsPolicy is a resource that specifies how a server should authenticate
/// incoming requests. This resource itself does not affect configuration unless
/// it is attached to a target HTTPS proxy or endpoint config selector resource.
///
/// ServerTlsPolicy in the form accepted by Application Load Balancers can
/// be attached only to TargetHttpsProxy with an `EXTERNAL`, `EXTERNAL_MANAGED`
/// or `INTERNAL_MANAGED` load balancing scheme. Traffic Director compatible
/// ServerTlsPolicies can be attached to EndpointPolicy and TargetHttpsProxy with
/// Traffic Director `INTERNAL_SELF_MANAGED` load balancing scheme.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerTlsPolicy {
    /// Required. Name of the ServerTlsPolicy resource. It matches the pattern
    /// `projects/*/locations/{location}/serverTlsPolicies/{server_tls_policy}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Free-text description of the resource.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Set of label tags associated with the resource.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// This field applies only for Traffic Director policies. It is must be set to
    /// false for Application Load Balancer policies.
    ///
    /// Determines if server allows plaintext connections. If set to true, server
    /// allows plain text connections. By default, it is set to false. This setting
    /// is not exclusive of other encryption modes. For example, if `allow_open`
    /// and `mtls_policy` are set, server allows both plain text and mTLS
    /// connections. See documentation of other encryption modes to confirm
    /// compatibility.
    ///
    /// Consider using it if you wish to upgrade in place your deployment to TLS
    /// while having mixed TLS and non-TLS traffic reaching port :80.
    #[prost(bool, tag = "6")]
    pub allow_open: bool,
    /// Optional if policy is to be used with Traffic Director. For Application
    /// Load Balancers must be empty.
    ///
    /// Defines a mechanism to provision server identity (public and private keys).
    /// Cannot be combined with `allow_open` as a permissive mode that allows both
    /// plain text and TLS is not supported.
    #[prost(message, optional, tag = "7")]
    pub server_certificate: ::core::option::Option<CertificateProvider>,
    /// This field is required if the policy is used with Application Load
    /// Balancers. This field can be empty for Traffic Director.
    ///
    /// Defines a mechanism to provision peer validation certificates for peer to
    /// peer authentication (Mutual TLS - mTLS). If not specified, client
    /// certificate will not be requested. The connection is treated as TLS and not
    /// mTLS. If `allow_open` and `mtls_policy` are set, server allows both plain
    /// text and mTLS connections.
    #[prost(message, optional, tag = "8")]
    pub mtls_policy: ::core::option::Option<server_tls_policy::MtlsPolicy>,
}
/// Nested message and enum types in `ServerTlsPolicy`.
pub mod server_tls_policy {
    /// Specification of the MTLSPolicy.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MtlsPolicy {
        /// When the client presents an invalid certificate or no certificate to the
        /// load balancer, the `client_validation_mode` specifies how the client
        /// connection is handled.
        ///
        /// Required if the policy is to be used with the Application Load
        /// Balancers. For Traffic Director it must be empty.
        #[prost(enumeration = "mtls_policy::ClientValidationMode", tag = "2")]
        pub client_validation_mode: i32,
        /// Required if the policy is to be used with Traffic Director. For
        /// Application Load Balancers it must be empty.
        ///
        /// Defines the mechanism to obtain the Certificate Authority certificate to
        /// validate the client certificate.
        #[prost(message, repeated, tag = "1")]
        pub client_validation_ca: ::prost::alloc::vec::Vec<super::ValidationCa>,
        /// Reference to the TrustConfig from certificatemanager.googleapis.com
        /// namespace.
        ///
        /// If specified, the chain validation will be performed against certificates
        /// configured in the given TrustConfig.
        ///
        /// Allowed only if the policy is to be used with Application Load
        /// Balancers.
        #[prost(string, tag = "4")]
        pub client_validation_trust_config: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `MTLSPolicy`.
    pub mod mtls_policy {
        /// Mutual TLS certificate validation mode.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ClientValidationMode {
            /// Not allowed.
            Unspecified = 0,
            /// Allow connection even if certificate chain validation
            /// of the client certificate failed or no client certificate was
            /// presented. The proof of possession of the private key is always checked
            /// if client certificate was presented. This mode requires the backend to
            /// implement processing of data extracted from a client certificate to
            /// authenticate the peer, or to reject connections if the client
            /// certificate fingerprint is missing.
            AllowInvalidOrMissingClientCert = 1,
            /// Require a client certificate and allow connection to the backend only
            /// if validation of the client certificate passed.
            ///
            /// If set, requires a reference to non-empty TrustConfig specified in
            /// `client_validation_trust_config`.
            RejectInvalid = 2,
        }
        impl ClientValidationMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "CLIENT_VALIDATION_MODE_UNSPECIFIED",
                    Self::AllowInvalidOrMissingClientCert => {
                        "ALLOW_INVALID_OR_MISSING_CLIENT_CERT"
                    }
                    Self::RejectInvalid => "REJECT_INVALID",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CLIENT_VALIDATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ALLOW_INVALID_OR_MISSING_CLIENT_CERT" => {
                        Some(Self::AllowInvalidOrMissingClientCert)
                    }
                    "REJECT_INVALID" => Some(Self::RejectInvalid),
                    _ => None,
                }
            }
        }
    }
}
/// Request used by the ListServerTlsPolicies method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListServerTlsPoliciesRequest {
    /// Required. The project and location from which the ServerTlsPolicies should
    /// be listed, specified in the format `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of ServerTlsPolicies to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListServerTlsPoliciesResponse`
    /// Indicates that this is a continuation of a prior
    /// `ListServerTlsPolicies` call, and that the system
    /// should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Setting this field to `true` will opt the request into returning
    /// the resources that are reachable, and into including the names of those
    /// that were unreachable in the \[ListServerTlsPoliciesResponse.unreachable\]
    /// field. This can only be `true` when reading across collections e.g. when
    /// `parent` is set to `"projects/example/locations/-"`.
    #[prost(bool, tag = "4")]
    pub return_partial_success: bool,
}
/// Response returned by the ListServerTlsPolicies method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServerTlsPoliciesResponse {
    /// List of ServerTlsPolicy resources.
    #[prost(message, repeated, tag = "1")]
    pub server_tls_policies: ::prost::alloc::vec::Vec<ServerTlsPolicy>,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unreachable resources. Populated when the request opts into
    /// `return_partial_success` and reading across collections e.g. when
    /// attempting to list all resources across all supported locations.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the GetServerTlsPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetServerTlsPolicyRequest {
    /// Required. A name of the ServerTlsPolicy to get. Must be in the format
    /// `projects/*/locations/{location}/serverTlsPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateServerTlsPolicy method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateServerTlsPolicyRequest {
    /// Required. The parent resource of the ServerTlsPolicy. Must be in
    /// the format `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the ServerTlsPolicy resource to be created. This
    /// value should be 1-63 characters long, containing only letters, numbers,
    /// hyphens, and underscores, and should not start with a number. E.g.
    /// "server_mtls_policy".
    #[prost(string, tag = "2")]
    pub server_tls_policy_id: ::prost::alloc::string::String,
    /// Required. ServerTlsPolicy resource to be created.
    #[prost(message, optional, tag = "3")]
    pub server_tls_policy: ::core::option::Option<ServerTlsPolicy>,
}
/// Request used by UpdateServerTlsPolicy method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServerTlsPolicyRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// ServerTlsPolicy resource by the update.  The fields
    /// specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the
    /// mask. If the user does not provide a mask then all fields will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated ServerTlsPolicy resource.
    #[prost(message, optional, tag = "2")]
    pub server_tls_policy: ::core::option::Option<ServerTlsPolicy>,
}
/// Request used by the DeleteServerTlsPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteServerTlsPolicyRequest {
    /// Required. A name of the ServerTlsPolicy to delete. Must be in
    /// the format `projects/*/locations/{location}/serverTlsPolicies/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The TlsInspectionPolicy resource contains references to CA pools in
/// Certificate Authority Service and associated metadata.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TlsInspectionPolicy {
    /// Required. Name of the resource. Name is of the form
    /// projects/{project}/locations/{location}/tlsInspectionPolicies/{tls_inspection_policy}
    /// tls_inspection_policy should match the
    /// pattern:(^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. A CA pool resource used to issue interception certificates.
    /// The CA pool string has a relative resource path following the form
    /// "projects/{project}/locations/{location}/caPools/{ca_pool}".
    #[prost(string, tag = "5")]
    pub ca_pool: ::prost::alloc::string::String,
    /// Optional. A TrustConfig resource used when making a connection to the TLS
    /// server. This is a relative resource path following the form
    /// "projects/{project}/locations/{location}/trustConfigs/{trust_config}". This
    /// is necessary to intercept TLS connections to servers with certificates
    /// signed by a private CA or self-signed certificates.
    /// Note that Secure Web Proxy does not yet honor this field.
    #[prost(string, tag = "6")]
    pub trust_config: ::prost::alloc::string::String,
    /// Optional. If  FALSE (the default), use our default set of public CAs in
    /// addition to any CAs specified in trust_config. These public CAs are
    /// currently based on the Mozilla Root Program and are subject to change over
    /// time. If TRUE, do not accept our default set of public CAs. Only CAs
    /// specified in trust_config will be accepted. This defaults to FALSE (use
    /// public CAs in addition to trust_config) for backwards compatibility, but
    /// trusting public root CAs is *not recommended* unless the traffic in
    /// question is outbound to public web servers. When possible, prefer setting
    /// this to "false" and explicitly specifying trusted CAs and certificates in a
    /// TrustConfig. Note that Secure Web Proxy does not yet honor this field.
    #[prost(bool, optional, tag = "7")]
    pub exclude_public_ca_set: ::core::option::Option<bool>,
    /// Optional. Minimum TLS version that the firewall should use when negotiating
    /// connections with both clients and servers. If this is not set, then the
    /// default value is to allow the broadest set of clients and servers (TLS 1.0
    /// or higher). Setting this to more restrictive values may improve security,
    /// but may also prevent the firewall from connecting to some clients or
    /// servers.
    /// Note that Secure Web Proxy does not yet honor this field.
    #[prost(enumeration = "tls_inspection_policy::TlsVersion", tag = "8")]
    pub min_tls_version: i32,
    /// Optional. The selected Profile. If this is not set, then the default value
    /// is to allow the broadest set of clients and servers ("PROFILE_COMPATIBLE").
    /// Setting this to more restrictive values may improve security, but may also
    /// prevent the TLS inspection proxy from connecting to some clients or
    /// servers. Note that Secure Web Proxy does not yet honor this field.
    #[prost(enumeration = "tls_inspection_policy::Profile", tag = "9")]
    pub tls_feature_profile: i32,
    /// Optional. List of custom TLS cipher suites selected.
    /// This field is valid only if the selected tls_feature_profile is CUSTOM.
    /// The \[compute.SslPoliciesService.ListAvailableFeatures\]\[\] method returns the
    /// set of features that can be specified in this list.
    /// Note that Secure Web Proxy does not yet honor this field.
    #[prost(string, repeated, tag = "10")]
    pub custom_tls_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TlsInspectionPolicy`.
pub mod tls_inspection_policy {
    /// The minimum version of TLS protocol that can be used by clients or servers
    /// to establish a connection with the TLS inspection proxy.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TlsVersion {
        /// Indicates no TLS version was specified.
        Unspecified = 0,
        /// TLS 1.0
        Tls10 = 1,
        /// TLS 1.1
        Tls11 = 2,
        /// TLS 1.2
        Tls12 = 3,
        /// TLS 1.3
        Tls13 = 4,
    }
    impl TlsVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TLS_VERSION_UNSPECIFIED",
                Self::Tls10 => "TLS_1_0",
                Self::Tls11 => "TLS_1_1",
                Self::Tls12 => "TLS_1_2",
                Self::Tls13 => "TLS_1_3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TLS_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "TLS_1_0" => Some(Self::Tls10),
                "TLS_1_1" => Some(Self::Tls11),
                "TLS_1_2" => Some(Self::Tls12),
                "TLS_1_3" => Some(Self::Tls13),
                _ => None,
            }
        }
    }
    /// Profile specifies the set of TLS cipher suites (and possibly
    /// other features in the future) that can be used by the firewall when
    /// negotiating TLS connections with clients and servers. The meaning of these
    /// fields is identical to the load balancers' SSLPolicy resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Profile {
        /// Indicates no profile was specified.
        Unspecified = 0,
        /// Compatible profile. Allows the broadest set of clients, even those
        /// which support only out-of-date SSL features to negotiate with the TLS
        /// inspection proxy.
        Compatible = 1,
        /// Modern profile. Supports a wide set of SSL features, allowing modern
        /// clients to negotiate SSL with the TLS inspection proxy.
        Modern = 2,
        /// Restricted profile. Supports a reduced set of SSL features, intended to
        /// meet stricter compliance requirements.
        Restricted = 3,
        /// Custom profile. Allow only the set of allowed SSL features specified in
        /// the custom_features field of SslPolicy.
        Custom = 4,
    }
    impl Profile {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROFILE_UNSPECIFIED",
                Self::Compatible => "PROFILE_COMPATIBLE",
                Self::Modern => "PROFILE_MODERN",
                Self::Restricted => "PROFILE_RESTRICTED",
                Self::Custom => "PROFILE_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROFILE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROFILE_COMPATIBLE" => Some(Self::Compatible),
                "PROFILE_MODERN" => Some(Self::Modern),
                "PROFILE_RESTRICTED" => Some(Self::Restricted),
                "PROFILE_CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// Request used by the CreateTlsInspectionPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTlsInspectionPolicyRequest {
    /// Required. The parent resource of the TlsInspectionPolicy. Must be in the
    /// format `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the TlsInspectionPolicy resource to be created.
    /// This value should be 1-63 characters long, containing only
    /// letters, numbers, hyphens, and underscores, and should not start
    /// with a number. E.g. "tls_inspection_policy1".
    #[prost(string, tag = "2")]
    pub tls_inspection_policy_id: ::prost::alloc::string::String,
    /// Required. TlsInspectionPolicy resource to be created.
    #[prost(message, optional, tag = "3")]
    pub tls_inspection_policy: ::core::option::Option<TlsInspectionPolicy>,
}
/// Request used with the ListTlsInspectionPolicies method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTlsInspectionPoliciesRequest {
    /// Required. The project and location from which the TlsInspectionPolicies
    /// should be listed, specified in the format
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of TlsInspectionPolicies to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last
    /// 'ListTlsInspectionPoliciesResponse' Indicates that this is a
    /// continuation of a prior 'ListTlsInspectionPolicies' call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListTlsInspectionPolicies method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTlsInspectionPoliciesResponse {
    /// List of TlsInspectionPolicies resources.
    #[prost(message, repeated, tag = "1")]
    pub tls_inspection_policies: ::prost::alloc::vec::Vec<TlsInspectionPolicy>,
    /// If there might be more results than those appearing in this response, then
    /// 'next_page_token' is included. To get the next set of results, call this
    /// method again using the value of 'next_page_token' as 'page_token'.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the GetTlsInspectionPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTlsInspectionPolicyRequest {
    /// Required. A name of the TlsInspectionPolicy to get. Must be in the format
    /// `projects/{project}/locations/{location}/tlsInspectionPolicies/{tls_inspection_policy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the DeleteTlsInspectionPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteTlsInspectionPolicyRequest {
    /// Required. A name of the TlsInspectionPolicy to delete. Must be in the
    /// format
    /// `projects/{project}/locations/{location}/tlsInspectionPolicies/{tls_inspection_policy}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// If set to true, any rules for this TlsInspectionPolicy will also be
    /// deleted. (Otherwise, the request will only work if the TlsInspectionPolicy
    /// has no rules.)
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// Request used by the UpdateTlsInspectionPolicy method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateTlsInspectionPolicyRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// TlsInspectionPolicy resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated TlsInspectionPolicy resource.
    #[prost(message, optional, tag = "2")]
    pub tls_inspection_policy: ::core::option::Option<TlsInspectionPolicy>,
}
/// UrlList proto helps users to set reusable, independently manageable lists
/// of hosts, host patterns, URLs, URL patterns.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UrlList {
    /// Required. Name of the resource provided by the user.
    /// Name is of the form
    /// projects/{project}/locations/{location}/urlLists/{url_list}
    /// url_list should match the
    /// pattern:(^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when the security policy was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the security policy was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Free-text description of the resource.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Required. FQDNs and URLs.
    #[prost(string, repeated, tag = "5")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the ListUrlList method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListUrlListsRequest {
    /// Required. The project and location from which the UrlLists should
    /// be listed, specified in the format
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of UrlLists to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last `ListUrlListsResponse`
    /// Indicates that this is a continuation of a prior
    /// `ListUrlLists` call, and that the system
    /// should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListUrlLists method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUrlListsResponse {
    /// List of UrlList resources.
    #[prost(message, repeated, tag = "1")]
    pub url_lists: ::prost::alloc::vec::Vec<UrlList>,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request used by the GetUrlList method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetUrlListRequest {
    /// Required. A name of the UrlList to get. Must be in the format
    /// `projects/*/locations/{location}/urlLists/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateUrlList method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateUrlListRequest {
    /// Required. The parent resource of the UrlList. Must be in
    /// the format `projects/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the UrlList resource to be created. This value
    /// should be 1-63 characters long, containing only letters, numbers, hyphens,
    /// and underscores, and should not start with a number. E.g. "url_list".
    #[prost(string, tag = "2")]
    pub url_list_id: ::prost::alloc::string::String,
    /// Required. UrlList resource to be created.
    #[prost(message, optional, tag = "3")]
    pub url_list: ::core::option::Option<UrlList>,
}
/// Request used by UpdateUrlList method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateUrlListRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// UrlList resource by the update.  The fields
    /// specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the
    /// mask. If the user does not provide a mask then all fields will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated UrlList resource.
    #[prost(message, optional, tag = "2")]
    pub url_list: ::core::option::Option<UrlList>,
}
/// Request used by the DeleteUrlList method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteUrlListRequest {
    /// Required. A name of the UrlList to delete. Must be in
    /// the format `projects/*/locations/{location}/urlLists/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod network_security_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Network Security API provides resources to configure authentication and
    /// authorization policies. Refer to per API resource documentation for more
    /// information.
    #[derive(Debug, Clone)]
    pub struct NetworkSecurityClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NetworkSecurityClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NetworkSecurityClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkSecurityClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NetworkSecurityClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists AuthorizationPolicies in a given project and location.
        pub async fn list_authorization_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAuthorizationPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAuthorizationPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListAuthorizationPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListAuthorizationPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single AuthorizationPolicy.
        pub async fn get_authorization_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAuthorizationPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AuthorizationPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetAuthorizationPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetAuthorizationPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new AuthorizationPolicy in a given project and location.
        pub async fn create_authorization_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAuthorizationPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateAuthorizationPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateAuthorizationPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single AuthorizationPolicy.
        pub async fn update_authorization_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAuthorizationPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateAuthorizationPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateAuthorizationPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single AuthorizationPolicy.
        pub async fn delete_authorization_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAuthorizationPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteAuthorizationPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteAuthorizationPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists BackendAuthenticationConfigs in a given project and location.
        pub async fn list_backend_authentication_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListBackendAuthenticationConfigsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListBackendAuthenticationConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListBackendAuthenticationConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListBackendAuthenticationConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single BackendAuthenticationConfig to
        /// BackendAuthenticationConfig.
        pub async fn get_backend_authentication_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetBackendAuthenticationConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BackendAuthenticationConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetBackendAuthenticationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetBackendAuthenticationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new BackendAuthenticationConfig in a given project and location.
        pub async fn create_backend_authentication_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateBackendAuthenticationConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateBackendAuthenticationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateBackendAuthenticationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single BackendAuthenticationConfig to
        /// BackendAuthenticationConfig.
        pub async fn update_backend_authentication_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateBackendAuthenticationConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateBackendAuthenticationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateBackendAuthenticationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single BackendAuthenticationConfig to
        /// BackendAuthenticationConfig.
        pub async fn delete_backend_authentication_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteBackendAuthenticationConfigRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteBackendAuthenticationConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteBackendAuthenticationConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists ServerTlsPolicies in a given project and location.
        pub async fn list_server_tls_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListServerTlsPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListServerTlsPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListServerTlsPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListServerTlsPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ServerTlsPolicy.
        pub async fn get_server_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServerTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServerTlsPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetServerTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetServerTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ServerTlsPolicy in a given project and location.
        pub async fn create_server_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateServerTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateServerTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateServerTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single ServerTlsPolicy.
        pub async fn update_server_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServerTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateServerTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateServerTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ServerTlsPolicy.
        pub async fn delete_server_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServerTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteServerTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteServerTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists ClientTlsPolicies in a given project and location.
        pub async fn list_client_tls_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClientTlsPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClientTlsPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListClientTlsPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListClientTlsPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ClientTlsPolicy.
        pub async fn get_client_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClientTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ClientTlsPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetClientTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetClientTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ClientTlsPolicy in a given project and location.
        pub async fn create_client_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateClientTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateClientTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateClientTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single ClientTlsPolicy.
        pub async fn update_client_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateClientTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateClientTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateClientTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ClientTlsPolicy.
        pub async fn delete_client_tls_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteClientTlsPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteClientTlsPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteClientTlsPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists GatewaySecurityPolicies in a given project and location.
        pub async fn list_gateway_security_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGatewaySecurityPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGatewaySecurityPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListGatewaySecurityPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListGatewaySecurityPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single GatewaySecurityPolicy.
        pub async fn get_gateway_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGatewaySecurityPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GatewaySecurityPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetGatewaySecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetGatewaySecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new GatewaySecurityPolicy in a given project and location.
        pub async fn create_gateway_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateGatewaySecurityPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateGatewaySecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateGatewaySecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single GatewaySecurityPolicy.
        pub async fn update_gateway_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateGatewaySecurityPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateGatewaySecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateGatewaySecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single GatewaySecurityPolicy.
        pub async fn delete_gateway_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGatewaySecurityPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteGatewaySecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteGatewaySecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists GatewaySecurityPolicyRules in a given project and location.
        pub async fn list_gateway_security_policy_rules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListGatewaySecurityPolicyRulesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListGatewaySecurityPolicyRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListGatewaySecurityPolicyRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListGatewaySecurityPolicyRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single GatewaySecurityPolicyRule.
        pub async fn get_gateway_security_policy_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGatewaySecurityPolicyRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GatewaySecurityPolicyRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetGatewaySecurityPolicyRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetGatewaySecurityPolicyRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new GatewaySecurityPolicy in a given project and location.
        pub async fn create_gateway_security_policy_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateGatewaySecurityPolicyRuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateGatewaySecurityPolicyRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateGatewaySecurityPolicyRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single GatewaySecurityPolicyRule.
        pub async fn update_gateway_security_policy_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateGatewaySecurityPolicyRuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateGatewaySecurityPolicyRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateGatewaySecurityPolicyRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single GatewaySecurityPolicyRule.
        pub async fn delete_gateway_security_policy_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteGatewaySecurityPolicyRuleRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteGatewaySecurityPolicyRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteGatewaySecurityPolicyRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists UrlLists in a given project and location.
        pub async fn list_url_lists(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUrlListsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUrlListsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListUrlLists",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListUrlLists",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single UrlList.
        pub async fn get_url_list(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUrlListRequest>,
        ) -> std::result::Result<tonic::Response<super::UrlList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetUrlList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetUrlList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new UrlList in a given project and location.
        pub async fn create_url_list(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUrlListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateUrlList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateUrlList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single UrlList.
        pub async fn update_url_list(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUrlListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateUrlList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateUrlList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single UrlList.
        pub async fn delete_url_list(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUrlListRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteUrlList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteUrlList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists TlsInspectionPolicies in a given project and location.
        pub async fn list_tls_inspection_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTlsInspectionPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTlsInspectionPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListTlsInspectionPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListTlsInspectionPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single TlsInspectionPolicy.
        pub async fn get_tls_inspection_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTlsInspectionPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TlsInspectionPolicy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetTlsInspectionPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetTlsInspectionPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new TlsInspectionPolicy in a given project and location.
        pub async fn create_tls_inspection_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTlsInspectionPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateTlsInspectionPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateTlsInspectionPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single TlsInspectionPolicy.
        pub async fn update_tls_inspection_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTlsInspectionPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateTlsInspectionPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateTlsInspectionPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single TlsInspectionPolicy.
        pub async fn delete_tls_inspection_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTlsInspectionPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteTlsInspectionPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteTlsInspectionPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists AuthzPolicies in a given project and location.
        pub async fn list_authz_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAuthzPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAuthzPoliciesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/ListAuthzPolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "ListAuthzPolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single AuthzPolicy.
        pub async fn get_authz_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAuthzPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::AuthzPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/GetAuthzPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "GetAuthzPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new AuthzPolicy in a given project and location.
        pub async fn create_authz_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAuthzPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/CreateAuthzPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "CreateAuthzPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single AuthzPolicy.
        pub async fn update_authz_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAuthzPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/UpdateAuthzPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "UpdateAuthzPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single AuthzPolicy.
        pub async fn delete_authz_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAuthzPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.NetworkSecurity/DeleteAuthzPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.NetworkSecurity",
                        "DeleteAuthzPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// CustomInterceptProfile defines in-band integration behavior (intercept).
/// It is used by firewall rules with an APPLY_SECURITY_PROFILE_GROUP action.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomInterceptProfile {
    /// Required. The target InterceptEndpointGroup.
    /// When a firewall rule with this security profile attached matches a packet,
    /// the packet will be intercepted to the location-local target in this group.
    #[prost(string, tag = "1")]
    pub intercept_endpoint_group: ::prost::alloc::string::String,
}
/// CustomMirroringProfile defines out-of-band integration behavior (mirroring).
/// It is used by mirroring rules with a MIRROR action.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomMirroringProfile {
    /// Required. Immutable. The target MirroringEndpointGroup.
    /// When a mirroring rule with this security profile attached matches a packet,
    /// a replica will be mirrored to the location-local target in this group.
    #[prost(string, tag = "1")]
    pub mirroring_endpoint_group: ::prost::alloc::string::String,
}
/// ThreatPreventionProfile defines an action for specific threat signatures or
/// severity levels.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThreatPreventionProfile {
    /// Optional. Configuration for overriding threats actions by severity match.
    #[prost(message, repeated, tag = "1")]
    pub severity_overrides: ::prost::alloc::vec::Vec<SeverityOverride>,
    /// Optional. Configuration for overriding threats actions by threat_id match.
    /// If a threat is matched both by configuration provided in severity_overrides
    /// and threat_overrides, the threat_overrides action is applied.
    #[prost(message, repeated, tag = "2")]
    pub threat_overrides: ::prost::alloc::vec::Vec<ThreatOverride>,
    /// Optional. Configuration for overriding antivirus actions per protocol.
    #[prost(message, repeated, tag = "4")]
    pub antivirus_overrides: ::prost::alloc::vec::Vec<AntivirusOverride>,
}
/// Defines what action to take for a specific severity match.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SeverityOverride {
    /// Required. Severity level to match.
    #[prost(enumeration = "Severity", tag = "1")]
    pub severity: i32,
    /// Required. Threat action override.
    #[prost(enumeration = "ThreatAction", tag = "2")]
    pub action: i32,
}
/// Defines what action to take for a specific threat_id match.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ThreatOverride {
    /// Required. Vendor-specific ID of a threat to override.
    #[prost(string, tag = "1")]
    pub threat_id: ::prost::alloc::string::String,
    /// Output only. Type of the threat (read only).
    #[prost(enumeration = "ThreatType", tag = "2")]
    pub r#type: i32,
    /// Required. Threat action override. For some threat types, only a subset of
    /// actions applies.
    #[prost(enumeration = "ThreatAction", tag = "3")]
    pub action: i32,
}
/// Defines what action to take for antivirus threats per protocol.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AntivirusOverride {
    /// Required. Protocol to match.
    #[prost(enumeration = "Protocol", tag = "1")]
    pub protocol: i32,
    /// Required. Threat action override. For some threat types, only a subset of
    /// actions applies.
    #[prost(enumeration = "ThreatAction", tag = "2")]
    pub action: i32,
}
/// Severity level.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// Severity level not specified.
    Unspecified = 0,
    /// Suspicious events that do not pose an immediate threat, but that are
    /// reported to call attention to deeper problems that could possibly exist.
    Informational = 1,
    /// Warning-level threats that have very little impact on an organization's
    /// infrastructure. They usually require local or physical system access and
    /// may often result in victim privacy issues and information leakage.
    Low = 2,
    /// Minor threats in which impact is minimized, that do not compromise the
    /// target or exploits that require an attacker to reside on the same local
    /// network as the victim, affect only non-standard configurations or obscure
    /// applications, or provide very limited access.
    Medium = 3,
    /// Threats that have the ability to become critical but have mitigating
    /// factors; for example, they may be difficult to exploit, do not result in
    /// elevated privileges, or do not have a large victim pool.
    High = 4,
    /// Serious threats, such as those that affect default installations of widely
    /// deployed software, result in root compromise of servers, and the exploit
    /// code is widely available to attackers. The attacker usually does not need
    /// any special authentication credentials or knowledge about the individual
    /// victims and the target does not need to be manipulated into performing any
    /// special functions.
    Critical = 5,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Informational => "INFORMATIONAL",
            Self::Low => "LOW",
            Self::Medium => "MEDIUM",
            Self::High => "HIGH",
            Self::Critical => "CRITICAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "INFORMATIONAL" => Some(Self::Informational),
            "LOW" => Some(Self::Low),
            "MEDIUM" => Some(Self::Medium),
            "HIGH" => Some(Self::High),
            "CRITICAL" => Some(Self::Critical),
            _ => None,
        }
    }
}
/// Type of threat.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreatType {
    /// Type of threat not specified.
    Unspecified = 0,
    /// Type of threat is not derivable from threat ID. An override will be
    /// created for all types. Firewall will ignore overridden signature ID's
    /// that don't exist in the specific type.
    Unknown = 1,
    /// Threats related to system flaws that an attacker might otherwise attempt
    /// to exploit.
    Vulnerability = 2,
    /// Threats related to viruses and malware found in executables and file
    /// types.
    Antivirus = 3,
    /// Threats related to command-and-control (C2) activity, where spyware on an
    /// infected client is collecting data without the user's consent and/or
    /// communicating with a remote attacker.
    Spyware = 4,
    /// Threats related to DNS.
    Dns = 5,
}
impl ThreatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "THREAT_TYPE_UNSPECIFIED",
            Self::Unknown => "UNKNOWN",
            Self::Vulnerability => "VULNERABILITY",
            Self::Antivirus => "ANTIVIRUS",
            Self::Spyware => "SPYWARE",
            Self::Dns => "DNS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THREAT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "UNKNOWN" => Some(Self::Unknown),
            "VULNERABILITY" => Some(Self::Vulnerability),
            "ANTIVIRUS" => Some(Self::Antivirus),
            "SPYWARE" => Some(Self::Spyware),
            "DNS" => Some(Self::Dns),
            _ => None,
        }
    }
}
/// Threat action override.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreatAction {
    /// Threat action not specified.
    Unspecified = 0,
    /// The default action (as specified by the vendor) is taken.
    DefaultAction = 4,
    /// The packet matching this rule will be allowed to transmit.
    Allow = 1,
    /// The packet matching this rule will be allowed to transmit, but a threat_log
    /// entry will be sent to the consumer project.
    Alert = 2,
    /// The packet matching this rule will be dropped, and a threat_log entry will
    /// be sent to the consumer project.
    Deny = 3,
}
impl ThreatAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "THREAT_ACTION_UNSPECIFIED",
            Self::DefaultAction => "DEFAULT_ACTION",
            Self::Allow => "ALLOW",
            Self::Alert => "ALERT",
            Self::Deny => "DENY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THREAT_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "DEFAULT_ACTION" => Some(Self::DefaultAction),
            "ALLOW" => Some(Self::Allow),
            "ALERT" => Some(Self::Alert),
            "DENY" => Some(Self::Deny),
            _ => None,
        }
    }
}
/// Antivirus protocol.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Protocol {
    /// Protocol not specified.
    Unspecified = 0,
    /// SMTP protocol
    Smtp = 1,
    /// SMB protocol
    Smb = 2,
    /// POP3 protocol
    Pop3 = 3,
    /// IMAP protocol
    Imap = 4,
    /// HTTP2 protocol
    Http2 = 5,
    /// HTTP protocol
    Http = 6,
    /// FTP protocol
    Ftp = 7,
}
impl Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTOCOL_UNSPECIFIED",
            Self::Smtp => "SMTP",
            Self::Smb => "SMB",
            Self::Pop3 => "POP3",
            Self::Imap => "IMAP",
            Self::Http2 => "HTTP2",
            Self::Http => "HTTP",
            Self::Ftp => "FTP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
            "SMTP" => Some(Self::Smtp),
            "SMB" => Some(Self::Smb),
            "POP3" => Some(Self::Pop3),
            "IMAP" => Some(Self::Imap),
            "HTTP2" => Some(Self::Http2),
            "HTTP" => Some(Self::Http),
            "FTP" => Some(Self::Ftp),
            _ => None,
        }
    }
}
/// UrlFilteringProfile defines filters based on URL.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlFilteringProfile {
    /// Optional. The list of filtering configs in which each config defines an
    /// action to take for some URL match.
    #[prost(message, repeated, tag = "1")]
    pub url_filters: ::prost::alloc::vec::Vec<UrlFilter>,
}
/// A URL filter defines an action to take for some URL match.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UrlFilter {
    /// Required. The action taken when this filter is applied.
    #[prost(enumeration = "url_filter::UrlFilteringAction", tag = "1")]
    pub filtering_action: i32,
    /// Required. The list of strings that a URL must match with for this filter to
    /// be applied.
    #[prost(string, repeated, tag = "2")]
    pub urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. The priority of this filter within the URL Filtering Profile.
    /// Lower integers indicate higher priorities. The priority of a filter must be
    /// unique within a URL Filtering Profile.
    #[prost(int32, optional, tag = "3")]
    pub priority: ::core::option::Option<i32>,
}
/// Nested message and enum types in `UrlFilter`.
pub mod url_filter {
    /// Action to be taken when a URL matches a filter.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UrlFilteringAction {
        /// Filtering action not specified.
        Unspecified = 0,
        /// The connection matching this filter will be allowed to transmit.
        Allow = 1,
        /// The connection matching this filter will be dropped.
        Deny = 2,
    }
    impl UrlFilteringAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "URL_FILTERING_ACTION_UNSPECIFIED",
                Self::Allow => "ALLOW",
                Self::Deny => "DENY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "URL_FILTERING_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                _ => None,
            }
        }
    }
}
/// SecurityProfileGroup is a resource that defines the behavior for various
/// ProfileTypes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityProfileGroup {
    /// Immutable. Identifier. Name of the SecurityProfileGroup resource. It
    /// matches pattern
    /// `projects|organizations/*/locations/{location}/securityProfileGroups/{security_profile_group}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional description of the profile group. Max length 2048
    /// characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Resource creation timestamp.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last resource update timestamp.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. Identifier used by the data-path. Unique within {container,
    /// location}.
    #[prost(uint64, tag = "12")]
    pub data_path_id: u64,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Reference to a SecurityProfile with the ThreatPrevention
    /// configuration.
    #[prost(string, tag = "6")]
    pub threat_prevention_profile: ::prost::alloc::string::String,
    /// Optional. Reference to a SecurityProfile with the CustomMirroring
    /// configuration.
    #[prost(string, tag = "8")]
    pub custom_mirroring_profile: ::prost::alloc::string::String,
    /// Optional. Reference to a SecurityProfile with the CustomIntercept
    /// configuration.
    #[prost(string, tag = "9")]
    pub custom_intercept_profile: ::prost::alloc::string::String,
    /// Optional. Reference to a SecurityProfile with the UrlFiltering
    /// configuration.
    #[prost(string, tag = "11")]
    pub url_filtering_profile: ::prost::alloc::string::String,
}
/// SecurityProfile is a resource that defines the behavior for one of many
/// ProfileTypes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityProfile {
    /// Immutable. Identifier. Name of the SecurityProfile resource. It matches
    /// pattern
    /// `projects|organizations/*/locations/{location}/securityProfiles/{security_profile}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional description of the profile. Max length 512
    /// characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Resource creation timestamp.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last resource update timestamp.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "5")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. The single ProfileType that the SecurityProfile resource
    /// configures.
    #[prost(enumeration = "security_profile::ProfileType", tag = "6")]
    pub r#type: i32,
    /// The behavior for the ProfileType that the SecurityProfile resource is meant
    /// to configure. This field must correspond to the ProfileType of the
    /// SecurityProfile.
    #[prost(oneof = "security_profile::Profile", tags = "7, 9, 10, 12")]
    pub profile: ::core::option::Option<security_profile::Profile>,
}
/// Nested message and enum types in `SecurityProfile`.
pub mod security_profile {
    /// The possible types that the SecurityProfile resource can configure.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProfileType {
        /// Profile type not specified.
        Unspecified = 0,
        /// Profile type for threat prevention.
        ThreatPrevention = 1,
        /// Profile type for packet mirroring v2
        CustomMirroring = 2,
        /// Profile type for TPPI.
        CustomIntercept = 3,
        /// Profile type for URL filtering.
        UrlFiltering = 5,
    }
    impl ProfileType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROFILE_TYPE_UNSPECIFIED",
                Self::ThreatPrevention => "THREAT_PREVENTION",
                Self::CustomMirroring => "CUSTOM_MIRRORING",
                Self::CustomIntercept => "CUSTOM_INTERCEPT",
                Self::UrlFiltering => "URL_FILTERING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROFILE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "THREAT_PREVENTION" => Some(Self::ThreatPrevention),
                "CUSTOM_MIRRORING" => Some(Self::CustomMirroring),
                "CUSTOM_INTERCEPT" => Some(Self::CustomIntercept),
                "URL_FILTERING" => Some(Self::UrlFiltering),
                _ => None,
            }
        }
    }
    /// The behavior for the ProfileType that the SecurityProfile resource is meant
    /// to configure. This field must correspond to the ProfileType of the
    /// SecurityProfile.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Profile {
        /// The threat prevention configuration for the SecurityProfile.
        #[prost(message, tag = "7")]
        ThreatPreventionProfile(super::ThreatPreventionProfile),
        /// The custom Packet Mirroring v2 configuration for the SecurityProfile.
        #[prost(message, tag = "9")]
        CustomMirroringProfile(super::CustomMirroringProfile),
        /// The custom TPPI configuration for the SecurityProfile.
        #[prost(message, tag = "10")]
        CustomInterceptProfile(super::CustomInterceptProfile),
        /// The URL filtering configuration for the SecurityProfile.
        #[prost(message, tag = "12")]
        UrlFilteringProfile(super::UrlFilteringProfile),
    }
}
/// Request used with the ListSecurityProfileGroups method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSecurityProfileGroupsRequest {
    /// Required. The project or organization and location from which the
    /// SecurityProfileGroups should be listed, specified in the format
    /// `projects|organizations/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of SecurityProfileGroups to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last
    /// `ListSecurityProfileGroupsResponse` Indicates that this is a
    /// continuation of a prior `ListSecurityProfileGroups` call, and
    /// that the system should return the next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListSecurityProfileGroups method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityProfileGroupsResponse {
    /// List of SecurityProfileGroups resources.
    #[prost(message, repeated, tag = "1")]
    pub security_profile_groups: ::prost::alloc::vec::Vec<SecurityProfileGroup>,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request used by the GetSecurityProfileGroup method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSecurityProfileGroupRequest {
    /// Required. A name of the SecurityProfileGroup to get. Must be in the format
    /// `projects|organizations/*/locations/{location}/securityProfileGroups/{security_profile_group}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateSecurityProfileGroup method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSecurityProfileGroupRequest {
    /// Required. The parent resource of the SecurityProfileGroup. Must be in the
    /// format `projects|organizations/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the SecurityProfileGroup resource to be created.
    /// This value should be 1-63 characters long, containing only
    /// letters, numbers, hyphens, and underscores, and should not start
    /// with a number. E.g. "security_profile_group1".
    #[prost(string, tag = "2")]
    pub security_profile_group_id: ::prost::alloc::string::String,
    /// Required. SecurityProfileGroup resource to be created.
    #[prost(message, optional, tag = "3")]
    pub security_profile_group: ::core::option::Option<SecurityProfileGroup>,
}
/// Request used by the UpdateSecurityProfileGroup method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSecurityProfileGroupRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// SecurityProfileGroup resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated SecurityProfileGroup resource.
    #[prost(message, optional, tag = "2")]
    pub security_profile_group: ::core::option::Option<SecurityProfileGroup>,
}
/// Request used by the DeleteSecurityProfileGroup method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSecurityProfileGroupRequest {
    /// Required. A name of the SecurityProfileGroup to delete. Must be in the
    /// format
    /// `projects|organizations/*/locations/{location}/securityProfileGroups/{security_profile_group}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If client provided etag is out of date, delete will return
    /// FAILED_PRECONDITION error.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Request used with the ListSecurityProfiles method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSecurityProfilesRequest {
    /// Required. The project or organization and location from which the
    /// SecurityProfiles should be listed, specified in the format
    /// `projects|organizations/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of SecurityProfiles to return per call.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The value returned by the last
    /// `ListSecurityProfilesResponse` Indicates that this is a continuation of a
    /// prior `ListSecurityProfiles` call, and that the system should return the
    /// next page of data.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response returned by the ListSecurityProfiles method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityProfilesResponse {
    /// List of SecurityProfile resources.
    #[prost(message, repeated, tag = "1")]
    pub security_profiles: ::prost::alloc::vec::Vec<SecurityProfile>,
    /// If there might be more results than those appearing in this response, then
    /// `next_page_token` is included. To get the next set of results, call this
    /// method again using the value of `next_page_token` as `page_token`.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request used by the GetSecurityProfile method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSecurityProfileRequest {
    /// Required. A name of the SecurityProfile to get. Must be in the format
    /// `projects|organizations/*/locations/{location}/securityProfiles/{security_profile_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request used by the CreateSecurityProfile method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSecurityProfileRequest {
    /// Required. The parent resource of the SecurityProfile. Must be in the format
    /// `projects|organizations/*/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Short name of the SecurityProfile resource to be created. This
    /// value should be 1-63 characters long, containing only letters, numbers,
    /// hyphens, and underscores, and should not start with a number. E.g.
    /// "security_profile1".
    #[prost(string, tag = "2")]
    pub security_profile_id: ::prost::alloc::string::String,
    /// Required. SecurityProfile resource to be created.
    #[prost(message, optional, tag = "3")]
    pub security_profile: ::core::option::Option<SecurityProfile>,
}
/// Request used by the UpdateSecurityProfile method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSecurityProfileRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// SecurityProfile resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. Updated SecurityProfile resource.
    #[prost(message, optional, tag = "2")]
    pub security_profile: ::core::option::Option<SecurityProfile>,
}
/// Request used by the DeleteSecurityProfile method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSecurityProfileRequest {
    /// Required. A name of the SecurityProfile to delete. Must be in the format
    /// `projects|organizations/*/locations/{location}/securityProfiles/{security_profile_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If client provided etag is out of date, delete will return
    /// FAILED_PRECONDITION error.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod organization_security_profile_group_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Organization SecurityProfileGroup is created under organization.
    #[derive(Debug, Clone)]
    pub struct OrganizationSecurityProfileGroupServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OrganizationSecurityProfileGroupServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OrganizationSecurityProfileGroupServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OrganizationSecurityProfileGroupServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OrganizationSecurityProfileGroupServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists SecurityProfileGroups in a given organization and location.
        pub async fn list_security_profile_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSecurityProfileGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSecurityProfileGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/ListSecurityProfileGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "ListSecurityProfileGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single SecurityProfileGroup.
        pub async fn get_security_profile_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSecurityProfileGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SecurityProfileGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/GetSecurityProfileGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "GetSecurityProfileGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new SecurityProfileGroup in a given organization and location.
        pub async fn create_security_profile_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSecurityProfileGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/CreateSecurityProfileGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "CreateSecurityProfileGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single SecurityProfileGroup.
        pub async fn update_security_profile_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSecurityProfileGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/UpdateSecurityProfileGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "UpdateSecurityProfileGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single SecurityProfileGroup.
        pub async fn delete_security_profile_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSecurityProfileGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/DeleteSecurityProfileGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "DeleteSecurityProfileGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SecurityProfiles in a given organization and location.
        pub async fn list_security_profiles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSecurityProfilesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSecurityProfilesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/ListSecurityProfiles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "ListSecurityProfiles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single SecurityProfile.
        pub async fn get_security_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSecurityProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SecurityProfile>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/GetSecurityProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "GetSecurityProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new SecurityProfile in a given organization and location.
        pub async fn create_security_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSecurityProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/CreateSecurityProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "CreateSecurityProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single SecurityProfile.
        pub async fn update_security_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSecurityProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/UpdateSecurityProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "UpdateSecurityProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single SecurityProfile.
        pub async fn delete_security_profile(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSecurityProfileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService/DeleteSecurityProfile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.OrganizationSecurityProfileGroupService",
                        "DeleteSecurityProfile",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Message describing PartnerSSEGateway object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartnerSseGateway {
    /// Immutable. name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Subnet range of the subnet where partner traffic is routed.
    /// This field is deprecated. Use sse_subnet_range instead.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub sse_vpc_subnet_range: ::prost::alloc::string::String,
    /// Output only. This is the IP where the partner traffic should be routed to.
    /// This field is deprecated. Use sse_target_ip instead.
    #[deprecated]
    #[prost(string, tag = "6")]
    pub sse_vpc_target_ip: ::prost::alloc::string::String,
    /// Required. ID of the SSEGatewayReference that pairs with this
    /// PartnerSSEGateway
    #[prost(string, tag = "7")]
    pub sse_gateway_reference_id: ::prost::alloc::string::String,
    /// Output only. IP of SSE BGP
    #[prost(string, repeated, tag = "8")]
    pub sse_bgp_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. ASN of SSE BGP
    #[prost(int32, tag = "9")]
    pub sse_bgp_asn: i32,
    /// Optional. Subnet range of the partner_vpc
    /// This field is deprecated. Use partner_subnet_range instead.
    #[deprecated]
    #[prost(string, tag = "11")]
    pub partner_vpc_subnet_range: ::prost::alloc::string::String,
    /// Output only. name of PartnerSSERealm owning the PartnerSSEGateway
    #[prost(string, tag = "12")]
    pub partner_sse_realm: ::prost::alloc::string::String,
    /// Optional. Subnet range where SSE GW instances are deployed.
    /// Default value is set to "100.88.255.0/24".
    /// The CIDR suffix should be less than or equal to 25.
    #[prost(string, tag = "17")]
    pub sse_subnet_range: ::prost::alloc::string::String,
    /// Output only. Target IP that belongs to sse_subnet_range where partner
    /// should send the traffic to reach the customer networks.
    #[prost(string, tag = "18")]
    pub sse_target_ip: ::prost::alloc::string::String,
    /// Optional. Subnet range of the partner-owned subnet.
    #[prost(string, tag = "19")]
    pub partner_subnet_range: ::prost::alloc::string::String,
    /// Optional. Virtual Network Identifier to use in NCG.
    /// Today the only partner that depends on it is Symantec.
    #[prost(int32, tag = "20")]
    pub vni: i32,
    /// Optional. Required iff Partner is Symantec.
    #[prost(message, optional, tag = "21")]
    pub symantec_options: ::core::option::Option<
        partner_sse_gateway::PartnerSseGatewaySymantecOptions,
    >,
    /// Output only. The project owning partner_facing_network. Only filled for
    /// PartnerSSEGateways associated with Symantec today.
    #[prost(string, tag = "22")]
    pub sse_project: ::prost::alloc::string::String,
    /// Output only. The ID of the network in sse_project containing
    /// sse_subnet_range. This is also known as the partnerFacingNetwork. Only
    /// filled for PartnerSSEGateways associated with Symantec today.
    #[prost(string, tag = "23")]
    pub sse_network: ::prost::alloc::string::String,
    /// Output only. Full URI of the partner environment this PartnerSSEGateway is
    /// connected to. Filled from the customer SSEGateway, and only for
    /// PartnerSSEGateways associated with Symantec today.
    #[prost(string, tag = "24")]
    pub partner_sse_environment: ::prost::alloc::string::String,
    /// Output only. ISO-3166 alpha 2 country code used for localization.
    /// Filled from the customer SSEGateway, and only for PartnerSSEGateways
    /// associated with Symantec today.
    #[prost(string, tag = "25")]
    pub country: ::prost::alloc::string::String,
    /// Output only. tzinfo identifier used for localization.
    /// Filled from the customer SSEGateway, and only for PartnerSSEGateways
    /// associated with Symantec today.
    #[prost(string, tag = "26")]
    pub timezone: ::prost::alloc::string::String,
    /// Output only. Copied from the associated NCC resource in Symantec NCCGW
    /// flows. Used by Symantec API.
    #[prost(int64, tag = "28")]
    pub capacity_bps: i64,
    /// Output only. State of the gateway.
    #[prost(enumeration = "partner_sse_gateway::State", tag = "29")]
    pub state: i32,
    /// Output only. Subnet ranges for Google-issued probe packets.
    /// It's populated only for Prisma Access partners.
    #[prost(string, repeated, tag = "30")]
    pub prober_subnet_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PartnerSSEGateway`.
pub mod partner_sse_gateway {
    /// Options specific to gateways connected to Symantec.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PartnerSseGatewaySymantecOptions {
        /// Output only. UUID of the Symantec Location created on the customer's
        /// behalf.
        #[prost(string, tag = "1")]
        pub symantec_location_uuid: ::prost::alloc::string::String,
        /// Optional. Target for the NCGs to send traffic to on the Symantec side.
        /// Only supports IP address today.
        #[prost(string, tag = "2")]
        pub symantec_site_target_host: ::prost::alloc::string::String,
        /// Output only. Symantec data center identifier that this SSEGW will connect
        /// to. Filled from the customer SSEGateway, and only for PartnerSSEGateways
        /// associated with Symantec today.
        #[prost(string, tag = "3")]
        pub symantec_site: ::prost::alloc::string::String,
    }
    /// State of the gateway.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// No state specified. This should not be used.
        Unspecified = 0,
        /// Attached to a customer. This is the default state when a gateway is
        /// successfully created.
        CustomerAttached = 1,
        /// No longer attached to a customer. This state arises when the
        /// customer attachment is deleted.
        CustomerDetached = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::CustomerAttached => "CUSTOMER_ATTACHED",
                Self::CustomerDetached => "CUSTOMER_DETACHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOMER_ATTACHED" => Some(Self::CustomerAttached),
                "CUSTOMER_DETACHED" => Some(Self::CustomerDetached),
                _ => None,
            }
        }
    }
}
/// Message for requesting list of PartnerSSEGateways
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPartnerSseGatewaysRequest {
    /// Required. Parent value for ListPartnerSSEGatewaysRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing PartnerSSEGateways
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartnerSseGatewaysResponse {
    /// The list of PartnerSSEGateway
    #[prost(message, repeated, tag = "1")]
    pub partner_sse_gateways: ::prost::alloc::vec::Vec<PartnerSseGateway>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a PartnerSSEGateway
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPartnerSseGatewayRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a PartnerSSEGateway
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePartnerSseGatewayRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// partner_sse_gateway_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub partner_sse_gateway_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub partner_sse_gateway: ::core::option::Option<PartnerSseGateway>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a PartnerSSEGateway
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeletePartnerSseGatewayRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a PartnerSSEGateway
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePartnerSseGatewayRequest {
    /// Required. The resource being created
    #[prost(message, optional, tag = "1")]
    pub partner_sse_gateway: ::core::option::Option<PartnerSseGateway>,
    /// The list of fields to update
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message describing SSEGatewayReference object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SseGatewayReference {
    /// Immutable. name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. PartnerSSERealm owning the PartnerSSEGateway that this
    /// SSEGateway intends to connect with
    #[prost(string, tag = "5")]
    pub partner_sse_realm: ::prost::alloc::string::String,
    /// Output only. Subnet ranges for Google probe packets.
    #[prost(string, repeated, tag = "7")]
    pub prober_subnet_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for requesting list of SSEGatewayReferences
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSseGatewayReferencesRequest {
    /// Required. Parent value for ListSSEGatewayReferencesRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing SSEGatewayReferences
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSseGatewayReferencesResponse {
    /// The list of SSEGatewayReference
    #[prost(message, repeated, tag = "1")]
    pub sse_gateway_references: ::prost::alloc::vec::Vec<SseGatewayReference>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a SSEGatewayReference
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSseGatewayReferenceRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sse_gateway_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct SseGatewayServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SseGatewayServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SseGatewayServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SseGatewayServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SseGatewayServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists PartnerSSEGateways in a given project and location.
        pub async fn list_partner_sse_gateways(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPartnerSseGatewaysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPartnerSseGatewaysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/ListPartnerSSEGateways",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "ListPartnerSSEGateways",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single PartnerSSEGateway.
        pub async fn get_partner_sse_gateway(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPartnerSseGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PartnerSseGateway>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/GetPartnerSSEGateway",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "GetPartnerSSEGateway",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new PartnerSSEGateway in a given project and location.
        pub async fn create_partner_sse_gateway(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePartnerSseGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/CreatePartnerSSEGateway",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "CreatePartnerSSEGateway",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single PartnerSSEGateway.
        pub async fn delete_partner_sse_gateway(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePartnerSseGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/DeletePartnerSSEGateway",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "DeletePartnerSSEGateway",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single PartnerSSEGateway.
        pub async fn update_partner_sse_gateway(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePartnerSseGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/UpdatePartnerSSEGateway",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "UpdatePartnerSSEGateway",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SSEGatewayReferences in a given project and location.
        pub async fn list_sse_gateway_references(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSseGatewayReferencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSseGatewayReferencesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/ListSSEGatewayReferences",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "ListSSEGatewayReferences",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single SSEGatewayReference.
        pub async fn get_sse_gateway_reference(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSseGatewayReferenceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SseGatewayReference>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSEGatewayService/GetSSEGatewayReference",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSEGatewayService",
                        "GetSSEGatewayReference",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a Secure Access Connect (SAC) realm resource.
///
/// A Secure Access Connect realm establishes a connection between your Google
/// Cloud project and an SSE service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SacRealm {
    /// Identifier. Resource name, in the form
    /// `projects/{project}/locations/global/sacRealms/{sacRealm}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Timestamp when the realm was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when the realm was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Optional list of labels applied to the resource.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. SSE service provider associated with the realm.
    #[prost(enumeration = "sac_realm::SecurityService", tag = "5")]
    pub security_service: i32,
    /// Output only. Key to be shared with SSE service provider during pairing.
    #[prost(message, optional, tag = "6")]
    pub pairing_key: ::core::option::Option<sac_realm::PairingKey>,
    /// Output only. State of the realm.
    #[prost(enumeration = "sac_realm::State", tag = "7")]
    pub state: i32,
    /// Optional. Configuration required for Symantec realms.
    #[prost(message, optional, tag = "8")]
    pub symantec_options: ::core::option::Option<sac_realm::SacRealmSymantecOptions>,
}
/// Nested message and enum types in `SACRealm`.
pub mod sac_realm {
    /// Key to be shared with SSE service provider to establish global handshake.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PairingKey {
        /// Output only. Key value.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Output only. Timestamp in UTC of when this resource is considered
        /// expired. It expires 7 days after creation.
        #[prost(message, optional, tag = "2")]
        pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Fields specific to realms using Symantec Cloud SWG.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SacRealmSymantecOptions {
        /// Output only. Symantec site IDs which the user can choose to connect to.
        #[prost(string, repeated, tag = "2")]
        pub available_symantec_sites: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Optional. API Key used to call Symantec APIs on the user's behalf.
        /// Required if using Symantec Cloud SWG.
        /// P4SA account needs permissions granted to read this secret.
        ///
        /// A secret ID, secret name, or secret URI can be specified,
        /// but it will be parsed and stored as a secret URI in the form
        /// `projects/{project_number}/secrets/my-secret`.
        #[prost(string, tag = "4")]
        pub secret_path: ::prost::alloc::string::String,
        /// Output only. Connection status to Symantec API.
        #[prost(
            enumeration = "sac_realm_symantec_options::SymantecConnectionState",
            tag = "5"
        )]
        pub symantec_connection_state: i32,
    }
    /// Nested message and enum types in `SACRealmSymantecOptions`.
    pub mod sac_realm_symantec_options {
        /// Connection status to Symantec API.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SymantecConnectionState {
            /// No state specified. This should not be used.
            Unspecified = 0,
            /// Successfully made a request to Symantec API.
            Succeeded = 1,
            /// Cannot access the API key in the provided `secret_path`.
            ReadSecretFailed = 2,
            /// Failed to get a successful response from Symantec API due to an invalid
            /// API key or Symantec API unavailability.
            RequestToSymantecFailed = 3,
        }
        impl SymantecConnectionState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SYMANTEC_CONNECTION_STATE_UNSPECIFIED",
                    Self::Succeeded => "SUCCEEDED",
                    Self::ReadSecretFailed => "READ_SECRET_FAILED",
                    Self::RequestToSymantecFailed => "REQUEST_TO_SYMANTEC_FAILED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SYMANTEC_CONNECTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    "READ_SECRET_FAILED" => Some(Self::ReadSecretFailed),
                    "REQUEST_TO_SYMANTEC_FAILED" => Some(Self::RequestToSymantecFailed),
                    _ => None,
                }
            }
        }
    }
    /// SSE service provider
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SecurityService {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// [Palo Alto Networks Prisma
        /// Access](<https://www.paloaltonetworks.com/sase/access>).
        PaloAltoPrismaAccess = 1,
        /// Symantec Cloud SWG.
        SymantecCloudSwg = 2,
    }
    impl SecurityService {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SECURITY_SERVICE_UNSPECIFIED",
                Self::PaloAltoPrismaAccess => "PALO_ALTO_PRISMA_ACCESS",
                Self::SymantecCloudSwg => "SYMANTEC_CLOUD_SWG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SECURITY_SERVICE_UNSPECIFIED" => Some(Self::Unspecified),
                "PALO_ALTO_PRISMA_ACCESS" => Some(Self::PaloAltoPrismaAccess),
                "SYMANTEC_CLOUD_SWG" => Some(Self::SymantecCloudSwg),
                _ => None,
            }
        }
    }
    /// State of the realm.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// No state specified. This should not be used.
        Unspecified = 0,
        /// Has never been attached to a partner.
        /// Used only for Prisma Access.
        PendingPartnerAttachment = 7,
        /// Currently attached to a partner.
        PartnerAttached = 1,
        /// Was once attached to a partner but has been detached.
        PartnerDetached = 2,
        /// Is not attached to a partner and has an expired pairing key.
        /// Used only for Prisma Access.
        KeyExpired = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::PendingPartnerAttachment => "PENDING_PARTNER_ATTACHMENT",
                Self::PartnerAttached => "PARTNER_ATTACHED",
                Self::PartnerDetached => "PARTNER_DETACHED",
                Self::KeyExpired => "KEY_EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING_PARTNER_ATTACHMENT" => Some(Self::PendingPartnerAttachment),
                "PARTNER_ATTACHED" => Some(Self::PartnerAttached),
                "PARTNER_DETACHED" => Some(Self::PartnerDetached),
                "KEY_EXPIRED" => Some(Self::KeyExpired),
                _ => None,
            }
        }
    }
}
/// Request for `ListSACRealms` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSacRealmsRequest {
    /// Required. The parent, in the form `projects/{project}/locations/global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort the results by a certain order.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for `ListSACRealms` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSacRealmsResponse {
    /// The list of SACRealms.
    #[prost(message, repeated, tag = "1")]
    pub sac_realms: ::prost::alloc::vec::Vec<SacRealm>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for `GetSACRealm` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSacRealmRequest {
    /// Required. Name of the resource, in the form
    /// `projects/{project}/locations/global/sacRealms/{sacRealm}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for `CreateSACRealm` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSacRealmRequest {
    /// Required. The parent, in the form `projects/{project}/locations/global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the created realm.
    /// The ID must be 1-63 characters long, and comply with
    /// <a href="<https://www.ietf.org/rfc/rfc1035.txt"> target="_blank">RFC1035</a>.
    /// Specifically, it must be 1-63 characters long and match the regular
    /// expression `[a-z](\[-a-z0-9\]*[a-z0-9])?`
    /// which means the first character must be a lowercase letter, and all
    /// following characters must be a dash, lowercase letter, or digit, except
    /// the last character, which cannot be a dash.
    #[prost(string, tag = "2")]
    pub sac_realm_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub sac_realm: ::core::option::Option<SacRealm>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for `DeleteSACRealm` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSacRealmRequest {
    /// Required. Name of the resource, in the form
    /// `projects/{project}/locations/global/sacRealms/{sacRealm}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Represents a Secure Access Connect (SAC) attachment resource.
///
/// A Secure Access Connect attachment enables NCC Gateway to process traffic
/// with an SSE product.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SacAttachment {
    /// Identifier. Resource name, in the form
    /// `projects/{project}/locations/{location}/sacAttachments/{sac_attachment}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Timestamp when the attachment was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when the attachment was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Optional list of labels applied to the resource.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. SAC Realm which owns the attachment. This can be input as an ID
    /// or a full resource name. The output always has the form
    /// `projects/{project_number}/locations/{location}/sacRealms/{sac_realm}`.
    #[prost(string, tag = "5")]
    pub sac_realm: ::prost::alloc::string::String,
    /// Required. NCC Gateway associated with the attachment. This can be input as
    /// an ID or a full resource name. The output always has the form
    /// `projects/{project_number}/locations/{location}/spokes/{ncc_gateway}`.
    #[prost(string, tag = "6")]
    pub ncc_gateway: ::prost::alloc::string::String,
    /// Optional. Case-insensitive ISO-3166 alpha-2 country code used for
    /// localization. Only valid for Symantec attachments.
    #[prost(string, tag = "7")]
    pub country: ::prost::alloc::string::String,
    /// Optional. Case-sensitive tzinfo identifier used for localization.
    /// Only valid for Symantec attachments.
    #[prost(string, tag = "8")]
    pub time_zone: ::prost::alloc::string::String,
    /// Optional. Configuration required for Symantec attachments.
    #[prost(message, optional, tag = "9")]
    pub symantec_options: ::core::option::Option<
        sac_attachment::SacAttachmentSymantecOptions,
    >,
    /// Output only. State of the attachment.
    #[prost(enumeration = "sac_attachment::State", tag = "10")]
    pub state: i32,
}
/// Nested message and enum types in `SACAttachment`.
pub mod sac_attachment {
    /// Fields specific to attachments associated with Symantec Cloud SWG.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SacAttachmentSymantecOptions {
        /// Immutable. Symantec data center identifier that this attachment will
        /// connect to.
        #[prost(string, tag = "1")]
        pub symantec_site: ::prost::alloc::string::String,
        /// Immutable. Name to be used when creating a location on the customer's
        /// behalf in Symantec's Location API. Not to be confused with Google Cloud
        /// locations.
        #[prost(string, tag = "2")]
        pub symantec_location_name: ::prost::alloc::string::String,
    }
    /// State of the attachment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// No state specified. This should not be used.
        Unspecified = 0,
        /// Has never been attached to a partner.
        PendingPartnerAttachment = 1,
        /// Currently attached to a partner.
        PartnerAttached = 2,
        /// Was once attached to a partner but has been detached.
        PartnerDetached = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::PendingPartnerAttachment => "PENDING_PARTNER_ATTACHMENT",
                Self::PartnerAttached => "PARTNER_ATTACHED",
                Self::PartnerDetached => "PARTNER_DETACHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING_PARTNER_ATTACHMENT" => Some(Self::PendingPartnerAttachment),
                "PARTNER_ATTACHED" => Some(Self::PartnerAttached),
                "PARTNER_DETACHED" => Some(Self::PartnerDetached),
                _ => None,
            }
        }
    }
}
/// Request for `ListSACAttachments` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSacAttachmentsRequest {
    /// Required. The parent, in the form
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression that filters the list of results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort the results by a certain order.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for `ListSACAttachments` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSacAttachmentsResponse {
    /// The list of SACAttachments.
    #[prost(message, repeated, tag = "1")]
    pub sac_attachments: ::prost::alloc::vec::Vec<SacAttachment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for `GetSACAttachment` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSacAttachmentRequest {
    /// Required. Name of the resource, in the form
    /// `projects/{project}/locations/{location}/sacAttachments/{sac_attachment}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for `CreateSACAttachment` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSacAttachmentRequest {
    /// Required. The parent, in the form
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the created attachment.
    /// The ID must be 1-63 characters long, and comply with
    /// <a href="<https://www.ietf.org/rfc/rfc1035.txt"> target="_blank">RFC1035</a>.
    /// Specifically, it must be 1-63 characters long and match the regular
    /// expression `[a-z](\[-a-z0-9\]*[a-z0-9])?`
    /// which means the first character must be a lowercase letter, and all
    /// following characters must be a dash, lowercase letter, or digit, except
    /// the last character, which cannot be a dash.
    #[prost(string, tag = "2")]
    pub sac_attachment_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub sac_attachment: ::core::option::Option<SacAttachment>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for `DeleteSACAttachment` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSacAttachmentRequest {
    /// Required. Name of the resource, in the form
    /// `projects/{project}/locations/{location}/sacAttachments/{sac_attachment}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message describing PartnerSSERealm object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartnerSseRealm {
    /// name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels as key value pairs
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. value of the key to establish global handshake from SSERealm
    #[prost(string, tag = "5")]
    pub pairing_key: ::prost::alloc::string::String,
    /// Optional. VPC owned by the partner to be peered with CDEN sse_vpc in
    /// sse_project This field is deprecated. Use partner_network instead.
    #[deprecated]
    #[prost(string, tag = "6")]
    pub partner_vpc: ::prost::alloc::string::String,
    /// Output only. CDEN owned VPC to be peered with partner_vpc
    /// This field is deprecated. Use sse_network instead.
    #[deprecated]
    #[prost(string, tag = "7")]
    pub sse_vpc: ::prost::alloc::string::String,
    /// Output only. CDEN owned project owning sse_vpc. It stores project id in the
    /// TTM flow, but project number in the NCCGW flow. This field will be
    /// deprecated after the partner migrates from using sse_project to using
    /// sse_project_number.
    #[prost(string, tag = "8")]
    pub sse_project: ::prost::alloc::string::String,
    /// Output only. State of the realm. It can be either CUSTOMER_ATTACHED or
    /// CUSTOMER_DETACHED.
    #[prost(enumeration = "partner_sse_realm::State", tag = "9")]
    pub state: i32,
    /// Optional. Partner-owned network to be peered with CDEN's sse_network in
    /// sse_project
    #[prost(string, tag = "10")]
    pub partner_network: ::prost::alloc::string::String,
    /// Output only. CDEN-owned network to be peered with partner_network
    #[prost(string, tag = "11")]
    pub sse_network: ::prost::alloc::string::String,
    /// Optional. Required only for PAN.
    #[prost(message, optional, tag = "12")]
    pub pan_options: ::core::option::Option<
        partner_sse_realm::PartnerSseRealmPanOptions,
    >,
    /// Output only. CDEN owned project owning sse_vpc
    #[prost(int64, tag = "13")]
    pub sse_project_number: i64,
}
/// Nested message and enum types in `PartnerSSERealm`.
pub mod partner_sse_realm {
    /// Fields specific to PAN realms.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PartnerSseRealmPanOptions {
        /// Optional. serial_number is provided by PAN to identify GCP customer on
        /// PAN side.
        #[prost(string, tag = "1")]
        pub serial_number: ::prost::alloc::string::String,
        /// Optional. tenant_id is provided by PAN to identify GCP customer on PAN
        /// side.
        #[prost(string, tag = "2")]
        pub tenant_id: ::prost::alloc::string::String,
    }
    /// State of the realm
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The default value. This value is used if the state is omitted.
        Unspecified = 0,
        /// This PartnerSSERealm is attached to a customer realm. This is the
        /// default state when a PartnerSSERealm is successfully created.
        CustomerAttached = 1,
        /// This PartnerSSERealm is no longer attached to a customer realm. This is
        /// the state when the customer realm is deleted.
        CustomerDetached = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::CustomerAttached => "CUSTOMER_ATTACHED",
                Self::CustomerDetached => "CUSTOMER_DETACHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOMER_ATTACHED" => Some(Self::CustomerAttached),
                "CUSTOMER_DETACHED" => Some(Self::CustomerDetached),
                _ => None,
            }
        }
    }
}
/// Message for requesting list of PartnerSSERealms
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPartnerSseRealmsRequest {
    /// Required. Parent value for ListPartnerSSERealmsRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing PartnerSSERealms
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPartnerSseRealmsResponse {
    /// The list of PartnerSSERealm
    #[prost(message, repeated, tag = "1")]
    pub partner_sse_realms: ::prost::alloc::vec::Vec<PartnerSseRealm>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a PartnerSSERealm
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPartnerSseRealmRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a PartnerSSERealm
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePartnerSseRealmRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// partner_sse_realm_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub partner_sse_realm_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub partner_sse_realm: ::core::option::Option<PartnerSseRealm>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a PartnerSSERealm
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeletePartnerSseRealmRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod sse_realm_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct SseRealmServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SseRealmServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SseRealmServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SseRealmServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SseRealmServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists SACRealms in a given project.
        pub async fn list_sac_realms(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSacRealmsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSacRealmsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/ListSACRealms",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "ListSACRealms",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified realm.
        pub async fn get_sac_realm(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSacRealmRequest>,
        ) -> std::result::Result<tonic::Response<super::SacRealm>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/GetSACRealm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "GetSACRealm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new SACRealm in a given project.
        pub async fn create_sac_realm(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSacRealmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/CreateSACRealm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "CreateSACRealm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified realm.
        pub async fn delete_sac_realm(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSacRealmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/DeleteSACRealm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "DeleteSACRealm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SACAttachments in a given project and location.
        pub async fn list_sac_attachments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSacAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSacAttachmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/ListSACAttachments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "ListSACAttachments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified attachment.
        pub async fn get_sac_attachment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSacAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::SacAttachment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/GetSACAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "GetSACAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new SACAttachment in a given project and location.
        pub async fn create_sac_attachment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSacAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/CreateSACAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "CreateSACAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified attachment.
        pub async fn delete_sac_attachment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSacAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/DeleteSACAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "DeleteSACAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists PartnerSSERealms in a given project and location.
        pub async fn list_partner_sse_realms(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPartnerSseRealmsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPartnerSseRealmsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/ListPartnerSSERealms",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "ListPartnerSSERealms",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single PartnerSSERealm.
        pub async fn get_partner_sse_realm(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPartnerSseRealmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PartnerSseRealm>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/GetPartnerSSERealm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "GetPartnerSSERealm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new PartnerSSERealm in a given project and location.
        pub async fn create_partner_sse_realm(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePartnerSseRealmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/CreatePartnerSSERealm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "CreatePartnerSSERealm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single PartnerSSERealm.
        pub async fn delete_partner_sse_realm(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePartnerSseRealmRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networksecurity.v1alpha1.SSERealmService/DeletePartnerSSERealm",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networksecurity.v1alpha1.SSERealmService",
                        "DeletePartnerSSERealm",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
