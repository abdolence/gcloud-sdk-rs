// This file is @generated by prost-build.
/// ResourceBundle represent a collection of kubernetes configuration resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceBundle {
    /// Identifier. Name of the `ResourceBundle`. Format is
    /// `projects/{project}/locations/{location}/resourceBundle  /[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time `ResourceBundle` was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time `ResourceBundle` was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Human readable description of the `ResourceBundle`.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
}
/// Message for requesting list of ResourceBundles.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourceBundlesRequest {
    /// Required. Parent value for ListResourceBundlesRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing ResourceBundles.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourceBundlesResponse {
    /// The list of ResourceBundle.
    #[prost(message, repeated, tag = "1")]
    pub resource_bundles: ::prost::alloc::vec::Vec<ResourceBundle>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a ResourceBundle.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetResourceBundleRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a ResourceBundle.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateResourceBundleRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// resource_bundle_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub resource_bundle_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub resource_bundle: ::core::option::Option<ResourceBundle>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a ResourceBundle
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateResourceBundleRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// ResourceBundle resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub resource_bundle: ::core::option::Option<ResourceBundle>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a ResourceBundle
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteResourceBundleRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, any releases of this resource bundle will also be
    /// deleted. (Otherwise, the request will only work if the resource bundle has
    /// no releases.)
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// A `FleetPackage` resource in the Config Delivery API.
///
/// A `FleetPackage` defines a package through which kubernetes
/// configuration is deployed to a fleet of kubernetes clusters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleetPackage {
    /// Identifier. Name of the `FleetPackage`. Format is
    /// `projects/{project}/locations/{location}/fleetPackages/{fleetPackage}`.
    /// The `fleetPackage` component must match
    /// `[a-z][a-z0-9\-]{0,62}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time at which the `FleetPackage` was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Most recent time at which the `FleetPackage` was updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels are attributes that can be set and used by both the
    /// user and by Config Delivery. Labels must meet the following constraints:
    ///
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes.
    /// * All characters must use UTF-8 encoding, and international characters are
    ///   allowed.
    /// * Keys must start with a lowercase letter or international character.
    /// * Each resource is limited to a maximum of 64 labels.
    ///
    /// Both keys and values are additionally constrained to be \<= 128 bytes.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Information specifying the source of kubernetes configuration to
    /// deploy.
    #[prost(message, optional, tag = "5")]
    pub resource_bundle_selector: ::core::option::Option<
        fleet_package::ResourceBundleSelector,
    >,
    /// Optional. Configuration to select target clusters to deploy kubernetes
    /// configuration to.
    #[prost(message, optional, tag = "9")]
    pub target: ::core::option::Option<fleet_package::Target>,
    /// Optional. The strategy to use to deploy kubernetes configuration to
    /// clusters.
    #[prost(message, optional, tag = "10")]
    pub rollout_strategy: ::core::option::Option<RolloutStrategy>,
    /// Required. Information specifying how to map a `ResourceBundle` variant to a
    /// target cluster.
    #[prost(message, optional, tag = "11")]
    pub variant_selector: ::core::option::Option<fleet_package::VariantSelector>,
    /// Output only. Information containing the rollout status of the
    /// `FleetPackage` across all the target clusters.
    #[prost(message, optional, tag = "13")]
    pub info: ::core::option::Option<FleetPackageInfo>,
    /// Optional. Information around how to handle kubernetes resources at the
    /// target clusters when the `FleetPackage` is deleted.
    #[prost(enumeration = "DeletionPropagationPolicy", tag = "15")]
    pub deletion_propagation_policy: i32,
    /// Optional. The desired state of the fleet package.
    #[prost(enumeration = "fleet_package::State", tag = "16")]
    pub state: i32,
}
/// Nested message and enum types in `FleetPackage`.
pub mod fleet_package {
    /// Information specifying the source of kubernetes configuration to deploy.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ResourceBundleSelector {
        /// source can be a directly pushed `ResourceBundle` or
        /// `CloudBuildRepository` containing the kubernetes configuration.
        #[prost(oneof = "resource_bundle_selector::Source", tags = "1, 3")]
        pub source: ::core::option::Option<resource_bundle_selector::Source>,
    }
    /// Nested message and enum types in `ResourceBundleSelector`.
    pub mod resource_bundle_selector {
        /// source can be a directly pushed `ResourceBundle` or
        /// `CloudBuildRepository` containing the kubernetes configuration.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Source {
            /// Information specifying `ResourceBundle`.
            #[prost(message, tag = "1")]
            ResourceBundle(super::ResourceBundleTag),
            /// Information specifying `CloudBuildRepository`.
            #[prost(message, tag = "3")]
            CloudBuildRepository(super::CloudBuildRepository),
        }
    }
    /// ResourceBundleTag contains the information to refer to a release for a
    /// `ResourceBundle`.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ResourceBundleTag {
        /// Required. Name of the `ResourceBundle`.
        /// Format is projects/{p}/locations/{l}/resourceBundles/{r}.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Required. Tag refers to a version of the release in a `ResourceBundle`.
        /// This is a Git tag in the semantic version format `vX.Y.Z`.
        #[prost(string, tag = "2")]
        pub tag: ::prost::alloc::string::String,
    }
    /// CloudBuildRepository contains information about fetching Kubernetes
    /// configuration from a `CloudBuildRepository`.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CloudBuildRepository {
        /// Required. Name of the cloud build repository.
        /// Format is projects/{p}/locations/{l}/connections/{c}/repositories/{r}.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Optional. path to the directory or file within the repository that
        /// contains the kubernetes configuration. If unspecified, path is assumed to
        /// the top level root directory of the repository.
        #[prost(string, tag = "2")]
        pub path: ::prost::alloc::string::String,
        /// Required. git tag of the underlying git repository.
        /// The git tag must be in the semantic version format `vX.Y.Z`.
        #[prost(string, tag = "3")]
        pub tag: ::prost::alloc::string::String,
        /// Required. Google service account to use in CloudBuild triggers to fetch
        /// and store kubernetes configuration.
        #[prost(string, tag = "4")]
        pub service_account: ::prost::alloc::string::String,
        /// variants_pattern is the configuration for how to read the repository
        /// to find variants.
        #[prost(oneof = "cloud_build_repository::Variants", tags = "5")]
        pub variants: ::core::option::Option<cloud_build_repository::Variants>,
    }
    /// Nested message and enum types in `CloudBuildRepository`.
    pub mod cloud_build_repository {
        /// variants_pattern is the configuration for how to read the repository
        /// to find variants.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Variants {
            /// Optional. variants_pattern is a glob pattern that will be used to find
            /// variants in the repository. Examples: `variants/*.yaml`, `us-*`
            #[prost(string, tag = "5")]
            VariantsPattern(::prost::alloc::string::String),
        }
    }
    /// The target defines different ways to target set of kubernetes clusters.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Target {
        /// target for the fleet package.
        #[prost(oneof = "target::Target", tags = "1")]
        pub target: ::core::option::Option<target::Target>,
    }
    /// Nested message and enum types in `Target`.
    pub mod target {
        /// target for the fleet package.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Target {
            /// The GKE fleet information.
            #[prost(message, tag = "1")]
            Fleet(super::super::Fleet),
        }
    }
    /// VariantSelector contains information for selecting a variant in
    /// `ResourceBundle` to deploy to a target cluster.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct VariantSelector {
        /// strategy for selecting a variant.
        #[prost(oneof = "variant_selector::Strategy", tags = "1")]
        pub strategy: ::core::option::Option<variant_selector::Strategy>,
    }
    /// Nested message and enum types in `VariantSelector`.
    pub mod variant_selector {
        /// strategy for selecting a variant.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Strategy {
            /// Required. variant_name_template is a template that can refer to
            /// variables containing cluster membership metadata such as location,
            /// name, and labels to generate the name of the variant for a target
            /// cluster. The variable syntax is similar to the unix shell variables.
            ///
            /// Available variables are `${membership.name}`, `${membership.location}`,
            /// `${membership.project}` and `${membership.labels\['label_name'\]}`.
            ///
            /// If you want to deploy a specific variant, say "default" to all the
            /// clusters, you can use "default" (string without any variables) as
            /// the variant_name_template.
            #[prost(string, tag = "1")]
            VariantNameTemplate(::prost::alloc::string::String),
        }
    }
    /// State indicates the desired state for the fleet package.
    /// Unspecified value is equivalent to `ACTIVE`. If state is set to
    /// `SUSPENDED`, active rollout (if any) will continue but no new rollouts will
    /// be scheduled.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// `FleetPackage` is intended to be active.
        Active = 1,
        /// `FleetPackage` is intended to be suspended.
        Suspended = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
}
/// FleetPackageInfo represents the status of the `FleetPackage` across all the
/// target clusters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FleetPackageInfo {
    /// Optional. The active rollout, if any. Format is
    /// `projects/{project}/locations/{location}/fleetPackages/{fleet_package}/rollouts/{rollout}`.
    #[prost(string, tag = "1")]
    pub active_rollout: ::prost::alloc::string::String,
    /// Optional. The last completed rollout, if any. Format is
    /// `projects/{project}/locations/{location}/fleetPackages/{fleet_package}/rollouts/{rollout}`.
    #[prost(string, tag = "2")]
    pub last_completed_rollout: ::prost::alloc::string::String,
    /// Optional. Output only. The current state of the `FleetPackage`.
    #[prost(enumeration = "fleet_package_info::State", tag = "3")]
    pub state: i32,
    /// Optional. Output only. Errors encountered during configuration deployment
    /// (if any).
    #[prost(message, repeated, tag = "6")]
    pub errors: ::prost::alloc::vec::Vec<FleetPackageError>,
}
/// Nested message and enum types in `FleetPackageInfo`.
pub mod fleet_package_info {
    /// Possible values for the `FleetPackage` state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// `FleetPackage` is active.
        Active = 1,
        /// `FleetPackage` is suspended.
        Suspended = 2,
        /// `FleetPackage` has failed to reconcile.
        Failed = 3,
        /// `FleetPackage` is being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Suspended => "SUSPENDED",
                Self::Failed => "FAILED",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "SUSPENDED" => Some(Self::Suspended),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Information representing an error encountered during rolling out
/// configurations.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FleetPackageError {
    /// Optional. A description of the error.
    #[prost(string, tag = "1")]
    pub error_message: ::prost::alloc::string::String,
}
/// ClusterInfo represents status of a resource bundle rollout for a cluster.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClusterInfo {
    /// Output only. gkehub membership of target cluster
    #[prost(string, tag = "1")]
    pub membership: ::prost::alloc::string::String,
    /// Output only. Desired state for the resource bundle.
    #[prost(message, optional, tag = "2")]
    pub desired: ::core::option::Option<ResourceBundleDeploymentInfo>,
    /// Output only. Initial state of the resource bundle prior to the deployment.
    #[prost(message, optional, tag = "3")]
    pub initial: ::core::option::Option<ResourceBundleDeploymentInfo>,
    /// Output only. Current state of the resource bundle.
    #[prost(message, optional, tag = "4")]
    pub current: ::core::option::Option<ResourceBundleDeploymentInfo>,
    /// Output only. State of the rollout for the cluster.
    #[prost(enumeration = "cluster_info::State", tag = "5")]
    pub state: i32,
    /// Output only. Unordered list. Messages convey additional information related
    /// to the deployment.
    #[prost(string, repeated, tag = "6")]
    pub messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Timestamp when reconciliation starts.
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when reconciliation ends.
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `ClusterInfo`.
pub mod cluster_info {
    /// State of the rollout for the cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// Waiting state.
        Waiting = 1,
        /// In progress state.
        InProgress = 2,
        /// Stalled state.
        Stalled = 3,
        /// Completed state.
        Completed = 4,
        /// Aborted state.
        Aborted = 5,
        /// Cancelled state.
        Cancelled = 6,
        /// Error state.
        Error = 7,
        /// Unchanged state.
        Unchanged = 8,
        /// Skipped state.
        Skipped = 9,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Waiting => "WAITING",
                Self::InProgress => "IN_PROGRESS",
                Self::Stalled => "STALLED",
                Self::Completed => "COMPLETED",
                Self::Aborted => "ABORTED",
                Self::Cancelled => "CANCELLED",
                Self::Error => "ERROR",
                Self::Unchanged => "UNCHANGED",
                Self::Skipped => "SKIPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "WAITING" => Some(Self::Waiting),
                "IN_PROGRESS" => Some(Self::InProgress),
                "STALLED" => Some(Self::Stalled),
                "COMPLETED" => Some(Self::Completed),
                "ABORTED" => Some(Self::Aborted),
                "CANCELLED" => Some(Self::Cancelled),
                "ERROR" => Some(Self::Error),
                "UNCHANGED" => Some(Self::Unchanged),
                "SKIPPED" => Some(Self::Skipped),
                _ => None,
            }
        }
    }
}
/// ResourceBundleDeploymentInfo represents the status of a resource bundle
/// deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceBundleDeploymentInfo {
    /// Output only. Refers to a `ResourceBundle` release.
    #[prost(string, tag = "1")]
    pub release: ::prost::alloc::string::String,
    /// Output only. Refers to a version of the `ResourceBundle` release.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Output only. Refers to a variant in a `ResourceBundle` release.
    #[prost(string, tag = "3")]
    pub variant: ::prost::alloc::string::String,
    /// Output only. Synchronization state of the `ResourceBundle` deployment.
    #[prost(enumeration = "resource_bundle_deployment_info::SyncState", tag = "4")]
    pub sync_state: i32,
    /// Output only. Unordered list. Messages contains information related to the
    /// `ResourceBundle` deployment. For example, in case of an error, indicate the
    /// reason for the error. In case of a pending deployment, reason for why the
    /// deployment of new release is pending.
    #[prost(string, repeated, tag = "5")]
    pub messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ResourceBundleDeploymentInfo`.
pub mod resource_bundle_deployment_info {
    /// Synchronization state of the resource bundle deployment.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SyncState {
        /// Unspecified state.
        Unspecified = 0,
        /// Reconciling state.
        Reconciling = 1,
        /// Stalled state.
        Stalled = 2,
        /// Synced state.
        Synced = 3,
        /// Pending state.
        Pending = 4,
        /// Error state.
        Error = 5,
        /// Deletion pending state.
        DeletionPending = 6,
        /// Deleting state.
        Deleting = 7,
        /// Deleted state.
        Deleted = 8,
    }
    impl SyncState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYNC_STATE_UNSPECIFIED",
                Self::Reconciling => "RECONCILING",
                Self::Stalled => "STALLED",
                Self::Synced => "SYNCED",
                Self::Pending => "PENDING",
                Self::Error => "ERROR",
                Self::DeletionPending => "DELETION_PENDING",
                Self::Deleting => "DELETING",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNC_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RECONCILING" => Some(Self::Reconciling),
                "STALLED" => Some(Self::Stalled),
                "SYNCED" => Some(Self::Synced),
                "PENDING" => Some(Self::Pending),
                "ERROR" => Some(Self::Error),
                "DELETION_PENDING" => Some(Self::DeletionPending),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// The fleet where the `FleetPackage` should be deployed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fleet {
    /// Required. The host project for the GKE fleet. Format is
    /// `projects/{project}`.
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// Optional. selector allows targeting a subset of fleet members using their
    /// labels.
    #[prost(message, optional, tag = "2")]
    pub selector: ::core::option::Option<fleet::LabelSelector>,
}
/// Nested message and enum types in `Fleet`.
pub mod fleet {
    /// A label selector is a label query over a set of resources. An empty label
    /// selector matches all objects.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct LabelSelector {
        /// Optional. match_labels is a map of {key,value} pairs. Each {key,value}
        /// pair must match an existing label key and value exactly in order to
        /// satisfy the match.
        #[prost(map = "string, string", tag = "1")]
        pub match_labels: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
}
/// AllAtOnceStrategy causes all clusters to be updated concurrently.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AllAtOnceStrategy {}
/// RollingStrategy causes a specified number of clusters to be updated
/// concurrently until all clusters are updated.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RollingStrategy {
    /// Optional. Maximum number of clusters to update the resource bundle on
    /// concurrently.
    #[prost(int32, tag = "1")]
    pub max_concurrent: i32,
}
/// RolloutStrategy defines different ways to rollout a resource bundle across
/// a set of clusters.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RolloutStrategy {
    /// strategy defines how updates to a resource bundle should be rolled out
    /// across clusters.
    #[prost(oneof = "rollout_strategy::Strategy", tags = "1, 2")]
    pub strategy: ::core::option::Option<rollout_strategy::Strategy>,
}
/// Nested message and enum types in `RolloutStrategy`.
pub mod rollout_strategy {
    /// strategy defines how updates to a resource bundle should be rolled out
    /// across clusters.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Strategy {
        /// AllAtOnceStrategy causes all clusters to be updated concurrently.
        #[prost(message, tag = "1")]
        AllAtOnce(super::AllAtOnceStrategy),
        /// RollingStrategy causes a specified number of clusters to be updated
        /// concurrently until all clusters are updated.
        #[prost(message, tag = "2")]
        Rolling(super::RollingStrategy),
    }
}
/// RolloutStrategyInfo represents the status of execution of different types of
/// rollout strategies. Only the field corresponding to the rollout strategy
/// specified at the rollout resource will be populated.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutStrategyInfo {
    /// strategy represents result of applying one of the rollout strategies.
    #[prost(oneof = "rollout_strategy_info::Strategy", tags = "1, 2")]
    pub strategy: ::core::option::Option<rollout_strategy_info::Strategy>,
}
/// Nested message and enum types in `RolloutStrategyInfo`.
pub mod rollout_strategy_info {
    /// strategy represents result of applying one of the rollout strategies.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Strategy {
        /// AllAtOnceStrategyInfo represents the status of AllAtOnce rollout strategy
        /// execution.
        #[prost(message, tag = "1")]
        AllAtOnceStrategyInfo(super::AllAtOnceStrategyInfo),
        /// RollingStrategyInfo represents the status of Rolling rollout strategy
        /// execution.
        #[prost(message, tag = "2")]
        RollingStrategyInfo(super::RollingStrategyInfo),
    }
}
/// AllAtOnceStrategyInfo represents the status of execution of AllAtOnce rollout
/// strategy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllAtOnceStrategyInfo {
    /// Unordered list. resource bundle's deployment status for all targeted
    /// clusters.
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterInfo>,
}
/// RollingStrategyInfo represents the status of execution of Rolling rollout
/// strategy.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollingStrategyInfo {
    /// Unordered list. resource bundle's deployment status for all targeted
    /// clusters.
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<ClusterInfo>,
}
/// Message for requesting list of FleetPackage.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFleetPackagesRequest {
    /// Required. Parent value for ListFleetPackagesRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing FleetPackage
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFleetPackagesResponse {
    /// The list of FleetPackage
    #[prost(message, repeated, tag = "1")]
    pub fleet_packages: ::prost::alloc::vec::Vec<FleetPackage>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a FleetPackage
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFleetPackageRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a FleetPackage
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFleetPackageRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// fleet_package_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub fleet_package_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub fleet_package: ::core::option::Option<FleetPackage>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a FleetPackage
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFleetPackageRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// FleetPackage resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub fleet_package: ::core::option::Option<FleetPackage>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a FleetPackage
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFleetPackageRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, any rollouts for this FleetPackage will also be
    /// deleted. (Otherwise, the request will only work if the fleet package has no
    /// rollouts.)
    #[prost(bool, tag = "3")]
    pub force: bool,
    /// Optional. If set to true, then deleting an already deleted or non existing
    /// FleetPackage will succeed.
    #[prost(bool, tag = "4")]
    pub allow_missing: bool,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have
    /// \[google.longrunning.Operation.error\]\[google.longrunning.Operation.error\]
    /// value with a \[google.rpc.Status.code\]\[google.rpc.Status.code\] of 1,
    /// corresponding to `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// `Release` represents a versioned release containing kubernetes manifests.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Release {
    /// Identifier. Name of the Release. Format is
    /// `projects/{project}/locations/location}/resourceBundles/{resource_bundle}/release/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time `Release` was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time `Release` was last updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. lifecycle of the `Release`.
    #[prost(enumeration = "release::Lifecycle", tag = "5")]
    pub lifecycle: i32,
    /// Required. version of the `Release`. This must be v<major>.<minor>.<patch>.
    #[prost(string, tag = "6")]
    pub version: ::prost::alloc::string::String,
    /// Output only. Time the `Release` was published.
    #[prost(message, optional, tag = "7")]
    pub publish_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. `ResourceBundle` Release extra information e.g., artifact
    /// registry image path.
    #[prost(message, optional, tag = "9")]
    pub info: ::core::option::Option<ReleaseInfo>,
}
/// Nested message and enum types in `Release`.
pub mod release {
    /// Lifecycle indicates the state of the `Release`. A published release is
    /// immutable.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Lifecycle {
        /// indicates lifecycle has not been specified.
        Unspecified = 0,
        /// indicates that the `Release` is being edited.
        Draft = 1,
        /// indicates that the `Release` is now published (or released) and
        /// immutable.
        Published = 2,
    }
    impl Lifecycle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LIFECYCLE_UNSPECIFIED",
                Self::Draft => "DRAFT",
                Self::Published => "PUBLISHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LIFECYCLE_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "PUBLISHED" => Some(Self::Published),
                _ => None,
            }
        }
    }
}
/// Variant represents the content of a `ResourceBundle` variant.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variant {
    /// Optional. labels to represent any metadata associated with the variant.
    #[prost(map = "string, string", tag = "1")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. Input only. Unordered list. resources contain the kubernetes
    /// manifests (YAMLs) for this variant.
    #[prost(string, repeated, tag = "2")]
    pub resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Identifier. Name follows format of
    /// projects/{project}/locations/{location}/resourceBundles/{resource_bundle}/releases/{release}/variants/{variant}
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create time stamp
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update time stamp
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Message for requesting list of Variants.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListVariantsRequest {
    /// Required. Parent value for ListVariantsRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Variants
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVariantsResponse {
    /// The list of Variants
    #[prost(message, repeated, tag = "1")]
    pub variants: ::prost::alloc::vec::Vec<Variant>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Variant
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetVariantRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Variant
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVariantRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    #[prost(string, tag = "2")]
    pub variant_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub variant: ::core::option::Option<Variant>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a Variant
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVariantRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Variant resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub variant: ::core::option::Option<Variant>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Variant
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteVariantRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// ReleaseInfo contains extra information about the `ResourceBundle` release
/// e.g., link to an artifact registry OCI image.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReleaseInfo {
    /// Output only. path to the oci image the service uploads to on a `Release`
    /// creation.
    #[prost(string, tag = "1")]
    pub oci_image_path: ::prost::alloc::string::String,
    /// Output only. per-variant paths to the oci images the service uploads on
    /// package release creation
    #[prost(map = "string, string", tag = "2")]
    pub variant_oci_image_paths: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Message for requesting list of Releases.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListReleasesRequest {
    /// Required. Parent value for ListReleasesRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Releases
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleasesResponse {
    /// The list of Releases
    #[prost(message, repeated, tag = "1")]
    pub releases: ::prost::alloc::vec::Vec<Release>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Release
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetReleaseRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Release
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReleaseRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// release_id from the method_signature of Create RPC
    #[prost(string, tag = "2")]
    pub release_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub release: ::core::option::Option<Release>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a Release
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReleaseRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Release resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub release: ::core::option::Option<Release>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Release
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteReleaseRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, any variants of this release will also be
    /// deleted. (Otherwise, the request will only work if the release has no
    /// variants.)
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// Message for requesting list of Rollouts
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRolloutsRequest {
    /// Required. Parent value for ListRolloutsRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Rollouts
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolloutsResponse {
    /// The list of Rollouts
    #[prost(message, repeated, tag = "1")]
    pub rollouts: ::prost::alloc::vec::Vec<Rollout>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Rollout
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRolloutRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// RolloutInfo represents the state of the `FleetPackage` at all the
/// clusters the rollout is targeting.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutInfo {
    /// Output only. state contains the overall status of the Rollout.
    #[prost(enumeration = "rollout_info::State", tag = "1")]
    pub state: i32,
    /// Output only. Time when the rollout started.
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the rollout completed.
    #[prost(message, optional, tag = "5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Message containing additional information related to the
    /// rollout.
    #[prost(string, tag = "6")]
    pub message: ::prost::alloc::string::String,
    /// Output only. Rollout strategy info represents the status of execution of
    /// rollout strategy.
    #[prost(message, optional, tag = "7")]
    pub rollout_strategy_info: ::core::option::Option<RolloutStrategyInfo>,
}
/// Nested message and enum types in `RolloutInfo`.
pub mod rollout_info {
    /// State of the rollout
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified state.
        Unspecified = 0,
        /// Rollout completed.
        Completed = 1,
        /// Rollout suspended.
        Suspended = 2,
        /// Rollout aborted.
        Aborted = 3,
        /// Rollout in progress.
        InProgress = 5,
        /// Rollout stalled.
        Stalled = 6,
        /// Rollout cancelled.
        Cancelled = 7,
        /// Rollout aborting.
        Aborting = 8,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Completed => "COMPLETED",
                Self::Suspended => "SUSPENDED",
                Self::Aborted => "ABORTED",
                Self::InProgress => "IN_PROGRESS",
                Self::Stalled => "STALLED",
                Self::Cancelled => "CANCELLED",
                Self::Aborting => "ABORTING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLETED" => Some(Self::Completed),
                "SUSPENDED" => Some(Self::Suspended),
                "ABORTED" => Some(Self::Aborted),
                "IN_PROGRESS" => Some(Self::InProgress),
                "STALLED" => Some(Self::Stalled),
                "CANCELLED" => Some(Self::Cancelled),
                "ABORTING" => Some(Self::Aborting),
                _ => None,
            }
        }
    }
}
/// Rollout resource represents an instance of `FleetPackage` rollout operation
/// across a fleet. This is a system generated resource and will be read only for
/// end-users. It will be primarily used by the service to process the changes in
/// the `FleetPackage` and other changes in the environment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollout {
    /// Identifier. Name of the Rollout. Format is
    /// `projects/{project}/locations/{location}/fleetPackages/{fleet_package}/rollouts/[a-z][a-z0-9\-]{0,62}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Reference to the `Release` being rolled out.
    #[prost(string, tag = "2")]
    pub release: ::prost::alloc::string::String,
    /// Rollout strategy for rolling out `FleetPackage` to clusters.
    #[prost(message, optional, tag = "4")]
    pub rollout_strategy: ::core::option::Option<RolloutStrategy>,
    /// Current details of the rollout.
    #[prost(message, optional, tag = "5")]
    pub info: ::core::option::Option<RolloutInfo>,
    /// Deletion propagation policy of the rollout.
    #[prost(enumeration = "DeletionPropagationPolicy", tag = "7")]
    pub deletion_propagation_policy: i32,
    /// Output only. The time the rollout was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the rollout was most recently updated.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Message for suspending a rollout.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SuspendRolloutRequest {
    /// Required. Name of the Rollout.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reason for suspension.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Message for resuming a rollout.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResumeRolloutRequest {
    /// Required. Name of the Rollout.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reason for resuming the rollout.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Message for aborting a rollout.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AbortRolloutRequest {
    /// Required. Name of the Rollout.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reason for aborting.
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
/// Deletion Propagation Policy determines what happens to the underlying
/// Kubernetes resources on a cluster when the `FleetPackage` managing
/// those resources no longer targets the cluster or is deleted.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeletionPropagationPolicy {
    /// Unspecified deletion propagation policy. Defaults to FOREGROUND.
    Unspecified = 0,
    /// Foreground deletion propagation policy. Any resources synced to the cluster
    /// will be deleted.
    Foreground = 1,
    /// Orphan deletion propagation policy. Any resources synced to the cluster
    /// will be abandoned.
    Orphan = 2,
}
impl DeletionPropagationPolicy {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DELETION_PROPAGATION_POLICY_UNSPECIFIED",
            Self::Foreground => "FOREGROUND",
            Self::Orphan => "ORPHAN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DELETION_PROPAGATION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
            "FOREGROUND" => Some(Self::Foreground),
            "ORPHAN" => Some(Self::Orphan),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod config_delivery_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// ConfigDelivery service manages the deployment of kubernetes configuration to
    /// a fleet of kubernetes clusters.
    #[derive(Debug, Clone)]
    pub struct ConfigDeliveryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConfigDeliveryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConfigDeliveryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConfigDeliveryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConfigDeliveryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists ResourceBundles in a given project and location.
        pub async fn list_resource_bundles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourceBundlesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListResourceBundlesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/ListResourceBundles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "ListResourceBundles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ResourceBundle.
        pub async fn get_resource_bundle(
            &mut self,
            request: impl tonic::IntoRequest<super::GetResourceBundleRequest>,
        ) -> std::result::Result<tonic::Response<super::ResourceBundle>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/GetResourceBundle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "GetResourceBundle",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ResourceBundle in a given project and location.
        pub async fn create_resource_bundle(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateResourceBundleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/CreateResourceBundle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "CreateResourceBundle",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single ResourceBundle.
        pub async fn update_resource_bundle(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateResourceBundleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/UpdateResourceBundle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "UpdateResourceBundle",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ResourceBundle.
        pub async fn delete_resource_bundle(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteResourceBundleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/DeleteResourceBundle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "DeleteResourceBundle",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists FleetPackages in a given project and location.
        pub async fn list_fleet_packages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFleetPackagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFleetPackagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/ListFleetPackages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "ListFleetPackages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single FleetPackage.
        pub async fn get_fleet_package(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFleetPackageRequest>,
        ) -> std::result::Result<tonic::Response<super::FleetPackage>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/GetFleetPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "GetFleetPackage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new FleetPackage in a given project and location.
        pub async fn create_fleet_package(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFleetPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/CreateFleetPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "CreateFleetPackage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single FleetPackage.
        pub async fn update_fleet_package(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFleetPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/UpdateFleetPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "UpdateFleetPackage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single FleetPackage.
        pub async fn delete_fleet_package(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFleetPackageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/DeleteFleetPackage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "DeleteFleetPackage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Releases in a given project and location.
        pub async fn list_releases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReleasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReleasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/ListReleases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "ListReleases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Release.
        pub async fn get_release(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReleaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Release>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/GetRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "GetRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Release in a given project, location and resource bundle.
        pub async fn create_release(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReleaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/CreateRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "CreateRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Release.
        pub async fn update_release(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReleaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/UpdateRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "UpdateRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Release.
        pub async fn delete_release(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReleaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/DeleteRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "DeleteRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Variants in a given project and location.
        pub async fn list_variants(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVariantsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVariantsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/ListVariants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "ListVariants",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Variant.
        pub async fn get_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVariantRequest>,
        ) -> std::result::Result<tonic::Response<super::Variant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/GetVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "GetVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Variant in a given project, location, resource bundle, and
        /// release.
        pub async fn create_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/CreateVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "CreateVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Variant.
        pub async fn update_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/UpdateVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "UpdateVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Variant.
        pub async fn delete_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVariantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/DeleteVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "DeleteVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Rollouts in a given project, location, and Fleet Package.
        pub async fn list_rollouts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRolloutsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRolloutsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/ListRollouts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "ListRollouts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Rollout.
        pub async fn get_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRolloutRequest>,
        ) -> std::result::Result<tonic::Response<super::Rollout>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/GetRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "GetRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Suspend a Rollout.
        pub async fn suspend_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::SuspendRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/SuspendRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "SuspendRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resume a Rollout.
        pub async fn resume_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/ResumeRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "ResumeRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Abort a Rollout.
        pub async fn abort_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::AbortRolloutRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.configdelivery.v1alpha.ConfigDelivery/AbortRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.configdelivery.v1alpha.ConfigDelivery",
                        "AbortRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
