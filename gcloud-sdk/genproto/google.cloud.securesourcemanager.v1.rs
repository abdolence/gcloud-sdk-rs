// This file is @generated by prost-build.
/// A resource that represents a Secure Source Manager instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    /// Optional. A unique identifier for an instance. The name should be of the
    /// format:
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`
    ///
    /// `project_number`: Maps to a unique int64 id assigned to each project.
    ///
    /// `location_id`: Refers to the region where the instance will be deployed.
    /// Since Secure Source Manager is a regional service, it must be one of the
    /// valid GCP regions.
    ///
    /// `instance_id`: User provided name for the instance, must be unique for a
    /// project_number and location_id combination.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Create timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Private settings for private instance.
    #[prost(message, optional, tag = "13")]
    pub private_config: ::core::option::Option<instance::PrivateConfig>,
    /// Output only. Current state of the instance.
    #[prost(enumeration = "instance::State", tag = "5")]
    pub state: i32,
    /// Output only. An optional field providing information about the current
    /// instance state.
    #[prost(enumeration = "instance::StateNote", tag = "10")]
    pub state_note: i32,
    /// Optional. Immutable. Customer-managed encryption key name, in the format
    /// projects/*/locations/*/keyRings/*/cryptoKeys/*.
    #[prost(string, tag = "11")]
    pub kms_key: ::prost::alloc::string::String,
    /// Output only. A list of hostnames for this instance.
    #[prost(message, optional, tag = "9")]
    pub host_config: ::core::option::Option<instance::HostConfig>,
    /// Optional. Configuration for Workforce Identity Federation to support
    /// third party identity provider. If unset, defaults to the Google OIDC IdP.
    #[prost(message, optional, tag = "14")]
    pub workforce_identity_federation_config: ::core::option::Option<
        instance::WorkforceIdentityFederationConfig,
    >,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
    /// HostConfig has different instance endpoints.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HostConfig {
        /// Output only. HTML hostname.
        #[prost(string, tag = "1")]
        pub html: ::prost::alloc::string::String,
        /// Output only. API hostname.
        #[prost(string, tag = "2")]
        pub api: ::prost::alloc::string::String,
        /// Output only. Git HTTP hostname.
        #[prost(string, tag = "3")]
        pub git_http: ::prost::alloc::string::String,
        /// Output only. Git SSH hostname.
        #[prost(string, tag = "4")]
        pub git_ssh: ::prost::alloc::string::String,
    }
    /// PrivateConfig includes settings for private instance.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PrivateConfig {
        /// Required. Immutable. Indicate if it's private instance.
        #[prost(bool, tag = "1")]
        pub is_private: bool,
        /// Optional. Immutable. CA pool resource, resource must in the format of
        /// `projects/{project}/locations/{location}/caPools/{ca_pool}`.
        #[prost(string, tag = "2")]
        pub ca_pool: ::prost::alloc::string::String,
        /// Output only. Service Attachment for HTTP, resource is in the format of
        /// `projects/{project}/regions/{region}/serviceAttachments/{service_attachment}`.
        #[prost(string, tag = "3")]
        pub http_service_attachment: ::prost::alloc::string::String,
        /// Output only. Service Attachment for SSH, resource is in the format of
        /// `projects/{project}/regions/{region}/serviceAttachments/{service_attachment}`.
        #[prost(string, tag = "4")]
        pub ssh_service_attachment: ::prost::alloc::string::String,
        /// Optional. Additional allowed projects for setting up PSC connections.
        /// Instance host project is automatically allowed and does not need to be
        /// included in this list.
        #[prost(string, repeated, tag = "6")]
        pub psc_allowed_projects: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
    /// WorkforceIdentityFederationConfig allows this instance to support users
    /// from external identity providers.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct WorkforceIdentityFederationConfig {
        /// Optional. Immutable. Whether Workforce Identity Federation is enabled.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
    /// Secure Source Manager instance state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Not set. This should only be the case for incoming requests.
        Unspecified = 0,
        /// Instance is being created.
        Creating = 1,
        /// Instance is ready.
        Active = 2,
        /// Instance is being deleted.
        Deleting = 3,
        /// Instance is paused.
        Paused = 4,
        /// Instance is unknown, we are not sure if it's functioning.
        Unknown = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Paused => "PAUSED",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "PAUSED" => Some(Self::Paused),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    /// Provides information about the current instance state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StateNote {
        /// STATE_NOTE_UNSPECIFIED as the first value of State.
        Unspecified = 0,
        /// CMEK access is unavailable.
        PausedCmekUnavailable = 1,
        /// INSTANCE_RESUMING indicates that the instance was previously paused
        /// and is under the process of being brought back.
        InstanceResuming = 2,
    }
    impl StateNote {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_NOTE_UNSPECIFIED",
                Self::PausedCmekUnavailable => "PAUSED_CMEK_UNAVAILABLE",
                Self::InstanceResuming => "INSTANCE_RESUMING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_NOTE_UNSPECIFIED" => Some(Self::Unspecified),
                "PAUSED_CMEK_UNAVAILABLE" => Some(Self::PausedCmekUnavailable),
                "INSTANCE_RESUMING" => Some(Self::InstanceResuming),
                _ => None,
            }
        }
    }
}
/// Metadata of a Secure Source Manager repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Repository {
    /// Optional. A unique identifier for a repository. The name should be of the
    /// format:
    /// `projects/{project}/locations/{location_id}/repositories/{repository_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Description of the repository, which cannot exceed 500
    /// characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The name of the instance in which the repository is hosted,
    /// formatted as
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`
    /// When creating repository via securesourcemanager.googleapis.com, this field
    /// is used as input. When creating repository via *.sourcemanager.dev, this
    /// field is output only.
    #[prost(string, tag = "3")]
    pub instance: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the repository.
    #[prost(string, tag = "4")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Create timestamp.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update timestamp.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. URIs for the repository.
    #[prost(message, optional, tag = "9")]
    pub uris: ::core::option::Option<repository::UrIs>,
    /// Input only. Initial configurations for the repository.
    #[prost(message, optional, tag = "10")]
    pub initial_config: ::core::option::Option<repository::InitialConfig>,
}
/// Nested message and enum types in `Repository`.
pub mod repository {
    /// URIs for the repository.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UrIs {
        /// Output only. HTML is the URI for user to view the repository in a
        /// browser.
        #[prost(string, tag = "1")]
        pub html: ::prost::alloc::string::String,
        /// Output only. git_https is the git HTTPS URI for git operations.
        #[prost(string, tag = "2")]
        pub git_https: ::prost::alloc::string::String,
        /// Output only. API is the URI for API access.
        #[prost(string, tag = "3")]
        pub api: ::prost::alloc::string::String,
    }
    /// Repository initialization configuration.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InitialConfig {
        /// Default branch name of the repository.
        #[prost(string, tag = "1")]
        pub default_branch: ::prost::alloc::string::String,
        /// List of gitignore template names user can choose from.
        /// Valid values: actionscript, ada, agda, android,
        /// anjuta, ansible, appcelerator-titanium, app-engine, archives,
        /// arch-linux-packages, atmel-studio, autotools, backup, bazaar, bazel,
        /// bitrix, bricx-cc, c, cake-php, calabash, cf-wheels, chef-cookbook,
        /// clojure, cloud9, c-make, code-igniter, code-kit, code-sniffer,
        /// common-lisp, composer, concrete5, coq, cordova, cpp, craft-cms, cuda,
        /// cvs, d, dart, dart-editor, delphi, diff, dm, dreamweaver, dropbox,
        /// drupal, drupal-7, eagle, eclipse, eiffel-studio, elisp, elixir, elm,
        /// emacs, ensime, epi-server, erlang, esp-idf, espresso, exercism,
        /// expression-engine, ext-js, fancy, finale, flex-builder, force-dot-com,
        /// fortran, fuel-php, gcov, git-book, gnome-shell-extension, go, godot, gpg,
        /// gradle, grails, gwt, haskell, hugo, iar-ewarm, idris, igor-pro, images,
        /// infor-cms, java, jboss, jboss-4, jboss-6, jdeveloper, jekyll,
        /// jenkins-home, jenv, jet-brains, jigsaw, joomla, julia, jupyter-notebooks,
        /// kate, kdevelop4, kentico, ki-cad, kohana, kotlin, lab-view, laravel,
        /// lazarus, leiningen, lemon-stand, libre-office, lilypond, linux, lithium,
        /// logtalk, lua, lyx, mac-os, magento, magento-1, magento-2, matlab, maven,
        /// mercurial, mercury, metals, meta-programming-system, meteor,
        /// microsoft-office, model-sim, momentics, mono-develop, nanoc, net-beans,
        /// nikola, nim, ninja, node, notepad-pp, nwjs, objective--c, ocaml, octave,
        /// opa, open-cart, openssl, oracle-forms, otto, packer, patch, perl, perl6,
        /// phalcon, phoenix, pimcore, play-framework, plone, prestashop, processing,
        /// psoc-creator, puppet, pure-script, putty, python, qooxdoo, qt, r, racket,
        /// rails, raku, red, redcar, redis, rhodes-rhomobile, ros, ruby, rust, sam,
        /// sass, sbt, scala, scheme, scons, scrivener, sdcc, seam-gen, sketch-up,
        /// slick-edit, smalltalk, snap, splunk, stata, stella, sublime-text,
        /// sugar-crm, svn, swift, symfony, symphony-cms, synopsys-vcs, tags,
        /// terraform, tex, text-mate, textpattern, think-php, tortoise-git,
        /// turbo-gears-2, typo3, umbraco, unity, unreal-engine, vagrant, vim,
        /// virtual-env, virtuoso, visual-studio, visual-studio-code, vue, vvvv, waf,
        /// web-methods, windows, word-press, xcode, xilinx, xilinx-ise, xojo,
        /// yeoman, yii, zend-framework, zephir.
        #[prost(string, repeated, tag = "2")]
        pub gitignores: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// License template name user can choose from.
        /// Valid values: license-0bsd, license-389-exception, aal, abstyles,
        /// adobe-2006, adobe-glyph, adsl, afl-1-1, afl-1-2, afl-2-0, afl-2-1,
        /// afl-3-0, afmparse, agpl-1-0, agpl-1-0-only, agpl-1-0-or-later,
        /// agpl-3-0-only, agpl-3-0-or-later, aladdin, amdplpa, aml, ampas, antlr-pd,
        /// antlr-pd-fallback, apache-1-0, apache-1-1, apache-2-0, apafml, apl-1-0,
        /// apsl-1-0, apsl-1-1, apsl-1-2, apsl-2-0, artistic-1-0, artistic-1-0-cl8,
        /// artistic-1-0-perl, artistic-2-0, autoconf-exception-2-0,
        /// autoconf-exception-3-0, bahyph, barr, beerware, bison-exception-2-2,
        /// bittorrent-1-0, bittorrent-1-1, blessing, blueoak-1-0-0,
        /// bootloader-exception, borceux, bsd-1-clause, bsd-2-clause,
        /// bsd-2-clause-freebsd, bsd-2-clause-netbsd, bsd-2-clause-patent,
        /// bsd-2-clause-views, bsd-3-clause, bsd-3-clause-attribution,
        /// bsd-3-clause-clear, bsd-3-clause-lbnl, bsd-3-clause-modification,
        /// bsd-3-clause-no-nuclear-license, bsd-3-clause-no-nuclear-license-2014,
        /// bsd-3-clause-no-nuclear-warranty, bsd-3-clause-open-mpi, bsd-4-clause,
        /// bsd-4-clause-shortened, bsd-4-clause-uc, bsd-protection, bsd-source-code,
        /// bsl-1-0, busl-1-1, cal-1-0, cal-1-0-combined-work-exception, caldera,
        /// catosl-1-1, cc0-1-0, cc-by-1-0, cc-by-2-0, cc-by-3-0, cc-by-3-0-at,
        /// cc-by-3-0-us, cc-by-4-0, cc-by-nc-1-0, cc-by-nc-2-0, cc-by-nc-3-0,
        /// cc-by-nc-4-0, cc-by-nc-nd-1-0, cc-by-nc-nd-2-0, cc-by-nc-nd-3-0,
        /// cc-by-nc-nd-3-0-igo, cc-by-nc-nd-4-0, cc-by-nc-sa-1-0, cc-by-nc-sa-2-0,
        /// cc-by-nc-sa-3-0, cc-by-nc-sa-4-0, cc-by-nd-1-0, cc-by-nd-2-0,
        /// cc-by-nd-3-0, cc-by-nd-4-0, cc-by-sa-1-0, cc-by-sa-2-0, cc-by-sa-2-0-uk,
        /// cc-by-sa-2-1-jp, cc-by-sa-3-0, cc-by-sa-3-0-at, cc-by-sa-4-0, cc-pddc,
        /// cddl-1-0, cddl-1-1, cdla-permissive-1-0, cdla-sharing-1-0, cecill-1-0,
        /// cecill-1-1, cecill-2-0, cecill-2-1, cecill-b, cecill-c, cern-ohl-1-1,
        /// cern-ohl-1-2, cern-ohl-p-2-0, cern-ohl-s-2-0, cern-ohl-w-2-0, clartistic,
        /// classpath-exception-2-0, clisp-exception-2-0, cnri-jython, cnri-python,
        /// cnri-python-gpl-compatible, condor-1-1, copyleft-next-0-3-0,
        /// copyleft-next-0-3-1, cpal-1-0, cpl-1-0, cpol-1-02, crossword,
        /// crystal-stacker, cua-opl-1-0, cube, c-uda-1-0, curl, d-fsl-1-0, diffmark,
        /// digirule-foss-exception, doc, dotseqn, drl-1-0, dsdp, dvipdfm, ecl-1-0,
        /// ecl-2-0, ecos-exception-2-0, efl-1-0, efl-2-0, egenix, entessa, epics,
        /// epl-1-0, epl-2-0, erlpl-1-1, etalab-2-0, eu-datagrid, eupl-1-0, eupl-1-1,
        /// eupl-1-2, eurosym, fair, fawkes-runtime-exception, fltk-exception,
        /// font-exception-2-0, frameworx-1-0, freebsd-doc, freeimage,
        /// freertos-exception-2-0, fsfap, fsful, fsfullr, ftl, gcc-exception-2-0,
        /// gcc-exception-3-1, gd, gfdl-1-1-invariants-only,
        /// gfdl-1-1-invariants-or-later, gfdl-1-1-no-invariants-only,
        /// gfdl-1-1-no-invariants-or-later, gfdl-1-1-only, gfdl-1-1-or-later,
        /// gfdl-1-2-invariants-only, gfdl-1-2-invariants-or-later,
        /// gfdl-1-2-no-invariants-only, gfdl-1-2-no-invariants-or-later,
        /// gfdl-1-2-only, gfdl-1-2-or-later, gfdl-1-3-invariants-only,
        /// gfdl-1-3-invariants-or-later, gfdl-1-3-no-invariants-only,
        /// gfdl-1-3-no-invariants-or-later, gfdl-1-3-only, gfdl-1-3-or-later,
        /// giftware, gl2ps, glide, glulxe, glwtpl, gnu-javamail-exception, gnuplot,
        /// gpl-1-0-only, gpl-1-0-or-later, gpl-2-0-only, gpl-2-0-or-later,
        /// gpl-3-0-linking-exception, gpl-3-0-linking-source-exception,
        /// gpl-3-0-only, gpl-3-0-or-later, gpl-cc-1-0, gsoap-1-3b, haskell-report,
        /// hippocratic-2-1, hpnd, hpnd-sell-variant, htmltidy,
        /// i2p-gpl-java-exception, ibm-pibs, icu, ijg, image-magick, imatix, imlib2,
        /// info-zip, intel, intel-acpi, interbase-1-0, ipa, ipl-1-0, isc,
        /// jasper-2-0, jpnic, json, lal-1-2, lal-1-3, latex2e, leptonica,
        /// lgpl-2-0-only, lgpl-2-0-or-later, lgpl-2-1-only, lgpl-2-1-or-later,
        /// lgpl-3-0-linking-exception, lgpl-3-0-only, lgpl-3-0-or-later, lgpllr,
        /// libpng, libpng-2-0, libselinux-1-0, libtiff, libtool-exception,
        /// liliq-p-1-1, liliq-r-1-1, liliq-rplus-1-1, linux-openib,
        /// linux-syscall-note, llvm-exception, lpl-1-0, lpl-1-02, lppl-1-0,
        /// lppl-1-1, lppl-1-2, lppl-1-3a, lppl-1-3c, lzma-exception, make-index,
        /// mif-exception, miros, mit, mit-0, mit-advertising, mit-cmu, mit-enna,
        /// mit-feh, mit-modern-variant, mitnfa, mit-open-group, motosoto, mpich2,
        /// mpl-1-0, mpl-1-1, mpl-2-0, mpl-2-0-no-copyleft-exception, ms-pl, ms-rl,
        /// mtll, mulanpsl-1-0, mulanpsl-2-0, multics, mup, naist-2003, nasa-1-3,
        /// naumen, nbpl-1-0, ncgl-uk-2-0, ncsa, netcdf, net-snmp, newsletr, ngpl,
        /// nist-pd, nist-pd-fallback, nlod-1-0, nlpl, nokia, nokia-qt-exception-1-1,
        /// nosl, noweb, npl-1-0, npl-1-1, nposl-3-0, nrl, ntp, ntp-0,
        /// ocaml-lgpl-linking-exception, occt-exception-1-0, occt-pl, oclc-2-0,
        /// odbl-1-0, odc-by-1-0, ofl-1-0, ofl-1-0-no-rfn, ofl-1-0-rfn, ofl-1-1,
        /// ofl-1-1-no-rfn, ofl-1-1-rfn, ogc-1-0, ogdl-taiwan-1-0, ogl-canada-2-0,
        /// ogl-uk-1-0, ogl-uk-2-0, ogl-uk-3-0, ogtsl, oldap-1-1, oldap-1-2,
        /// oldap-1-3, oldap-1-4, oldap-2-0, oldap-2-0-1, oldap-2-1, oldap-2-2,
        /// oldap-2-2-1, oldap-2-2-2, oldap-2-3, oldap-2-4, oldap-2-7, oml,
        /// openjdk-assembly-exception-1-0, openssl, openvpn-openssl-exception,
        /// opl-1-0, oset-pl-2-1, osl-1-0, osl-1-1, osl-2-0, osl-2-1, osl-3-0,
        /// o-uda-1-0, parity-6-0-0, parity-7-0-0, pddl-1-0, php-3-0, php-3-01,
        /// plexus, polyform-noncommercial-1-0-0, polyform-small-business-1-0-0,
        /// postgresql, psf-2-0, psfrag, ps-or-pdf-font-exception-20170817, psutils,
        /// python-2-0, qhull, qpl-1-0, qt-gpl-exception-1-0, qt-lgpl-exception-1-1,
        /// qwt-exception-1-0, rdisc, rhecos-1-1, rpl-1-1, rpsl-1-0, rsa-md, rscpl,
        /// ruby, saxpath, sax-pd, scea, sendmail, sendmail-8-23, sgi-b-1-0,
        /// sgi-b-1-1, sgi-b-2-0, shl-0-51, shl-2-0, shl-2-1, simpl-2-0, sissl,
        /// sissl-1-2, sleepycat, smlnj, smppl, snia, spencer-86, spencer-94,
        /// spencer-99, spl-1-0, ssh-openssh, ssh-short, sspl-1-0, sugarcrm-1-1-3,
        /// swift-exception, swl, tapr-ohl-1-0, tcl, tcp-wrappers, tmate, torque-1-1,
        /// tosl, tu-berlin-1-0, tu-berlin-2-0, u-boot-exception-2-0, ucl-1-0,
        /// unicode-dfs-2015, unicode-dfs-2016, unicode-tou,
        /// universal-foss-exception-1-0, unlicense, upl-1-0, vim, vostrom, vsl-1-0,
        /// w3c, w3c-19980720, w3c-20150513, watcom-1-0, wsuipa, wtfpl,
        /// wxwindows-exception-3-1, x11, xerox, xfree86-1-1, xinetd, xnet, xpp,
        /// xskat, ypl-1-0, ypl-1-1, zed, zend-2-0, zimbra-1-3, zimbra-1-4, zlib,
        /// zlib-acknowledgement, zpl-1-1, zpl-2-0, zpl-2-1.
        #[prost(string, tag = "3")]
        pub license: ::prost::alloc::string::String,
        /// README template name.
        /// Valid template name(s) are: default.
        #[prost(string, tag = "4")]
        pub readme: ::prost::alloc::string::String,
    }
}
/// Metadata of a Secure Source Manager Hook.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hook {
    /// Identifier. A unique identifier for a Hook. The name should be of the
    /// format:
    /// `projects/{project}/locations/{location_id}/repositories/{repository_id}/hooks/{hook_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The target URI to which the payloads will be delivered.
    #[prost(string, tag = "2")]
    pub target_uri: ::prost::alloc::string::String,
    /// Optional. Determines if the hook disabled or not.
    /// Set to true to stop sending traffic.
    #[prost(bool, tag = "3")]
    pub disabled: bool,
    /// Optional. The events that trigger hook on.
    #[prost(enumeration = "hook::HookEventType", repeated, packed = "false", tag = "4")]
    pub events: ::prost::alloc::vec::Vec<i32>,
    /// Output only. Create timestamp.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update timestamp.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Unique identifier of the hook.
    #[prost(string, tag = "7")]
    pub uid: ::prost::alloc::string::String,
    /// Optional. The trigger option for push events.
    #[prost(message, optional, tag = "9")]
    pub push_option: ::core::option::Option<hook::PushOption>,
    /// Optional. The sensitive query string to be appended to the target URI.
    #[prost(string, tag = "10")]
    pub sensitive_query_string: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Hook`.
pub mod hook {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PushOption {
        /// Optional. Trigger hook for matching branches only.
        /// Specified as glob pattern. If empty or *, events for all branches are
        /// reported. Examples: main, {main,release*}.
        /// See <https://pkg.go.dev/github.com/gobwas/glob> documentation.
        #[prost(string, tag = "1")]
        pub branch_filter: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HookEventType {
        /// Unspecified.
        Unspecified = 0,
        /// Push events are triggered when pushing to the repository.
        Push = 1,
        /// Pull request events are triggered when a pull request is opened, closed,
        /// reopened, or edited.
        PullRequest = 2,
    }
    impl HookEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Push => "PUSH",
                Self::PullRequest => "PULL_REQUEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "PUSH" => Some(Self::Push),
                "PULL_REQUEST" => Some(Self::PullRequest),
                _ => None,
            }
        }
    }
}
/// Metadata of a BranchRule. BranchRule is the protection rule to enforce
/// pre-defined rules on designated branches within a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BranchRule {
    /// Optional. A unique identifier for a BranchRule. The name should be of the
    /// format:
    /// `projects/{project}/locations/{location}/repositories/{repository}/branchRules/{branch_rule}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique identifier of the repository.
    #[prost(string, tag = "2")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. Create timestamp.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Update timestamp.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. User annotations. These attributes can only be set and used by
    /// the user. See <https://google.aip.dev/128#annotations> for more details such
    /// as format and size limitations.
    #[prost(map = "string, string", tag = "5")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "6")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. The pattern of the branch that can match to this BranchRule.
    /// Specified as regex.
    /// .* for all branches. Examples: main, (main|release.*).
    /// Current MVP phase only support `.*` for wildcard.
    #[prost(string, tag = "7")]
    pub include_pattern: ::prost::alloc::string::String,
    /// Optional. Determines if the branch rule is disabled or not.
    #[prost(bool, tag = "8")]
    pub disabled: bool,
    /// Optional. Determines if the branch rule requires a pull request or not.
    #[prost(bool, tag = "9")]
    pub require_pull_request: bool,
    /// Optional. The minimum number of reviews required for the branch rule to be
    /// matched.
    #[prost(int32, tag = "10")]
    pub minimum_reviews_count: i32,
    /// Optional. The minimum number of approvals required for the branch rule to
    /// be matched.
    #[prost(int32, tag = "11")]
    pub minimum_approvals_count: i32,
    /// Optional. Determines if require comments resolved before merging to the
    /// branch.
    #[prost(bool, tag = "12")]
    pub require_comments_resolved: bool,
    /// Optional. Determines if allow stale reviews or approvals before merging to
    /// the branch.
    #[prost(bool, tag = "15")]
    pub allow_stale_reviews: bool,
    /// Optional. Determines if require linear history before merging to the
    /// branch.
    #[prost(bool, tag = "13")]
    pub require_linear_history: bool,
    /// Optional. List of required status checks before merging to the branch.
    #[prost(message, repeated, tag = "14")]
    pub required_status_checks: ::prost::alloc::vec::Vec<branch_rule::Check>,
}
/// Nested message and enum types in `BranchRule`.
pub mod branch_rule {
    /// Check is a type for status check.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Check {
        /// Required. The context of the check.
        #[prost(string, tag = "1")]
        pub context: ::prost::alloc::string::String,
    }
}
/// Metadata of a PullRequest. PullRequest is the request
/// from a user to merge a branch (head) into another branch (base).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRequest {
    /// Output only. A unique identifier for a PullRequest. The number appended at
    /// the end is generated by the server. Format:
    /// `projects/{project}/locations/{location}/repositories/{repository}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The pull request title.
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// Optional. The pull request body. Provides a detailed description of the
    /// changes.
    #[prost(string, tag = "3")]
    pub body: ::prost::alloc::string::String,
    /// Required. The branch to merge changes in.
    #[prost(message, optional, tag = "4")]
    pub base: ::core::option::Option<pull_request::Branch>,
    /// Immutable. The branch containing the changes to be merged.
    #[prost(message, optional, tag = "5")]
    pub head: ::core::option::Option<pull_request::Branch>,
    /// Output only. State of the pull request (open, closed or merged).
    #[prost(enumeration = "pull_request::State", tag = "6")]
    pub state: i32,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last updated timestamp.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Close timestamp (if closed or merged). Cleared when pull
    /// request is re-opened.
    #[prost(message, optional, tag = "9")]
    pub close_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PullRequest`.
pub mod pull_request {
    /// Branch represents a branch involved in a pull request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Branch {
        /// Required. Name of the branch.
        #[prost(string, tag = "1")]
        pub r#ref: ::prost::alloc::string::String,
        /// Output only. The commit at the tip of the branch.
        #[prost(string, tag = "2")]
        pub sha: ::prost::alloc::string::String,
    }
    /// State of the pull request.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified.
        Unspecified = 0,
        /// An open pull request.
        Open = 1,
        /// A closed pull request.
        Closed = 2,
        /// A merged pull request.
        Merged = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Open => "OPEN",
                Self::Closed => "CLOSED",
                Self::Merged => "MERGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "OPEN" => Some(Self::Open),
                "CLOSED" => Some(Self::Closed),
                "MERGED" => Some(Self::Merged),
                _ => None,
            }
        }
    }
}
/// Metadata of a FileDiff. FileDiff represents a single file diff in a pull
/// request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDiff {
    /// Output only. The name of the file.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The action taken on the file (eg. added, modified, deleted).
    #[prost(enumeration = "file_diff::Action", tag = "2")]
    pub action: i32,
    /// Output only. The commit pointing to the file changes.
    #[prost(string, tag = "3")]
    pub sha: ::prost::alloc::string::String,
    /// Output only. The git patch containing the file changes.
    #[prost(string, tag = "4")]
    pub patch: ::prost::alloc::string::String,
}
/// Nested message and enum types in `FileDiff`.
pub mod file_diff {
    /// Action taken on the file.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        /// Unspecified.
        Unspecified = 0,
        /// The file was added.
        Added = 1,
        /// The file was modified.
        Modified = 2,
        /// The file was deleted.
        Deleted = 3,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACTION_UNSPECIFIED",
                Self::Added => "ADDED",
                Self::Modified => "MODIFIED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "ADDED" => Some(Self::Added),
                "MODIFIED" => Some(Self::Modified),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// Metadata of an Issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Issue {
    /// Identifier. Unique identifier for an issue. The issue id is generated by
    /// the server. Format:
    /// `projects/{project}/locations/{location}/repositories/{repository}/issues/{issue_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Issue title.
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// Optional. Issue body. Provides a detailed description of the issue.
    #[prost(string, tag = "3")]
    pub body: ::prost::alloc::string::String,
    /// Output only. State of the issue.
    #[prost(enumeration = "issue::State", tag = "4")]
    pub state: i32,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last updated timestamp.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Close timestamp (if closed). Cleared when is re-opened.
    #[prost(message, optional, tag = "7")]
    pub close_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[prost(string, tag = "8")]
    pub etag: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Issue`.
pub mod issue {
    /// Possible states of an issue.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unspecified.
        Unspecified = 0,
        /// An open issue.
        Open = 1,
        /// A closed issue.
        Closed = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Open => "OPEN",
                Self::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "OPEN" => Some(Self::Open),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
/// IssueComment represents a comment on an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssueComment {
    /// Identifier. Unique identifier for an issue comment. The comment id is
    /// generated by the server. Format:
    /// `projects/{project}/locations/{location}/repositories/{repository}/issues/{issue}/issueComments/{comment_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The comment body.
    #[prost(string, tag = "2")]
    pub body: ::prost::alloc::string::String,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last updated timestamp.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// PullRequestComment represents a comment on a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PullRequestComment {
    /// Identifier. Unique identifier for the pull request comment. The comment id
    /// is generated by the server. Format:
    /// `projects/{project}/locations/{location}/repositories/{repository}/pullRequests/{pull_request}/pullRequestComments/{comment_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last updated timestamp.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The comment detail. A comment can be a review, a general comment, or a
    /// code comment.
    #[prost(oneof = "pull_request_comment::CommentDetail", tags = "4, 5, 6")]
    pub comment_detail: ::core::option::Option<pull_request_comment::CommentDetail>,
}
/// Nested message and enum types in `PullRequestComment`.
pub mod pull_request_comment {
    /// The review summary comment.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Review {
        /// Required. The review action type.
        #[prost(enumeration = "review::ActionType", tag = "1")]
        pub action_type: i32,
        /// Optional. The comment body.
        #[prost(string, tag = "2")]
        pub body: ::prost::alloc::string::String,
        /// Output only. The effective commit sha this review is pointing to.
        #[prost(string, tag = "4")]
        pub effective_commit_sha: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `Review`.
    pub mod review {
        /// The review action type.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ActionType {
            /// Unspecified.
            Unspecified = 0,
            /// A general review comment.
            Comment = 1,
            /// Change required from this review.
            ChangeRequested = 2,
            /// Change approved from this review.
            Approved = 3,
        }
        impl ActionType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ACTION_TYPE_UNSPECIFIED",
                    Self::Comment => "COMMENT",
                    Self::ChangeRequested => "CHANGE_REQUESTED",
                    Self::Approved => "APPROVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "COMMENT" => Some(Self::Comment),
                    "CHANGE_REQUESTED" => Some(Self::ChangeRequested),
                    "APPROVED" => Some(Self::Approved),
                    _ => None,
                }
            }
        }
    }
    /// The general pull request comment.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Comment {
        /// Required. The comment body.
        #[prost(string, tag = "1")]
        pub body: ::prost::alloc::string::String,
    }
    /// The comment on a code line.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Code {
        /// Required. The comment body.
        #[prost(string, tag = "1")]
        pub body: ::prost::alloc::string::String,
        /// Optional. Input only. The PullRequestComment resource name that this
        /// comment is replying to.
        #[prost(string, tag = "2")]
        pub reply: ::prost::alloc::string::String,
        /// Optional. The position of the comment.
        #[prost(message, optional, tag = "3")]
        pub position: ::core::option::Option<Position>,
        /// Output only. The root comment of the conversation, derived from the reply
        /// field.
        #[prost(string, tag = "4")]
        pub effective_root_comment: ::prost::alloc::string::String,
        /// Output only. Boolean indicator if the comment is resolved.
        #[prost(bool, tag = "5")]
        pub resolved: bool,
        /// Output only. The effective commit sha this code comment is pointing to.
        #[prost(string, tag = "7")]
        pub effective_commit_sha: ::prost::alloc::string::String,
    }
    /// The position of the code comment.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Position {
        /// Required. The path of the file.
        #[prost(string, tag = "1")]
        pub path: ::prost::alloc::string::String,
        /// Required. The line number of the comment. Positive value means it's on
        /// the new side of the diff, negative value means it's on the old side.
        #[prost(int64, tag = "2")]
        pub line: i64,
    }
    /// The comment detail. A comment can be a review, a general comment, or a
    /// code comment.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CommentDetail {
        /// Optional. The review summary comment.
        #[prost(message, tag = "4")]
        Review(Review),
        /// Optional. The general pull request comment.
        #[prost(message, tag = "5")]
        Comment(Comment),
        /// Optional. The comment on a code line.
        #[prost(message, tag = "6")]
        Code(Code),
    }
}
/// ListInstancesRequest is the request to list instances.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    /// Required. Parent value for ListInstancesRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter for filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Hint for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
    /// The list of instances.
    #[prost(message, repeated, tag = "1")]
    pub instances: ::prost::alloc::vec::Vec<Instance>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// GetInstanceRequest is the request for getting an instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// CreateInstanceRequest is the request for creating an instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the instance to be created.
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub instance: ::core::option::Option<Instance>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// DeleteInstanceRequest is the request for deleting an instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][google.longrunning.Operation.error] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// ListRepositoriesRequest is request to list repositories.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRepositoriesRequest {
    /// Required. Parent value for ListRepositoriesRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The name of the instance in which the repository is hosted,
    /// formatted as
    /// `projects/{project_number}/locations/{location_id}/instances/{instance_id}`.
    /// When listing repositories via securesourcemanager.googleapis.com, this
    /// field is required. When listing repositories via *.sourcemanager.dev, this
    /// field is ignored.
    #[prost(string, tag = "5")]
    pub instance: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRepositoriesResponse {
    /// The list of repositories.
    #[prost(message, repeated, tag = "1")]
    pub repositories: ::prost::alloc::vec::Vec<Repository>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// GetRepositoryRequest is the request for getting a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRepositoryRequest {
    /// Required. Name of the repository to retrieve.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// CreateRepositoryRequest is the request for creating a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRepositoryRequest {
    /// Required. The project in which to create the repository. Values are of the
    /// form `projects/{project_number}/locations/{location_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "2")]
    pub repository: ::core::option::Option<Repository>,
    /// Required. The ID to use for the repository, which will become the final
    /// component of the repository's resource name. This value should be 4-63
    /// characters, and valid characters are /[a-z][0-9]-/.
    #[prost(string, tag = "3")]
    pub repository_id: ::prost::alloc::string::String,
}
/// UpdateRepositoryRequest is the request to update a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRepositoryRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// repository resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The repository being updated.
    #[prost(message, optional, tag = "2")]
    pub repository: ::core::option::Option<Repository>,
    /// Optional. False by default. If set to true, the request is validated and
    /// the user is provided with an expected result, but no actual change is made.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
}
/// DeleteRepositoryRequest is the request to delete a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRepositoryRequest {
    /// Required. Name of the repository to delete.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, and the repository is not found, the request will
    /// succeed but no action will be taken on the server.
    #[prost(bool, tag = "2")]
    pub allow_missing: bool,
}
/// ListHooksRequest is request to list hooks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHooksRequest {
    /// Required. Parent value for ListHooksRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListHooksResponse is response to list hooks.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHooksResponse {
    /// The list of hooks.
    #[prost(message, repeated, tag = "1")]
    pub hooks: ::prost::alloc::vec::Vec<Hook>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// GetHookRequest is the request for getting a hook.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHookRequest {
    /// Required. Name of the hook to retrieve.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/hooks/{hook_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// CreateHookRequest is the request for creating a hook.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateHookRequest {
    /// Required. The repository in which to create the hook. Values are of the
    /// form
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "2")]
    pub hook: ::core::option::Option<Hook>,
    /// Required. The ID to use for the hook, which will become the final component
    /// of the hook's resource name. This value restricts to lower-case letters,
    /// numbers, and hyphen, with the first character a letter, the last a letter
    /// or a number, and a 63 character maximum.
    #[prost(string, tag = "3")]
    pub hook_id: ::prost::alloc::string::String,
}
/// UpdateHookRequest is the request to update a hook.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHookRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// hook resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// The special value "*" means full replacement.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The hook being updated.
    #[prost(message, optional, tag = "2")]
    pub hook: ::core::option::Option<Hook>,
}
/// DeleteHookRequest is the request to delete a hook.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHookRequest {
    /// Required. Name of the hook to delete.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/hooks/{hook_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// GetBranchRuleRequest is the request for getting a branch rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBranchRuleRequest {
    /// Required. Name of the repository to retrieve.
    /// The format is
    /// `projects/{project}/locations/{location}/repositories/{repository}/branchRules/{branch_rule}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// CreateBranchRuleRequest is the request to create a branch rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBranchRuleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub branch_rule: ::core::option::Option<BranchRule>,
    #[prost(string, tag = "3")]
    pub branch_rule_id: ::prost::alloc::string::String,
}
/// ListBranchRulesRequest is the request to list branch rules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBranchRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// DeleteBranchRuleRequest is the request to delete a branch rule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBranchRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, and the branch rule is not found, the request
    /// will succeed but no action will be taken on the server.
    #[prost(bool, tag = "2")]
    pub allow_missing: bool,
}
/// UpdateBranchRuleRequest is the request to update a branchRule.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBranchRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub branch_rule: ::core::option::Option<BranchRule>,
    /// Optional. If set, validate the request and preview the review, but do not
    /// actually post it.  (<https://google.aip.dev/163,> for declarative friendly)
    #[prost(bool, tag = "2")]
    pub validate_only: bool,
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// branchRule resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// The special value "*" means full replacement.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// ListBranchRulesResponse is the response to listing branchRules.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBranchRulesResponse {
    /// The list of branch rules.
    #[prost(message, repeated, tag = "1")]
    pub branch_rules: ::prost::alloc::vec::Vec<BranchRule>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// CreatePullRequestRequest is the request to create a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePullRequestRequest {
    /// Required. The repository that the pull request is created from. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The pull request to create.
    #[prost(message, optional, tag = "2")]
    pub pull_request: ::core::option::Option<PullRequest>,
}
/// GetPullRequestRequest is the request to get a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPullRequestRequest {
    /// Required. Name of the pull request to retrieve.
    /// The format is
    /// `projects/{project}/locations/{location}/repositories/{repository}/pullRequests/{pull_request}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// ListPullRequestsRequest is the request to list pull requests.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPullRequestsRequest {
    /// Required. The repository in which to list pull requests. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListPullRequestsResponse is the response to list pull requests.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPullRequestsResponse {
    /// The list of pull requests.
    #[prost(message, repeated, tag = "1")]
    pub pull_requests: ::prost::alloc::vec::Vec<PullRequest>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// UpdatePullRequestRequest is the request to update a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePullRequestRequest {
    /// Required. The pull request to update.
    #[prost(message, optional, tag = "1")]
    pub pull_request: ::core::option::Option<PullRequest>,
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// pull request resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// The special value "*" means full replacement.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// MergePullRequestRequest is the request to merge a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergePullRequestRequest {
    /// Required. The pull request to merge.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// OpenPullRequestRequest is the request to open a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenPullRequestRequest {
    /// Required. The pull request to open.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// ClosePullRequestRequest is the request to close a pull request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClosePullRequestRequest {
    /// Required. The pull request to close.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// ListPullRequestFileDiffsRequest is the request to list pull request file
/// diffs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPullRequestFileDiffsRequest {
    /// Required. The pull request to list file diffs for.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// ListPullRequestFileDiffsResponse is the response containing file diffs
/// returned from ListPullRequestFileDiffs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPullRequestFileDiffsResponse {
    /// The list of pull request file diffs.
    #[prost(message, repeated, tag = "1")]
    pub file_diffs: ::prost::alloc::vec::Vec<FileDiff>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to create an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueRequest {
    /// Required. The repository in which to create the issue. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The issue to create.
    #[prost(message, optional, tag = "2")]
    pub issue: ::core::option::Option<Issue>,
}
/// The request to get an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIssueRequest {
    /// Required. Name of the issue to retrieve.
    /// The format is
    /// `projects/{project}/locations/{location}/repositories/{repository}/issues/{issue_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to list issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssuesRequest {
    /// Required. The repository in which to list issues. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Used to filter the resulting issues list.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response to list issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssuesResponse {
    /// The list of issues.
    #[prost(message, repeated, tag = "1")]
    pub issues: ::prost::alloc::vec::Vec<Issue>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to update an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueRequest {
    /// Required. The issue to update.
    #[prost(message, optional, tag = "1")]
    pub issue: ::core::option::Option<Issue>,
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// issue resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// The special value "*" means full replacement.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueRequest {
    /// Required. Name of the issue to delete.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/issues/{issue_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The current etag of the issue.
    /// If the etag is provided and does not match the current etag of the issue,
    /// deletion will be blocked and an ABORTED error will be returned.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// The request to close an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloseIssueRequest {
    /// Required. Name of the issue to close.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/issues/{issue_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The current etag of the issue.
    /// If the etag is provided and does not match the current etag of the issue,
    /// closing will be blocked and an ABORTED error will be returned.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// The request to open an issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OpenIssueRequest {
    /// Required. Name of the issue to open.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/issues/{issue_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The current etag of the issue.
    /// If the etag is provided and does not match the current etag of the issue,
    /// opening will be blocked and an ABORTED error will be returned.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Represents an entry within a tree structure (like a Git tree).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeEntry {
    /// Output only. The type of the object (TREE, BLOB, COMMIT).  Output-only.
    #[prost(enumeration = "tree_entry::ObjectType", tag = "1")]
    pub r#type: i32,
    /// Output only. The SHA-1 hash of the object (unique identifier). Output-only.
    #[prost(string, tag = "2")]
    pub sha: ::prost::alloc::string::String,
    /// Output only. The path of the file or directory within the tree (e.g.,
    /// "src/main/java/MyClass.java"). Output-only.
    #[prost(string, tag = "3")]
    pub path: ::prost::alloc::string::String,
    /// Output only. The file mode as a string (e.g., "100644"). Indicates file
    /// type. Output-only.
    #[prost(string, tag = "4")]
    pub mode: ::prost::alloc::string::String,
    /// Output only. The size of the object in bytes (only for blobs). Output-only.
    #[prost(int64, tag = "5")]
    pub size: i64,
}
/// Nested message and enum types in `TreeEntry`.
pub mod tree_entry {
    /// Defines the type of object the TreeEntry represents.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ObjectType {
        /// Default value, indicating the object type is unspecified.
        Unspecified = 0,
        /// Represents a directory (folder).
        Tree = 1,
        /// Represents a file (contains file data).
        Blob = 2,
        /// Represents a pointer to another repository (submodule).
        Commit = 3,
    }
    impl ObjectType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OBJECT_TYPE_UNSPECIFIED",
                Self::Tree => "TREE",
                Self::Blob => "BLOB",
                Self::Commit => "COMMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OBJECT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TREE" => Some(Self::Tree),
                "BLOB" => Some(Self::Blob),
                "COMMIT" => Some(Self::Commit),
                _ => None,
            }
        }
    }
}
/// Request message for fetching a tree structure from a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTreeRequest {
    /// Required. The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`.
    /// Specifies the repository to fetch the tree from.
    #[prost(string, tag = "1")]
    pub repository: ::prost::alloc::string::String,
    /// Optional. `ref` can be a SHA-1 hash, a branch name, or a tag. Specifies
    /// which tree to fetch. If not specified, the default branch will be used.
    #[prost(string, tag = "2")]
    pub r#ref: ::prost::alloc::string::String,
    /// Optional. If true, include all subfolders and their files in the response.
    /// If false, only the immediate children are returned.
    #[prost(bool, tag = "3")]
    pub recursive: bool,
    /// Optional. Requested page size.  Server may return fewer items than
    /// requested. If unspecified, at most 10,000 items will be returned.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message containing a list of TreeEntry objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchTreeResponse {
    /// The list of TreeEntry objects.
    #[prost(message, repeated, tag = "1")]
    pub tree_entries: ::prost::alloc::vec::Vec<TreeEntry>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for fetching a blob (file content) from a repository.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchBlobRequest {
    /// Required. The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}`.
    /// Specifies the repository containing the blob.
    #[prost(string, tag = "1")]
    pub repository: ::prost::alloc::string::String,
    /// Required. The SHA-1 hash of the blob to retrieve.
    #[prost(string, tag = "2")]
    pub sha: ::prost::alloc::string::String,
}
/// Response message containing the content of a blob.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchBlobResponse {
    /// The SHA-1 hash of the blob.
    #[prost(string, tag = "1")]
    pub sha: ::prost::alloc::string::String,
    /// The content of the blob, encoded as base64.
    #[prost(string, tag = "2")]
    pub content: ::prost::alloc::string::String,
}
/// The request to list pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPullRequestCommentsRequest {
    /// Required. The pull request in which to list pull request comments. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. If unspecified, at most 100 pull request
    /// comments will be returned. The maximum value is 100; values above 100 will
    /// be coerced to 100.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response to list pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPullRequestCommentsResponse {
    /// The list of pull request comments.
    #[prost(message, repeated, tag = "1")]
    pub pull_request_comments: ::prost::alloc::vec::Vec<PullRequestComment>,
    /// A token to set as page_token to retrieve the next page. If this field is
    /// omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to create a pull request comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePullRequestCommentRequest {
    /// Required. The pull request in which to create the pull request comment.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The pull request comment to create.
    #[prost(message, optional, tag = "2")]
    pub pull_request_comment: ::core::option::Option<PullRequestComment>,
}
/// The request to batch create pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreatePullRequestCommentsRequest {
    /// Required. The pull request in which to create the pull request comments.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request message specifying the resources to create. There
    /// should be exactly one CreatePullRequestCommentRequest with CommentDetail
    /// being REVIEW in the list, and no more than 100
    /// CreatePullRequestCommentRequests with CommentDetail being CODE in the list
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreatePullRequestCommentRequest>,
}
/// The response to batch create pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreatePullRequestCommentsResponse {
    /// The list of pull request comments created.
    #[prost(message, repeated, tag = "1")]
    pub pull_request_comments: ::prost::alloc::vec::Vec<PullRequestComment>,
}
/// The request to update a pull request comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePullRequestCommentRequest {
    /// Required. The pull request comment to update.
    #[prost(message, optional, tag = "1")]
    pub pull_request_comment: ::core::option::Option<PullRequestComment>,
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// pull request comment resource by the update. Updatable fields are
    /// `body`.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete a pull request comment. A Review PullRequestComment
/// cannot be deleted.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePullRequestCommentRequest {
    /// Required. Name of the pull request comment to delete.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}/pullRequestComments/{comment_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to get a pull request comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPullRequestCommentRequest {
    /// Required. Name of the pull request comment to retrieve.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}/pullRequestComments/{comment_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to resolve multiple pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvePullRequestCommentsRequest {
    /// Required. The pull request in which to resolve the pull request comments.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The names of the pull request comments to resolve. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}/pullRequestComments/{comment_id}`
    /// Only comments from the same threads are allowed in the same request.
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. If set, at least one comment in a thread is required, rest of the
    /// comments in the same thread will be automatically updated to resolved. If
    /// unset, all comments in the same thread need be present.
    #[prost(bool, tag = "3")]
    pub auto_fill: bool,
}
/// The response to resolve multiple pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvePullRequestCommentsResponse {
    /// The list of pull request comments resolved.
    #[prost(message, repeated, tag = "1")]
    pub pull_request_comments: ::prost::alloc::vec::Vec<PullRequestComment>,
}
/// The request to unresolve multiple pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnresolvePullRequestCommentsRequest {
    /// Required. The pull request in which to resolve the pull request comments.
    /// Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The names of the pull request comments to unresolve. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/pullRequests/{pull_request_id}/pullRequestComments/{comment_id}`
    /// Only comments from the same threads are allowed in the same request.
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. If set, at least one comment in a thread is required, rest of the
    /// comments in the same thread will be automatically updated to unresolved. If
    /// unset, all comments in the same thread need be present.
    #[prost(bool, tag = "3")]
    pub auto_fill: bool,
}
/// The response to unresolve multiple pull request comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnresolvePullRequestCommentsResponse {
    /// The list of pull request comments unresolved.
    #[prost(message, repeated, tag = "1")]
    pub pull_request_comments: ::prost::alloc::vec::Vec<PullRequestComment>,
}
/// The request to create an issue comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIssueCommentRequest {
    /// Required. The issue in which to create the issue comment. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/issues/{issue_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The issue comment to create.
    #[prost(message, optional, tag = "2")]
    pub issue_comment: ::core::option::Option<IssueComment>,
}
/// The request to get an issue comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIssueCommentRequest {
    /// Required. Name of the issue comment to retrieve.
    /// The format is
    /// `projects/{project}/locations/{location}/repositories/{repository}/issues/{issue_id}/issueComments/{comment_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request to list issue comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssueCommentsRequest {
    /// Required. The issue in which to list the comments. Format:
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/issues/{issue_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response to list issue comments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIssueCommentsResponse {
    /// The list of issue comments.
    #[prost(message, repeated, tag = "1")]
    pub issue_comments: ::prost::alloc::vec::Vec<IssueComment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request to update an issue comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssueCommentRequest {
    /// Required. The issue comment to update.
    #[prost(message, optional, tag = "1")]
    pub issue_comment: ::core::option::Option<IssueComment>,
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// issue comment resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    /// The special value "*" means full replacement.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request to delete an issue comment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIssueCommentRequest {
    /// Required. Name of the issue comment to delete.
    /// The format is
    /// `projects/{project_number}/locations/{location_id}/repositories/{repository_id}/issues/{issue_id}/issueComments/{comment_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod secure_source_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Secure Source Manager API
    ///
    /// Access Secure Source Manager instances, resources, and repositories.
    #[derive(Debug, Clone)]
    pub struct SecureSourceManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SecureSourceManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SecureSourceManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SecureSourceManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SecureSourceManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Instances in a given project and location.
        pub async fn list_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInstancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single instance.
        pub async fn get_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Instance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new instance in a given project and location.
        pub async fn create_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreateInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreateInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single instance.
        pub async fn delete_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeleteInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeleteInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Repositories in a given project and location.
        ///
        /// The instance field is required in the query parameter for requests using
        /// the securesourcemanager.googleapis.com endpoint.
        pub async fn list_repositories(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRepositoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRepositoriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListRepositories",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListRepositories",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets metadata of a repository.
        pub async fn get_repository(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRepositoryRequest>,
        ) -> std::result::Result<tonic::Response<super::Repository>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetRepository",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetRepository",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new repository in a given project and location.
        ///
        /// The Repository.Instance field is required in the request body for requests
        /// using the securesourcemanager.googleapis.com endpoint.
        pub async fn create_repository(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRepositoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreateRepository",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreateRepository",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the metadata of a repository.
        pub async fn update_repository(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRepositoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdateRepository",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdateRepository",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Repository.
        pub async fn delete_repository(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRepositoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeleteRepository",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeleteRepository",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists hooks in a given repository.
        pub async fn list_hooks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHooksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHooksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListHooks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListHooks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets metadata of a hook.
        pub async fn get_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHookRequest>,
        ) -> std::result::Result<tonic::Response<super::Hook>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetHook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new hook in a given repository.
        pub async fn create_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateHookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreateHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreateHook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the metadata of a hook.
        pub async fn update_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdateHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdateHook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Hook.
        pub async fn delete_hook(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHookRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeleteHook",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeleteHook",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get IAM policy for a repository.
        pub async fn get_iam_policy_repo(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetIamPolicyRepo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetIamPolicyRepo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set IAM policy on a repository.
        pub async fn set_iam_policy_repo(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/SetIamPolicyRepo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "SetIamPolicyRepo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Test IAM permissions on a repository.
        /// IAM permission checks are not required on this method.
        pub async fn test_iam_permissions_repo(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::super::super::iam::v1::TestIamPermissionsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/TestIamPermissionsRepo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "TestIamPermissionsRepo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// CreateBranchRule creates a branch rule in a given repository.
        pub async fn create_branch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBranchRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreateBranchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreateBranchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// ListBranchRules lists branch rules in a given repository.
        pub async fn list_branch_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBranchRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBranchRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListBranchRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListBranchRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// GetBranchRule gets a branch rule.
        pub async fn get_branch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBranchRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::BranchRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetBranchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetBranchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// UpdateBranchRule updates a branch rule.
        pub async fn update_branch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBranchRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdateBranchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdateBranchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// DeleteBranchRule deletes a branch rule.
        pub async fn delete_branch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBranchRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeleteBranchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeleteBranchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a pull request.
        pub async fn create_pull_request(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePullRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreatePullRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreatePullRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a pull request.
        pub async fn get_pull_request(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPullRequestRequest>,
        ) -> std::result::Result<tonic::Response<super::PullRequest>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetPullRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetPullRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists pull requests in a repository.
        pub async fn list_pull_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPullRequestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPullRequestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListPullRequests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListPullRequests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a pull request.
        pub async fn update_pull_request(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePullRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdatePullRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdatePullRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Merges a pull request.
        pub async fn merge_pull_request(
            &mut self,
            request: impl tonic::IntoRequest<super::MergePullRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/MergePullRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "MergePullRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Opens a pull request.
        pub async fn open_pull_request(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenPullRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/OpenPullRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "OpenPullRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Closes a pull request without merging.
        pub async fn close_pull_request(
            &mut self,
            request: impl tonic::IntoRequest<super::ClosePullRequestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ClosePullRequest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ClosePullRequest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists a pull request's file diffs.
        pub async fn list_pull_request_file_diffs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPullRequestFileDiffsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPullRequestFileDiffsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListPullRequestFileDiffs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListPullRequestFileDiffs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches a tree from a repository.
        pub async fn fetch_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchTreeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchTreeResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/FetchTree",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "FetchTree",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches a blob from a repository.
        pub async fn fetch_blob(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchBlobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchBlobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/FetchBlob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "FetchBlob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an issue.
        pub async fn create_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreateIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreateIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an issue.
        pub async fn get_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIssueRequest>,
        ) -> std::result::Result<tonic::Response<super::Issue>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists issues in a repository.
        pub async fn list_issues(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIssuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListIssues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListIssues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a issue.
        pub async fn update_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdateIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdateIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an issue.
        pub async fn delete_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeleteIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeleteIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Opens an issue.
        pub async fn open_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::OpenIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/OpenIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "OpenIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Closes an issue.
        pub async fn close_issue(
            &mut self,
            request: impl tonic::IntoRequest<super::CloseIssueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CloseIssue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CloseIssue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a pull request comment.
        pub async fn get_pull_request_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPullRequestCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PullRequestComment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetPullRequestComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetPullRequestComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists pull request comments.
        pub async fn list_pull_request_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPullRequestCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPullRequestCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListPullRequestComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListPullRequestComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a pull request comment. This function is used to create a single
        /// PullRequestComment of type Comment, or a single PullRequestComment of type
        /// Code that's replying to another PullRequestComment of type Code. Use
        /// BatchCreatePullRequestComments to create multiple PullRequestComments for
        /// code reviews.
        pub async fn create_pull_request_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePullRequestCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreatePullRequestComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreatePullRequestComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a pull request comment.
        pub async fn update_pull_request_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePullRequestCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdatePullRequestComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdatePullRequestComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a pull request comment.
        pub async fn delete_pull_request_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePullRequestCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeletePullRequestComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeletePullRequestComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Batch creates pull request comments. This function is used to create
        /// multiple PullRequestComments for code review. There needs to be exactly one
        /// PullRequestComment of type Review, and at most 100 PullRequestComments of
        /// type Code per request. The Postition of the code comments must be unique
        /// within the request.
        pub async fn batch_create_pull_request_comments(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchCreatePullRequestCommentsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/BatchCreatePullRequestComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "BatchCreatePullRequestComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resolves pull request comments. A list of PullRequestComment names must be
        /// provided. The PullRequestComment names must be in the same conversation
        /// thread. If auto_fill is set, all comments in the conversation thread will
        /// be resolved.
        pub async fn resolve_pull_request_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ResolvePullRequestCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ResolvePullRequestComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ResolvePullRequestComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Unresolves pull request comments. A list of PullRequestComment names must
        /// be provided. The PullRequestComment names must be in the same conversation
        /// thread. If auto_fill is set, all comments in the conversation thread will
        /// be unresolved.
        pub async fn unresolve_pull_request_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::UnresolvePullRequestCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UnresolvePullRequestComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UnresolvePullRequestComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an issue comment.
        pub async fn create_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/CreateIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "CreateIssueComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an issue comment.
        pub async fn get_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIssueCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::IssueComment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/GetIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "GetIssueComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists comments in an issue.
        pub async fn list_issue_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIssueCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIssueCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/ListIssueComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "ListIssueComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an issue comment.
        pub async fn update_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/UpdateIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "UpdateIssueComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an issue comment.
        pub async fn delete_issue_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIssueCommentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.securesourcemanager.v1.SecureSourceManager/DeleteIssueComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.securesourcemanager.v1.SecureSourceManager",
                        "DeleteIssueComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
