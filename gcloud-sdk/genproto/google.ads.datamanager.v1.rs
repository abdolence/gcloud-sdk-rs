// This file is @generated by prost-build.
/// [Digital Markets Act
/// (DMA)](//digital-markets-act.ec.europa.eu/index_en) consent settings
/// for the user.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Consent {
    /// Optional. Represents if the user consents to ad user data.
    #[prost(enumeration = "ConsentStatus", tag = "1")]
    pub ad_user_data: i32,
    /// Optional. Represents if the user consents to ad personalization.
    #[prost(enumeration = "ConsentStatus", tag = "2")]
    pub ad_personalization: i32,
}
/// Represents if the user granted, denied, or hasn't specified consent.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsentStatus {
    /// Not specified.
    Unspecified = 0,
    /// Granted.
    ConsentGranted = 1,
    /// Denied.
    ConsentDenied = 2,
}
impl ConsentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSENT_STATUS_UNSPECIFIED",
            Self::ConsentGranted => "CONSENT_GRANTED",
            Self::ConsentDenied => "CONSENT_DENIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSENT_GRANTED" => Some(Self::ConsentGranted),
            "CONSENT_DENIED" => Some(Self::ConsentDenied),
            _ => None,
        }
    }
}
/// Data that identifies the user. At least one identifier is required.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserData {
    /// Required. The identifiers for the user. It's possible to provide multiple
    /// instances of the same type of data (for example, multiple email addresses).
    /// To increase the likelihood of a match, provide as many identifiers as
    /// possible. At most 10 `userIdentifiers` can be provided in a single
    /// \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\] or
    /// \[Event\]\[google.ads.datamanager.v1.Event\].
    #[prost(message, repeated, tag = "1")]
    pub user_identifiers: ::prost::alloc::vec::Vec<UserIdentifier>,
}
/// A single identifier for the user.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserIdentifier {
    /// Exactly one must be specified.
    #[prost(oneof = "user_identifier::Identifier", tags = "1, 2, 3")]
    pub identifier: ::core::option::Option<user_identifier::Identifier>,
}
/// Nested message and enum types in `UserIdentifier`.
pub mod user_identifier {
    /// Exactly one must be specified.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Identifier {
        /// Hashed email address using SHA-256 hash function after normalization.
        #[prost(string, tag = "1")]
        EmailAddress(::prost::alloc::string::String),
        /// Hashed phone number using SHA-256 hash function after normalization (E164
        /// standard).
        #[prost(string, tag = "2")]
        PhoneNumber(::prost::alloc::string::String),
        /// The known components of a user's address. Holds a grouping
        /// of identifiers that are matched all at once.
        #[prost(message, tag = "3")]
        Address(super::AddressInfo),
    }
}
/// Address information for the user.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddressInfo {
    /// Required. Given (first) name of the user, all lowercase, with no
    /// punctuation, no leading or trailing whitespace, and hashed as SHA-256.
    #[prost(string, tag = "1")]
    pub given_name: ::prost::alloc::string::String,
    /// Required. Family (last) name of the user, all lowercase, with no
    /// punctuation, no leading or trailing whitespace, and hashed as SHA-256.
    #[prost(string, tag = "2")]
    pub family_name: ::prost::alloc::string::String,
    /// Required. The 2-letter region code in ISO-3166-1 alpha-2 of the user's
    /// address.
    #[prost(string, tag = "3")]
    pub region_code: ::prost::alloc::string::String,
    /// Required. The postal code of the user's address.
    #[prost(string, tag = "4")]
    pub postal_code: ::prost::alloc::string::String,
}
/// The audience member to be operated on.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceMember {
    /// Optional. Defines which
    /// \[Destination\]\[google.ads.datamanager.v1.Destination\] to send the audience
    /// member to.
    #[prost(string, repeated, tag = "1")]
    pub destination_references: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The consent setting for the user.
    #[prost(message, optional, tag = "3")]
    pub consent: ::core::option::Option<Consent>,
    /// The type of identifying data to be operated on.
    #[prost(oneof = "audience_member::Data", tags = "2, 4, 5")]
    pub data: ::core::option::Option<audience_member::Data>,
}
/// Nested message and enum types in `AudienceMember`.
pub mod audience_member {
    /// The type of identifying data to be operated on.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// User-provided data that identifies the user.
        #[prost(message, tag = "2")]
        UserData(super::UserData),
        /// [Publisher Advertiser Identity Reconciliation (PAIR)
        /// IDs](//support.google.com/admanager/answer/15067908).
        #[prost(message, tag = "4")]
        PairData(super::PairData),
        /// Data identifying the user's mobile devices.
        #[prost(message, tag = "5")]
        MobileData(super::MobileData),
    }
}
/// [PAIR](//support.google.com/admanager/answer/15067908) IDs for the audience.
/// At least one PAIR ID is required.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PairData {
    /// Required. Cleanroom-provided PII data, hashed with SHA256, and encrypted
    /// with an EC commutative cipher using publisher key for the
    /// [PAIR]((//support.google.com/admanager/answer/15067908)) user list. At most
    /// 10 `pairIds` can be provided in a single
    /// \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\].
    #[prost(string, repeated, tag = "1")]
    pub pair_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Mobile IDs for the audience. At least one mobile ID is required.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MobileData {
    /// Required. The list of mobile device IDs (advertising ID/IDFA). At most 10
    /// `mobileIds` can be provided in a single
    /// \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\].
    #[prost(string, repeated, tag = "1")]
    pub mobile_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A bucket of any [event parameters related to an
/// item](<https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference/events>)
/// to be included within the event that were not already specified using other
/// structured fields.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ItemParameter {
    /// Required. The name of the parameter to use.
    #[prost(string, tag = "1")]
    pub parameter_name: ::prost::alloc::string::String,
    /// Required. The string representation of the value of the parameter to set.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// The cart data associated with the event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CartData {
    /// Optional. The Merchant Center ID associated with the items.
    #[prost(string, tag = "1")]
    pub merchant_id: ::prost::alloc::string::String,
    /// Optional. The Merchant Center feed label associated with the feed of the
    /// items.
    #[prost(string, tag = "2")]
    pub merchant_feed_label: ::prost::alloc::string::String,
    /// Optional. The language code in ISO 639-1 associated with the Merchant
    /// Center feed of the items.where your items are uploaded.
    #[prost(string, tag = "3")]
    pub merchant_feed_language_code: ::prost::alloc::string::String,
    /// Optional. The sum of all discounts associated with the transaction.
    #[prost(double, tag = "4")]
    pub transaction_discount: f64,
    /// Optional. The list of items associated with the event.
    #[prost(message, repeated, tag = "5")]
    pub items: ::prost::alloc::vec::Vec<Item>,
}
/// Represents an item in the cart associated with the event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Item {
    /// Optional. The product ID within the Merchant Center account.
    #[prost(string, tag = "1")]
    pub merchant_product_id: ::prost::alloc::string::String,
    /// Optional. The number of this item associated with the event.
    #[prost(int64, tag = "2")]
    pub quantity: i64,
    /// Optional. The unit price excluding tax, shipping, and any transaction level
    /// discounts.
    #[prost(double, tag = "3")]
    pub unit_price: f64,
    /// Optional. A unique identifier to reference the item.
    #[prost(string, tag = "4")]
    pub item_id: ::prost::alloc::string::String,
    /// Optional. A bucket of any [event parameters related to an
    /// item](<https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference/events>)
    /// to be included within the event that were not already specified using other
    /// structured fields.
    #[prost(message, repeated, tag = "5")]
    pub additional_item_parameters: ::prost::alloc::vec::Vec<ItemParameter>,
}
/// The Google product you're sending data to. For example, a Google
/// Ads account.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Destination {
    /// Optional. ID for this `Destination` resource, unique within the request.
    /// Use to reference this `Destination` in  the
    /// \[IngestEventsRequest\]\[google.ads.datamanager.v1.IngestEventsRequest\] and
    /// \[IngestAudienceMembersRequest\]\[google.ads.datamanager.v1.IngestAudienceMembersRequest\].
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    /// Optional. The account used to make this API call. To add or remove data
    /// from the
    /// \[`operating_account`\]\[google.ads.datamanager.v1.Destination.operating_account\],
    /// this `login_account` must have write access to the `operating_account`. For
    /// example, a manager account of the `operating_account`, or an account with
    /// an established link to the `operating_account`.
    #[prost(message, optional, tag = "2")]
    pub login_account: ::core::option::Option<ProductAccount>,
    /// Optional. An account that the calling user's
    /// \[`login_account`\]\[google.ads.datamanager.v1.Destination.login_account\] has
    /// access to, through an established account link. For example, a data
    /// partner's `login_account` might have access to a client's `linked_account`.
    /// The partner might use this field to send data from the `linked_account` to
    /// another
    /// \[`operating_account`\]\[google.ads.datamanager.v1.Destination.operating_account\].
    #[prost(message, optional, tag = "3")]
    pub linked_account: ::core::option::Option<ProductAccount>,
    /// Required. The account to send the data to or remove the data from.
    #[prost(message, optional, tag = "4")]
    pub operating_account: ::core::option::Option<ProductAccount>,
    /// Required. The object within the product account to ingest into. For
    /// example, a Google Ads audience ID, a Display & Video 360 audience ID or a
    /// Google Ads conversion action ID.
    #[prost(string, tag = "5")]
    pub product_destination_id: ::prost::alloc::string::String,
}
/// Represents a specific account.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProductAccount {
    /// Deprecated. Use
    /// \[`account_type`\]\[google.ads.datamanager.v1.ProductAccount.account_type\]
    /// instead.
    #[deprecated]
    #[prost(enumeration = "Product", tag = "1")]
    pub product: i32,
    /// Required. The ID of the account. For example, your Google Ads account ID.
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
    /// Optional. The type of the account. For example, `GOOGLE_ADS`.
    /// Either `account_type` or the deprecated `product` is required.
    /// If both are set, the values must match.
    #[prost(enumeration = "product_account::AccountType", tag = "3")]
    pub account_type: i32,
}
/// Nested message and enum types in `ProductAccount`.
pub mod product_account {
    /// Represents Google account types. Used to locate accounts and
    /// destinations.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountType {
        /// Unspecified product. Should never be used.
        Unspecified = 0,
        /// Google Ads.
        GoogleAds = 1,
        /// Display & Video 360 partner.
        DisplayVideoPartner = 2,
        /// Display & Video 360 advertiser.
        DisplayVideoAdvertiser = 3,
        /// Data Partner.
        DataPartner = 4,
        /// Google Analytics.
        GoogleAnalyticsProperty = 5,
    }
    impl AccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ACCOUNT_TYPE_UNSPECIFIED",
                Self::GoogleAds => "GOOGLE_ADS",
                Self::DisplayVideoPartner => "DISPLAY_VIDEO_PARTNER",
                Self::DisplayVideoAdvertiser => "DISPLAY_VIDEO_ADVERTISER",
                Self::DataPartner => "DATA_PARTNER",
                Self::GoogleAnalyticsProperty => "GOOGLE_ANALYTICS_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACCOUNT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_ADS" => Some(Self::GoogleAds),
                "DISPLAY_VIDEO_PARTNER" => Some(Self::DisplayVideoPartner),
                "DISPLAY_VIDEO_ADVERTISER" => Some(Self::DisplayVideoAdvertiser),
                "DATA_PARTNER" => Some(Self::DataPartner),
                "GOOGLE_ANALYTICS_PROPERTY" => Some(Self::GoogleAnalyticsProperty),
                _ => None,
            }
        }
    }
}
/// Deprecated. Use
/// \[`AccountType`\]\[google.ads.datamanager.v1.ProductAccount.AccountType\]
/// instead. Represents a specific Google product.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Product {
    /// Unspecified product. Should never be used.
    Unspecified = 0,
    /// Google Ads.
    GoogleAds = 1,
    /// Display & Video 360 partner.
    DisplayVideoPartner = 2,
    /// Display & Video 360 advertiser.
    DisplayVideoAdvertiser = 3,
    /// Data Partner.
    DataPartner = 4,
}
impl Product {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRODUCT_UNSPECIFIED",
            Self::GoogleAds => "GOOGLE_ADS",
            Self::DisplayVideoPartner => "DISPLAY_VIDEO_PARTNER",
            Self::DisplayVideoAdvertiser => "DISPLAY_VIDEO_ADVERTISER",
            Self::DataPartner => "DATA_PARTNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRODUCT_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_ADS" => Some(Self::GoogleAds),
            "DISPLAY_VIDEO_PARTNER" => Some(Self::DisplayVideoPartner),
            "DISPLAY_VIDEO_ADVERTISER" => Some(Self::DisplayVideoAdvertiser),
            "DATA_PARTNER" => Some(Self::DataPartner),
            _ => None,
        }
    }
}
/// Information about the device being used (if any) when the event happened.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceInfo {
    /// Optional. The user-agent string of the device for the given context.
    #[prost(string, tag = "1")]
    pub user_agent: ::prost::alloc::string::String,
    /// Optional. The IP address of the device for the given context.
    ///
    /// **Note:** Google Ads does not support IP address matching for end users in
    /// the European Economic Area (EEA), United Kingdom (UK), or Switzerland (CH).
    /// Add logic to conditionally exclude sharing IP addresses from users from
    /// these regions and ensure that you provide users with clear and
    /// comprehensive information about the data you collect on your sites, apps,
    /// and other properties and get consent where required by law or any
    /// applicable Google policies. See the [About offline conversion
    /// imports](<https://support.google.com/google-ads/answer/2998031>) page for
    /// more details.
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
}
/// Encryption information for the data being ingested.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptionInfo {
    /// The [wrapped key](//cloud.google.com/kms/docs/key-wrapping) used to encrypt
    /// the data.
    #[prost(oneof = "encryption_info::WrappedKey", tags = "1, 2")]
    pub wrapped_key: ::core::option::Option<encryption_info::WrappedKey>,
}
/// Nested message and enum types in `EncryptionInfo`.
pub mod encryption_info {
    /// The [wrapped key](//cloud.google.com/kms/docs/key-wrapping) used to encrypt
    /// the data.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum WrappedKey {
        /// Google Cloud Platform wrapped key information.
        #[prost(message, tag = "1")]
        GcpWrappedKeyInfo(super::GcpWrappedKeyInfo),
        /// Amazon Web Services wrapped key information.
        #[prost(message, tag = "2")]
        AwsWrappedKeyInfo(super::AwsWrappedKeyInfo),
    }
}
/// Information about the Google Cloud Platform wrapped
/// key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcpWrappedKeyInfo {
    /// Required. The type of algorithm used to encrypt the data.
    #[prost(enumeration = "gcp_wrapped_key_info::KeyType", tag = "1")]
    pub key_type: i32,
    /// Required. The [Workload
    /// Identity](//cloud.google.com/iam/docs/workload-identity-federation) pool
    /// provider required to use KEK.
    #[prost(string, tag = "2")]
    pub wip_provider: ::prost::alloc::string::String,
    /// Required. Google Cloud Platform [Cloud Key Management Service resource
    /// ID](//cloud.google.com/kms/docs/getting-resource-ids).  Should be in the
    /// format of
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{key}`
    /// or
    /// `gcp-kms://projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{key}`
    #[prost(string, tag = "3")]
    pub kek_uri: ::prost::alloc::string::String,
    /// Required. The base64 encoded encrypted data encryption key.
    #[prost(string, tag = "4")]
    pub encrypted_dek: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GcpWrappedKeyInfo`.
pub mod gcp_wrapped_key_info {
    /// The type of algorithm used to encrypt the data.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyType {
        /// Unspecified key type. Should never be used.
        Unspecified = 0,
        /// Algorithm XChaCha20-Poly1305
        Xchacha20Poly1305 = 1,
    }
    impl KeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KEY_TYPE_UNSPECIFIED",
                Self::Xchacha20Poly1305 => "XCHACHA20_POLY1305",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "XCHACHA20_POLY1305" => Some(Self::Xchacha20Poly1305),
                _ => None,
            }
        }
    }
}
/// A data encryption key wrapped by an AWS KMS key.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AwsWrappedKeyInfo {
    /// Required. The type of algorithm used to encrypt the data.
    #[prost(enumeration = "aws_wrapped_key_info::KeyType", tag = "1")]
    pub key_type: i32,
    /// Required. The Amazon Resource Name of the IAM Role to assume for KMS
    /// decryption access. Should be in the format of
    /// `arn:{partition}:iam::{account_id}:role/{role_name}`
    #[prost(string, tag = "2")]
    pub role_arn: ::prost::alloc::string::String,
    /// Required. The URI of the AWS KMS key used to decrypt the DEK. Should be in
    /// the format of `arn:{partition}:kms:{region}:{account_id}:key/{key_id}` or
    /// `aws-kms://arn:{partition}:kms:{region}:{account_id}:key/{key_id}`
    #[prost(string, tag = "3")]
    pub kek_uri: ::prost::alloc::string::String,
    /// Required. The base64 encoded encrypted data encryption key.
    #[prost(string, tag = "4")]
    pub encrypted_dek: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AwsWrappedKeyInfo`.
pub mod aws_wrapped_key_info {
    /// The type of algorithm used to encrypt the data.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyType {
        /// Unspecified key type. Should never be used.
        Unspecified = 0,
        /// Algorithm XChaCha20-Poly1305
        Xchacha20Poly1305 = 1,
    }
    impl KeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KEY_TYPE_UNSPECIFIED",
                Self::Xchacha20Poly1305 => "XCHACHA20_POLY1305",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "XCHACHA20_POLY1305" => Some(Self::Xchacha20Poly1305),
                _ => None,
            }
        }
    }
}
/// Error reasons for Data Manager API.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorReason {
    /// Do not use this default value.
    Unspecified = 0,
    /// An internal error has occurred.
    InternalError = 1,
    /// The request took too long to respond.
    DeadlineExceeded = 2,
    /// Too many requests.
    ResourceExhausted = 3,
    /// Resource not found.
    NotFound = 4,
    /// The user does not have permission or the resource is not found.
    PermissionDenied = 5,
    /// There was a problem with the request.
    InvalidArgument = 6,
    /// Required field is missing.
    RequiredFieldMissing = 7,
    /// Format is invalid.
    InvalidFormat = 8,
    /// The HEX encoded value is malformed.
    InvalidHexEncoding = 9,
    /// The base64 encoded value is malformed.
    InvalidBase64Encoding = 10,
    /// The SHA256 encoded value is malformed.
    InvalidSha256Format = 11,
    /// Postal code is not valid.
    InvalidPostalCode = 12,
    /// Country code is not valid.
    InvalidCountryCode = 13,
    /// Enum value cannot be used.
    InvalidEnumValue = 14,
    /// Type of the user list is not applicable for this request.
    InvalidUserListType = 15,
    /// This audience member is not valid.
    InvalidAudienceMember = 16,
    /// Maximum number of audience members allowed per request is 10,000.
    TooManyAudienceMembers = 17,
    /// Maximum number of user identifiers allowed per audience member is 10.
    TooManyUserIdentifiers = 18,
    /// Maximum number of destinations allowed per request is 10.
    TooManyDestinations = 19,
    /// This Destination is not valid.
    InvalidDestination = 20,
    /// Data Partner does not have access to the operating account owned userlist.
    DataPartnerUserListMutateNotAllowed = 21,
    /// Mobile ID format is not valid.
    InvalidMobileIdFormat = 22,
    /// User list is not valid.
    InvalidUserListId = 23,
    /// Multiple data types are not allowed to be ingested in a single request.
    MultipleDataTypesNotAllowed = 24,
    /// Destination configs containing a DataPartner login account must have the
    /// same login account across all destination configs.
    DifferentLoginAccountsNotAllowedForDataPartner = 25,
    /// Required terms and conditions are not accepted.
    TermsAndConditionsNotSigned = 26,
    /// Invalid number format.
    InvalidNumberFormat = 27,
    /// Conversion action ID is not valid.
    InvalidConversionActionId = 28,
    /// The conversion action type is not valid.
    InvalidConversionActionType = 29,
    /// The currency code is not supported.
    InvalidCurrencyCode = 30,
    /// This event is not valid.
    InvalidEvent = 31,
    /// Maximum number of events allowed per request is 10,000.
    TooManyEvents = 32,
    /// The destination account is not enabled for enhanced conversions for leads.
    DestinationAccountNotEnabledEnhancedConversionsForLeads = 33,
    /// Enhanced conversions can't be used for the destination account because of
    /// Google customer data policies. Contact your Google representative..
    DestinationAccountDataPolicyProhibitsEnhancedConversions = 34,
    /// The destination account hasn't agreed to the terms for enhanced
    /// conversions.
    DestinationAccountEnhancedConversionsTermsNotSigned = 35,
    /// Two or more destinations in the request have the same reference.
    DuplicateDestinationReference = 36,
    /// Unsupported operating account for data partner authorization.
    UnsupportedOperatingAccountForDataPartner = 37,
    /// Unsupported linked account for data partner authorization.
    UnsupportedLinkedAccountForDataPartner = 38,
    /// Events data contains no user identifiers or ad identifiers.
    NoIdentifiersProvided = 39,
    /// The property type is not supported.
    InvalidPropertyType = 40,
    /// The stream type is not supported.
    InvalidStreamType = 41,
    /// Linked account is only supported when the login account is a `DATA_PARTNER`
    /// account.
    LinkedAccountOnlyAllowedWithDataPartnerLoginAccount = 42,
    /// The login account must be the same as the operating account for the given
    /// use case.
    OperatingAccountLoginAccountMismatch = 43,
    /// Event did not occur within the acceptable time window.
    EventTimeInvalid = 44,
    /// Parameter uses a reserved name.
    ReservedNameUsed = 45,
    /// The event name is not supported.
    InvalidEventName = 46,
    /// The account is not allowlisted for the given feature.
    NotAllowlisted = 47,
    /// The request ID used to retrieve the status of a request is not valid.
    /// Status can only be retrieved for requests that succeed and don't have
    /// `validate_only=true`.
    InvalidRequestId = 48,
    /// An event had 2 or more Google Analytics destinations.
    MultipleDestinationsForGoogleAnalyticsEvent = 49,
    /// The field value is too long.
    FieldValueTooLong = 50,
    /// Too many elements in a list in the request.
    TooManyElements = 51,
}
impl ErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ERROR_REASON_UNSPECIFIED",
            Self::InternalError => "INTERNAL_ERROR",
            Self::DeadlineExceeded => "DEADLINE_EXCEEDED",
            Self::ResourceExhausted => "RESOURCE_EXHAUSTED",
            Self::NotFound => "NOT_FOUND",
            Self::PermissionDenied => "PERMISSION_DENIED",
            Self::InvalidArgument => "INVALID_ARGUMENT",
            Self::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
            Self::InvalidFormat => "INVALID_FORMAT",
            Self::InvalidHexEncoding => "INVALID_HEX_ENCODING",
            Self::InvalidBase64Encoding => "INVALID_BASE64_ENCODING",
            Self::InvalidSha256Format => "INVALID_SHA256_FORMAT",
            Self::InvalidPostalCode => "INVALID_POSTAL_CODE",
            Self::InvalidCountryCode => "INVALID_COUNTRY_CODE",
            Self::InvalidEnumValue => "INVALID_ENUM_VALUE",
            Self::InvalidUserListType => "INVALID_USER_LIST_TYPE",
            Self::InvalidAudienceMember => "INVALID_AUDIENCE_MEMBER",
            Self::TooManyAudienceMembers => "TOO_MANY_AUDIENCE_MEMBERS",
            Self::TooManyUserIdentifiers => "TOO_MANY_USER_IDENTIFIERS",
            Self::TooManyDestinations => "TOO_MANY_DESTINATIONS",
            Self::InvalidDestination => "INVALID_DESTINATION",
            Self::DataPartnerUserListMutateNotAllowed => {
                "DATA_PARTNER_USER_LIST_MUTATE_NOT_ALLOWED"
            }
            Self::InvalidMobileIdFormat => "INVALID_MOBILE_ID_FORMAT",
            Self::InvalidUserListId => "INVALID_USER_LIST_ID",
            Self::MultipleDataTypesNotAllowed => "MULTIPLE_DATA_TYPES_NOT_ALLOWED",
            Self::DifferentLoginAccountsNotAllowedForDataPartner => {
                "DIFFERENT_LOGIN_ACCOUNTS_NOT_ALLOWED_FOR_DATA_PARTNER"
            }
            Self::TermsAndConditionsNotSigned => "TERMS_AND_CONDITIONS_NOT_SIGNED",
            Self::InvalidNumberFormat => "INVALID_NUMBER_FORMAT",
            Self::InvalidConversionActionId => "INVALID_CONVERSION_ACTION_ID",
            Self::InvalidConversionActionType => "INVALID_CONVERSION_ACTION_TYPE",
            Self::InvalidCurrencyCode => "INVALID_CURRENCY_CODE",
            Self::InvalidEvent => "INVALID_EVENT",
            Self::TooManyEvents => "TOO_MANY_EVENTS",
            Self::DestinationAccountNotEnabledEnhancedConversionsForLeads => {
                "DESTINATION_ACCOUNT_NOT_ENABLED_ENHANCED_CONVERSIONS_FOR_LEADS"
            }
            Self::DestinationAccountDataPolicyProhibitsEnhancedConversions => {
                "DESTINATION_ACCOUNT_DATA_POLICY_PROHIBITS_ENHANCED_CONVERSIONS"
            }
            Self::DestinationAccountEnhancedConversionsTermsNotSigned => {
                "DESTINATION_ACCOUNT_ENHANCED_CONVERSIONS_TERMS_NOT_SIGNED"
            }
            Self::DuplicateDestinationReference => "DUPLICATE_DESTINATION_REFERENCE",
            Self::UnsupportedOperatingAccountForDataPartner => {
                "UNSUPPORTED_OPERATING_ACCOUNT_FOR_DATA_PARTNER"
            }
            Self::UnsupportedLinkedAccountForDataPartner => {
                "UNSUPPORTED_LINKED_ACCOUNT_FOR_DATA_PARTNER"
            }
            Self::NoIdentifiersProvided => "NO_IDENTIFIERS_PROVIDED",
            Self::InvalidPropertyType => "INVALID_PROPERTY_TYPE",
            Self::InvalidStreamType => "INVALID_STREAM_TYPE",
            Self::LinkedAccountOnlyAllowedWithDataPartnerLoginAccount => {
                "LINKED_ACCOUNT_ONLY_ALLOWED_WITH_DATA_PARTNER_LOGIN_ACCOUNT"
            }
            Self::OperatingAccountLoginAccountMismatch => {
                "OPERATING_ACCOUNT_LOGIN_ACCOUNT_MISMATCH"
            }
            Self::EventTimeInvalid => "EVENT_TIME_INVALID",
            Self::ReservedNameUsed => "RESERVED_NAME_USED",
            Self::InvalidEventName => "INVALID_EVENT_NAME",
            Self::NotAllowlisted => "NOT_ALLOWLISTED",
            Self::InvalidRequestId => "INVALID_REQUEST_ID",
            Self::MultipleDestinationsForGoogleAnalyticsEvent => {
                "MULTIPLE_DESTINATIONS_FOR_GOOGLE_ANALYTICS_EVENT"
            }
            Self::FieldValueTooLong => "FIELD_VALUE_TOO_LONG",
            Self::TooManyElements => "TOO_MANY_ELEMENTS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "INTERNAL_ERROR" => Some(Self::InternalError),
            "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
            "RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
            "NOT_FOUND" => Some(Self::NotFound),
            "PERMISSION_DENIED" => Some(Self::PermissionDenied),
            "INVALID_ARGUMENT" => Some(Self::InvalidArgument),
            "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
            "INVALID_FORMAT" => Some(Self::InvalidFormat),
            "INVALID_HEX_ENCODING" => Some(Self::InvalidHexEncoding),
            "INVALID_BASE64_ENCODING" => Some(Self::InvalidBase64Encoding),
            "INVALID_SHA256_FORMAT" => Some(Self::InvalidSha256Format),
            "INVALID_POSTAL_CODE" => Some(Self::InvalidPostalCode),
            "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
            "INVALID_ENUM_VALUE" => Some(Self::InvalidEnumValue),
            "INVALID_USER_LIST_TYPE" => Some(Self::InvalidUserListType),
            "INVALID_AUDIENCE_MEMBER" => Some(Self::InvalidAudienceMember),
            "TOO_MANY_AUDIENCE_MEMBERS" => Some(Self::TooManyAudienceMembers),
            "TOO_MANY_USER_IDENTIFIERS" => Some(Self::TooManyUserIdentifiers),
            "TOO_MANY_DESTINATIONS" => Some(Self::TooManyDestinations),
            "INVALID_DESTINATION" => Some(Self::InvalidDestination),
            "DATA_PARTNER_USER_LIST_MUTATE_NOT_ALLOWED" => {
                Some(Self::DataPartnerUserListMutateNotAllowed)
            }
            "INVALID_MOBILE_ID_FORMAT" => Some(Self::InvalidMobileIdFormat),
            "INVALID_USER_LIST_ID" => Some(Self::InvalidUserListId),
            "MULTIPLE_DATA_TYPES_NOT_ALLOWED" => Some(Self::MultipleDataTypesNotAllowed),
            "DIFFERENT_LOGIN_ACCOUNTS_NOT_ALLOWED_FOR_DATA_PARTNER" => {
                Some(Self::DifferentLoginAccountsNotAllowedForDataPartner)
            }
            "TERMS_AND_CONDITIONS_NOT_SIGNED" => Some(Self::TermsAndConditionsNotSigned),
            "INVALID_NUMBER_FORMAT" => Some(Self::InvalidNumberFormat),
            "INVALID_CONVERSION_ACTION_ID" => Some(Self::InvalidConversionActionId),
            "INVALID_CONVERSION_ACTION_TYPE" => Some(Self::InvalidConversionActionType),
            "INVALID_CURRENCY_CODE" => Some(Self::InvalidCurrencyCode),
            "INVALID_EVENT" => Some(Self::InvalidEvent),
            "TOO_MANY_EVENTS" => Some(Self::TooManyEvents),
            "DESTINATION_ACCOUNT_NOT_ENABLED_ENHANCED_CONVERSIONS_FOR_LEADS" => {
                Some(Self::DestinationAccountNotEnabledEnhancedConversionsForLeads)
            }
            "DESTINATION_ACCOUNT_DATA_POLICY_PROHIBITS_ENHANCED_CONVERSIONS" => {
                Some(Self::DestinationAccountDataPolicyProhibitsEnhancedConversions)
            }
            "DESTINATION_ACCOUNT_ENHANCED_CONVERSIONS_TERMS_NOT_SIGNED" => {
                Some(Self::DestinationAccountEnhancedConversionsTermsNotSigned)
            }
            "DUPLICATE_DESTINATION_REFERENCE" => {
                Some(Self::DuplicateDestinationReference)
            }
            "UNSUPPORTED_OPERATING_ACCOUNT_FOR_DATA_PARTNER" => {
                Some(Self::UnsupportedOperatingAccountForDataPartner)
            }
            "UNSUPPORTED_LINKED_ACCOUNT_FOR_DATA_PARTNER" => {
                Some(Self::UnsupportedLinkedAccountForDataPartner)
            }
            "NO_IDENTIFIERS_PROVIDED" => Some(Self::NoIdentifiersProvided),
            "INVALID_PROPERTY_TYPE" => Some(Self::InvalidPropertyType),
            "INVALID_STREAM_TYPE" => Some(Self::InvalidStreamType),
            "LINKED_ACCOUNT_ONLY_ALLOWED_WITH_DATA_PARTNER_LOGIN_ACCOUNT" => {
                Some(Self::LinkedAccountOnlyAllowedWithDataPartnerLoginAccount)
            }
            "OPERATING_ACCOUNT_LOGIN_ACCOUNT_MISMATCH" => {
                Some(Self::OperatingAccountLoginAccountMismatch)
            }
            "EVENT_TIME_INVALID" => Some(Self::EventTimeInvalid),
            "RESERVED_NAME_USED" => Some(Self::ReservedNameUsed),
            "INVALID_EVENT_NAME" => Some(Self::InvalidEventName),
            "NOT_ALLOWLISTED" => Some(Self::NotAllowlisted),
            "INVALID_REQUEST_ID" => Some(Self::InvalidRequestId),
            "MULTIPLE_DESTINATIONS_FOR_GOOGLE_ANALYTICS_EVENT" => {
                Some(Self::MultipleDestinationsForGoogleAnalyticsEvent)
            }
            "FIELD_VALUE_TOO_LONG" => Some(Self::FieldValueTooLong),
            "TOO_MANY_ELEMENTS" => Some(Self::TooManyElements),
            _ => None,
        }
    }
}
/// Experimental field representing unofficial fields.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExperimentalField {
    /// Optional. The name of the field to use.
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    /// Optional. The value the field to set.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Advertiser-assessed information about the user at the time that the event
/// happened. See <https://support.google.com/google-ads/answer/14007601> for more
/// details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserProperties {
    /// Optional. Type of the customer associated with the event.
    #[prost(enumeration = "CustomerType", tag = "1")]
    pub customer_type: i32,
    /// Optional. The advertiser-assessed value of the customer.
    #[prost(enumeration = "CustomerValueBucket", tag = "2")]
    pub customer_value_bucket: i32,
    /// Optional. A bucket of any additional [user
    /// properties](<https://developers.google.com/analytics/devguides/collection/protocol/ga4/user-properties>)
    /// for the user associated with this event.
    #[prost(message, repeated, tag = "3")]
    pub additional_user_properties: ::prost::alloc::vec::Vec<UserProperty>,
}
/// A bucket of any additional [user
/// properties](<https://developers.google.com/analytics/devguides/collection/protocol/ga4/user-properties>)
/// for the user associated with this event.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserProperty {
    /// Required. The name of the user property to use.
    #[prost(string, tag = "1")]
    pub property_name: ::prost::alloc::string::String,
    /// Required. The string representation of the value of the user property to
    /// use.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// Type of the customer associated with the event.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomerType {
    /// Unspecified CustomerType. Should never be used.
    Unspecified = 0,
    /// The customer is new to the advertiser.
    New = 1,
    /// The customer is returning to the advertiser.
    Returning = 2,
    /// The customer has re-engaged with the advertiser.
    Reengaged = 3,
}
impl CustomerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CUSTOMER_TYPE_UNSPECIFIED",
            Self::New => "NEW",
            Self::Returning => "RETURNING",
            Self::Reengaged => "REENGAGED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CUSTOMER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "NEW" => Some(Self::New),
            "RETURNING" => Some(Self::Returning),
            "REENGAGED" => Some(Self::Reengaged),
            _ => None,
        }
    }
}
/// The advertiser-assessed value of the customer.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CustomerValueBucket {
    /// Unspecified CustomerValueBucket. Should never be used.
    Unspecified = 0,
    /// The customer is low value.
    Low = 1,
    /// The customer is medium value.
    Medium = 2,
    /// The customer is high value.
    High = 3,
}
impl CustomerValueBucket {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CUSTOMER_VALUE_BUCKET_UNSPECIFIED",
            Self::Low => "LOW",
            Self::Medium => "MEDIUM",
            Self::High => "HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CUSTOMER_VALUE_BUCKET_UNSPECIFIED" => Some(Self::Unspecified),
            "LOW" => Some(Self::Low),
            "MEDIUM" => Some(Self::Medium),
            "HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
/// An event representing a user interaction with an advertiser's website or app.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Optional. Reference string used to determine the destination. If empty, the
    /// event will be sent to all
    /// \[destinations\]\[google.ads.datamanager.v1.IngestEventsRequest.destinations\]
    /// in the request.
    #[prost(string, repeated, tag = "1")]
    pub destination_references: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The unique identifier for this event. Required for conversions
    /// using multiple data sources.
    #[prost(string, tag = "2")]
    pub transaction_id: ::prost::alloc::string::String,
    /// Required. The time the event occurred.
    #[prost(message, optional, tag = "3")]
    pub event_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The last time the event was updated.
    #[prost(message, optional, tag = "4")]
    pub last_updated_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Pieces of user provided data, representing the user the event is
    /// associated with.
    #[prost(message, optional, tag = "5")]
    pub user_data: ::core::option::Option<UserData>,
    /// Optional. Information about whether the associated user has provided
    /// different types of consent.
    #[prost(message, optional, tag = "6")]
    pub consent: ::core::option::Option<Consent>,
    /// Optional. Identifiers and other information used to match the conversion
    /// event with other online activity (such as ad clicks).
    #[prost(message, optional, tag = "7")]
    pub ad_identifiers: ::core::option::Option<AdIdentifiers>,
    /// Optional. The currency code associated with all monetary values within this
    /// event.
    #[prost(string, tag = "8")]
    pub currency: ::prost::alloc::string::String,
    /// Optional. The conversion value associated with the event, for value-based
    /// conversions.
    #[prost(double, tag = "9")]
    pub conversion_value: f64,
    /// Optional. Signal for where the event happened (web, app, in-store, etc.).
    #[prost(enumeration = "EventSource", tag = "10")]
    pub event_source: i32,
    /// Optional. Information gathered about the device being used (if any) when
    /// the event happened.
    #[prost(message, optional, tag = "11")]
    pub event_device_info: ::core::option::Option<DeviceInfo>,
    /// Optional. Information about the transaction and items associated with the
    /// event.
    #[prost(message, optional, tag = "12")]
    pub cart_data: ::core::option::Option<CartData>,
    /// Optional. Additional key/value pair information to send to the conversion
    /// containers (conversion action or FL activity).
    #[prost(message, repeated, tag = "13")]
    pub custom_variables: ::prost::alloc::vec::Vec<CustomVariable>,
    /// Optional. A list of key/value pairs for experimental fields that may
    /// eventually be promoted to be part of the API.
    #[prost(message, repeated, tag = "14")]
    pub experimental_fields: ::prost::alloc::vec::Vec<ExperimentalField>,
    /// Optional. Advertiser-assessed information about the user at the time that
    /// the event happened.
    #[prost(message, optional, tag = "15")]
    pub user_properties: ::core::option::Option<UserProperties>,
    /// Optional. The name of the event. Required for GA4 events.
    #[prost(string, tag = "16")]
    pub event_name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for the user instance of a web client for
    /// this GA4 web stream.
    #[prost(string, tag = "17")]
    pub client_id: ::prost::alloc::string::String,
    /// Optional. A unique identifier for a user, as defined by the advertiser.
    #[prost(string, tag = "18")]
    pub user_id: ::prost::alloc::string::String,
    /// Optional. A bucket of any [event
    /// parameters](<https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference/events>)
    /// to be included within the event that were not already specified using other
    /// structured fields.
    #[prost(message, repeated, tag = "19")]
    pub additional_event_parameters: ::prost::alloc::vec::Vec<EventParameter>,
}
/// Identifiers and other information used to match the conversion event with
/// other online activity (such as ad clicks).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdIdentifiers {
    /// Optional. Session attributes for event attribution and modeling.
    #[prost(string, tag = "1")]
    pub session_attributes: ::prost::alloc::string::String,
    /// Optional. The Google click ID (gclid) associated with this event.
    #[prost(string, tag = "2")]
    pub gclid: ::prost::alloc::string::String,
    /// Optional. The click identifier for clicks associated with app events and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "3")]
    pub gbraid: ::prost::alloc::string::String,
    /// Optional. The click identifier for clicks associated with web events and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "4")]
    pub wbraid: ::prost::alloc::string::String,
    /// Optional. Information gathered about the device being used (if any) at the
    /// time of landing onto the advertiserâ€™s site after interacting with the ad.
    #[prost(message, optional, tag = "5")]
    pub landing_page_device_info: ::core::option::Option<DeviceInfo>,
}
/// Custom variable for ads conversions.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomVariable {
    /// Optional. The name of the custom variable to set. If the variable is not
    /// found for the given destination, it will be ignored.
    #[prost(string, tag = "1")]
    pub variable: ::prost::alloc::string::String,
    /// Optional. The value to store for the custom variable.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// Optional. Reference string used to determine which of the
    /// \[Event.destination_references\]\[google.ads.datamanager.v1.Event.destination_references\]
    /// the custom variable should be sent to. If empty, the
    /// \[Event.destination_references\]\[google.ads.datamanager.v1.Event.destination_references\]
    /// will be used.
    #[prost(string, repeated, tag = "3")]
    pub destination_references: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Event parameter for GA4 events.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventParameter {
    /// Required. The name of the parameter to use.
    #[prost(string, tag = "1")]
    pub parameter_name: ::prost::alloc::string::String,
    /// Required. The string representation of the value of the parameter to set.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// The source of the event.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventSource {
    /// Unspecified EventSource. Should never be used.
    Unspecified = 0,
    /// The event was generated from a web browser.
    Web = 1,
    /// The event was generated from an app.
    App = 2,
    /// The event was generated from an in-store transaction.
    InStore = 3,
    /// The event was generated from a phone call.
    Phone = 4,
    /// The event was generated from other sources.
    Other = 5,
}
impl EventSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVENT_SOURCE_UNSPECIFIED",
            Self::Web => "WEB",
            Self::App => "APP",
            Self::InStore => "IN_STORE",
            Self::Phone => "PHONE",
            Self::Other => "OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "WEB" => Some(Self::Web),
            "APP" => Some(Self::App),
            "IN_STORE" => Some(Self::InStore),
            "PHONE" => Some(Self::Phone),
            "OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// The match rate range of the upload or userlist.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MatchRateRange {
    /// The match rate range is unknown.
    Unknown = 0,
    /// The match rate range is not eligible.
    NotEligible = 1,
    /// The match rate range is less than 20% (in the interval `[0, 20)`).
    LessThan20 = 2,
    /// The match rate range is between 20% and 30% (in the interval `[20, 31)`).
    MatchRateRange20To30 = 3,
    /// The match rate range is between 31% and 40% (in the interval `[31, 41)`).
    MatchRateRange31To40 = 4,
    /// The match rate range is between 41% and 50% (in the interval `[41, 51)`).
    MatchRateRange41To50 = 5,
    /// The match rate range is between 51% and 60% (in the interval `[51, 61)`.
    MatchRateRange51To60 = 6,
    /// The match rate range is between 61% and 70% (in the interval `[61, 71)`).
    MatchRateRange61To70 = 7,
    /// The match rate range is between 71% and 80% (in the interval `[71, 81)`).
    MatchRateRange71To80 = 8,
    /// The match rate range is between 81% and 90% (in the interval `[81, 91)`).
    MatchRateRange81To90 = 9,
    /// The match rate range is between 91% and 100% (in the interval `\[91,  100\]`).
    MatchRateRange91To100 = 10,
}
impl MatchRateRange {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MATCH_RATE_RANGE_UNKNOWN",
            Self::NotEligible => "MATCH_RATE_RANGE_NOT_ELIGIBLE",
            Self::LessThan20 => "MATCH_RATE_RANGE_LESS_THAN_20",
            Self::MatchRateRange20To30 => "MATCH_RATE_RANGE_20_TO_30",
            Self::MatchRateRange31To40 => "MATCH_RATE_RANGE_31_TO_40",
            Self::MatchRateRange41To50 => "MATCH_RATE_RANGE_41_TO_50",
            Self::MatchRateRange51To60 => "MATCH_RATE_RANGE_51_TO_60",
            Self::MatchRateRange61To70 => "MATCH_RATE_RANGE_61_TO_70",
            Self::MatchRateRange71To80 => "MATCH_RATE_RANGE_71_TO_80",
            Self::MatchRateRange81To90 => "MATCH_RATE_RANGE_81_TO_90",
            Self::MatchRateRange91To100 => "MATCH_RATE_RANGE_91_TO_100",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MATCH_RATE_RANGE_UNKNOWN" => Some(Self::Unknown),
            "MATCH_RATE_RANGE_NOT_ELIGIBLE" => Some(Self::NotEligible),
            "MATCH_RATE_RANGE_LESS_THAN_20" => Some(Self::LessThan20),
            "MATCH_RATE_RANGE_20_TO_30" => Some(Self::MatchRateRange20To30),
            "MATCH_RATE_RANGE_31_TO_40" => Some(Self::MatchRateRange31To40),
            "MATCH_RATE_RANGE_41_TO_50" => Some(Self::MatchRateRange41To50),
            "MATCH_RATE_RANGE_51_TO_60" => Some(Self::MatchRateRange51To60),
            "MATCH_RATE_RANGE_61_TO_70" => Some(Self::MatchRateRange61To70),
            "MATCH_RATE_RANGE_71_TO_80" => Some(Self::MatchRateRange71To80),
            "MATCH_RATE_RANGE_81_TO_90" => Some(Self::MatchRateRange81To90),
            "MATCH_RATE_RANGE_91_TO_100" => Some(Self::MatchRateRange91To100),
            _ => None,
        }
    }
}
/// Error counts for each type of error.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorInfo {
    /// A list of errors and counts per error reason. May not be populated
    /// in all cases.
    #[prost(message, repeated, tag = "1")]
    pub error_counts: ::prost::alloc::vec::Vec<ErrorCount>,
}
/// The error count for a given error reason.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorCount {
    /// The count of records that failed to upload for a given reason.
    #[prost(int64, tag = "1")]
    pub record_count: i64,
    /// The error reason of the failed records.
    #[prost(enumeration = "ProcessingErrorReason", tag = "2")]
    pub reason: i32,
}
/// Warning counts for each type of warning.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WarningInfo {
    /// A list of warnings and counts per warning reason.
    #[prost(message, repeated, tag = "1")]
    pub warning_counts: ::prost::alloc::vec::Vec<WarningCount>,
}
/// The warning count for a given warning reason.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WarningCount {
    /// The count of records that have a warning.
    #[prost(int64, tag = "1")]
    pub record_count: i64,
    /// The warning reason.
    #[prost(enumeration = "ProcessingWarningReason", tag = "2")]
    pub reason: i32,
}
/// The processing error reason.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingErrorReason {
    /// The processing error reason is unknown.
    Unspecified = 0,
    /// The custom variable is invalid.
    InvalidCustomVariable = 1,
    /// The status of the custom variable is not enabled.
    CustomVariableNotEnabled = 2,
    /// The conversion is older than max supported age.
    EventTooOld = 3,
    /// The ad user data is denied, either by the user or in
    /// the advertiser default settings.
    DeniedConsent = 4,
    /// Advertiser did not give 3P consent for the Ads core platform services.
    NoConsent = 5,
    /// The overall consent (determined from row level consent, request level
    /// consent, and account settings) could not be determined for this user
    UnknownConsent = 6,
    /// A conversion with the same GCLID and conversion time already exists in
    /// the system.
    DuplicateGclid = 7,
    /// A conversion with the same order id and conversion action combination was
    /// already uploaded.
    DuplicateTransactionId = 8,
    /// The gbraid could not be decoded.
    InvalidGbraid = 9,
    /// The google click ID could not be decoded.
    InvalidGclid = 10,
    /// Merchant id contains non-digit characters.
    InvalidMerchantId = 11,
    /// The wbraid could not be decoded.
    InvalidWbraid = 12,
    /// Internal error.
    InternalError = 13,
    /// Enhanced conversions terms are not signed in the destination account.
    DestinationAccountEnhancedConversionsTermsNotSigned = 14,
    /// The event is invalid.
    InvalidEvent = 15,
    /// The matched transactions are less than the minimum threshold.
    InsufficientMatchedTransactions = 16,
    /// The transactions are less than the minimum threshold.
    InsufficientTransactions = 17,
    /// The event has format error.
    InvalidFormat = 18,
    /// The event has a decryption error.
    DecryptionError = 19,
    /// The DEK failed to be decrypted.
    DekDecryptionError = 20,
    /// The WIP is formatted incorrectly or the WIP does not exist.
    InvalidWip = 21,
    /// The KEK cannot decrypt data because it is the wrong KEK, or it does not
    /// exist.
    InvalidKek = 22,
    /// The WIP could not be used because it was rejected by its attestation
    /// condition.
    WipAuthFailed = 23,
    /// The system did not have the permissions needed to access the KEK.
    KekPermissionDenied = 24,
    /// The system failed to authenticate with AWS.
    AwsAuthFailed = 27,
    /// Failed to decrypt the
    /// \[UserIdentifier\]\[google.ads.datamanager.v1.UserIdentifier\] data using the
    /// DEK.
    UserIdentifierDecryptionError = 25,
    /// The user attempted to ingest events with an ad identifier that isn't
    /// from the operating account's ads.
    ProcessingErrorOperatingAccountMismatchForAdIdentifier = 26,
}
impl ProcessingErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROCESSING_ERROR_REASON_UNSPECIFIED",
            Self::InvalidCustomVariable => {
                "PROCESSING_ERROR_REASON_INVALID_CUSTOM_VARIABLE"
            }
            Self::CustomVariableNotEnabled => {
                "PROCESSING_ERROR_REASON_CUSTOM_VARIABLE_NOT_ENABLED"
            }
            Self::EventTooOld => "PROCESSING_ERROR_REASON_EVENT_TOO_OLD",
            Self::DeniedConsent => "PROCESSING_ERROR_REASON_DENIED_CONSENT",
            Self::NoConsent => "PROCESSING_ERROR_REASON_NO_CONSENT",
            Self::UnknownConsent => "PROCESSING_ERROR_REASON_UNKNOWN_CONSENT",
            Self::DuplicateGclid => "PROCESSING_ERROR_REASON_DUPLICATE_GCLID",
            Self::DuplicateTransactionId => {
                "PROCESSING_ERROR_REASON_DUPLICATE_TRANSACTION_ID"
            }
            Self::InvalidGbraid => "PROCESSING_ERROR_REASON_INVALID_GBRAID",
            Self::InvalidGclid => "PROCESSING_ERROR_REASON_INVALID_GCLID",
            Self::InvalidMerchantId => "PROCESSING_ERROR_REASON_INVALID_MERCHANT_ID",
            Self::InvalidWbraid => "PROCESSING_ERROR_REASON_INVALID_WBRAID",
            Self::InternalError => "PROCESSING_ERROR_REASON_INTERNAL_ERROR",
            Self::DestinationAccountEnhancedConversionsTermsNotSigned => {
                "PROCESSING_ERROR_REASON_DESTINATION_ACCOUNT_ENHANCED_CONVERSIONS_TERMS_NOT_SIGNED"
            }
            Self::InvalidEvent => "PROCESSING_ERROR_REASON_INVALID_EVENT",
            Self::InsufficientMatchedTransactions => {
                "PROCESSING_ERROR_REASON_INSUFFICIENT_MATCHED_TRANSACTIONS"
            }
            Self::InsufficientTransactions => {
                "PROCESSING_ERROR_REASON_INSUFFICIENT_TRANSACTIONS"
            }
            Self::InvalidFormat => "PROCESSING_ERROR_REASON_INVALID_FORMAT",
            Self::DecryptionError => "PROCESSING_ERROR_REASON_DECRYPTION_ERROR",
            Self::DekDecryptionError => "PROCESSING_ERROR_REASON_DEK_DECRYPTION_ERROR",
            Self::InvalidWip => "PROCESSING_ERROR_REASON_INVALID_WIP",
            Self::InvalidKek => "PROCESSING_ERROR_REASON_INVALID_KEK",
            Self::WipAuthFailed => "PROCESSING_ERROR_REASON_WIP_AUTH_FAILED",
            Self::KekPermissionDenied => "PROCESSING_ERROR_REASON_KEK_PERMISSION_DENIED",
            Self::AwsAuthFailed => "PROCESSING_ERROR_REASON_AWS_AUTH_FAILED",
            Self::UserIdentifierDecryptionError => {
                "PROCESSING_ERROR_REASON_USER_IDENTIFIER_DECRYPTION_ERROR"
            }
            Self::ProcessingErrorOperatingAccountMismatchForAdIdentifier => {
                "PROCESSING_ERROR_OPERATING_ACCOUNT_MISMATCH_FOR_AD_IDENTIFIER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROCESSING_ERROR_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "PROCESSING_ERROR_REASON_INVALID_CUSTOM_VARIABLE" => {
                Some(Self::InvalidCustomVariable)
            }
            "PROCESSING_ERROR_REASON_CUSTOM_VARIABLE_NOT_ENABLED" => {
                Some(Self::CustomVariableNotEnabled)
            }
            "PROCESSING_ERROR_REASON_EVENT_TOO_OLD" => Some(Self::EventTooOld),
            "PROCESSING_ERROR_REASON_DENIED_CONSENT" => Some(Self::DeniedConsent),
            "PROCESSING_ERROR_REASON_NO_CONSENT" => Some(Self::NoConsent),
            "PROCESSING_ERROR_REASON_UNKNOWN_CONSENT" => Some(Self::UnknownConsent),
            "PROCESSING_ERROR_REASON_DUPLICATE_GCLID" => Some(Self::DuplicateGclid),
            "PROCESSING_ERROR_REASON_DUPLICATE_TRANSACTION_ID" => {
                Some(Self::DuplicateTransactionId)
            }
            "PROCESSING_ERROR_REASON_INVALID_GBRAID" => Some(Self::InvalidGbraid),
            "PROCESSING_ERROR_REASON_INVALID_GCLID" => Some(Self::InvalidGclid),
            "PROCESSING_ERROR_REASON_INVALID_MERCHANT_ID" => {
                Some(Self::InvalidMerchantId)
            }
            "PROCESSING_ERROR_REASON_INVALID_WBRAID" => Some(Self::InvalidWbraid),
            "PROCESSING_ERROR_REASON_INTERNAL_ERROR" => Some(Self::InternalError),
            "PROCESSING_ERROR_REASON_DESTINATION_ACCOUNT_ENHANCED_CONVERSIONS_TERMS_NOT_SIGNED" => {
                Some(Self::DestinationAccountEnhancedConversionsTermsNotSigned)
            }
            "PROCESSING_ERROR_REASON_INVALID_EVENT" => Some(Self::InvalidEvent),
            "PROCESSING_ERROR_REASON_INSUFFICIENT_MATCHED_TRANSACTIONS" => {
                Some(Self::InsufficientMatchedTransactions)
            }
            "PROCESSING_ERROR_REASON_INSUFFICIENT_TRANSACTIONS" => {
                Some(Self::InsufficientTransactions)
            }
            "PROCESSING_ERROR_REASON_INVALID_FORMAT" => Some(Self::InvalidFormat),
            "PROCESSING_ERROR_REASON_DECRYPTION_ERROR" => Some(Self::DecryptionError),
            "PROCESSING_ERROR_REASON_DEK_DECRYPTION_ERROR" => {
                Some(Self::DekDecryptionError)
            }
            "PROCESSING_ERROR_REASON_INVALID_WIP" => Some(Self::InvalidWip),
            "PROCESSING_ERROR_REASON_INVALID_KEK" => Some(Self::InvalidKek),
            "PROCESSING_ERROR_REASON_WIP_AUTH_FAILED" => Some(Self::WipAuthFailed),
            "PROCESSING_ERROR_REASON_KEK_PERMISSION_DENIED" => {
                Some(Self::KekPermissionDenied)
            }
            "PROCESSING_ERROR_REASON_AWS_AUTH_FAILED" => Some(Self::AwsAuthFailed),
            "PROCESSING_ERROR_REASON_USER_IDENTIFIER_DECRYPTION_ERROR" => {
                Some(Self::UserIdentifierDecryptionError)
            }
            "PROCESSING_ERROR_OPERATING_ACCOUNT_MISMATCH_FOR_AD_IDENTIFIER" => {
                Some(Self::ProcessingErrorOperatingAccountMismatchForAdIdentifier)
            }
            _ => None,
        }
    }
}
/// The processing warning reason.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProcessingWarningReason {
    /// The processing warning reason is unknown.
    Unspecified = 0,
    /// The system did not have the permissions needed to access the KEK.
    KekPermissionDenied = 1,
    /// The DEK failed to be decrypted.
    DekDecryptionError = 2,
    /// The event has a decryption error.
    DecryptionError = 3,
    /// The WIP could not be used because it was rejected by its attestation
    /// condition.
    WipAuthFailed = 4,
    /// The WIP is formatted incorrectly or the WIP does not exist.
    InvalidWip = 5,
    /// The KEK cannot decrypt data because it is the wrong KEK, or it does not
    /// exist.
    InvalidKek = 6,
    /// Failed to decrypt th
    /// \[UserIdentifier\]\[google.ads.datamanager.v1.UserIdentifier\] data using the
    /// DEK.
    UserIdentifierDecryptionError = 7,
    /// Internal error.
    InternalError = 8,
    /// The system failed to authenticate with AWS.
    AwsAuthFailed = 9,
}
impl ProcessingWarningReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROCESSING_WARNING_REASON_UNSPECIFIED",
            Self::KekPermissionDenied => {
                "PROCESSING_WARNING_REASON_KEK_PERMISSION_DENIED"
            }
            Self::DekDecryptionError => "PROCESSING_WARNING_REASON_DEK_DECRYPTION_ERROR",
            Self::DecryptionError => "PROCESSING_WARNING_REASON_DECRYPTION_ERROR",
            Self::WipAuthFailed => "PROCESSING_WARNING_REASON_WIP_AUTH_FAILED",
            Self::InvalidWip => "PROCESSING_WARNING_REASON_INVALID_WIP",
            Self::InvalidKek => "PROCESSING_WARNING_REASON_INVALID_KEK",
            Self::UserIdentifierDecryptionError => {
                "PROCESSING_WARNING_REASON_USER_IDENTIFIER_DECRYPTION_ERROR"
            }
            Self::InternalError => "PROCESSING_WARNING_REASON_INTERNAL_ERROR",
            Self::AwsAuthFailed => "PROCESSING_WARNING_REASON_AWS_AUTH_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROCESSING_WARNING_REASON_UNSPECIFIED" => Some(Self::Unspecified),
            "PROCESSING_WARNING_REASON_KEK_PERMISSION_DENIED" => {
                Some(Self::KekPermissionDenied)
            }
            "PROCESSING_WARNING_REASON_DEK_DECRYPTION_ERROR" => {
                Some(Self::DekDecryptionError)
            }
            "PROCESSING_WARNING_REASON_DECRYPTION_ERROR" => Some(Self::DecryptionError),
            "PROCESSING_WARNING_REASON_WIP_AUTH_FAILED" => Some(Self::WipAuthFailed),
            "PROCESSING_WARNING_REASON_INVALID_WIP" => Some(Self::InvalidWip),
            "PROCESSING_WARNING_REASON_INVALID_KEK" => Some(Self::InvalidKek),
            "PROCESSING_WARNING_REASON_USER_IDENTIFIER_DECRYPTION_ERROR" => {
                Some(Self::UserIdentifierDecryptionError)
            }
            "PROCESSING_WARNING_REASON_INTERNAL_ERROR" => Some(Self::InternalError),
            "PROCESSING_WARNING_REASON_AWS_AUTH_FAILED" => Some(Self::AwsAuthFailed),
            _ => None,
        }
    }
}
/// A request status per destination.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestStatusPerDestination {
    /// A destination within a DM API request.
    #[prost(message, optional, tag = "1")]
    pub destination: ::core::option::Option<Destination>,
    /// The request status of the destination.
    #[prost(enumeration = "request_status_per_destination::RequestStatus", tag = "2")]
    pub request_status: i32,
    /// An error info error containing the error reason and error counts related to
    /// the upload.
    #[prost(message, optional, tag = "3")]
    pub error_info: ::core::option::Option<ErrorInfo>,
    /// A warning info containing the warning reason and warning counts related to
    /// the upload.
    #[prost(message, optional, tag = "7")]
    pub warning_info: ::core::option::Option<WarningInfo>,
    /// The status of the destination.
    #[prost(oneof = "request_status_per_destination::Status", tags = "4, 5, 6")]
    pub status: ::core::option::Option<request_status_per_destination::Status>,
}
/// Nested message and enum types in `RequestStatusPerDestination`.
pub mod request_status_per_destination {
    /// The status of the ingest audience members request.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IngestAudienceMembersStatus {
        /// The status of the audience members ingestion to the destination.
        #[prost(oneof = "ingest_audience_members_status::Status", tags = "1, 2, 3")]
        pub status: ::core::option::Option<ingest_audience_members_status::Status>,
    }
    /// Nested message and enum types in `IngestAudienceMembersStatus`.
    pub mod ingest_audience_members_status {
        /// The status of the audience members ingestion to the destination.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Status {
            /// The status of the user data ingestion to the destination.
            #[prost(message, tag = "1")]
            UserDataIngestionStatus(super::IngestUserDataStatus),
            /// The status of the mobile data ingestion to the destination.
            #[prost(message, tag = "2")]
            MobileDataIngestionStatus(super::IngestMobileDataStatus),
            /// The status of the pair data ingestion to the destination.
            #[prost(message, tag = "3")]
            PairDataIngestionStatus(super::IngestPairDataStatus),
        }
    }
    /// The status of the remove audience members request.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RemoveAudienceMembersStatus {
        /// The status of the audience members removal from the destination.
        #[prost(oneof = "remove_audience_members_status::Status", tags = "1, 2, 3")]
        pub status: ::core::option::Option<remove_audience_members_status::Status>,
    }
    /// Nested message and enum types in `RemoveAudienceMembersStatus`.
    pub mod remove_audience_members_status {
        /// The status of the audience members removal from the destination.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Status {
            /// The status of the user data removal from the destination.
            #[prost(message, tag = "1")]
            UserDataRemovalStatus(super::RemoveUserDataStatus),
            /// The status of the mobile data removal from the destination.
            #[prost(message, tag = "2")]
            MobileDataRemovalStatus(super::RemoveMobileDataStatus),
            /// The status of the pair data removal from the destination.
            #[prost(message, tag = "3")]
            PairDataRemovalStatus(super::RemovePairDataStatus),
        }
    }
    /// The status of the events ingestion to the destination.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IngestEventsStatus {
        /// The total count of events sent in the upload request. Includes all
        /// events in the request, regardless of whether they were successfully
        /// ingested or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
    }
    /// The status of the user data ingestion to the destination containing stats
    /// related to the ingestion.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IngestUserDataStatus {
        /// The total count of audience members sent in the upload request for the
        /// destination. Includes all audience members in the request, regardless of
        /// whether they were successfully ingested or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
        /// The total count of user identifiers sent in the upload request for the
        /// destination. Includes all user identifiers in the request, regardless of
        /// whether they were successfully ingested or not.
        #[prost(int64, tag = "2")]
        pub user_identifier_count: i64,
        /// The match rate range of the upload.
        #[prost(enumeration = "super::MatchRateRange", tag = "3")]
        pub upload_match_rate_range: i32,
    }
    /// The status of the user data removal from the destination.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RemoveUserDataStatus {
        /// The total count of audience members sent in the removal request. Includes
        /// all audience members in the request, regardless of whether they were
        /// successfully removed or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
        /// The total count of user identifiers sent in the removal request. Includes
        /// all user identifiers in the request, regardless of whether they were
        /// successfully removed or not.
        #[prost(int64, tag = "2")]
        pub user_identifier_count: i64,
    }
    /// The status of the mobile data ingestion to the destination containing stats
    /// related to the ingestion.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IngestMobileDataStatus {
        /// The total count of audience members sent in the upload request for the
        /// destination. Includes all audience members in the request, regardless of
        /// whether they were successfully ingested or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
        /// The total count of mobile ids sent in the upload request for the
        /// destination. Includes all mobile ids in the request, regardless of
        /// whether they were successfully ingested or not.
        #[prost(int64, tag = "2")]
        pub mobile_id_count: i64,
    }
    /// The status of the mobile data removal from the destination.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RemoveMobileDataStatus {
        /// The total count of audience members sent in the removal request. Includes
        /// all audience members in the request, regardless of whether they were
        /// successfully removed or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
        /// The total count of mobile Ids sent in the removal request. Includes all
        /// mobile ids in the request, regardless of whether they were successfully
        /// removed or not.
        #[prost(int64, tag = "2")]
        pub mobile_id_count: i64,
    }
    /// The status of the pair data ingestion to the destination containing stats
    /// related to the ingestion.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IngestPairDataStatus {
        /// The total count of audience members sent in the upload request for the
        /// destination. Includes all audience members in the request, regardless of
        /// whether they were successfully ingested or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
        /// The total count of pair ids sent in the upload request for the
        /// destination. Includes all pair ids in the request, regardless of
        /// whether they were successfully ingested or not.
        #[prost(int64, tag = "2")]
        pub pair_id_count: i64,
    }
    /// The status of the pair data removal from the destination.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RemovePairDataStatus {
        /// The total count of audience members sent in the removal request. Includes
        /// all audience members in the request, regardless of whether they were
        /// successfully removed or not.
        #[prost(int64, tag = "1")]
        pub record_count: i64,
        /// The total count of pair ids sent in the removal request. Includes all
        /// pair ids in the request, regardless of whether they were successfully
        /// removed or not.
        #[prost(int64, tag = "2")]
        pub pair_id_count: i64,
    }
    /// The request status.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestStatus {
        /// The request status is unknown.
        Unknown = 0,
        /// The request succeeded.
        Success = 1,
        /// The request is processing.
        Processing = 2,
        /// The request failed.
        Failed = 3,
        /// The request partially succeeded.
        PartialSuccess = 4,
    }
    impl RequestStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "REQUEST_STATUS_UNKNOWN",
                Self::Success => "SUCCESS",
                Self::Processing => "PROCESSING",
                Self::Failed => "FAILED",
                Self::PartialSuccess => "PARTIAL_SUCCESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REQUEST_STATUS_UNKNOWN" => Some(Self::Unknown),
                "SUCCESS" => Some(Self::Success),
                "PROCESSING" => Some(Self::Processing),
                "FAILED" => Some(Self::Failed),
                "PARTIAL_SUCCESS" => Some(Self::PartialSuccess),
                _ => None,
            }
        }
    }
    /// The status of the destination.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Status {
        /// The status of the ingest audience members request.
        #[prost(message, tag = "4")]
        AudienceMembersIngestionStatus(IngestAudienceMembersStatus),
        /// The status of the ingest events request.
        #[prost(message, tag = "5")]
        EventsIngestionStatus(IngestEventsStatus),
        /// The status of the remove audience members request.
        #[prost(message, tag = "6")]
        AudienceMembersRemovalStatus(RemoveAudienceMembersStatus),
    }
}
/// The terms of service that the user has accepted/rejected.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TermsOfService {
    /// Optional. The Customer Match terms of service:
    /// <https://support.google.com/adspolicy/answer/6299717.> This must be
    /// accepted when ingesting
    /// \[UserData\]\[google.ads.datamanager.v1.UserData\]
    /// or \[MobileData\]\[google.ads.datamanager.v1.MobileData\].
    /// This field is not required for Partner Match User list.
    #[prost(enumeration = "TermsOfServiceStatus", tag = "1")]
    pub customer_match_terms_of_service_status: i32,
}
/// Represents the caller's decision to accept or reject the terms of service.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TermsOfServiceStatus {
    /// Not specified.
    Unspecified = 0,
    /// Status indicating the caller has chosen to accept the terms of service.
    Accepted = 1,
    /// Status indicating the caller has chosen to reject the terms of service.
    Rejected = 2,
}
impl TermsOfServiceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TERMS_OF_SERVICE_STATUS_UNSPECIFIED",
            Self::Accepted => "ACCEPTED",
            Self::Rejected => "REJECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TERMS_OF_SERVICE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCEPTED" => Some(Self::Accepted),
            "REJECTED" => Some(Self::Rejected),
            _ => None,
        }
    }
}
/// Request to upload audience members to the provided destinations. Returns an
/// \[IngestAudienceMembersResponse\]\[google.ads.datamanager.v1.IngestAudienceMembersResponse\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestAudienceMembersRequest {
    /// Required. The list of destinations to send the audience members to.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
    /// Required. The list of users to send to the specified destinations. At most
    /// 10000 \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\] resources
    /// can be sent in a single request.
    #[prost(message, repeated, tag = "2")]
    pub audience_members: ::prost::alloc::vec::Vec<AudienceMember>,
    /// Optional. Request-level consent to apply to all users in the request.
    /// User-level consent overrides request-level consent, and can be specified in
    /// each \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\].
    #[prost(message, optional, tag = "3")]
    pub consent: ::core::option::Option<Consent>,
    /// Optional. For testing purposes. If `true`, the request is validated but not
    /// executed. Only errors are returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Optional. Required for \[UserData\]\[google.ads.datamanager.v1.UserData\]
    /// uploads. The encoding type of the user identifiers. For hashed user
    /// identifiers, this is the encoding type of the hashed string. For encrypted
    /// hashed user identifiers, this is the encoding type of the outer encrypted
    /// string, but not necessarily the inner hashed string, meaning the inner
    /// hashed string could be encoded in a different way than the outer encrypted
    /// string. For non `UserData` uploads, this field is ignored.
    #[prost(enumeration = "Encoding", tag = "5")]
    pub encoding: i32,
    /// Optional. Encryption information for
    /// \[UserData\]\[google.ads.datamanager.v1.UserData\] uploads. If not set, it's
    /// assumed that uploaded identifying information is hashed but not encrypted.
    /// For non `UserData` uploads, this field is ignored.
    #[prost(message, optional, tag = "6")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
    /// Optional. The terms of service that the user has accepted/rejected.
    #[prost(message, optional, tag = "7")]
    pub terms_of_service: ::core::option::Option<TermsOfService>,
}
/// Response from the
/// \[IngestAudienceMembersRequest\]\[google.ads.datamanager.v1.IngestAudienceMembersRequest\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IngestAudienceMembersResponse {
    /// The auto-generated ID of the request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request to remove users from an audience in the provided destinations.
/// Returns a
/// \[RemoveAudienceMembersResponse\]\[google.ads.datamanager.v1.RemoveAudienceMembersResponse\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAudienceMembersRequest {
    /// Required. The list of destinations to remove the users from.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
    /// Required. The list of users to remove.
    #[prost(message, repeated, tag = "2")]
    pub audience_members: ::prost::alloc::vec::Vec<AudienceMember>,
    /// Optional. For testing purposes. If `true`, the request is validated but not
    /// executed. Only errors are returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// Optional. Required for \[UserData\]\[google.ads.datamanager.v1.UserData\]
    /// uploads. The encoding type of the user identifiers. Applies to only the
    /// outer encoding for encrypted user identifiers. For non `UserData` uploads,
    /// this field is ignored.
    #[prost(enumeration = "Encoding", tag = "4")]
    pub encoding: i32,
    /// Optional. Encryption information for
    /// \[UserData\]\[google.ads.datamanager.v1.UserData\] uploads. If not set, it's
    /// assumed that uploaded identifying information is hashed but not encrypted.
    /// For non `UserData` uploads, this field is ignored.
    #[prost(message, optional, tag = "5")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
}
/// Response from the
/// \[RemoveAudienceMembersRequest\]\[google.ads.datamanager.v1.RemoveAudienceMembersRequest\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveAudienceMembersResponse {
    /// The auto-generated ID of the request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request to upload audience members to the provided destinations. Returns an
/// \[IngestEventsResponse\]\[google.ads.datamanager.v1.IngestEventsResponse\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestEventsRequest {
    /// Required. The list of destinations to send the events to.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
    /// Required. The list of events to send to the specified destinations. At most
    /// 2000 \[Event\]\[google.ads.datamanager.v1.Event\] resources
    /// can be sent in a single request.
    #[prost(message, repeated, tag = "2")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    /// Optional. Request-level consent to apply to all users in the request.
    /// User-level consent overrides request-level consent, and can be specified in
    /// each \[Event\]\[google.ads.datamanager.v1.Event\].
    #[prost(message, optional, tag = "3")]
    pub consent: ::core::option::Option<Consent>,
    /// Optional. For testing purposes. If `true`, the request is validated but not
    /// executed. Only errors are returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Optional. Required for \[UserData\]\[google.ads.datamanager.v1.UserData\]
    /// uploads. The encoding type of the user identifiers. For hashed user
    /// identifiers, this is the encoding type of the hashed string. For encrypted
    /// hashed user identifiers, this is the encoding type of the outer encrypted
    /// string, but not necessarily the inner hashed string, meaning the inner
    /// hashed string could be encoded in a different way than the outer encrypted
    /// string. For non `UserData` uploads, this field is ignored.
    #[prost(enumeration = "Encoding", tag = "5")]
    pub encoding: i32,
    /// Optional. Encryption information for
    /// \[UserData\]\[google.ads.datamanager.v1.UserData\] uploads. If not set, it's
    /// assumed that uploaded identifying information is hashed but not encrypted.
    /// For non `UserData` uploads, this field is ignored.
    #[prost(message, optional, tag = "6")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
}
/// Response from the
/// \[IngestEventsRequest\]\[google.ads.datamanager.v1.IngestEventsRequest\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IngestEventsResponse {
    /// The auto-generated ID of the request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request to get the status of request made to the DM API for a given request
/// ID. Returns a
/// \[RetrieveRequestStatusResponse\]\[google.ads.datamanager.v1.RetrieveRequestStatusResponse\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RetrieveRequestStatusRequest {
    /// Required. Required. The request ID of the Data Manager API request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Response from the
/// \[RetrieveRequestStatusRequest\]\[google.ads.datamanager.v1.RetrieveRequestStatusRequest\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveRequestStatusResponse {
    /// A list of request statuses per destination. The order of the statuses
    /// matches the order of the destinations in the original request.
    #[prost(message, repeated, tag = "1")]
    pub request_status_per_destination: ::prost::alloc::vec::Vec<
        RequestStatusPerDestination,
    >,
}
/// The encoding type of the hashed identifying information.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    /// Unspecified Encoding type. Should never be used.
    Unspecified = 0,
    /// Hex encoding.
    Hex = 1,
    /// Base 64 encoding.
    Base64 = 2,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_UNSPECIFIED",
            Self::Hex => "HEX",
            Self::Base64 => "BASE64",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "HEX" => Some(Self::Hex),
            "BASE64" => Some(Self::Base64),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod ingestion_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for sending audience data to supported destinations.
    #[derive(Debug, Clone)]
    pub struct IngestionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IngestionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IngestionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IngestionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IngestionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Uploads a list of
        /// \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\] resources to the
        /// provided \[Destination\]\[google.ads.datamanager.v1.Destination\].
        pub async fn ingest_audience_members(
            &mut self,
            request: impl tonic::IntoRequest<super::IngestAudienceMembersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IngestAudienceMembersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/IngestAudienceMembers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "IngestAudienceMembers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes a list of
        /// \[AudienceMember\]\[google.ads.datamanager.v1.AudienceMember\] resources from
        /// the provided \[Destination\]\[google.ads.datamanager.v1.Destination\].
        pub async fn remove_audience_members(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveAudienceMembersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveAudienceMembersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/RemoveAudienceMembers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "RemoveAudienceMembers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Uploads a list of
        /// \[Event\]\[google.ads.datamanager.v1.Event\] resources from
        /// the provided \[Destination\]\[google.ads.datamanager.v1.Destination\].
        pub async fn ingest_events(
            &mut self,
            request: impl tonic::IntoRequest<super::IngestEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IngestEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/IngestEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "IngestEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the status of a request given request id.
        pub async fn retrieve_request_status(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveRequestStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveRequestStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/RetrieveRequestStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "RetrieveRequestStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
