// This file is @generated by prost-build.
/// [Digital Markets Act
/// (DMA)](//digital-markets-act.ec.europa.eu/index_en) consent settings
/// for the user.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Consent {
    /// Optional. Represents if the user consents to ad user data.
    #[prost(enumeration = "ConsentStatus", tag = "1")]
    pub ad_user_data: i32,
    /// Optional. Represents if the user consents to ad personalization.
    #[prost(enumeration = "ConsentStatus", tag = "2")]
    pub ad_personalization: i32,
}
/// Represents if the user granted, denied, or hasn't specified consent.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConsentStatus {
    /// Not specified.
    Unspecified = 0,
    /// Granted.
    ConsentGranted = 1,
    /// Denied.
    ConsentDenied = 2,
}
impl ConsentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONSENT_STATUS_UNSPECIFIED",
            Self::ConsentGranted => "CONSENT_GRANTED",
            Self::ConsentDenied => "CONSENT_DENIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONSENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "CONSENT_GRANTED" => Some(Self::ConsentGranted),
            "CONSENT_DENIED" => Some(Self::ConsentDenied),
            _ => None,
        }
    }
}
/// Data that identifies the user. At least one identifier is required.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserData {
    /// Required. The identifiers for the user. It's possible to provide multiple
    /// instances of the same type of data (for example, multiple email addresses).
    /// To increase the likelihood of a match, provide as many identifiers as
    /// possible. At most 10 `userIdentifiers` can be provided in a single
    /// [AudienceMember][google.ads.datamanager.v1.AudienceMember] or
    /// [Event][google.ads.datamanager.v1.Event].
    #[prost(message, repeated, tag = "1")]
    pub user_identifiers: ::prost::alloc::vec::Vec<UserIdentifier>,
}
/// A single identifier for the user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserIdentifier {
    /// Exactly one must be specified.
    #[prost(oneof = "user_identifier::Identifier", tags = "1, 2, 3")]
    pub identifier: ::core::option::Option<user_identifier::Identifier>,
}
/// Nested message and enum types in `UserIdentifier`.
pub mod user_identifier {
    /// Exactly one must be specified.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Identifier {
        /// Hashed email address using SHA-256 hash function after normalization.
        #[prost(string, tag = "1")]
        EmailAddress(::prost::alloc::string::String),
        /// Hashed phone number using SHA-256 hash function after normalization (E164
        /// standard).
        #[prost(string, tag = "2")]
        PhoneNumber(::prost::alloc::string::String),
        /// The known components of a user's address. Holds a grouping
        /// of identifiers that are matched all at once.
        #[prost(message, tag = "3")]
        Address(super::AddressInfo),
    }
}
/// Address information for the user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressInfo {
    /// Required. Given (first) name of the user, all lowercase, with no
    /// punctuation, no leading or trailing whitespace, and hashed as SHA-256.
    #[prost(string, tag = "1")]
    pub given_name: ::prost::alloc::string::String,
    /// Required. Family (last) name of the user, all lowercase, with no
    /// punctuation, no leading or trailing whitespace, and hashed as SHA-256.
    #[prost(string, tag = "2")]
    pub family_name: ::prost::alloc::string::String,
    /// Required. The 2-letter region code in ISO-3166-1 alpha-2 of the user's
    /// address.
    #[prost(string, tag = "3")]
    pub region_code: ::prost::alloc::string::String,
    /// Required. The postal code of the user's address.
    #[prost(string, tag = "4")]
    pub postal_code: ::prost::alloc::string::String,
}
/// The audience member to be operated on.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceMember {
    /// Optional. The consent setting for the user.
    #[prost(message, optional, tag = "3")]
    pub consent: ::core::option::Option<Consent>,
    /// The type of identifying data to be operated on.
    #[prost(oneof = "audience_member::Data", tags = "2, 4, 5")]
    pub data: ::core::option::Option<audience_member::Data>,
}
/// Nested message and enum types in `AudienceMember`.
pub mod audience_member {
    /// The type of identifying data to be operated on.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// User-provided data that identifies the user.
        #[prost(message, tag = "2")]
        UserData(super::UserData),
        /// [Publisher Advertiser Identity Reconciliation (PAIR)
        /// IDs](//support.google.com/admanager/answer/15067908).
        #[prost(message, tag = "4")]
        PairData(super::PairData),
        /// Data identifying the user's mobile devices.
        #[prost(message, tag = "5")]
        MobileData(super::MobileData),
    }
}
/// [PAIR](//support.google.com/admanager/answer/15067908) IDs for the audience.
/// At least one PAIR ID is required.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PairData {
    /// Required. Cleanroom-provided PII data, hashed with SHA256, and encrypted
    /// with an EC commutative cipher using publisher key for the
    /// [PAIR]((//support.google.com/admanager/answer/15067908)) user list. At most
    /// 10 `pairIds` can be provided in a single
    /// [AudienceMember][google.ads.datamanager.v1.AudienceMember].
    #[prost(string, repeated, tag = "1")]
    pub pair_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Mobile IDs for the audience. At least one mobile ID is required.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MobileData {
    /// Required. The list of mobile device IDs (advertising ID/IDFA). At most 10
    /// `mobileIds` can be provided in a single
    /// [AudienceMember][google.ads.datamanager.v1.AudienceMember].
    #[prost(string, repeated, tag = "1")]
    pub mobile_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The cart data associated with the event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CartData {
    /// Optional. The Merchant Center ID associated with the items.
    #[prost(string, tag = "1")]
    pub merchant_id: ::prost::alloc::string::String,
    /// Optional. The Merchant Center feed label associated with the feed of the
    /// items.
    #[prost(string, tag = "2")]
    pub merchant_feed_label: ::prost::alloc::string::String,
    /// Optional. The language code in ISO 639-1 associated with the Merchant
    /// Center feed of the items.where your items are uploaded.
    #[prost(string, tag = "3")]
    pub merchant_feed_language_code: ::prost::alloc::string::String,
    /// Optional. The sum of all discounts associated with the transaction.
    #[prost(double, tag = "4")]
    pub transaction_discount: f64,
    /// Optional. The list of items associated with the event.
    #[prost(message, repeated, tag = "5")]
    pub items: ::prost::alloc::vec::Vec<Item>,
}
/// Represents an item in the cart associated with the event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Item {
    /// Optional. The product ID within the Merchant Center account.
    #[prost(string, tag = "1")]
    pub merchant_product_id: ::prost::alloc::string::String,
    /// Optional. The number of this item associated with the event.
    #[prost(int64, tag = "2")]
    pub quantity: i64,
    /// Optional. The unit price excluding tax, shipping, and any transaction level
    /// discounts.
    #[prost(double, tag = "3")]
    pub unit_price: f64,
}
/// The Google product you're sending data to. For example, a Google
/// Ads account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Destination {
    /// Optional. ID for this `Destination` resource, unique within the request.
    /// Use to reference this `Destination` in  the
    /// [IngestEventsRequest][google.ads.datamanager.v1.IngestEventsRequest].
    #[prost(string, tag = "1")]
    pub reference: ::prost::alloc::string::String,
    /// Optional. The account used to make this API call. To add or remove data
    /// from the
    /// [`operating_account`][google.ads.datamanager.v1.Destination.operating_account],
    /// this `login_account` must have write access to the `operating_account`. For
    /// example, a manager account of the `operating_account`, or an account with
    /// an established link to the `operating_account`.
    #[prost(message, optional, tag = "2")]
    pub login_account: ::core::option::Option<ProductAccount>,
    /// Optional. An account that the calling user's
    /// [`login_account`][google.ads.datamanager.v1.Destination.login_account] has
    /// access to, through an established account link. For example, a data
    /// partner's `login_account` might have access to a client's `linked_account`.
    /// The partner might use this field to send data from the `linked_account` to
    /// another
    /// [`operating_account`][google.ads.datamanager.v1.Destination.operating_account].
    #[prost(message, optional, tag = "3")]
    pub linked_account: ::core::option::Option<ProductAccount>,
    /// Required. The account to send the data to or remove the data from.
    #[prost(message, optional, tag = "4")]
    pub operating_account: ::core::option::Option<ProductAccount>,
    /// Required. The object within the product account to ingest into. For
    /// example, a Google Ads audience ID or a Display & Video 360 audience ID.
    #[prost(string, tag = "5")]
    pub product_destination_id: ::prost::alloc::string::String,
}
/// Represents a specific account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProductAccount {
    /// Required. The product the account belongs to. For example, `GOOGLE_ADS`.
    #[prost(enumeration = "Product", tag = "1")]
    pub product: i32,
    /// Required. The ID of the account. For example, your Google Ads account ID.
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
}
/// Represents a specific Google product. Used to locate accounts and
/// destinations.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Product {
    /// Unspecified product. Should never be used.
    Unspecified = 0,
    /// Google Ads.
    GoogleAds = 1,
    /// Display & Video 360 partner.
    DisplayVideoPartner = 2,
    /// Display & Video 360 advertiser.
    DisplayVideoAdvertiser = 3,
    /// Data Partner.
    DataPartner = 4,
}
impl Product {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRODUCT_UNSPECIFIED",
            Self::GoogleAds => "GOOGLE_ADS",
            Self::DisplayVideoPartner => "DISPLAY_VIDEO_PARTNER",
            Self::DisplayVideoAdvertiser => "DISPLAY_VIDEO_ADVERTISER",
            Self::DataPartner => "DATA_PARTNER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRODUCT_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_ADS" => Some(Self::GoogleAds),
            "DISPLAY_VIDEO_PARTNER" => Some(Self::DisplayVideoPartner),
            "DISPLAY_VIDEO_ADVERTISER" => Some(Self::DisplayVideoAdvertiser),
            "DATA_PARTNER" => Some(Self::DataPartner),
            _ => None,
        }
    }
}
/// Information about the device being used (if any) when the event happened.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceInfo {
    /// Optional. The user-agent string of the device for the given context.
    #[prost(string, tag = "1")]
    pub user_agent: ::prost::alloc::string::String,
    /// Optional. The IP address of the device for the given context.
    #[prost(string, tag = "2")]
    pub ip_address: ::prost::alloc::string::String,
}
/// Encryption information for the data being ingested.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionInfo {
    /// The [wrapped key](//cloud.google.com/kms/docs/key-wrapping) used to encrypt
    /// the data.
    #[prost(oneof = "encryption_info::WrappedKey", tags = "1")]
    pub wrapped_key: ::core::option::Option<encryption_info::WrappedKey>,
}
/// Nested message and enum types in `EncryptionInfo`.
pub mod encryption_info {
    /// The [wrapped key](//cloud.google.com/kms/docs/key-wrapping) used to encrypt
    /// the data.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WrappedKey {
        /// Google Cloud Platform wrapped key information.
        #[prost(message, tag = "1")]
        GcpWrappedKeyInfo(super::GcpWrappedKeyInfo),
    }
}
/// Information about the Google Cloud Platform wrapped
/// key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcpWrappedKeyInfo {
    /// Required. The type of algorithm used to encrypt the data.
    #[prost(enumeration = "gcp_wrapped_key_info::KeyType", tag = "1")]
    pub key_type: i32,
    /// Required. The [Workload
    /// Identity](//cloud.google.com/iam/docs/workload-identity-federation) pool
    /// provider required to use KEK.
    #[prost(string, tag = "2")]
    pub wip_provider: ::prost::alloc::string::String,
    /// Required. Google Cloud Platform [Cloud Key Management Service resource
    /// ID](//cloud.google.com/kms/docs/getting-resource-ids).
    #[prost(string, tag = "3")]
    pub kek_uri: ::prost::alloc::string::String,
    /// Required. The base64 encoded encrypted data encryption key.
    #[prost(string, tag = "4")]
    pub encrypted_dek: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GcpWrappedKeyInfo`.
pub mod gcp_wrapped_key_info {
    /// The type of algorithm used to encrypt the data.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyType {
        /// Unspecified key type. Should never be used.
        Unspecified = 0,
        /// Algorithm XChaCha20-Poly1305
        Xchacha20Poly1305 = 1,
    }
    impl KeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "KEY_TYPE_UNSPECIFIED",
                Self::Xchacha20Poly1305 => "XCHACHA20_POLY1305",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "KEY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "XCHACHA20_POLY1305" => Some(Self::Xchacha20Poly1305),
                _ => None,
            }
        }
    }
}
/// Experimental field representing unofficial fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExperimentalField {
    /// Optional. The name of the field to use.
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    /// Optional. The value the field to set.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// An event representing a user interaction with an advertiser's website or app.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Event {
    /// Optional. Reference string used to determine the destination.
    #[prost(string, repeated, tag = "1")]
    pub destination_references: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. The unique identifier for this event.
    #[prost(string, tag = "2")]
    pub transaction_id: ::prost::alloc::string::String,
    /// Required. The time the event occurred.
    #[prost(message, optional, tag = "3")]
    pub event_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The last time the event was updated.
    #[prost(message, optional, tag = "4")]
    pub last_updated_timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Pieces of user provided data, representing the user the event is
    /// associated with.
    #[prost(message, optional, tag = "5")]
    pub user_data: ::core::option::Option<UserData>,
    /// Optional. Information about whether the associated user has provided
    /// different types of consent.
    #[prost(message, optional, tag = "6")]
    pub consent: ::core::option::Option<Consent>,
    /// Optional. Identifiers and other information used to match the conversion
    /// event with other online activity (such as ad clicks).
    #[prost(message, optional, tag = "7")]
    pub ad_identifiers: ::core::option::Option<AdIdentifiers>,
    /// Optional. The currency code associated with all monetary values within this
    /// event.
    #[prost(string, tag = "8")]
    pub currency: ::prost::alloc::string::String,
    /// Optional. The conversion value associated with the event, for value-based
    /// conversions.
    #[prost(double, tag = "9")]
    pub conversion_value: f64,
    /// Optional. Signal for where the event happened (web, app, in-store, etc.).
    #[prost(enumeration = "EventSource", tag = "10")]
    pub event_source: i32,
    /// Optional. Information gathered about the device being used (if any) when
    /// the event happened.
    #[prost(message, optional, tag = "11")]
    pub event_device_info: ::core::option::Option<DeviceInfo>,
    /// Optional. Information about the transaction and items associated with the
    /// event.
    #[prost(message, optional, tag = "12")]
    pub cart_data: ::core::option::Option<CartData>,
    /// Optional. Additional key/value pair information to send to the conversion
    /// containers (conversion action or FL activity).
    #[prost(message, repeated, tag = "13")]
    pub custom_variables: ::prost::alloc::vec::Vec<CustomVariable>,
    /// Optional. A list of key/value pairs for experimental fields that may
    /// eventually be promoted to be part of the API.
    #[prost(message, repeated, tag = "14")]
    pub experimental_fields: ::prost::alloc::vec::Vec<ExperimentalField>,
}
/// Identifiers and other information used to match the conversion event with
/// other online activity (such as ad clicks).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdIdentifiers {
    /// Optional. Session attributes for event attribution and modeling.
    #[prost(string, tag = "1")]
    pub session_attributes: ::prost::alloc::string::String,
    /// Optional. The Google click ID (gclid) associated with this event.
    #[prost(string, tag = "2")]
    pub gclid: ::prost::alloc::string::String,
    /// Optional. The click identifier for clicks associated with app events and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "3")]
    pub gbraid: ::prost::alloc::string::String,
    /// Optional. The click identifier for clicks associated with web events and
    /// originating from iOS devices starting with iOS14.
    #[prost(string, tag = "4")]
    pub wbraid: ::prost::alloc::string::String,
    /// Optional. Information gathered about the device being used (if any) at the
    /// time of landing onto the advertiser’s site after interacting with the ad.
    #[prost(message, optional, tag = "5")]
    pub landing_page_device_info: ::core::option::Option<DeviceInfo>,
}
/// Custom variable for ads conversions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomVariable {
    /// Optional. The name of the custom variable to set. If the variable is not
    /// found for the given destination, it will be ignored.
    #[prost(string, tag = "1")]
    pub variable: ::prost::alloc::string::String,
    /// Optional. The value to store for the custom variable.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// The source of the event.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventSource {
    /// Unspecified EventSource. Should never be used.
    Unspecified = 0,
    /// The event was generated from a web browser.
    Web = 1,
}
impl EventSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVENT_SOURCE_UNSPECIFIED",
            Self::Web => "WEB",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "WEB" => Some(Self::Web),
            _ => None,
        }
    }
}
/// The terms of service that the user has accepted/rejected.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TermsOfService {
    /// Optional. The Customer Match terms of service:
    /// <https://support.google.com/adspolicy/answer/6299717.> This must be
    /// accepted for all uploads to Customer Match userlists.
    #[prost(enumeration = "TermsOfServiceStatus", tag = "1")]
    pub customer_match_terms_of_service_status: i32,
}
/// Represents the caller's decision to accept or reject the terms of service.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TermsOfServiceStatus {
    /// Not specified.
    Unspecified = 0,
    /// Status indicating the caller has chosen to accept the terms of service.
    Accepted = 1,
    /// Status indicating the caller has chosen to reject the terms of service.
    Rejected = 2,
}
impl TermsOfServiceStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TERMS_OF_SERVICE_STATUS_UNSPECIFIED",
            Self::Accepted => "ACCEPTED",
            Self::Rejected => "REJECTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TERMS_OF_SERVICE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCEPTED" => Some(Self::Accepted),
            "REJECTED" => Some(Self::Rejected),
            _ => None,
        }
    }
}
/// Request to upload audience members to the provided destinations. Returns an
/// [IngestAudienceMembersResponse][google.ads.datamanager.v1.IngestAudienceMembersResponse].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestAudienceMembersRequest {
    /// Required. The list of destinations to send the audience members to.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
    /// Required. The list of users to send to the specified destinations. At most
    /// 10000 [AudienceMember][google.ads.datamanager.v1.AudienceMember] resources
    /// can be sent in a single request.
    #[prost(message, repeated, tag = "2")]
    pub audience_members: ::prost::alloc::vec::Vec<AudienceMember>,
    /// Optional. Request-level consent to apply to all users in the request.
    /// User-level consent overrides request-level consent, and can be specified in
    /// each [AudienceMember][google.ads.datamanager.v1.AudienceMember].
    #[prost(message, optional, tag = "3")]
    pub consent: ::core::option::Option<Consent>,
    /// Optional. For testing purposes. If `true`, the request is validated but not
    /// executed. Only errors are returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Optional. Required for [UserData][google.ads.datamanager.v1.UserData]
    /// uploads. The encoding type of the user identifiers. For hashed user
    /// identifiers, this is the encoding type of the hashed string. For encrypted
    /// hashed user identifiers, this is the encoding type of the outer encrypted
    /// string, but not necessarily the inner hashed string, meaning the inner
    /// hashed string could be encoded in a different way than the outer encrypted
    /// string. For non `UserData` uploads, this field is ignored.
    #[prost(enumeration = "Encoding", tag = "5")]
    pub encoding: i32,
    /// Optional. Encryption information for
    /// [UserData][google.ads.datamanager.v1.UserData] uploads. If not set, it's
    /// assumed that uploaded identifying information is hashed but not encrypted.
    /// For non `UserData` uploads, this field is ignored.
    #[prost(message, optional, tag = "6")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
    /// Optional. The terms of service that the user has accepted/rejected.
    #[prost(message, optional, tag = "7")]
    pub terms_of_service: ::core::option::Option<TermsOfService>,
}
/// Response from the
/// [IngestAudienceMembersRequest][google.ads.datamanager.v1.IngestAudienceMembersRequest].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestAudienceMembersResponse {
    /// The auto-generated ID of the request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request to remove users from an audience in the provided destinations.
/// Returns a
/// [RemoveAudienceMembersResponse][google.ads.datamanager.v1.RemoveAudienceMembersResponse].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAudienceMembersRequest {
    /// Required. The list of destinations to remove the users from.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
    /// Required. The list of users to remove.
    #[prost(message, repeated, tag = "2")]
    pub audience_members: ::prost::alloc::vec::Vec<AudienceMember>,
    /// Optional. For testing purposes. If `true`, the request is validated but not
    /// executed. Only errors are returned, not results.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// Optional. Required for [UserData][google.ads.datamanager.v1.UserData]
    /// uploads. The encoding type of the user identifiers. Applies to only the
    /// outer encoding for encrypted user identifiers. For non `UserData` uploads,
    /// this field is ignored.
    #[prost(enumeration = "Encoding", tag = "4")]
    pub encoding: i32,
    /// Optional. Encryption information for
    /// [UserData][google.ads.datamanager.v1.UserData] uploads. If not set, it's
    /// assumed that uploaded identifying information is hashed but not encrypted.
    /// For non `UserData` uploads, this field is ignored.
    #[prost(message, optional, tag = "5")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
}
/// Response from the
/// [RemoveAudienceMembersRequest][google.ads.datamanager.v1.RemoveAudienceMembersRequest].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAudienceMembersResponse {
    /// The auto-generated ID of the request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request to upload audience members to the provided destinations. Returns an
/// [IngestEventsResponse][google.ads.datamanager.v1.IngestEventsResponse].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestEventsRequest {
    /// Required. The list of destinations to send the events to.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<Destination>,
    /// Required. The list of events to send to the specified destinations. At most
    /// 2000 [Event][google.ads.datamanager.v1.Event] resources
    /// can be sent in a single request.
    #[prost(message, repeated, tag = "2")]
    pub events: ::prost::alloc::vec::Vec<Event>,
    /// Optional. Request-level consent to apply to all users in the request.
    /// User-level consent overrides request-level consent, and can be specified in
    /// each [Event][google.ads.datamanager.v1.Event].
    #[prost(message, optional, tag = "3")]
    pub consent: ::core::option::Option<Consent>,
    /// Optional. For testing purposes. If `true`, the request is validated but not
    /// executed. Only errors are returned, not results.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Optional. Required for [UserData][google.ads.datamanager.v1.UserData]
    /// uploads. The encoding type of the user identifiers. For hashed user
    /// identifiers, this is the encoding type of the hashed string. For encrypted
    /// hashed user identifiers, this is the encoding type of the outer encrypted
    /// string, but not necessarily the inner hashed string, meaning the inner
    /// hashed string could be encoded in a different way than the outer encrypted
    /// string. For non `UserData` uploads, this field is ignored.
    #[prost(enumeration = "Encoding", tag = "5")]
    pub encoding: i32,
    /// Optional. Encryption information for
    /// [UserData][google.ads.datamanager.v1.UserData] uploads. If not set, it's
    /// assumed that uploaded identifying information is hashed but not encrypted.
    /// For non `UserData` uploads, this field is ignored.
    #[prost(message, optional, tag = "6")]
    pub encryption_info: ::core::option::Option<EncryptionInfo>,
}
/// Response from the
/// [IngestEventsRequest][google.ads.datamanager.v1.IngestEventsRequest].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestEventsResponse {
    /// The auto-generated ID of the request.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
/// The encoding type of the hashed identifying information.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    /// Unspecified Encoding type. Should never be used.
    Unspecified = 0,
    /// Hex encoding.
    Hex = 1,
    /// Base 64 encoding.
    Base64 = 2,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODING_UNSPECIFIED",
            Self::Hex => "HEX",
            Self::Base64 => "BASE64",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
            "HEX" => Some(Self::Hex),
            "BASE64" => Some(Self::Base64),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod ingestion_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for sending audience data to supported destinations.
    #[derive(Debug, Clone)]
    pub struct IngestionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IngestionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IngestionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IngestionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IngestionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Uploads a list of
        /// [AudienceMember][google.ads.datamanager.v1.AudienceMember] resources to the
        /// provided [Destination][google.ads.datamanager.v1.Destination].
        pub async fn ingest_audience_members(
            &mut self,
            request: impl tonic::IntoRequest<super::IngestAudienceMembersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IngestAudienceMembersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/IngestAudienceMembers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "IngestAudienceMembers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes a list of
        /// [AudienceMember][google.ads.datamanager.v1.AudienceMember] resources from
        /// the provided [Destination][google.ads.datamanager.v1.Destination].
        pub async fn remove_audience_members(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveAudienceMembersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RemoveAudienceMembersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/RemoveAudienceMembers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "RemoveAudienceMembers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Uploads a list of
        /// [Event][google.ads.datamanager.v1.Event] resources from
        /// the provided [Destination][google.ads.datamanager.v1.Destination].
        pub async fn ingest_events(
            &mut self,
            request: impl tonic::IntoRequest<super::IngestEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IngestEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.datamanager.v1.IngestionService/IngestEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.datamanager.v1.IngestionService",
                        "IngestEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
