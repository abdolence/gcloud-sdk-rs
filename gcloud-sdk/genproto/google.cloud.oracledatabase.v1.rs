// This file is @generated by prost-build.
/// The CustomerContact reference as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/CustomerContact>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomerContact {
    /// Required. The email address used by Oracle to send notifications regarding
    /// databases and infrastructure.
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// The identity connector details which will allow OCI to securely access
/// the resources in the customer project.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdentityConnector {
    /// Output only. A google managed service account on which customers can grant
    /// roles to access resources in the customer project. Example:
    /// `p176944527254-55-75119d87fd8f@gcp-sa-oci.iam.gserviceaccount.com`
    #[prost(string, tag = "1")]
    pub service_agent_email: ::prost::alloc::string::String,
    /// Output only. The connection state of the identity connector.
    #[prost(enumeration = "identity_connector::ConnectionState", tag = "2")]
    pub connection_state: i32,
}
/// Nested message and enum types in `IdentityConnector`.
pub mod identity_connector {
    /// The various connection states of the WorkloadIdentityPoolConnection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectionState {
        /// Default unspecified value.
        Unspecified = 0,
        /// The identity pool connection is connected.
        Connected = 1,
        /// The identity pool connection is partially connected.
        PartiallyConnected = 2,
        /// The identity pool connection is disconnected.
        Disconnected = 3,
        /// The identity pool connection is in an unknown state.
        Unknown = 4,
    }
    impl ConnectionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONNECTION_STATE_UNSPECIFIED",
                Self::Connected => "CONNECTED",
                Self::PartiallyConnected => "PARTIALLY_CONNECTED",
                Self::Disconnected => "DISCONNECTED",
                Self::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONNECTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONNECTED" => Some(Self::Connected),
                "PARTIALLY_CONNECTED" => Some(Self::PartiallyConnected),
                "DISCONNECTED" => Some(Self::Disconnected),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
/// Data collection options for diagnostics.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DataCollectionOptions>
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataCollectionOptionsCommon {
    /// Optional. Indicates whether to enable data collection for diagnostics.
    #[prost(bool, tag = "1")]
    pub is_diagnostics_events_enabled: bool,
    /// Optional. Indicates whether to enable health monitoring.
    #[prost(bool, tag = "2")]
    pub is_health_monitoring_enabled: bool,
    /// Optional. Indicates whether to enable incident logs and trace collection.
    #[prost(bool, tag = "3")]
    pub is_incident_logs_enabled: bool,
}
/// The compute model of the Exadata Infrastructure, VM Cluster and Autonomous
/// Database.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComputeModel {
    /// Unspecified compute model.
    Unspecified = 0,
    /// Abstract measure of compute resources. ECPUs are based on the number of
    /// cores elastically allocated from a pool of compute and storage servers.
    Ecpu = 1,
    /// Physical measure of compute resources. OCPUs are based on the physical
    /// core of a processor.
    Ocpu = 2,
}
impl ComputeModel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMPUTE_MODEL_UNSPECIFIED",
            Self::Ecpu => "COMPUTE_MODEL_ECPU",
            Self::Ocpu => "COMPUTE_MODEL_OCPU",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPUTE_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPUTE_MODEL_ECPU" => Some(Self::Ecpu),
            "COMPUTE_MODEL_OCPU" => Some(Self::Ocpu),
            _ => None,
        }
    }
}
/// Details of the Autonomous Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabase/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabase {
    /// Identifier. The name of the Autonomous Database resource in the following
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The name of the Autonomous Database. The database name must be
    /// unique in the project. The name must begin with a letter and can contain a
    /// maximum of 30 alphanumeric characters.
    #[prost(string, tag = "2")]
    pub database: ::prost::alloc::string::String,
    /// Optional. The display name for the Autonomous Database. The name does not
    /// have to be unique within your project.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The ID of the subscription entitlement associated with the
    /// Autonomous Database.
    #[prost(string, tag = "5")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Optional. The password for the default ADMIN user.
    #[prost(string, tag = "6")]
    pub admin_password: ::prost::alloc::string::String,
    /// Optional. The properties of the Autonomous Database.
    #[prost(message, optional, tag = "7")]
    pub properties: ::core::option::Option<AutonomousDatabaseProperties>,
    /// Optional. The labels or tags associated with the Autonomous Database.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The name of the VPC network used by the Autonomous Database in
    /// the following format: projects/{project}/global/networks/{network}
    #[prost(string, tag = "9")]
    pub network: ::prost::alloc::string::String,
    /// Optional. The subnet CIDR range for the Autonomous Database.
    #[prost(string, tag = "10")]
    pub cidr: ::prost::alloc::string::String,
    /// Optional. The name of the OdbNetwork associated with the Autonomous
    /// Database. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network} It is
    /// optional but if specified, this should match the parent ODBNetwork of the
    /// OdbSubnet.
    #[prost(string, tag = "16")]
    pub odb_network: ::prost::alloc::string::String,
    /// Optional. The name of the OdbSubnet associated with the Autonomous
    /// Database. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "17")]
    pub odb_subnet: ::prost::alloc::string::String,
    /// Optional. The source Autonomous Database configuration for the standby
    /// Autonomous Database. The source Autonomous Database is configured while
    /// creating the Peer Autonomous Database and can't be updated after creation.
    #[prost(message, optional, tag = "11")]
    pub source_config: ::core::option::Option<SourceConfig>,
    /// Output only. The peer Autonomous Database names of the given Autonomous
    /// Database.
    #[prost(string, repeated, tag = "12")]
    pub peer_autonomous_databases: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the Autonomous Database was created.
    #[prost(message, optional, tag = "13")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. List of supported GCP region to clone the Autonomous Database
    /// for disaster recovery. Format: `project/{project}/locations/{location}`.
    #[prost(string, repeated, tag = "15")]
    pub disaster_recovery_supported_locations: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// The source configuration for the standby Autonomous Database.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SourceConfig {
    /// Optional. The name of the primary Autonomous Database that is used to
    /// create a Peer Autonomous Database from a source.
    #[prost(string, tag = "1")]
    pub autonomous_database: ::prost::alloc::string::String,
    /// Optional. This field specifies if the replication of automatic backups is
    /// enabled when creating a Data Guard.
    #[prost(bool, tag = "2")]
    pub automatic_backups_replication_enabled: bool,
}
/// The properties of an Autonomous Database.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseProperties {
    /// Output only. OCID of the Autonomous Database.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. The number of compute servers for the Autonomous Database.
    #[prost(float, tag = "2")]
    pub compute_count: f32,
    /// Optional. The number of CPU cores to be made available to the database.
    #[prost(int32, tag = "3")]
    pub cpu_core_count: i32,
    /// Optional. The size of the data stored in the database, in terabytes.
    #[prost(int32, tag = "4")]
    pub data_storage_size_tb: i32,
    /// Optional. The size of the data stored in the database, in gigabytes.
    #[prost(int32, tag = "63")]
    pub data_storage_size_gb: i32,
    /// Required. The workload type of the Autonomous Database.
    #[prost(enumeration = "DbWorkload", tag = "5")]
    pub db_workload: i32,
    /// Optional. The edition of the Autonomous Databases.
    #[prost(enumeration = "autonomous_database_properties::DatabaseEdition", tag = "6")]
    pub db_edition: i32,
    /// Optional. The character set for the Autonomous Database. The default is
    /// AL32UTF8.
    #[prost(string, tag = "8")]
    pub character_set: ::prost::alloc::string::String,
    /// Optional. The national character set for the Autonomous Database. The
    /// default is AL16UTF16.
    #[prost(string, tag = "9")]
    pub n_character_set: ::prost::alloc::string::String,
    /// Optional. The private endpoint IP address for the Autonomous Database.
    #[prost(string, tag = "10")]
    pub private_endpoint_ip: ::prost::alloc::string::String,
    /// Optional. The private endpoint label for the Autonomous Database.
    #[prost(string, tag = "11")]
    pub private_endpoint_label: ::prost::alloc::string::String,
    /// Optional. The Oracle Database version for the Autonomous Database.
    #[prost(string, tag = "12")]
    pub db_version: ::prost::alloc::string::String,
    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database CPU core count.
    #[prost(bool, tag = "14")]
    pub is_auto_scaling_enabled: bool,
    /// Optional. This field indicates if auto scaling is enabled for the
    /// Autonomous Database storage.
    #[prost(bool, tag = "15")]
    pub is_storage_auto_scaling_enabled: bool,
    /// Required. The license type used for the Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::LicenseType", tag = "16")]
    pub license_type: i32,
    /// Optional. The list of customer contacts.
    #[prost(message, repeated, tag = "17")]
    pub customer_contacts: ::prost::alloc::vec::Vec<CustomerContact>,
    /// Optional. The ID of the Oracle Cloud Infrastructure vault secret.
    #[prost(string, tag = "18")]
    pub secret_id: ::prost::alloc::string::String,
    /// Optional. The ID of the Oracle Cloud Infrastructure vault.
    #[prost(string, tag = "19")]
    pub vault_id: ::prost::alloc::string::String,
    /// Optional. The maintenance schedule of the Autonomous Database.
    #[prost(
        enumeration = "autonomous_database_properties::MaintenanceScheduleType",
        tag = "20"
    )]
    pub maintenance_schedule_type: i32,
    /// Optional. This field specifies if the Autonomous Database requires mTLS
    /// connections.
    #[prost(bool, tag = "34")]
    pub mtls_connection_required: bool,
    /// Optional. The retention period for the Autonomous Database. This field is
    /// specified in days, can range from 1 day to 60 days, and has a default value
    /// of 60 days.
    #[prost(int32, tag = "57")]
    pub backup_retention_period_days: i32,
    /// Output only. The amount of storage currently being used for user and system
    /// data, in terabytes.
    #[prost(double, tag = "21")]
    pub actual_used_data_storage_size_tb: f64,
    /// Output only. The amount of storage currently allocated for the database
    /// tables and billed for, rounded up in terabytes.
    #[prost(double, tag = "22")]
    pub allocated_storage_size_tb: f64,
    /// Output only. The details for the Oracle APEX Application Development.
    #[prost(message, optional, tag = "23")]
    pub apex_details: ::core::option::Option<AutonomousDatabaseApex>,
    /// Output only. This field indicates the status of Data Guard and Access
    /// control for the Autonomous Database. The field's value is null if Data
    /// Guard is disabled or Access Control is disabled. The field's value is TRUE
    /// if both Data Guard and Access Control are enabled, and the Autonomous
    /// Database is using primary IP access control list (ACL) for standby. The
    /// field's value is FALSE if both Data Guard and Access Control are enabled,
    /// and the Autonomous Database is using a different IP access control list
    /// (ACL) for standby compared to primary.
    #[prost(bool, optional, tag = "24")]
    pub are_primary_allowlisted_ips_used: ::core::option::Option<bool>,
    /// Output only. The details of the current lifestyle state of the Autonomous
    /// Database.
    #[prost(string, tag = "25")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The current lifecycle state of the Autonomous Database.
    #[prost(enumeration = "State", tag = "26")]
    pub state: i32,
    /// Output only. The Autonomous Container Database OCID.
    #[prost(string, tag = "27")]
    pub autonomous_container_database_id: ::prost::alloc::string::String,
    /// Output only. The list of available Oracle Database upgrade versions for an
    /// Autonomous Database.
    #[prost(string, repeated, tag = "28")]
    pub available_upgrade_versions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The connection strings used to connect to an Autonomous
    /// Database.
    #[prost(message, optional, tag = "29")]
    pub connection_strings: ::core::option::Option<AutonomousDatabaseConnectionStrings>,
    /// Output only. The Oracle Connection URLs for an Autonomous Database.
    #[prost(message, optional, tag = "30")]
    pub connection_urls: ::core::option::Option<AutonomousDatabaseConnectionUrls>,
    /// Output only. This field indicates the number of seconds of data loss during
    /// a Data Guard failover.
    #[prost(message, optional, tag = "31")]
    pub failed_data_recovery_duration: ::core::option::Option<::prost_types::Duration>,
    /// Output only. The memory assigned to in-memory tables in an Autonomous
    /// Database.
    #[prost(int32, tag = "32")]
    pub memory_table_gbs: i32,
    /// Output only. This field indicates whether the Autonomous Database has local
    /// (in-region) Data Guard enabled.
    #[prost(bool, tag = "33")]
    pub is_local_data_guard_enabled: bool,
    /// Output only. This field indicates the maximum data loss limit for an
    /// Autonomous Database, in seconds.
    #[prost(int32, tag = "35")]
    pub local_adg_auto_failover_max_data_loss_limit: i32,
    /// Output only. The details of the Autonomous Data Guard standby database.
    #[prost(message, optional, tag = "36")]
    pub local_standby_db: ::core::option::Option<AutonomousDatabaseStandbySummary>,
    /// Output only. The amount of memory enabled per ECPU, in gigabytes.
    #[prost(int32, tag = "37")]
    pub memory_per_oracle_compute_unit_gbs: i32,
    /// Output only. This field indicates the local disaster recovery (DR) type of
    /// an Autonomous Database.
    #[prost(
        enumeration = "autonomous_database_properties::LocalDisasterRecoveryType",
        tag = "38"
    )]
    pub local_disaster_recovery_type: i32,
    /// Output only. The current state of the Data Safe registration for the
    /// Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::DataSafeState", tag = "39")]
    pub data_safe_state: i32,
    /// Output only. The current state of database management for the Autonomous
    /// Database.
    #[prost(
        enumeration = "autonomous_database_properties::DatabaseManagementState",
        tag = "40"
    )]
    pub database_management_state: i32,
    /// Output only. This field indicates the current mode of the Autonomous
    /// Database.
    #[prost(enumeration = "autonomous_database_properties::OpenMode", tag = "41")]
    pub open_mode: i32,
    /// Output only. This field indicates the state of Operations Insights for the
    /// Autonomous Database.
    #[prost(enumeration = "OperationsInsightsState", tag = "42")]
    pub operations_insights_state: i32,
    /// Output only. The list of OCIDs of standby databases located in Autonomous
    /// Data Guard remote regions that are associated with the source database.
    #[prost(string, repeated, tag = "43")]
    pub peer_db_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The permission level of the Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::PermissionLevel", tag = "44")]
    pub permission_level: i32,
    /// Output only. The private endpoint for the Autonomous Database.
    #[prost(string, tag = "45")]
    pub private_endpoint: ::prost::alloc::string::String,
    /// Output only. The refresh mode of the cloned Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::RefreshableMode", tag = "46")]
    pub refreshable_mode: i32,
    /// Output only. The refresh State of the clone.
    #[prost(
        enumeration = "autonomous_database_properties::RefreshableState",
        tag = "47"
    )]
    pub refreshable_state: i32,
    /// Output only. The Data Guard role of the Autonomous Database.
    #[prost(enumeration = "autonomous_database_properties::Role", tag = "48")]
    pub role: i32,
    /// Output only. The list and details of the scheduled operations of the
    /// Autonomous Database.
    #[prost(message, repeated, tag = "64")]
    pub scheduled_operation_details: ::prost::alloc::vec::Vec<ScheduledOperationDetails>,
    /// Output only. The SQL Web Developer URL for the Autonomous Database.
    #[prost(string, tag = "50")]
    pub sql_web_developer_url: ::prost::alloc::string::String,
    /// Output only. The list of available regions that can be used to create a
    /// clone for the Autonomous Database.
    #[prost(string, repeated, tag = "51")]
    pub supported_clone_regions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The storage space used by Autonomous Database, in gigabytes.
    #[prost(int32, tag = "53")]
    pub used_data_storage_size_tbs: i32,
    /// Output only. The Oracle Cloud Infrastructure link for the Autonomous
    /// Database.
    #[prost(string, tag = "54")]
    pub oci_url: ::prost::alloc::string::String,
    /// Output only. The storage space used by automatic backups of Autonomous
    /// Database, in gigabytes.
    #[prost(float, tag = "59")]
    pub total_auto_backup_storage_size_gbs: f32,
    /// Output only. The long term backup schedule of the Autonomous Database.
    #[prost(message, optional, tag = "60")]
    pub next_long_term_backup_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the Autonomous Data Guard role was changed
    /// for the standby Autonomous Database.
    #[prost(message, optional, tag = "61")]
    pub data_guard_role_changed_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the Disaster Recovery role was changed for
    /// the standby Autonomous Database.
    #[prost(message, optional, tag = "62")]
    pub disaster_recovery_role_changed_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
    /// Output only. The date and time when maintenance will begin.
    #[prost(message, optional, tag = "65")]
    pub maintenance_begin_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time when maintenance will end.
    #[prost(message, optional, tag = "66")]
    pub maintenance_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The list of allowlisted IP addresses for the Autonomous Database.
    #[prost(string, repeated, tag = "67")]
    pub allowlisted_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The encryption key used to encrypt the Autonomous Database.
    /// Updating this field will add a new entry in the
    /// `encryption_key_history_entries` field with the former version.
    #[prost(message, optional, tag = "68")]
    pub encryption_key: ::core::option::Option<EncryptionKey>,
    /// Output only. The history of the encryption keys used to encrypt the
    /// Autonomous Database.
    #[prost(message, repeated, tag = "69")]
    pub encryption_key_history_entries: ::prost::alloc::vec::Vec<
        EncryptionKeyHistoryEntry,
    >,
    /// Output only. An Oracle-managed Google Cloud service account on which
    /// customers can grant roles to access resources in the customer project.
    #[prost(string, tag = "70")]
    pub service_agent_email: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AutonomousDatabaseProperties`.
pub mod autonomous_database_properties {
    /// The editions available for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseEdition {
        /// Default unspecified value.
        Unspecified = 0,
        /// Standard Database Edition
        StandardEdition = 1,
        /// Enterprise Database Edition
        EnterpriseEdition = 2,
    }
    impl DatabaseEdition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATABASE_EDITION_UNSPECIFIED",
                Self::StandardEdition => "STANDARD_EDITION",
                Self::EnterpriseEdition => "ENTERPRISE_EDITION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATABASE_EDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD_EDITION" => Some(Self::StandardEdition),
                "ENTERPRISE_EDITION" => Some(Self::EnterpriseEdition),
                _ => None,
            }
        }
    }
    /// The license types available for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseType {
        /// Unspecified
        Unspecified = 0,
        /// License included part of offer
        LicenseIncluded = 1,
        /// Bring your own license
        BringYourOwnLicense = 2,
    }
    impl LicenseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_TYPE_UNSPECIFIED",
                Self::LicenseIncluded => "LICENSE_INCLUDED",
                Self::BringYourOwnLicense => "BRING_YOUR_OWN_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE_INCLUDED" => Some(Self::LicenseIncluded),
                "BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
                _ => None,
            }
        }
    }
    /// The available maintenance schedules for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenanceScheduleType {
        /// Default unspecified value.
        Unspecified = 0,
        /// An EARLY maintenance schedule patches the database before
        /// the regular scheduled maintenance.
        Early = 1,
        /// A REGULAR maintenance schedule follows the normal maintenance cycle.
        Regular = 2,
    }
    impl MaintenanceScheduleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED",
                Self::Early => "EARLY",
                Self::Regular => "REGULAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MAINTENANCE_SCHEDULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EARLY" => Some(Self::Early),
                "REGULAR" => Some(Self::Regular),
                _ => None,
            }
        }
    }
    /// The types of local disaster recovery available for an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalDisasterRecoveryType {
        /// Default unspecified value.
        Unspecified = 0,
        /// Autonomous Data Guard recovery.
        Adg = 1,
        /// Backup based recovery.
        BackupBased = 2,
    }
    impl LocalDisasterRecoveryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED",
                Self::Adg => "ADG",
                Self::BackupBased => "BACKUP_BASED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCAL_DISASTER_RECOVERY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADG" => Some(Self::Adg),
                "BACKUP_BASED" => Some(Self::BackupBased),
                _ => None,
            }
        }
    }
    /// Varies states of the Data Safe registration for the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataSafeState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Registering data safe state.
        Registering = 1,
        /// Registered data safe state.
        Registered = 2,
        /// Deregistering data safe state.
        Deregistering = 3,
        /// Not registered data safe state.
        NotRegistered = 4,
        /// Failed data safe state.
        Failed = 5,
    }
    impl DataSafeState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATA_SAFE_STATE_UNSPECIFIED",
                Self::Registering => "REGISTERING",
                Self::Registered => "REGISTERED",
                Self::Deregistering => "DEREGISTERING",
                Self::NotRegistered => "NOT_REGISTERED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_SAFE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REGISTERING" => Some(Self::Registering),
                "REGISTERED" => Some(Self::Registered),
                "DEREGISTERING" => Some(Self::Deregistering),
                "NOT_REGISTERED" => Some(Self::NotRegistered),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// The different states of database management for an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseManagementState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Enabling Database Management state
        Enabling = 1,
        /// Enabled Database Management state
        Enabled = 2,
        /// Disabling Database Management state
        Disabling = 3,
        /// Not Enabled Database Management state
        NotEnabled = 4,
        /// Failed enabling Database Management state
        FailedEnabling = 5,
        /// Failed disabling Database Management state
        FailedDisabling = 6,
    }
    impl DatabaseManagementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATABASE_MANAGEMENT_STATE_UNSPECIFIED",
                Self::Enabling => "ENABLING",
                Self::Enabled => "ENABLED",
                Self::Disabling => "DISABLING",
                Self::NotEnabled => "NOT_ENABLED",
                Self::FailedEnabling => "FAILED_ENABLING",
                Self::FailedDisabling => "FAILED_DISABLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATABASE_MANAGEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLING" => Some(Self::Enabling),
                "ENABLED" => Some(Self::Enabled),
                "DISABLING" => Some(Self::Disabling),
                "NOT_ENABLED" => Some(Self::NotEnabled),
                "FAILED_ENABLING" => Some(Self::FailedEnabling),
                "FAILED_DISABLING" => Some(Self::FailedDisabling),
                _ => None,
            }
        }
    }
    /// This field indicates the modes of an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OpenMode {
        /// Default unspecified value.
        Unspecified = 0,
        /// Read Only Mode
        ReadOnly = 1,
        /// Read Write Mode
        ReadWrite = 2,
    }
    impl OpenMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPEN_MODE_UNSPECIFIED",
                Self::ReadOnly => "READ_ONLY",
                Self::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPEN_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    /// The types of permission levels for an Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PermissionLevel {
        /// Default unspecified value.
        Unspecified = 0,
        /// Restricted mode allows access only by admin users.
        Restricted = 1,
        /// Normal access.
        Unrestricted = 2,
    }
    impl PermissionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PERMISSION_LEVEL_UNSPECIFIED",
                Self::Restricted => "RESTRICTED",
                Self::Unrestricted => "UNRESTRICTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERMISSION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "RESTRICTED" => Some(Self::Restricted),
                "UNRESTRICTED" => Some(Self::Unrestricted),
                _ => None,
            }
        }
    }
    /// The refresh mode of the cloned Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RefreshableMode {
        /// The default unspecified value.
        Unspecified = 0,
        /// AUTOMATIC indicates that the cloned database is automatically
        /// refreshed with data from the source Autonomous Database.
        Automatic = 1,
        /// MANUAL indicates that the cloned database is manually refreshed with
        /// data from the source Autonomous Database.
        Manual = 2,
    }
    impl RefreshableMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REFRESHABLE_MODE_UNSPECIFIED",
                Self::Automatic => "AUTOMATIC",
                Self::Manual => "MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFRESHABLE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOMATIC" => Some(Self::Automatic),
                "MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
    /// The refresh state of the cloned Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RefreshableState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Refreshing
        Refreshing = 1,
        /// Not refreshed
        NotRefreshing = 2,
    }
    impl RefreshableState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REFRESHABLE_STATE_UNSPECIFIED",
                Self::Refreshing => "REFRESHING",
                Self::NotRefreshing => "NOT_REFRESHING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REFRESHABLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "REFRESHING" => Some(Self::Refreshing),
                "NOT_REFRESHING" => Some(Self::NotRefreshing),
                _ => None,
            }
        }
    }
    /// The Data Guard role of the Autonomous Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        /// Default unspecified value.
        Unspecified = 0,
        /// Primary role
        Primary = 1,
        /// Standby role
        Standby = 2,
        /// Disabled standby role
        DisabledStandby = 3,
        /// Backup copy role
        BackupCopy = 4,
        /// Snapshot standby role
        SnapshotStandby = 5,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ROLE_UNSPECIFIED",
                Self::Primary => "PRIMARY",
                Self::Standby => "STANDBY",
                Self::DisabledStandby => "DISABLED_STANDBY",
                Self::BackupCopy => "BACKUP_COPY",
                Self::SnapshotStandby => "SNAPSHOT_STANDBY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
                "PRIMARY" => Some(Self::Primary),
                "STANDBY" => Some(Self::Standby),
                "DISABLED_STANDBY" => Some(Self::DisabledStandby),
                "BACKUP_COPY" => Some(Self::BackupCopy),
                "SNAPSHOT_STANDBY" => Some(Self::SnapshotStandby),
                _ => None,
            }
        }
    }
}
/// The history of the encryption keys used to encrypt the Autonomous Database.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptionKeyHistoryEntry {
    /// Output only. The encryption key used to encrypt the Autonomous Database.
    #[prost(message, optional, tag = "1")]
    pub encryption_key: ::core::option::Option<EncryptionKey>,
    /// Output only. The date and time when the encryption key was activated on the
    /// Autonomous Database..
    #[prost(message, optional, tag = "2")]
    pub activation_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The encryption key used to encrypt the Autonomous Database.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptionKey {
    /// Optional. The provider of the encryption key.
    #[prost(enumeration = "encryption_key::Provider", tag = "1")]
    pub provider: i32,
    /// Optional. The KMS key used to encrypt the Autonomous Database.
    /// This field is required if the provider is GOOGLE_MANAGED.
    /// The name of the KMS key resource in the following format:
    /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
    #[prost(string, tag = "2")]
    pub kms_key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `EncryptionKey`.
pub mod encryption_key {
    /// The provider of the encryption key.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Provider {
        /// Default unspecified value.
        Unspecified = 0,
        /// Google Managed KMS key, if selected, please provide the KMS key name.
        GoogleManaged = 1,
        /// Oracle Managed.
        OracleManaged = 2,
    }
    impl Provider {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVIDER_UNSPECIFIED",
                Self::GoogleManaged => "GOOGLE_MANAGED",
                Self::OracleManaged => "ORACLE_MANAGED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_MANAGED" => Some(Self::GoogleManaged),
                "ORACLE_MANAGED" => Some(Self::OracleManaged),
                _ => None,
            }
        }
    }
}
/// Oracle APEX Application Development.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseApex>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutonomousDatabaseApex {
    /// Output only. The Oracle APEX Application Development version.
    #[prost(string, tag = "1")]
    pub apex_version: ::prost::alloc::string::String,
    /// Output only. The Oracle REST Data Services (ORDS) version.
    #[prost(string, tag = "2")]
    pub ords_version: ::prost::alloc::string::String,
}
/// The connection string used to connect to the Autonomous Database.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionStrings>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseConnectionStrings {
    /// Output only. Returns all connection strings that can be used to connect to
    /// the Autonomous Database.
    #[prost(message, optional, tag = "1")]
    pub all_connection_strings: ::core::option::Option<AllConnectionStrings>,
    /// Output only. The database service provides the least level of resources to
    /// each SQL statement, but supports the most number of concurrent SQL
    /// statements.
    #[prost(string, tag = "2")]
    pub dedicated: ::prost::alloc::string::String,
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[prost(string, tag = "3")]
    pub high: ::prost::alloc::string::String,
    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[prost(string, tag = "4")]
    pub low: ::prost::alloc::string::String,
    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[prost(string, tag = "5")]
    pub medium: ::prost::alloc::string::String,
    /// Output only. A list of connection string profiles to allow clients to
    /// group, filter, and select values based on the structured metadata.
    #[prost(message, repeated, tag = "6")]
    pub profiles: ::prost::alloc::vec::Vec<DatabaseConnectionStringProfile>,
}
/// The connection string profile to allow clients to group.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/DatabaseConnectionStringProfile>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseConnectionStringProfile {
    /// Output only. The current consumer group being used by the connection.
    #[prost(
        enumeration = "database_connection_string_profile::ConsumerGroup",
        tag = "1"
    )]
    pub consumer_group: i32,
    /// Output only. The display name for the database connection.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The host name format being currently used in connection
    /// string.
    #[prost(enumeration = "database_connection_string_profile::HostFormat", tag = "3")]
    pub host_format: i32,
    /// Output only. This field indicates if the connection string is regional and
    /// is only applicable for cross-region Data Guard.
    #[prost(bool, tag = "4")]
    pub is_regional: bool,
    /// Output only. The protocol being used by the connection.
    #[prost(enumeration = "database_connection_string_profile::Protocol", tag = "5")]
    pub protocol: i32,
    /// Output only. The current session mode of the connection.
    #[prost(enumeration = "database_connection_string_profile::SessionMode", tag = "6")]
    pub session_mode: i32,
    /// Output only. The syntax of the connection string.
    #[prost(enumeration = "database_connection_string_profile::SyntaxFormat", tag = "7")]
    pub syntax_format: i32,
    /// Output only. This field indicates the TLS authentication type of the
    /// connection.
    #[prost(
        enumeration = "database_connection_string_profile::TlsAuthentication",
        tag = "8"
    )]
    pub tls_authentication: i32,
    /// Output only. The value of the connection string.
    #[prost(string, tag = "9")]
    pub value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DatabaseConnectionStringProfile`.
pub mod database_connection_string_profile {
    /// The various consumer groups available in the connection string profile.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConsumerGroup {
        /// Default unspecified value.
        Unspecified = 0,
        /// High consumer group.
        High = 1,
        /// Medium consumer group.
        Medium = 2,
        /// Low consumer group.
        Low = 3,
        /// TP consumer group.
        Tp = 4,
        /// TPURGENT consumer group.
        Tpurgent = 5,
    }
    impl ConsumerGroup {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONSUMER_GROUP_UNSPECIFIED",
                Self::High => "HIGH",
                Self::Medium => "MEDIUM",
                Self::Low => "LOW",
                Self::Tp => "TP",
                Self::Tpurgent => "TPURGENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONSUMER_GROUP_UNSPECIFIED" => Some(Self::Unspecified),
                "HIGH" => Some(Self::High),
                "MEDIUM" => Some(Self::Medium),
                "LOW" => Some(Self::Low),
                "TP" => Some(Self::Tp),
                "TPURGENT" => Some(Self::Tpurgent),
                _ => None,
            }
        }
    }
    /// The host name format being used in the connection string.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HostFormat {
        /// Default unspecified value.
        Unspecified = 0,
        /// FQDN
        Fqdn = 1,
        /// IP
        Ip = 2,
    }
    impl HostFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HOST_FORMAT_UNSPECIFIED",
                Self::Fqdn => "FQDN",
                Self::Ip => "IP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HOST_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "FQDN" => Some(Self::Fqdn),
                "IP" => Some(Self::Ip),
                _ => None,
            }
        }
    }
    /// The protocol being used by the connection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        /// Default unspecified value.
        Unspecified = 0,
        /// Tcp
        Tcp = 1,
        /// Tcps
        Tcps = 2,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROTOCOL_UNSPECIFIED",
                Self::Tcp => "TCP",
                Self::Tcps => "TCPS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
                "TCP" => Some(Self::Tcp),
                "TCPS" => Some(Self::Tcps),
                _ => None,
            }
        }
    }
    /// The session mode of the connection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionMode {
        /// Default unspecified value.
        Unspecified = 0,
        /// Direct
        Direct = 1,
        /// Indirect
        Indirect = 2,
    }
    impl SessionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SESSION_MODE_UNSPECIFIED",
                Self::Direct => "DIRECT",
                Self::Indirect => "INDIRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SESSION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DIRECT" => Some(Self::Direct),
                "INDIRECT" => Some(Self::Indirect),
                _ => None,
            }
        }
    }
    /// Specifies syntax of the connection string.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SyntaxFormat {
        /// Default unspecified value.
        Unspecified = 0,
        /// Long
        Long = 1,
        /// Ezconnect
        Ezconnect = 2,
        /// Ezconnectplus
        Ezconnectplus = 3,
    }
    impl SyntaxFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYNTAX_FORMAT_UNSPECIFIED",
                Self::Long => "LONG",
                Self::Ezconnect => "EZCONNECT",
                Self::Ezconnectplus => "EZCONNECTPLUS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYNTAX_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "LONG" => Some(Self::Long),
                "EZCONNECT" => Some(Self::Ezconnect),
                "EZCONNECTPLUS" => Some(Self::Ezconnectplus),
                _ => None,
            }
        }
    }
    /// This field indicates the TLS authentication type of the connection.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TlsAuthentication {
        /// Default unspecified value.
        Unspecified = 0,
        /// Server
        Server = 1,
        /// Mutual
        Mutual = 2,
    }
    impl TlsAuthentication {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TLS_AUTHENTICATION_UNSPECIFIED",
                Self::Server => "SERVER",
                Self::Mutual => "MUTUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TLS_AUTHENTICATION_UNSPECIFIED" => Some(Self::Unspecified),
                "SERVER" => Some(Self::Server),
                "MUTUAL" => Some(Self::Mutual),
                _ => None,
            }
        }
    }
}
/// A list of all connection strings that can be used to connect to the
/// Autonomous Database.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AllConnectionStrings {
    /// Output only. The database service provides the highest level of resources
    /// to each SQL statement.
    #[prost(string, tag = "1")]
    pub high: ::prost::alloc::string::String,
    /// Output only. The database service provides the least level of resources to
    /// each SQL statement.
    #[prost(string, tag = "2")]
    pub low: ::prost::alloc::string::String,
    /// Output only. The database service provides a lower level of resources to
    /// each SQL statement.
    #[prost(string, tag = "3")]
    pub medium: ::prost::alloc::string::String,
}
/// The URLs for accessing Oracle Application Express (APEX) and SQL Developer
/// Web with a browser from a Compute instance.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseConnectionUrls>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutonomousDatabaseConnectionUrls {
    /// Output only. Oracle Application Express (APEX) URL.
    #[prost(string, tag = "1")]
    pub apex_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Database Transforms for the Autonomous
    /// Database.
    #[prost(string, tag = "2")]
    pub database_transforms_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Graph Studio for the Autonomous Database.
    #[prost(string, tag = "3")]
    pub graph_studio_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Oracle Machine Learning (OML) Notebook for the
    /// Autonomous Database.
    #[prost(string, tag = "4")]
    pub machine_learning_notebook_uri: ::prost::alloc::string::String,
    /// Output only. The URL of Machine Learning user management the Autonomous
    /// Database.
    #[prost(string, tag = "5")]
    pub machine_learning_user_management_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the MongoDB API for the Autonomous Database.
    #[prost(string, tag = "6")]
    pub mongo_db_uri: ::prost::alloc::string::String,
    /// Output only. The Oracle REST Data Services (ORDS) URL of the Web Access for
    /// the Autonomous Database.
    #[prost(string, tag = "7")]
    pub ords_uri: ::prost::alloc::string::String,
    /// Output only. The URL of the Oracle SQL Developer Web for the Autonomous
    /// Database.
    #[prost(string, tag = "8")]
    pub sql_dev_web_uri: ::prost::alloc::string::String,
}
/// Autonomous Data Guard standby database details.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/AutonomousDatabaseStandbySummary>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutonomousDatabaseStandbySummary {
    /// Output only. The amount of time, in seconds, that the data of the standby
    /// database lags in comparison to the data of the primary database.
    #[prost(message, optional, tag = "1")]
    pub lag_time_duration: ::core::option::Option<::prost_types::Duration>,
    /// Output only. The additional details about the current lifecycle state of
    /// the Autonomous Database.
    #[prost(string, tag = "2")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The current lifecycle state of the Autonomous Database.
    #[prost(enumeration = "State", tag = "3")]
    pub state: i32,
    /// Output only. The date and time the Autonomous Data Guard role was switched
    /// for the standby Autonomous Database.
    #[prost(message, optional, tag = "4")]
    pub data_guard_role_changed_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the Disaster Recovery role was switched for
    /// the standby Autonomous Database.
    #[prost(message, optional, tag = "5")]
    pub disaster_recovery_role_changed_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
}
/// Details of scheduled operation.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/ScheduledOperationDetails>
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScheduledOperationDetails {
    /// Output only. Day of week.
    #[prost(enumeration = "super::super::super::r#type::DayOfWeek", tag = "1")]
    pub day_of_week: i32,
    /// Output only. Auto start time.
    #[prost(message, optional, tag = "4")]
    pub start_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
    /// Output only. Auto stop time.
    #[prost(message, optional, tag = "5")]
    pub stop_time: ::core::option::Option<super::super::super::r#type::TimeOfDay>,
}
/// The type of wallet generation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GenerateType {
    /// Default unspecified value.
    Unspecified = 0,
    /// Used to generate wallet for all databases in the region.
    All = 1,
    /// Used to generate wallet for a single database.
    Single = 2,
}
impl GenerateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GENERATE_TYPE_UNSPECIFIED",
            Self::All => "ALL",
            Self::Single => "SINGLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GENERATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ALL" => Some(Self::All),
            "SINGLE" => Some(Self::Single),
            _ => None,
        }
    }
}
/// The various lifecycle states of the Autonomous Database.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// Default unspecified value.
    Unspecified = 0,
    /// Indicates that the Autonomous Database is in provisioning state.
    Provisioning = 1,
    /// Indicates that the Autonomous Database is in available state.
    Available = 2,
    /// Indicates that the Autonomous Database is in stopping state.
    Stopping = 3,
    /// Indicates that the Autonomous Database is in stopped state.
    Stopped = 4,
    /// Indicates that the Autonomous Database is in starting state.
    Starting = 5,
    /// Indicates that the Autonomous Database is in terminating state.
    Terminating = 6,
    /// Indicates that the Autonomous Database is in terminated state.
    Terminated = 7,
    /// Indicates that the Autonomous Database is in unavailable state.
    Unavailable = 8,
    /// Indicates that the Autonomous Database restore is in progress.
    RestoreInProgress = 9,
    /// Indicates that the Autonomous Database failed to restore.
    RestoreFailed = 10,
    /// Indicates that the Autonomous Database backup is in progress.
    BackupInProgress = 11,
    /// Indicates that the Autonomous Database scale is in progress.
    ScaleInProgress = 12,
    /// Indicates that the Autonomous Database is available but needs attention
    /// state.
    AvailableNeedsAttention = 13,
    /// Indicates that the Autonomous Database is in updating state.
    Updating = 14,
    /// Indicates that the Autonomous Database's maintenance is in progress state.
    MaintenanceInProgress = 15,
    /// Indicates that the Autonomous Database is in restarting state.
    Restarting = 16,
    /// Indicates that the Autonomous Database is in recreating state.
    Recreating = 17,
    /// Indicates that the Autonomous Database's role change is in progress state.
    RoleChangeInProgress = 18,
    /// Indicates that the Autonomous Database is in upgrading state.
    Upgrading = 19,
    /// Indicates that the Autonomous Database is in inaccessible state.
    Inaccessible = 20,
    /// Indicates that the Autonomous Database is in standby state.
    Standby = 21,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::Provisioning => "PROVISIONING",
            Self::Available => "AVAILABLE",
            Self::Stopping => "STOPPING",
            Self::Stopped => "STOPPED",
            Self::Starting => "STARTING",
            Self::Terminating => "TERMINATING",
            Self::Terminated => "TERMINATED",
            Self::Unavailable => "UNAVAILABLE",
            Self::RestoreInProgress => "RESTORE_IN_PROGRESS",
            Self::RestoreFailed => "RESTORE_FAILED",
            Self::BackupInProgress => "BACKUP_IN_PROGRESS",
            Self::ScaleInProgress => "SCALE_IN_PROGRESS",
            Self::AvailableNeedsAttention => "AVAILABLE_NEEDS_ATTENTION",
            Self::Updating => "UPDATING",
            Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            Self::Restarting => "RESTARTING",
            Self::Recreating => "RECREATING",
            Self::RoleChangeInProgress => "ROLE_CHANGE_IN_PROGRESS",
            Self::Upgrading => "UPGRADING",
            Self::Inaccessible => "INACCESSIBLE",
            Self::Standby => "STANDBY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROVISIONING" => Some(Self::Provisioning),
            "AVAILABLE" => Some(Self::Available),
            "STOPPING" => Some(Self::Stopping),
            "STOPPED" => Some(Self::Stopped),
            "STARTING" => Some(Self::Starting),
            "TERMINATING" => Some(Self::Terminating),
            "TERMINATED" => Some(Self::Terminated),
            "UNAVAILABLE" => Some(Self::Unavailable),
            "RESTORE_IN_PROGRESS" => Some(Self::RestoreInProgress),
            "RESTORE_FAILED" => Some(Self::RestoreFailed),
            "BACKUP_IN_PROGRESS" => Some(Self::BackupInProgress),
            "SCALE_IN_PROGRESS" => Some(Self::ScaleInProgress),
            "AVAILABLE_NEEDS_ATTENTION" => Some(Self::AvailableNeedsAttention),
            "UPDATING" => Some(Self::Updating),
            "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
            "RESTARTING" => Some(Self::Restarting),
            "RECREATING" => Some(Self::Recreating),
            "ROLE_CHANGE_IN_PROGRESS" => Some(Self::RoleChangeInProgress),
            "UPGRADING" => Some(Self::Upgrading),
            "INACCESSIBLE" => Some(Self::Inaccessible),
            "STANDBY" => Some(Self::Standby),
            _ => None,
        }
    }
}
/// The state of the Operations Insights for this Autonomous Database.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationsInsightsState {
    /// Default unspecified value.
    Unspecified = 0,
    /// Enabling status for operation insights.
    Enabling = 1,
    /// Enabled status for operation insights.
    Enabled = 2,
    /// Disabling status for operation insights.
    Disabling = 3,
    /// Not Enabled status for operation insights.
    NotEnabled = 4,
    /// Failed enabling status for operation insights.
    FailedEnabling = 5,
    /// Failed disabling status for operation insights.
    FailedDisabling = 6,
}
impl OperationsInsightsState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED",
            Self::Enabling => "ENABLING",
            Self::Enabled => "ENABLED",
            Self::Disabling => "DISABLING",
            Self::NotEnabled => "NOT_ENABLED",
            Self::FailedEnabling => "FAILED_ENABLING",
            Self::FailedDisabling => "FAILED_DISABLING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENABLING" => Some(Self::Enabling),
            "ENABLED" => Some(Self::Enabled),
            "DISABLING" => Some(Self::Disabling),
            "NOT_ENABLED" => Some(Self::NotEnabled),
            "FAILED_ENABLING" => Some(Self::FailedEnabling),
            "FAILED_DISABLING" => Some(Self::FailedDisabling),
            _ => None,
        }
    }
}
/// The various states available for the Autonomous Database workload type.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DbWorkload {
    /// Default unspecified value.
    Unspecified = 0,
    /// Autonomous Transaction Processing database.
    Oltp = 1,
    /// Autonomous Data Warehouse database.
    Dw = 2,
    /// Autonomous JSON Database.
    Ajd = 3,
    /// Autonomous Database with the Oracle APEX Application Development workload
    /// type.
    Apex = 4,
}
impl DbWorkload {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DB_WORKLOAD_UNSPECIFIED",
            Self::Oltp => "OLTP",
            Self::Dw => "DW",
            Self::Ajd => "AJD",
            Self::Apex => "APEX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DB_WORKLOAD_UNSPECIFIED" => Some(Self::Unspecified),
            "OLTP" => Some(Self::Oltp),
            "DW" => Some(Self::Dw),
            "AJD" => Some(Self::Ajd),
            "APEX" => Some(Self::Apex),
            _ => None,
        }
    }
}
/// Details of the Autonomous Database character set resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseCharacterSets/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutonomousDatabaseCharacterSet {
    /// Identifier. The name of the Autonomous Database Character Set resource in
    /// the following format:
    /// projects/{project}/locations/{region}/autonomousDatabaseCharacterSets/{autonomous_database_character_set}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The character set type for the Autonomous Database.
    #[prost(
        enumeration = "autonomous_database_character_set::CharacterSetType",
        tag = "2"
    )]
    pub character_set_type: i32,
    /// Output only. The character set name for the Autonomous Database which is
    /// the ID in the resource name.
    #[prost(string, tag = "3")]
    pub character_set: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AutonomousDatabaseCharacterSet`.
pub mod autonomous_database_character_set {
    /// The type of character set an Autonomous Database can have.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified = 0,
        /// Character set type is set to database.
        Database = 1,
        /// Character set type is set to national.
        National = 2,
    }
    impl CharacterSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CHARACTER_SET_TYPE_UNSPECIFIED",
                Self::Database => "DATABASE",
                Self::National => "NATIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATABASE" => Some(Self::Database),
                "NATIONAL" => Some(Self::National),
                _ => None,
            }
        }
    }
}
/// Details of the Autonomous Database Backup resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDatabaseBackup/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseBackup {
    /// Identifier. The name of the Autonomous Database Backup resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDatabaseBackups/{autonomous_database_backup}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the Autonomous Database resource for which the backup
    /// is being created. Format:
    /// projects/{project}/locations/{region}/autonomousDatabases/{autonomous_database}
    #[prost(string, tag = "2")]
    pub autonomous_database: ::prost::alloc::string::String,
    /// Optional. User friendly name for the Backup. The name does not have to be
    /// unique.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Various properties of the backup.
    #[prost(message, optional, tag = "4")]
    pub properties: ::core::option::Option<AutonomousDatabaseBackupProperties>,
    /// Optional. labels or tags associated with the resource.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Properties of the Autonomous Database Backup resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutonomousDatabaseBackupProperties {
    /// Output only. OCID of the Autonomous Database backup.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. Retention period in days for the backup.
    #[prost(int32, tag = "2")]
    pub retention_period_days: i32,
    /// Output only. The OCID of the compartment.
    #[prost(string, tag = "3")]
    pub compartment_id: ::prost::alloc::string::String,
    /// Output only. The quantity of data in the database, in terabytes.
    #[prost(float, tag = "4")]
    pub database_size_tb: f32,
    /// Output only. A valid Oracle Database version for Autonomous Database.
    #[prost(string, tag = "5")]
    pub db_version: ::prost::alloc::string::String,
    /// Output only. Indicates if the backup is long term backup.
    #[prost(bool, tag = "6")]
    pub is_long_term_backup: bool,
    /// Output only. Indicates if the backup is automatic or user initiated.
    #[prost(bool, tag = "7")]
    pub is_automatic_backup: bool,
    /// Output only. Indicates if the backup can be used to restore the Autonomous
    /// Database.
    #[prost(bool, tag = "8")]
    pub is_restorable: bool,
    /// Optional. The OCID of the key store of Oracle Vault.
    #[prost(string, tag = "9")]
    pub key_store_id: ::prost::alloc::string::String,
    /// Optional. The wallet name for Oracle Key Vault.
    #[prost(string, tag = "10")]
    pub key_store_wallet: ::prost::alloc::string::String,
    /// Optional. The OCID of the key container that is used as the master
    /// encryption key in database transparent data encryption (TDE) operations.
    #[prost(string, tag = "11")]
    pub kms_key_id: ::prost::alloc::string::String,
    /// Optional. The OCID of the key container version that is used in database
    /// transparent data encryption (TDE) operations KMS Key can have multiple key
    /// versions. If none is specified, the current key version (latest) of the Key
    /// Id is used for the operation. Autonomous Database Serverless does not use
    /// key versions, hence is not applicable for Autonomous Database Serverless
    /// instances.
    #[prost(string, tag = "12")]
    pub kms_key_version_id: ::prost::alloc::string::String,
    /// Output only. Additional information about the current lifecycle state.
    #[prost(string, tag = "13")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The lifecycle state of the backup.
    #[prost(enumeration = "autonomous_database_backup_properties::State", tag = "14")]
    pub lifecycle_state: i32,
    /// Output only. The backup size in terabytes.
    #[prost(float, tag = "15")]
    pub size_tb: f32,
    /// Output only. Timestamp until when the backup will be available.
    #[prost(message, optional, tag = "16")]
    pub available_till_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the backup completed.
    #[prost(message, optional, tag = "17")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The date and time the backup started.
    #[prost(message, optional, tag = "18")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The type of the backup.
    #[prost(enumeration = "autonomous_database_backup_properties::Type", tag = "19")]
    pub r#type: i32,
    /// Optional. The OCID of the vault.
    #[prost(string, tag = "20")]
    pub vault_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AutonomousDatabaseBackupProperties`.
pub mod autonomous_database_backup_properties {
    /// // The various lifecycle states of the Autonomous Database Backup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in creating state.
        Creating = 1,
        /// Indicates that the resource is in active state.
        Active = 2,
        /// Indicates that the resource is in deleting state.
        Deleting = 3,
        /// Indicates that the resource is in deleted state.
        Deleted = 4,
        /// Indicates that the resource is in failed state.
        Failed = 6,
        /// Indicates that the resource is in updating state.
        Updating = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Deleting => "DELETING",
                Self::Deleted => "DELETED",
                Self::Failed => "FAILED",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                "FAILED" => Some(Self::Failed),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
    /// The type of the backup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Default unspecified value.
        Unspecified = 0,
        /// Incremental backups.
        Incremental = 1,
        /// Full backups.
        Full = 2,
        /// Long term backups.
        LongTerm = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Incremental => "INCREMENTAL",
                Self::Full => "FULL",
                Self::LongTerm => "LONG_TERM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCREMENTAL" => Some(Self::Incremental),
                "FULL" => Some(Self::Full),
                "LONG_TERM" => Some(Self::LongTerm),
                _ => None,
            }
        }
    }
}
/// Details of the Autonomous Database version.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/AutonomousDbVersionSummary/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AutonomousDbVersion {
    /// Identifier. The name of the Autonomous Database Version resource with the
    /// format:
    /// projects/{project}/locations/{region}/autonomousDbVersions/{autonomous_db_version}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. An Oracle Database version for Autonomous Database.
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
    /// Output only. The Autonomous Database workload type.
    #[prost(enumeration = "DbWorkload", tag = "4")]
    pub db_workload: i32,
    /// Output only. A URL that points to a detailed description of the Autonomous
    /// Database version.
    #[prost(string, tag = "5")]
    pub workload_uri: ::prost::alloc::string::String,
}
/// The PluggableDatabase resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/PluggableDatabase/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluggableDatabase {
    /// Identifier. The name of the PluggableDatabase resource in the following
    /// format:
    /// projects/{project}/locations/{region}/pluggableDatabases/{pluggable_database}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The properties of the PluggableDatabase.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<PluggableDatabaseProperties>,
    /// Output only. HTTPS link to OCI resources exposed to Customer via UI
    /// Interface.
    #[prost(string, tag = "3")]
    pub oci_url: ::prost::alloc::string::String,
    /// Output only. The date and time that the PluggableDatabase was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The properties of a PluggableDatabase.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluggableDatabaseProperties {
    /// Required. The OCID of the compartment.
    #[prost(string, tag = "1")]
    pub compartment_id: ::prost::alloc::string::String,
    /// Optional. The Connection strings used to connect to the Oracle Database.
    #[prost(message, optional, tag = "2")]
    pub connection_strings: ::core::option::Option<PluggableDatabaseConnectionStrings>,
    /// Required. The OCID of the CDB.
    #[prost(string, tag = "3")]
    pub container_database_ocid: ::prost::alloc::string::String,
    /// Optional. Defined tags for this resource. Each key is predefined and scoped
    /// to a namespace.
    #[prost(map = "string, message", tag = "4")]
    pub defined_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        pluggable_database_properties::DefinedTagValue,
    >,
    /// Optional. Free-form tags for this resource. Each tag is a simple key-value
    /// pair with no predefined name, type, or namespace.
    #[prost(map = "string, string", tag = "5")]
    pub freeform_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The OCID of the pluggable database.
    #[prost(string, tag = "6")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. The restricted mode of the pluggable database. If a pluggable
    /// database is opened in restricted mode, the user needs both create a session
    /// and have restricted session privileges to connect to it.
    #[prost(bool, tag = "7")]
    pub is_restricted: bool,
    /// Output only. Additional information about the current lifecycle state.
    #[prost(string, tag = "8")]
    pub lifecycle_details: ::prost::alloc::string::String,
    /// Output only. The current state of the pluggable database.
    #[prost(
        enumeration = "pluggable_database_properties::PluggableDatabaseLifecycleState",
        tag = "9"
    )]
    pub lifecycle_state: i32,
    /// Required. The database name.
    #[prost(string, tag = "10")]
    pub pdb_name: ::prost::alloc::string::String,
    /// Optional. Pluggable Database Node Level Details
    #[prost(message, repeated, tag = "11")]
    pub pdb_node_level_details: ::prost::alloc::vec::Vec<
        PluggableDatabaseNodeLevelDetails,
    >,
    /// Output only. The configuration of the Database Management service.
    #[prost(message, optional, tag = "13")]
    pub database_management_config: ::core::option::Option<DatabaseManagementConfig>,
    /// Output only. The status of Operations Insights for this Database.
    #[prost(
        enumeration = "pluggable_database_properties::OperationsInsightsState",
        tag = "14"
    )]
    pub operations_insights_state: i32,
}
/// Nested message and enum types in `PluggableDatabaseProperties`.
pub mod pluggable_database_properties {
    /// Wrapper message for the value of a defined tag.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DefinedTagValue {
        /// The tags within the namespace.
        #[prost(map = "string, string", tag = "1")]
        pub tags: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    /// The various lifecycle states of the PluggableDatabase.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PluggableDatabaseLifecycleState {
        /// The lifecycle state is unspecified.
        Unspecified = 0,
        /// The pluggable database is provisioning.
        Provisioning = 1,
        /// The pluggable database is available.
        Available = 2,
        /// The pluggable database is terminating.
        Terminating = 3,
        /// The pluggable database is terminated.
        Terminated = 4,
        /// The pluggable database is updating.
        Updating = 5,
        /// The pluggable database is in a failed state.
        Failed = 6,
        /// The pluggable database is relocating.
        Relocating = 7,
        /// The pluggable database is relocated.
        Relocated = 8,
        /// The pluggable database is refreshing.
        Refreshing = 9,
        /// The pluggable database is restoring.
        RestoreInProgress = 10,
        /// The pluggable database restore failed.
        RestoreFailed = 11,
        /// The pluggable database is backing up.
        BackupInProgress = 12,
        /// The pluggable database is disabled.
        Disabled = 13,
    }
    impl PluggableDatabaseLifecycleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PLUGGABLE_DATABASE_LIFECYCLE_STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Updating => "UPDATING",
                Self::Failed => "FAILED",
                Self::Relocating => "RELOCATING",
                Self::Relocated => "RELOCATED",
                Self::Refreshing => "REFRESHING",
                Self::RestoreInProgress => "RESTORE_IN_PROGRESS",
                Self::RestoreFailed => "RESTORE_FAILED",
                Self::BackupInProgress => "BACKUP_IN_PROGRESS",
                Self::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLUGGABLE_DATABASE_LIFECYCLE_STATE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "UPDATING" => Some(Self::Updating),
                "FAILED" => Some(Self::Failed),
                "RELOCATING" => Some(Self::Relocating),
                "RELOCATED" => Some(Self::Relocated),
                "REFRESHING" => Some(Self::Refreshing),
                "RESTORE_IN_PROGRESS" => Some(Self::RestoreInProgress),
                "RESTORE_FAILED" => Some(Self::RestoreFailed),
                "BACKUP_IN_PROGRESS" => Some(Self::BackupInProgress),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
    /// The status of Operations Insights for this Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationsInsightsState {
        /// The status is not specified.
        Unspecified = 0,
        /// Operations Insights is enabling.
        Enabling = 1,
        /// Operations Insights is enabled.
        Enabled = 2,
        /// Operations Insights is disabling.
        Disabling = 3,
        /// Operations Insights is not enabled.
        NotEnabled = 4,
        /// Operations Insights failed to enable.
        FailedEnabling = 5,
        /// Operations Insights failed to disable.
        FailedDisabling = 6,
    }
    impl OperationsInsightsState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED",
                Self::Enabling => "ENABLING",
                Self::Enabled => "ENABLED",
                Self::Disabling => "DISABLING",
                Self::NotEnabled => "NOT_ENABLED",
                Self::FailedEnabling => "FAILED_ENABLING",
                Self::FailedDisabling => "FAILED_DISABLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATIONS_INSIGHTS_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLING" => Some(Self::Enabling),
                "ENABLED" => Some(Self::Enabled),
                "DISABLING" => Some(Self::Disabling),
                "NOT_ENABLED" => Some(Self::NotEnabled),
                "FAILED_ENABLING" => Some(Self::FailedEnabling),
                "FAILED_DISABLING" => Some(Self::FailedDisabling),
                _ => None,
            }
        }
    }
}
/// The connection strings used to connect to the Oracle Database.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PluggableDatabaseConnectionStrings {
    /// Optional. All connection strings to use to connect to the pluggable
    /// database.
    #[prost(map = "string, string", tag = "1")]
    pub all_connection_strings: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The default connection string to use to connect to the pluggable
    /// database.
    #[prost(string, tag = "2")]
    pub pdb_default: ::prost::alloc::string::String,
    /// Optional. The default connection string to use to connect to the pluggable
    /// database using IP.
    #[prost(string, tag = "3")]
    pub pdb_ip_default: ::prost::alloc::string::String,
}
/// The Pluggable Database Node Level Details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PluggableDatabaseNodeLevelDetails {
    /// Required. The Node name of the Database home.
    #[prost(string, tag = "1")]
    pub node_name: ::prost::alloc::string::String,
    /// Required. The mode that the pluggable database is in to open it.
    #[prost(
        enumeration = "pluggable_database_node_level_details::PluggableDatabaseOpenMode",
        tag = "2"
    )]
    pub open_mode: i32,
    /// Required. The OCID of the Pluggable Database.
    #[prost(string, tag = "3")]
    pub pluggable_database_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `PluggableDatabaseNodeLevelDetails`.
pub mod pluggable_database_node_level_details {
    /// The mode that the pluggable database is in to open it.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PluggableDatabaseOpenMode {
        /// The open mode is unspecified.
        Unspecified = 0,
        /// The pluggable database is opened in read-only mode.
        ReadOnly = 1,
        /// The pluggable database is opened in read-write mode.
        ReadWrite = 2,
        /// The pluggable database is mounted.
        Mounted = 3,
        /// The pluggable database is migrated.
        Migrate = 4,
    }
    impl PluggableDatabaseOpenMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PLUGGABLE_DATABASE_OPEN_MODE_UNSPECIFIED",
                Self::ReadOnly => "READ_ONLY",
                Self::ReadWrite => "READ_WRITE",
                Self::Mounted => "MOUNTED",
                Self::Migrate => "MIGRATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLUGGABLE_DATABASE_OPEN_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                "MOUNTED" => Some(Self::Mounted),
                "MIGRATE" => Some(Self::Migrate),
                _ => None,
            }
        }
    }
}
/// The configuration of the Database Management service.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseManagementConfig {
    /// Output only. The status of the Database Management service.
    #[prost(enumeration = "database_management_config::ManagementState", tag = "1")]
    pub management_state: i32,
    /// Output only. The Database Management type.
    #[prost(enumeration = "database_management_config::ManagementType", tag = "2")]
    pub management_type: i32,
}
/// Nested message and enum types in `DatabaseManagementConfig`.
pub mod database_management_config {
    /// The status of the Database Management service.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagementState {
        /// The status is not specified.
        Unspecified = 0,
        /// The Database Management service is enabling.
        Enabling = 1,
        /// The Database Management service is enabled.
        Enabled = 2,
        /// The Database Management service is disabling.
        Disabling = 3,
        /// The Database Management service is disabled.
        Disabled = 4,
        /// The Database Management service is updating.
        Updating = 5,
        /// The Database Management service failed to enable.
        FailedEnabling = 6,
        /// The Database Management service failed to disable.
        FailedDisabling = 7,
        /// The Database Management service failed to update.
        FailedUpdating = 8,
    }
    impl ManagementState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MANAGEMENT_STATE_UNSPECIFIED",
                Self::Enabling => "ENABLING",
                Self::Enabled => "ENABLED",
                Self::Disabling => "DISABLING",
                Self::Disabled => "DISABLED",
                Self::Updating => "UPDATING",
                Self::FailedEnabling => "FAILED_ENABLING",
                Self::FailedDisabling => "FAILED_DISABLING",
                Self::FailedUpdating => "FAILED_UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MANAGEMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLING" => Some(Self::Enabling),
                "ENABLED" => Some(Self::Enabled),
                "DISABLING" => Some(Self::Disabling),
                "DISABLED" => Some(Self::Disabled),
                "UPDATING" => Some(Self::Updating),
                "FAILED_ENABLING" => Some(Self::FailedEnabling),
                "FAILED_DISABLING" => Some(Self::FailedDisabling),
                "FAILED_UPDATING" => Some(Self::FailedUpdating),
                _ => None,
            }
        }
    }
    /// The Database Management type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagementType {
        /// The type is not specified.
        Unspecified = 0,
        /// Basic Database Management.
        Basic = 1,
        /// Advanced Database Management.
        Advanced = 2,
    }
    impl ManagementType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MANAGEMENT_TYPE_UNSPECIFIED",
                Self::Basic => "BASIC",
                Self::Advanced => "ADVANCED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MANAGEMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BASIC" => Some(Self::Basic),
                "ADVANCED" => Some(Self::Advanced),
                _ => None,
            }
        }
    }
}
/// The request for `PluggableDatabase.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPluggableDatabaseRequest {
    /// Required. The name of the PluggableDatabase resource in the following
    /// format:
    /// projects/{project}/locations/{region}/pluggableDatabases/{pluggable_database}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `PluggableDatabase.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPluggableDatabasesRequest {
    /// Required. The parent, which owns this collection of PluggableDatabases.
    /// Format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of PluggableDatabases to return. The service
    /// may return fewer than this value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListPluggableDatabases`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPluggableDatabases`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. List for
    /// pluggable databases is supported only with a valid container database (full
    /// resource name) filter in this format:
    /// `database="projects/{project}/locations/{location}/databases/{database}"`
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `PluggableDatabase.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPluggableDatabasesResponse {
    /// The list of PluggableDatabases.
    #[prost(message, repeated, tag = "1")]
    pub pluggable_databases: ::prost::alloc::vec::Vec<PluggableDatabase>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Details of the Database resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/Database/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Database {
    /// Identifier. The name of the Database resource in the following format:
    /// projects/{project}/locations/{region}/databases/{database}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The database name. The name must begin with an alphabetic
    /// character and can contain a maximum of eight alphanumeric characters.
    /// Special characters are not permitted.
    #[prost(string, tag = "2")]
    pub db_name: ::prost::alloc::string::String,
    /// Optional. The DB_UNIQUE_NAME of the Oracle Database being backed up.
    #[prost(string, tag = "3")]
    pub db_unique_name: ::prost::alloc::string::String,
    /// Required. The password for the default ADMIN user.
    #[prost(string, tag = "4")]
    pub admin_password: ::prost::alloc::string::String,
    /// Optional. The TDE wallet password for the database.
    #[prost(string, tag = "5")]
    pub tde_wallet_password: ::prost::alloc::string::String,
    /// Optional. The character set for the database. The default is AL32UTF8.
    #[prost(string, tag = "6")]
    pub character_set: ::prost::alloc::string::String,
    /// Optional. The national character set for the database. The default is
    /// AL16UTF16.
    #[prost(string, tag = "7")]
    pub ncharacter_set: ::prost::alloc::string::String,
    /// Output only. HTTPS link to OCI resources exposed to Customer via UI
    /// Interface.
    #[prost(string, tag = "8")]
    pub oci_url: ::prost::alloc::string::String,
    /// Output only. The date and time that the Database was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The properties of the Database.
    #[prost(message, optional, tag = "10")]
    pub properties: ::core::option::Option<DatabaseProperties>,
    /// Optional. The database ID of the Database.
    #[prost(string, tag = "11")]
    pub database_id: ::prost::alloc::string::String,
    /// Optional. The name of the DbHome resource associated with the Database.
    #[prost(string, tag = "12")]
    pub db_home_name: ::prost::alloc::string::String,
    /// Output only. The GCP Oracle zone where the Database is created.
    #[prost(string, tag = "13")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Output only. The Status of Operations Insights for this Database.
    #[prost(enumeration = "database::OperationsInsightsStatus", tag = "14")]
    pub ops_insights_status: i32,
}
/// Nested message and enum types in `Database`.
pub mod database {
    /// The Status of Operations Insights for this Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationsInsightsStatus {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the operations insights are being enabled.
        Enabling = 1,
        /// Indicates that the operations insights are enabled.
        Enabled = 2,
        /// Indicates that the operations insights are being disabled.
        Disabling = 3,
        /// Indicates that the operations insights are not enabled.
        NotEnabled = 4,
        /// Indicates that the operations insights failed to enable.
        FailedEnabling = 5,
        /// Indicates that the operations insights failed to disable.
        FailedDisabling = 6,
    }
    impl OperationsInsightsStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OPERATIONS_INSIGHTS_STATUS_UNSPECIFIED",
                Self::Enabling => "ENABLING",
                Self::Enabled => "ENABLED",
                Self::Disabling => "DISABLING",
                Self::NotEnabled => "NOT_ENABLED",
                Self::FailedEnabling => "FAILED_ENABLING",
                Self::FailedDisabling => "FAILED_DISABLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATIONS_INSIGHTS_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLING" => Some(Self::Enabling),
                "ENABLED" => Some(Self::Enabled),
                "DISABLING" => Some(Self::Disabling),
                "NOT_ENABLED" => Some(Self::NotEnabled),
                "FAILED_ENABLING" => Some(Self::FailedEnabling),
                "FAILED_DISABLING" => Some(Self::FailedDisabling),
                _ => None,
            }
        }
    }
}
/// The properties of a Database.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatabaseProperties {
    /// Output only. State of the Database.
    #[prost(enumeration = "database_properties::DatabaseLifecycleState", tag = "1")]
    pub state: i32,
    /// Required. The Oracle Database version.
    #[prost(string, tag = "2")]
    pub db_version: ::prost::alloc::string::String,
    /// Optional. Backup options for the Database.
    #[prost(message, optional, tag = "3")]
    pub db_backup_config: ::core::option::Option<DbBackupConfig>,
    /// Output only. The Database Management config.
    #[prost(message, optional, tag = "4")]
    pub database_management_config: ::core::option::Option<DatabaseManagementConfig>,
}
/// Nested message and enum types in `DatabaseProperties`.
pub mod database_properties {
    /// The various lifecycle states of the Database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseLifecycleState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in backup in progress state.
        BackupInProgress = 4,
        /// Indicates that the resource is in upgrading state.
        Upgrading = 5,
        /// Indicates that the resource is in converting state.
        Converting = 6,
        /// Indicates that the resource is in terminating state.
        Terminating = 7,
        /// Indicates that the resource is in terminated state.
        Terminated = 8,
        /// Indicates that the resource is in restore failed state.
        RestoreFailed = 9,
        /// Indicates that the resource is in failed state.
        Failed = 10,
    }
    impl DatabaseLifecycleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DATABASE_LIFECYCLE_STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::BackupInProgress => "BACKUP_IN_PROGRESS",
                Self::Upgrading => "UPGRADING",
                Self::Converting => "CONVERTING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::RestoreFailed => "RESTORE_FAILED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATABASE_LIFECYCLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "BACKUP_IN_PROGRESS" => Some(Self::BackupInProgress),
                "UPGRADING" => Some(Self::Upgrading),
                "CONVERTING" => Some(Self::Converting),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "RESTORE_FAILED" => Some(Self::RestoreFailed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Backup Options for the Database.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbBackupConfig {
    /// Optional. If set to true, enables automatic backups on the database.
    #[prost(bool, tag = "1")]
    pub auto_backup_enabled: bool,
    /// Optional. Details of the database backup destinations.
    #[prost(message, repeated, tag = "2")]
    pub backup_destination_details: ::prost::alloc::vec::Vec<
        db_backup_config::BackupDestinationDetails,
    >,
    /// Optional. The number of days an automatic backup is retained before being
    /// automatically deleted. This value determines the earliest point in time to
    /// which a database can be restored. Min: 1, Max: 60.
    #[prost(int32, tag = "3")]
    pub retention_period_days: i32,
    /// Optional. This defines when the backups will be deleted after Database
    /// termination.
    #[prost(enumeration = "db_backup_config::BackupDeletionPolicy", tag = "4")]
    pub backup_deletion_policy: i32,
    /// Optional. The day of the week on which the full backup should be performed
    /// on the database. If no value is provided, it will default to Sunday.
    #[prost(enumeration = "super::super::super::r#type::DayOfWeek", tag = "5")]
    pub auto_full_backup_day: i32,
    /// Optional. The window in which the full backup should be performed on the
    /// database. If no value is provided, the default is anytime.
    #[prost(enumeration = "db_backup_config::BackupWindow", tag = "6")]
    pub auto_full_backup_window: i32,
    /// Optional. The window in which the incremental backup should be performed on
    /// the database. If no value is provided, the default is anytime except the
    /// auto full backup day.
    #[prost(enumeration = "db_backup_config::BackupWindow", tag = "7")]
    pub auto_incremental_backup_window: i32,
}
/// Nested message and enum types in `DbBackupConfig`.
pub mod db_backup_config {
    /// The details of the database backup destination.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BackupDestinationDetails {
        /// Optional. The type of the database backup destination.
        #[prost(enumeration = "BackupDestinationType", tag = "1")]
        pub r#type: i32,
    }
    /// The type of the database backup destination.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupDestinationType {
        /// Default unspecified value.
        Unspecified = 0,
        /// Backup destination type is NFS.
        Nfs = 1,
        /// Backup destination type is Recovery Appliance.
        RecoveryAppliance = 2,
        /// Backup destination type is Object Store.
        ObjectStore = 3,
        /// Backup destination type is Local.
        Local = 4,
        /// Backup destination type is DBRS.
        Dbrs = 5,
    }
    impl BackupDestinationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_DESTINATION_TYPE_UNSPECIFIED",
                Self::Nfs => "NFS",
                Self::RecoveryAppliance => "RECOVERY_APPLIANCE",
                Self::ObjectStore => "OBJECT_STORE",
                Self::Local => "LOCAL",
                Self::Dbrs => "DBRS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_DESTINATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NFS" => Some(Self::Nfs),
                "RECOVERY_APPLIANCE" => Some(Self::RecoveryAppliance),
                "OBJECT_STORE" => Some(Self::ObjectStore),
                "LOCAL" => Some(Self::Local),
                "DBRS" => Some(Self::Dbrs),
                _ => None,
            }
        }
    }
    /// The 2 hour window in which the backup should be performed on the database.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupWindow {
        /// Default unspecified value.
        Unspecified = 0,
        /// 12:00 AM - 2:00 AM
        SlotOne = 1,
        /// 2:00 AM - 4:00 AM
        SlotTwo = 2,
        /// 4:00 AM - 6:00 AM
        SlotThree = 3,
        /// 6:00 AM - 8:00 AM
        SlotFour = 4,
        /// 8:00 AM - 10:00 AM
        SlotFive = 5,
        /// 10:00 AM - 12:00 PM
        SlotSix = 6,
        /// 12:00 PM - 2:00 PM
        SlotSeven = 7,
        /// 2:00 PM - 4:00 PM
        SlotEight = 8,
        /// 4:00 PM - 6:00 PM
        SlotNine = 9,
        /// 6:00 PM - 8:00 PM
        SlotTen = 10,
        /// 8:00 PM - 10:00 PM
        SlotEleven = 11,
        /// 10:00 PM - 12:00 AM
        SlotTwelve = 12,
    }
    impl BackupWindow {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_WINDOW_UNSPECIFIED",
                Self::SlotOne => "SLOT_ONE",
                Self::SlotTwo => "SLOT_TWO",
                Self::SlotThree => "SLOT_THREE",
                Self::SlotFour => "SLOT_FOUR",
                Self::SlotFive => "SLOT_FIVE",
                Self::SlotSix => "SLOT_SIX",
                Self::SlotSeven => "SLOT_SEVEN",
                Self::SlotEight => "SLOT_EIGHT",
                Self::SlotNine => "SLOT_NINE",
                Self::SlotTen => "SLOT_TEN",
                Self::SlotEleven => "SLOT_ELEVEN",
                Self::SlotTwelve => "SLOT_TWELVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_WINDOW_UNSPECIFIED" => Some(Self::Unspecified),
                "SLOT_ONE" => Some(Self::SlotOne),
                "SLOT_TWO" => Some(Self::SlotTwo),
                "SLOT_THREE" => Some(Self::SlotThree),
                "SLOT_FOUR" => Some(Self::SlotFour),
                "SLOT_FIVE" => Some(Self::SlotFive),
                "SLOT_SIX" => Some(Self::SlotSix),
                "SLOT_SEVEN" => Some(Self::SlotSeven),
                "SLOT_EIGHT" => Some(Self::SlotEight),
                "SLOT_NINE" => Some(Self::SlotNine),
                "SLOT_TEN" => Some(Self::SlotTen),
                "SLOT_ELEVEN" => Some(Self::SlotEleven),
                "SLOT_TWELVE" => Some(Self::SlotTwelve),
                _ => None,
            }
        }
    }
    /// This defines when the backups will be deleted after Database termination.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackupDeletionPolicy {
        /// Default unspecified value.
        Unspecified = 0,
        /// Keeps the backup for predefined time
        /// i.e. 72 hours and then delete permanently.
        DeleteImmediately = 1,
        /// Keeps the backups as per the policy defined
        /// for database backups.
        DeleteAfterRetentionPeriod = 2,
    }
    impl BackupDeletionPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BACKUP_DELETION_POLICY_UNSPECIFIED",
                Self::DeleteImmediately => "DELETE_IMMEDIATELY",
                Self::DeleteAfterRetentionPeriod => "DELETE_AFTER_RETENTION_PERIOD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKUP_DELETION_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE_IMMEDIATELY" => Some(Self::DeleteImmediately),
                "DELETE_AFTER_RETENTION_PERIOD" => Some(Self::DeleteAfterRetentionPeriod),
                _ => None,
            }
        }
    }
}
/// The request for `Database.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDatabaseRequest {
    /// Required. The name of the Database resource in the following format:
    /// projects/{project}/locations/{region}/databases/{database}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `Database.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDatabasesRequest {
    /// Required. The parent resource name in the following format:
    /// projects/{project}/locations/{region}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Databases will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. list for
    /// container databases is supported only with a valid dbSystem (full resource
    /// name) filter in this format:
    /// `dbSystem="projects/{project}/locations/{location}/dbSystems/{dbSystemId}"`
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `Database.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatabasesResponse {
    /// The list of Databases.
    #[prost(message, repeated, tag = "1")]
    pub databases: ::prost::alloc::vec::Vec<Database>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Details of the Database character set resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DatabaseCharacterSet {
    /// Identifier. The name of the Database Character Set resource in the
    /// following format:
    /// projects/{project}/locations/{region}/databaseCharacterSets/{database_character_set}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The character set type for the Database.
    #[prost(enumeration = "database_character_set::CharacterSetType", tag = "2")]
    pub character_set_type: i32,
    /// Output only. The character set name for the Database which is the ID in the
    /// resource name.
    #[prost(string, tag = "3")]
    pub character_set: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DatabaseCharacterSet`.
pub mod database_character_set {
    /// The type of character set a Database can have.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CharacterSetType {
        /// Character set type is not specified.
        Unspecified = 0,
        /// Character set type is set to database.
        Database = 1,
        /// Character set type is set to national.
        National = 2,
    }
    impl CharacterSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CHARACTER_SET_TYPE_UNSPECIFIED",
                Self::Database => "DATABASE",
                Self::National => "NATIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHARACTER_SET_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "DATABASE" => Some(Self::Database),
                "NATIONAL" => Some(Self::National),
                _ => None,
            }
        }
    }
}
/// The request for `DatabaseCharacterSet.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDatabaseCharacterSetsRequest {
    /// Required. The parent value for DatabaseCharacterSets in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of DatabaseCharacterSets to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// DatabaseCharacterSets will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListDatabaseCharacterSets` call. Provide this to retrieve the subsequent
    /// page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDatabaseCharacterSets` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `DatabaseCharacterSet.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatabaseCharacterSetsResponse {
    /// The list of DatabaseCharacterSets.
    #[prost(message, repeated, tag = "1")]
    pub database_character_sets: ::prost::alloc::vec::Vec<DatabaseCharacterSet>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Details of the database node resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbNode/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbNode {
    /// Identifier. The name of the database node resource in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}/dbNodes/{db_node}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Various properties of the database node.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<DbNodeProperties>,
}
/// Various properties and settings associated with Db node.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbNodeProperties {
    /// Output only. OCID of database node.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. OCPU count per database node.
    #[prost(int32, tag = "2")]
    pub ocpu_count: i32,
    /// Memory allocated in GBs.
    #[prost(int32, tag = "3")]
    pub memory_size_gb: i32,
    /// Optional. Local storage per database node.
    #[prost(int32, tag = "4")]
    pub db_node_storage_size_gb: i32,
    /// Optional. Database server OCID.
    #[prost(string, tag = "5")]
    pub db_server_ocid: ::prost::alloc::string::String,
    /// Optional. DNS
    #[prost(string, tag = "8")]
    pub hostname: ::prost::alloc::string::String,
    /// Output only. State of the database node.
    #[prost(enumeration = "db_node_properties::State", tag = "9")]
    pub state: i32,
    /// Total CPU core count of the database node.
    #[prost(int32, tag = "10")]
    pub total_cpu_core_count: i32,
    /// Output only. The date and time that the database node was created.
    #[prost(message, optional, tag = "11")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `DbNodeProperties`.
pub mod db_node_properties {
    /// The various lifecycle states of the database node.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in stopping state.
        Stopping = 4,
        /// Indicates that the resource is in stopped state.
        Stopped = 5,
        /// Indicates that the resource is in starting state.
        Starting = 6,
        /// Indicates that the resource is in terminating state.
        Terminating = 7,
        /// Indicates that the resource is in terminated state.
        Terminated = 8,
        /// Indicates that the resource is in failed state.
        Failed = 9,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Stopping => "STOPPING",
                Self::Stopped => "STOPPED",
                Self::Starting => "STARTING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "STOPPING" => Some(Self::Stopping),
                "STOPPED" => Some(Self::Stopped),
                "STARTING" => Some(Self::Starting),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Details of the database server resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbServer/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbServer {
    /// Identifier. The name of the database server resource with the format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}/dbServers/{db_server}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly name for this resource.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Various properties of the database server.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<DbServerProperties>,
}
/// Various properties and settings associated with Exadata database server.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbServerProperties {
    /// Output only. OCID of database server.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. OCPU count per database.
    #[prost(int32, tag = "2")]
    pub ocpu_count: i32,
    /// Optional. Maximum OCPU count per database.
    #[prost(int32, tag = "3")]
    pub max_ocpu_count: i32,
    /// Optional. Memory allocated in GBs.
    #[prost(int32, tag = "4")]
    pub memory_size_gb: i32,
    /// Optional. Maximum memory allocated in GBs.
    #[prost(int32, tag = "5")]
    pub max_memory_size_gb: i32,
    /// Optional. Local storage per VM.
    #[prost(int32, tag = "6")]
    pub db_node_storage_size_gb: i32,
    /// Optional. Maximum local storage per VM.
    #[prost(int32, tag = "7")]
    pub max_db_node_storage_size_gb: i32,
    /// Optional. Vm count per database.
    #[prost(int32, tag = "8")]
    pub vm_count: i32,
    /// Output only. State of the database server.
    #[prost(enumeration = "db_server_properties::State", tag = "9")]
    pub state: i32,
    /// Output only. OCID of database nodes associated with the database server.
    #[prost(string, repeated, tag = "10")]
    pub db_node_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DbServerProperties`.
pub mod db_server_properties {
    /// The various lifecycle states of the database server.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in creating state.
        Creating = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in unavailable state.
        Unavailable = 3,
        /// Indicates that the resource is in deleting state.
        Deleting = 4,
        /// Indicates that the resource is in deleted state.
        Deleted = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Available => "AVAILABLE",
                Self::Unavailable => "UNAVAILABLE",
                Self::Deleting => "DELETING",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "AVAILABLE" => Some(Self::Available),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "DELETING" => Some(Self::Deleting),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// Details of the DbSystem (BaseDB) resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystem/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbSystem {
    /// Identifier. The name of the DbSystem resource in the following format:
    /// projects/{project}/locations/{region}/dbSystems/{db_system}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The properties of the DbSystem.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<DbSystemProperties>,
    /// Optional. The GCP Oracle zone where Oracle DbSystem is hosted.
    /// Example: us-east4-b-r2.
    /// If not specified, the system will pick a zone based on availability.
    #[prost(string, tag = "3")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Optional. The labels or tags associated with the DbSystem.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The name of the OdbNetwork associated with the DbSystem.
    /// Format: projects/{project}/locations/{location}/odbNetworks/{odb_network}
    /// It is optional but if specified, this should match the parent ODBNetwork of
    /// the OdbSubnet.
    #[prost(string, tag = "5")]
    pub odb_network: ::prost::alloc::string::String,
    /// Required. The name of the OdbSubnet associated with the DbSystem for IP
    /// allocation. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "6")]
    pub odb_subnet: ::prost::alloc::string::String,
    /// Output only. The ID of the subscription entitlement associated with the
    /// DbSystem
    #[prost(string, tag = "7")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Required. The display name for the System db. The name does not have to
    /// be unique within your project.
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The date and time that the DbSystem was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. HTTPS link to OCI resources exposed to Customer via UI
    /// Interface.
    #[prost(string, tag = "10")]
    pub oci_url: ::prost::alloc::string::String,
}
/// The properties of a DbSystem.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbSystemProperties {
    /// Required. Shape of DB System.
    #[prost(string, tag = "1")]
    pub shape: ::prost::alloc::string::String,
    /// Required. The number of CPU cores to enable for the DbSystem.
    #[prost(int32, tag = "2")]
    pub compute_count: i32,
    /// Required. The initial data storage size in GB.
    #[prost(int32, tag = "3")]
    pub initial_data_storage_size_gb: i32,
    /// Required. The database edition of the DbSystem.
    #[prost(enumeration = "db_system_properties::DbSystemDatabaseEdition", tag = "4")]
    pub database_edition: i32,
    /// Required. The license model of the DbSystem.
    #[prost(enumeration = "db_system_properties::LicenseModel", tag = "5")]
    pub license_model: i32,
    /// Required. SSH public keys to be stored with the DbSystem.
    #[prost(string, repeated, tag = "6")]
    pub ssh_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Prefix for DB System host names.
    #[prost(string, tag = "7")]
    pub hostname_prefix: ::prost::alloc::string::String,
    /// Output only. The hostname of the DbSystem.
    #[prost(string, tag = "8")]
    pub hostname: ::prost::alloc::string::String,
    /// Optional. The private IP address of the DbSystem.
    #[prost(string, tag = "9")]
    pub private_ip: ::prost::alloc::string::String,
    /// Optional. Data collection options for diagnostics.
    #[prost(message, optional, tag = "10")]
    pub data_collection_options: ::core::option::Option<DataCollectionOptionsDbSystem>,
    /// Optional. Time zone of the DbSystem.
    #[prost(message, optional, tag = "11")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Output only. State of the DbSystem.
    #[prost(enumeration = "db_system_properties::DbSystemLifecycleState", tag = "12")]
    pub lifecycle_state: i32,
    /// Optional. Details for creating a Database Home.
    #[prost(message, optional, tag = "13")]
    pub db_home: ::core::option::Option<DbHome>,
    /// Output only. OCID of the DbSystem.
    #[prost(string, tag = "14")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. The memory size in GB.
    #[prost(int32, tag = "15")]
    pub memory_size_gb: i32,
    /// Optional. The compute model of the DbSystem.
    #[prost(enumeration = "db_system_properties::ComputeModel", tag = "16")]
    pub compute_model: i32,
    /// Optional. The data storage size in GB that is currently available to
    /// DbSystems.
    #[prost(int32, tag = "17")]
    pub data_storage_size_gb: i32,
    /// Optional. The reco/redo storage size in GB.
    #[prost(int32, tag = "18")]
    pub reco_storage_size_gb: i32,
    /// Optional. The host domain name of the DbSystem.
    #[prost(string, tag = "19")]
    pub domain: ::prost::alloc::string::String,
    /// Optional. The number of nodes in the DbSystem.
    #[prost(int32, tag = "20")]
    pub node_count: i32,
    /// Optional. The options for the DbSystem.
    #[prost(message, optional, tag = "21")]
    pub db_system_options: ::core::option::Option<DbSystemOptions>,
}
/// Nested message and enum types in `DbSystemProperties`.
pub mod db_system_properties {
    /// The editions available for DbSystem.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DbSystemDatabaseEdition {
        /// The database edition is unspecified.
        Unspecified = 0,
        /// The database edition is Standard.
        StandardEdition = 1,
        /// The database edition is Enterprise.
        EnterpriseEdition = 2,
        /// The database edition is Enterprise Edition.
        EnterpriseEditionHighPerformance = 3,
    }
    impl DbSystemDatabaseEdition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DB_SYSTEM_DATABASE_EDITION_UNSPECIFIED",
                Self::StandardEdition => "STANDARD_EDITION",
                Self::EnterpriseEdition => "ENTERPRISE_EDITION",
                Self::EnterpriseEditionHighPerformance => {
                    "ENTERPRISE_EDITION_HIGH_PERFORMANCE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DB_SYSTEM_DATABASE_EDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD_EDITION" => Some(Self::StandardEdition),
                "ENTERPRISE_EDITION" => Some(Self::EnterpriseEdition),
                "ENTERPRISE_EDITION_HIGH_PERFORMANCE" => {
                    Some(Self::EnterpriseEditionHighPerformance)
                }
                _ => None,
            }
        }
    }
    /// The license model of the DbSystem.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseModel {
        /// The license model is unspecified.
        Unspecified = 0,
        /// The license model is included.
        LicenseIncluded = 1,
        /// The license model is bring your own license.
        BringYourOwnLicense = 2,
    }
    impl LicenseModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_MODEL_UNSPECIFIED",
                Self::LicenseIncluded => "LICENSE_INCLUDED",
                Self::BringYourOwnLicense => "BRING_YOUR_OWN_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE_INCLUDED" => Some(Self::LicenseIncluded),
                "BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
                _ => None,
            }
        }
    }
    /// The various lifecycle states of the DbSystem.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DbSystemLifecycleState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in terminating state.
        Terminating = 4,
        /// Indicates that the resource is in terminated state.
        Terminated = 5,
        /// Indicates that the resource is in failed state.
        Failed = 6,
        /// Indicates that the resource has been migrated.
        Migrated = 7,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress = 8,
        /// Indicates that the resource needs attention.
        NeedsAttention = 9,
        /// Indicates that the resource is upgrading.
        Upgrading = 10,
    }
    impl DbSystemLifecycleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DB_SYSTEM_LIFECYCLE_STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
                Self::Migrated => "MIGRATED",
                Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
                Self::NeedsAttention => "NEEDS_ATTENTION",
                Self::Upgrading => "UPGRADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DB_SYSTEM_LIFECYCLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                "MIGRATED" => Some(Self::Migrated),
                "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "UPGRADING" => Some(Self::Upgrading),
                _ => None,
            }
        }
    }
    /// The compute model of the DbSystem.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ComputeModel {
        /// The compute model is unspecified.
        Unspecified = 0,
        /// The compute model is virtual.
        Ecpu = 1,
        /// The compute model is physical.
        Ocpu = 2,
    }
    impl ComputeModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPUTE_MODEL_UNSPECIFIED",
                Self::Ecpu => "ECPU",
                Self::Ocpu => "OCPU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPUTE_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "ECPU" => Some(Self::Ecpu),
                "OCPU" => Some(Self::Ocpu),
                _ => None,
            }
        }
    }
}
/// Data collection options for DbSystem.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataCollectionOptionsDbSystem {
    /// Optional. Indicates whether to enable data collection for diagnostics.
    #[prost(bool, tag = "1")]
    pub is_diagnostics_events_enabled: bool,
    /// Optional. Indicates whether to enable incident logs and trace collection.
    #[prost(bool, tag = "2")]
    pub is_incident_logs_enabled: bool,
}
/// Details of the DbSystem Options.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbSystemOptions {
    /// Optional. The storage option used in DB system.
    #[prost(enumeration = "db_system_options::StorageManagement", tag = "1")]
    pub storage_management: i32,
}
/// Nested message and enum types in `DbSystemOptions`.
pub mod db_system_options {
    /// The storage option used in DB system.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageManagement {
        /// The storage management is unspecified.
        Unspecified = 0,
        /// Automatic storage management.
        Asm = 1,
        /// Logical Volume management.
        Lvm = 2,
    }
    impl StorageManagement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STORAGE_MANAGEMENT_UNSPECIFIED",
                Self::Asm => "ASM",
                Self::Lvm => "LVM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STORAGE_MANAGEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "ASM" => Some(Self::Asm),
                "LVM" => Some(Self::Lvm),
                _ => None,
            }
        }
    }
}
/// Details of the Database Home resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbHome {
    /// Optional. The display name for the Database Home. The name does not have to
    /// be unique within your project.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. A valid Oracle Database version. For a list of supported
    /// versions, use the ListDbVersions operation.
    #[prost(string, tag = "2")]
    pub db_version: ::prost::alloc::string::String,
    /// Required. The Database resource.
    #[prost(message, optional, tag = "3")]
    pub database: ::core::option::Option<Database>,
    /// Optional. Whether unified auditing is enabled for the Database Home.
    #[prost(bool, tag = "4")]
    pub is_unified_auditing_enabled: bool,
}
/// The request for `DbSystem.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDbSystemRequest {
    /// Required. The value for parent of the DbSystem in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the DbSystem to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub db_system_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub db_system: ::core::option::Option<DbSystem>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `DbSystem.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDbSystemRequest {
    /// Required. The name of the DbSystem in the following format:
    /// projects/{project}/locations/{location}/dbSystems/{db_system}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `DbSystem.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDbSystemRequest {
    /// Required. The name of the DbSystem in the following format:
    /// projects/{project}/locations/{location}/dbSystems/{db_system}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `DbSystem.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDbSystemsRequest {
    /// Required. The parent value for DbSystems in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 DbSystems will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `DbSystem.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbSystemsResponse {
    /// The list of DbSystems.
    #[prost(message, repeated, tag = "1")]
    pub db_systems: ::prost::alloc::vec::Vec<DbSystem>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Summary of the DbSystem initial storage size.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbSystemInitialStorageSize {
    /// Output only. The name of the resource.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The properties of the DbSystem initial storage size summary.
    #[prost(message, optional, tag = "3")]
    pub properties: ::core::option::Option<DbSystemInitialStorageSizeProperties>,
}
/// The properties of a DbSystem initial storage size summary.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DbSystemInitialStorageSizeProperties {
    /// Output only. The storage option used in DB system.
    #[prost(
        enumeration = "db_system_initial_storage_size_properties::StorageManagement",
        tag = "1"
    )]
    pub storage_management: i32,
    /// Output only. VM shape platform type
    #[prost(
        enumeration = "db_system_initial_storage_size_properties::ShapeType",
        tag = "2"
    )]
    pub shape_type: i32,
    /// Output only. List of storage disk details.
    #[prost(message, repeated, tag = "3")]
    pub storage_size_details: ::prost::alloc::vec::Vec<StorageSizeDetails>,
    /// Output only. List of storage disk details available for launches from
    /// backup.
    #[prost(message, repeated, tag = "4")]
    pub launch_from_backup_storage_size_details: ::prost::alloc::vec::Vec<
        StorageSizeDetails,
    >,
}
/// Nested message and enum types in `DbSystemInitialStorageSizeProperties`.
pub mod db_system_initial_storage_size_properties {
    /// The storage option used in the DB system.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageManagement {
        /// Unspecified storage management.
        Unspecified = 0,
        /// Automatic Storage Management.
        Asm = 1,
        /// Logical Volume Management.
        Lvm = 2,
    }
    impl StorageManagement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STORAGE_MANAGEMENT_UNSPECIFIED",
                Self::Asm => "ASM",
                Self::Lvm => "LVM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STORAGE_MANAGEMENT_UNSPECIFIED" => Some(Self::Unspecified),
                "ASM" => Some(Self::Asm),
                "LVM" => Some(Self::Lvm),
                _ => None,
            }
        }
    }
    /// The shape type of the DB system.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShapeType {
        /// Unspecified shape type.
        Unspecified = 0,
        /// Standard X86.
        StandardX86 = 1,
    }
    impl ShapeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHAPE_TYPE_UNSPECIFIED",
                Self::StandardX86 => "STANDARD_X86",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHAPE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD_X86" => Some(Self::StandardX86),
                _ => None,
            }
        }
    }
}
/// The initial storage size, in gigabytes, that is applicable for virtual
/// machine DBSystem.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorageSizeDetails {
    /// Output only. The data storage size, in gigabytes, that is applicable for
    /// virtual machine DBSystem.
    #[prost(int32, tag = "1")]
    pub data_storage_size_in_gbs: i32,
    /// Output only. The RECO/REDO storage size, in gigabytes, that is applicable
    /// for virtual machine DBSystem.
    #[prost(int32, tag = "2")]
    pub reco_storage_size_in_gbs: i32,
}
/// The request for `DbSystemInitialStorageSizes.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDbSystemInitialStorageSizesRequest {
    /// Required. The parent value for the DbSystemInitialStorageSize resource with
    /// the format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 DbSystemInitialStorageSizes will be
    /// returned. The maximum value is 1000; values above 1000 will be reset to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `DbSystemInitialStorageSizes.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbSystemInitialStorageSizesResponse {
    /// The list of DbSystemInitialStorageSizes.
    #[prost(message, repeated, tag = "1")]
    pub db_system_initial_storage_sizes: ::prost::alloc::vec::Vec<
        DbSystemInitialStorageSize,
    >,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Details of the Database System Shapes resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/DbSystemShapeSummary/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbSystemShape {
    /// Identifier. The name of the Database System Shape resource with the format:
    /// projects/{project}/locations/{region}/dbSystemShapes/{db_system_shape}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. shape
    #[prost(string, tag = "2")]
    pub shape: ::prost::alloc::string::String,
    /// Optional. Minimum number of database servers.
    #[prost(int32, tag = "3")]
    pub min_node_count: i32,
    /// Optional. Maximum number of database servers.
    #[prost(int32, tag = "4")]
    pub max_node_count: i32,
    /// Optional. Minimum number of storage servers.
    #[prost(int32, tag = "5")]
    pub min_storage_count: i32,
    /// Optional. Maximum number of storage servers.
    #[prost(int32, tag = "6")]
    pub max_storage_count: i32,
    /// Optional. Number of cores per node.
    #[prost(int32, tag = "7")]
    pub available_core_count_per_node: i32,
    /// Optional. Memory per database server node in gigabytes.
    #[prost(int32, tag = "8")]
    pub available_memory_per_node_gb: i32,
    /// Optional. Storage per storage server in terabytes.
    #[prost(int32, tag = "9")]
    pub available_data_storage_tb: i32,
    /// Optional. Minimum core count per node.
    #[prost(int32, tag = "10")]
    pub min_core_count_per_node: i32,
    /// Optional. Minimum memory per node in gigabytes.
    #[prost(int32, tag = "11")]
    pub min_memory_per_node_gb: i32,
    /// Optional. Minimum node storage per database server in gigabytes.
    #[prost(int32, tag = "12")]
    pub min_db_node_storage_per_node_gb: i32,
}
/// A valid Oracle Database version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbVersion {
    /// Output only. The name of the DbVersion resource in the following format:
    /// projects/{project}/locations/{region}/dbVersions/{db_version}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The properties of the DbVersion.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<DbVersionProperties>,
}
/// The properties of a DbVersion.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DbVersionProperties {
    /// Output only. A valid Oracle Database version.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Output only. True if this version of the Oracle Database software is the
    /// latest version for a release.
    #[prost(bool, tag = "2")]
    pub is_latest_for_major_version: bool,
    /// Output only. True if this version of the Oracle Database software supports
    /// pluggable databases.
    #[prost(bool, tag = "3")]
    pub supports_pdb: bool,
    /// Output only. True if this version of the Oracle Database software is the
    /// preview version.
    #[prost(bool, tag = "4")]
    pub is_preview_db_version: bool,
    /// Output only. True if this version of the Oracle Database software is
    /// supported for Upgrade.
    #[prost(bool, tag = "5")]
    pub is_upgrade_supported: bool,
}
/// The request for `DbVersions.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDbVersionsRequest {
    /// Required. The parent value for the DbVersion resource with the
    /// format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 DbVersions will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter expression that matches a subset of the DbVersions to
    /// show. The supported filter for dbSystem creation is `db_system_shape =  {db_system_shape} AND storage_management = {storage_management}`. If no
    /// filter is provided, all DbVersions will be returned.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `DbVersions.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbVersionsResponse {
    /// The list of DbVersions.
    #[prost(message, repeated, tag = "1")]
    pub db_versions: ::prost::alloc::vec::Vec<DbVersion>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Details of the Entitlement resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Entitlement {
    /// Identifier. The name of the Entitlement resource with the format:
    /// projects/{project}/locations/{region}/entitlements/{entitlement}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Details of the OCI Cloud Account.
    #[prost(message, optional, tag = "2")]
    pub cloud_account_details: ::core::option::Option<CloudAccountDetails>,
    /// Output only. Google Cloud Marketplace order ID (aka entitlement ID)
    #[prost(string, tag = "3")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Output only. Entitlement State.
    #[prost(enumeration = "entitlement::State", tag = "4")]
    pub state: i32,
}
/// Nested message and enum types in `Entitlement`.
pub mod entitlement {
    /// The various lifecycle states of the subscription.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Account not linked.
        AccountNotLinked = 1,
        /// Account is linked but not active.
        AccountNotActive = 2,
        /// Entitlement and Account are active.
        Active = 3,
        /// Account is suspended.
        AccountSuspended = 4,
        /// Entitlement is not approved in private marketplace.
        NotApprovedInPrivateMarketplace = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::AccountNotLinked => "ACCOUNT_NOT_LINKED",
                Self::AccountNotActive => "ACCOUNT_NOT_ACTIVE",
                Self::Active => "ACTIVE",
                Self::AccountSuspended => "ACCOUNT_SUSPENDED",
                Self::NotApprovedInPrivateMarketplace => {
                    "NOT_APPROVED_IN_PRIVATE_MARKETPLACE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACCOUNT_NOT_LINKED" => Some(Self::AccountNotLinked),
                "ACCOUNT_NOT_ACTIVE" => Some(Self::AccountNotActive),
                "ACTIVE" => Some(Self::Active),
                "ACCOUNT_SUSPENDED" => Some(Self::AccountSuspended),
                "NOT_APPROVED_IN_PRIVATE_MARKETPLACE" => {
                    Some(Self::NotApprovedInPrivateMarketplace)
                }
                _ => None,
            }
        }
    }
}
/// Details of the OCI Cloud Account.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudAccountDetails {
    /// Output only. OCI account name.
    #[prost(string, tag = "1")]
    pub cloud_account: ::prost::alloc::string::String,
    /// Output only. OCI account home region.
    #[prost(string, tag = "2")]
    pub cloud_account_home_region: ::prost::alloc::string::String,
    /// Output only. URL to link an existing account.
    #[prost(string, optional, tag = "3")]
    pub link_existing_account_uri: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Output only. URL to create a new account and link.
    #[prost(string, optional, tag = "4")]
    pub account_creation_uri: ::core::option::Option<::prost::alloc::string::String>,
}
/// Represents CloudExadataInfrastructure resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudExadataInfrastructure/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudExadataInfrastructure {
    /// Identifier. The name of the Exadata Infrastructure resource with the
    /// format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly name for this resource.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The GCP Oracle zone where Oracle Exadata Infrastructure is
    /// hosted. Example: us-east4-b-r2. If not specified, the system will pick a
    /// zone based on availability.
    #[prost(string, tag = "8")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Output only. Entitlement ID of the private offer against which this
    /// infrastructure resource is provisioned.
    #[prost(string, tag = "4")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Optional. Various properties of the infra.
    #[prost(message, optional, tag = "5")]
    pub properties: ::core::option::Option<CloudExadataInfrastructureProperties>,
    /// Optional. Labels or tags associated with the resource.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the Exadata Infrastructure was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Various properties of Exadata Infrastructure.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudExadataInfrastructureProperties {
    /// Output only. OCID of created infra.
    /// <https://docs.oracle.com/en-us/iaas/Content/General/Concepts/identifiers.htm#Oracle>
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Optional. The number of compute servers for the Exadata Infrastructure.
    #[prost(int32, tag = "2")]
    pub compute_count: i32,
    /// Optional. The number of Cloud Exadata storage servers for the Exadata
    /// Infrastructure.
    #[prost(int32, tag = "3")]
    pub storage_count: i32,
    /// Optional. The total storage allocated to the Exadata Infrastructure
    /// resource, in gigabytes (GB).
    #[prost(int32, tag = "4")]
    pub total_storage_size_gb: i32,
    /// Output only. The available storage can be allocated to the Exadata
    /// Infrastructure resource, in gigabytes (GB).
    #[prost(int32, tag = "5")]
    pub available_storage_size_gb: i32,
    /// Optional. Maintenance window for repair.
    #[prost(message, optional, tag = "6")]
    pub maintenance_window: ::core::option::Option<MaintenanceWindow>,
    /// Output only. The current lifecycle state of the Exadata Infrastructure.
    #[prost(enumeration = "cloud_exadata_infrastructure_properties::State", tag = "7")]
    pub state: i32,
    /// Required. The shape of the Exadata Infrastructure. The shape determines the
    /// amount of CPU, storage, and memory resources allocated to the instance.
    #[prost(string, tag = "8")]
    pub shape: ::prost::alloc::string::String,
    /// Output only. Deep link to the OCI console to view this resource.
    #[prost(string, tag = "9")]
    pub oci_url: ::prost::alloc::string::String,
    /// Output only. The number of enabled CPU cores.
    #[prost(int32, tag = "10")]
    pub cpu_count: i32,
    /// Output only. The total number of CPU cores available.
    #[prost(int32, tag = "11")]
    pub max_cpu_count: i32,
    /// Output only. The memory allocated in GBs.
    #[prost(int32, tag = "12")]
    pub memory_size_gb: i32,
    /// Output only. The total memory available in GBs.
    #[prost(int32, tag = "13")]
    pub max_memory_gb: i32,
    /// Output only. The local node storage allocated in GBs.
    #[prost(int32, tag = "14")]
    pub db_node_storage_size_gb: i32,
    /// Output only. The total local node storage available in GBs.
    #[prost(int32, tag = "15")]
    pub max_db_node_storage_size_gb: i32,
    /// Output only. Size, in terabytes, of the DATA disk group.
    #[prost(double, tag = "16")]
    pub data_storage_size_tb: f64,
    /// Output only. The total available DATA disk group size.
    #[prost(double, tag = "17")]
    pub max_data_storage_tb: f64,
    /// Output only. The requested number of additional storage servers activated
    /// for the Exadata Infrastructure.
    #[prost(int32, tag = "18")]
    pub activated_storage_count: i32,
    /// Output only. The requested number of additional storage servers for the
    /// Exadata Infrastructure.
    #[prost(int32, tag = "19")]
    pub additional_storage_count: i32,
    /// Output only. The software version of the database servers (dom0) in the
    /// Exadata Infrastructure.
    #[prost(string, tag = "20")]
    pub db_server_version: ::prost::alloc::string::String,
    /// Output only. The software version of the storage servers (cells) in the
    /// Exadata Infrastructure.
    #[prost(string, tag = "21")]
    pub storage_server_version: ::prost::alloc::string::String,
    /// Output only. The OCID of the next maintenance run.
    #[prost(string, tag = "22")]
    pub next_maintenance_run_id: ::prost::alloc::string::String,
    /// Output only. The time when the next maintenance run will occur.
    #[prost(message, optional, tag = "23")]
    pub next_maintenance_run_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the next security maintenance run will occur.
    #[prost(message, optional, tag = "24")]
    pub next_security_maintenance_run_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
    /// Optional. The list of customer contacts.
    #[prost(message, repeated, tag = "25")]
    pub customer_contacts: ::prost::alloc::vec::Vec<CustomerContact>,
    /// Output only. The monthly software version of the storage servers (cells)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[prost(string, tag = "26")]
    pub monthly_storage_server_version: ::prost::alloc::string::String,
    /// Output only. The monthly software version of the database servers (dom0)
    /// in the Exadata Infrastructure. Example: 20.1.15
    #[prost(string, tag = "27")]
    pub monthly_db_server_version: ::prost::alloc::string::String,
    /// Output only. The compute model of the Exadata Infrastructure.
    #[prost(enumeration = "ComputeModel", tag = "31")]
    pub compute_model: i32,
    /// Output only. The database server type of the Exadata Infrastructure.
    #[prost(string, tag = "29")]
    pub database_server_type: ::prost::alloc::string::String,
    /// Output only. The storage server type of the Exadata Infrastructure.
    #[prost(string, tag = "30")]
    pub storage_server_type: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CloudExadataInfrastructureProperties`.
pub mod cloud_exadata_infrastructure_properties {
    /// The various lifecycle states of the Exadata Infrastructure.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// The Exadata Infrastructure is being provisioned.
        Provisioning = 1,
        /// The Exadata Infrastructure is available for use.
        Available = 2,
        /// The Exadata Infrastructure is being updated.
        Updating = 3,
        /// The Exadata Infrastructure is being terminated.
        Terminating = 4,
        /// The Exadata Infrastructure is terminated.
        Terminated = 5,
        /// The Exadata Infrastructure is in failed state.
        Failed = 6,
        /// The Exadata Infrastructure is in maintenance.
        MaintenanceInProgress = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
                Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
                _ => None,
            }
        }
    }
}
/// Maintenance window as defined by Oracle.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/datatypes/MaintenanceWindow>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MaintenanceWindow {
    /// Optional. The maintenance window scheduling preference.
    #[prost(enumeration = "maintenance_window::MaintenanceWindowPreference", tag = "1")]
    pub preference: i32,
    /// Optional. Months during the year when maintenance should be performed.
    #[prost(
        enumeration = "super::super::super::r#type::Month",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub months: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Weeks during the month when maintenance should be performed.
    /// Weeks start on the 1st, 8th, 15th, and 22nd days of the month, and have a
    /// duration of 7 days. Weeks start and end based on calendar dates, not days
    /// of the week.
    #[prost(int32, repeated, packed = "false", tag = "3")]
    pub weeks_of_month: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Days during the week when maintenance should be performed.
    #[prost(
        enumeration = "super::super::super::r#type::DayOfWeek",
        repeated,
        packed = "false",
        tag = "4"
    )]
    pub days_of_week: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The window of hours during the day when maintenance should be
    /// performed. The window is a 4 hour slot. Valid values are:
    /// 0 - represents time slot 0:00 - 3:59 UTC
    /// 4 - represents time slot 4:00 - 7:59 UTC
    /// 8 - represents time slot 8:00 - 11:59 UTC
    /// 12 - represents time slot 12:00 - 15:59 UTC
    /// 16 - represents time slot 16:00 - 19:59 UTC
    /// 20 - represents time slot 20:00 - 23:59 UTC
    #[prost(int32, repeated, packed = "false", tag = "5")]
    pub hours_of_day: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Lead time window allows user to set a lead time to prepare for a
    /// down time. The lead time is in weeks and valid value is between 1 to 4.
    #[prost(int32, tag = "6")]
    pub lead_time_week: i32,
    /// Optional. Cloud CloudExadataInfrastructure node patching method, either
    /// "ROLLING" or "NONROLLING". Default value is ROLLING.
    #[prost(enumeration = "maintenance_window::PatchingMode", tag = "7")]
    pub patching_mode: i32,
    /// Optional. Determines the amount of time the system will wait before the
    /// start of each database server patching operation. Custom action timeout is
    /// in minutes and valid value is between 15 to 120 (inclusive).
    #[prost(int32, tag = "8")]
    pub custom_action_timeout_mins: i32,
    /// Optional. If true, enables the configuration of a custom action timeout
    /// (waiting period) between database server patching operations.
    #[prost(bool, tag = "9")]
    pub is_custom_action_timeout_enabled: bool,
}
/// Nested message and enum types in `MaintenanceWindow`.
pub mod maintenance_window {
    /// Maintenance window preference.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenanceWindowPreference {
        /// Default unspecified value.
        Unspecified = 0,
        /// Custom preference.
        CustomPreference = 1,
        /// No preference.
        NoPreference = 2,
    }
    impl MaintenanceWindowPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED",
                Self::CustomPreference => "CUSTOM_PREFERENCE",
                Self::NoPreference => "NO_PREFERENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MAINTENANCE_WINDOW_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOM_PREFERENCE" => Some(Self::CustomPreference),
                "NO_PREFERENCE" => Some(Self::NoPreference),
                _ => None,
            }
        }
    }
    /// Patching mode.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PatchingMode {
        /// Default unspecified value.
        Unspecified = 0,
        /// Updates the Cloud Exadata database server hosts in a rolling fashion.
        Rolling = 1,
        /// The non-rolling maintenance method first updates your storage servers at
        /// the same time, then your database servers at the same time.
        NonRolling = 2,
    }
    impl PatchingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PATCHING_MODE_UNSPECIFIED",
                Self::Rolling => "ROLLING",
                Self::NonRolling => "NON_ROLLING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PATCHING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "ROLLING" => Some(Self::Rolling),
                "NON_ROLLING" => Some(Self::NonRolling),
                _ => None,
            }
        }
    }
}
/// ExadbVmCluster represents a cluster of VMs that are used to run Exadata
/// workloads.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/ExadbVmCluster/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExadbVmCluster {
    /// Identifier. The name of the ExadbVmCluster resource in the following
    /// format:
    /// projects/{project}/locations/{region}/exadbVmClusters/{exadb_vm_cluster}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The properties of the ExadbVmCluster.
    #[prost(message, optional, tag = "2")]
    pub properties: ::core::option::Option<ExadbVmClusterProperties>,
    /// Output only. Immutable. The GCP Oracle zone where Oracle ExadbVmCluster is
    /// hosted. Example: us-east4-b-r2. During creation, the system will pick the
    /// zone assigned to the ExascaleDbStorageVault.
    #[prost(string, tag = "3")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Optional. The labels or tags associated with the ExadbVmCluster.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Immutable. The name of the OdbNetwork associated with the
    /// ExadbVmCluster. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network} It is
    /// optional but if specified, this should match the parent ODBNetwork of the
    /// OdbSubnet.
    #[prost(string, tag = "6")]
    pub odb_network: ::prost::alloc::string::String,
    /// Required. Immutable. The name of the OdbSubnet associated with the
    /// ExadbVmCluster for IP allocation. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "7")]
    pub odb_subnet: ::prost::alloc::string::String,
    /// Required. Immutable. The name of the backup OdbSubnet associated with the
    /// ExadbVmCluster. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "8")]
    pub backup_odb_subnet: ::prost::alloc::string::String,
    /// Required. Immutable. The display name for the ExadbVmCluster. The name does
    /// not have to be unique within your project. The name must be 1-255
    /// characters long and can only contain alphanumeric characters.
    #[prost(string, tag = "9")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The date and time that the ExadbVmCluster was created.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The ID of the subscription entitlement associated with the
    /// ExadbVmCluster.
    #[prost(string, tag = "11")]
    pub entitlement_id: ::prost::alloc::string::String,
}
/// The storage allocation for the exadbvmcluster, in gigabytes (GB).
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExadbVmClusterStorageDetails {
    /// Required. The storage allocation for the exadbvmcluster per node, in
    /// gigabytes (GB). This field is used to calculate the total storage
    /// allocation for the exadbvmcluster.
    #[prost(int32, tag = "2")]
    pub size_in_gbs_per_node: i32,
}
/// The properties of an ExadbVmCluster.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExadbVmClusterProperties {
    /// Optional. Immutable. The cluster name for Exascale vm cluster. The cluster
    /// name must begin with an alphabetic character and may contain hyphens(-) but
    /// can not contain underscores(\_). It should be not more than 11 characters
    /// and is not case sensitive. OCI Cluster name.
    #[prost(string, tag = "1")]
    pub cluster_name: ::prost::alloc::string::String,
    /// Required. Immutable. Grid Infrastructure Version.
    #[prost(string, tag = "2")]
    pub grid_image_id: ::prost::alloc::string::String,
    /// Required. The number of nodes/VMs in the ExadbVmCluster.
    #[prost(int32, tag = "3")]
    pub node_count: i32,
    /// Required. Immutable. The number of ECPUs enabled per node for an exadata vm
    /// cluster on exascale infrastructure.
    #[prost(int32, tag = "20")]
    pub enabled_ecpu_count_per_node: i32,
    /// Optional. Immutable. The number of additional ECPUs per node for an Exadata
    /// VM cluster on exascale infrastructure.
    #[prost(int32, tag = "21")]
    pub additional_ecpu_count_per_node: i32,
    /// Required. Immutable. Total storage details for the ExadbVmCluster.
    #[prost(message, optional, tag = "6")]
    pub vm_file_system_storage: ::core::option::Option<ExadbVmClusterStorageDetails>,
    /// Optional. Immutable. The license type of the ExadbVmCluster.
    #[prost(enumeration = "exadb_vm_cluster_properties::LicenseModel", tag = "7")]
    pub license_model: i32,
    /// Required. Immutable. The name of ExascaleDbStorageVault associated with the
    /// ExadbVmCluster. It can refer to an existing ExascaleDbStorageVault. Or a
    /// new one can be created during the ExadbVmCluster creation (requires
    /// storage_vault_properties to be set).
    /// Format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}
    #[prost(string, tag = "8")]
    pub exascale_db_storage_vault: ::prost::alloc::string::String,
    /// Required. Immutable. Prefix for VM cluster host names.
    #[prost(string, tag = "9")]
    pub hostname_prefix: ::prost::alloc::string::String,
    /// Output only. The hostname of the ExadbVmCluster.
    #[prost(string, tag = "10")]
    pub hostname: ::prost::alloc::string::String,
    /// Required. Immutable. The SSH public keys for the ExadbVmCluster.
    #[prost(string, repeated, tag = "11")]
    pub ssh_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Immutable. Indicates user preference for data collection options.
    #[prost(message, optional, tag = "12")]
    pub data_collection_options: ::core::option::Option<DataCollectionOptionsCommon>,
    /// Optional. Immutable. The time zone of the ExadbVmCluster.
    #[prost(message, optional, tag = "13")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Output only. State of the cluster.
    #[prost(
        enumeration = "exadb_vm_cluster_properties::ExadbVmClusterLifecycleState",
        tag = "14"
    )]
    pub lifecycle_state: i32,
    /// Required. Immutable. The shape attribute of the VM cluster. The type of
    /// Exascale storage used for Exadata VM cluster. The default is SMART_STORAGE
    /// which supports Oracle Database 23ai and later
    #[prost(enumeration = "exadb_vm_cluster_properties::ShapeAttribute", tag = "15")]
    pub shape_attribute: i32,
    /// Output only. Memory per VM (GB) (Read-only): Shows the amount of memory
    /// allocated to each VM. Memory is calculated based on 2.75 GB per Total
    /// ECPUs.
    #[prost(int32, tag = "16")]
    pub memory_size_gb: i32,
    /// Optional. Immutable. SCAN listener port - TCP
    #[prost(int32, tag = "17")]
    pub scan_listener_port_tcp: i32,
    /// Output only. Deep link to the OCI console to view this resource.
    #[prost(string, tag = "18")]
    pub oci_uri: ::prost::alloc::string::String,
    /// Output only. The Oracle Grid Infrastructure (GI) software version.
    #[prost(string, tag = "19")]
    pub gi_version: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExadbVmClusterProperties`.
pub mod exadb_vm_cluster_properties {
    /// The Oracle license model that applies to the ExaScale VM cluster
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseModel {
        /// Unspecified.
        Unspecified = 0,
        /// Default is license included.
        LicenseIncluded = 1,
        /// Bring your own license.
        BringYourOwnLicense = 2,
    }
    impl LicenseModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_MODEL_UNSPECIFIED",
                Self::LicenseIncluded => "LICENSE_INCLUDED",
                Self::BringYourOwnLicense => "BRING_YOUR_OWN_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE_INCLUDED" => Some(Self::LicenseIncluded),
                "BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
                _ => None,
            }
        }
    }
    /// The various lifecycle states of the VM cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExadbVmClusterLifecycleState {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in terminating state.
        Terminating = 4,
        /// Indicates that the resource is in terminated state.
        Terminated = 5,
        /// Indicates that the resource is in failed state.
        Failed = 6,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress = 7,
    }
    impl ExadbVmClusterLifecycleState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXADB_VM_CLUSTER_LIFECYCLE_STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
                Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXADB_VM_CLUSTER_LIFECYCLE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
                _ => None,
            }
        }
    }
    /// The shape attribute of the VM cluster. The type of Exascale storage used
    /// for Exadata VM cluster. The default is SMART_STORAGE which supports Oracle
    /// Database 23ai and later
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShapeAttribute {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in smart storage.
        SmartStorage = 1,
        /// Indicates that the resource is in block storage.
        BlockStorage = 2,
    }
    impl ShapeAttribute {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHAPE_ATTRIBUTE_UNSPECIFIED",
                Self::SmartStorage => "SMART_STORAGE",
                Self::BlockStorage => "BLOCK_STORAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHAPE_ATTRIBUTE_UNSPECIFIED" => Some(Self::Unspecified),
                "SMART_STORAGE" => Some(Self::SmartStorage),
                "BLOCK_STORAGE" => Some(Self::BlockStorage),
                _ => None,
            }
        }
    }
}
/// ExascaleDbStorageVault represents a storage vault exadb vm cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/ExascaleDbStorageVault/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExascaleDbStorageVault {
    /// Identifier. The resource name of the ExascaleDbStorageVault.
    /// Format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name for the ExascaleDbStorageVault. The name does
    /// not have to be unique within your project. The name must be 1-255
    /// characters long and can only contain alphanumeric characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The GCP Oracle zone where Oracle ExascaleDbStorageVault is
    /// hosted. Example: us-east4-b-r2. If not specified, the system will pick a
    /// zone based on availability.
    #[prost(string, tag = "3")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Required. The properties of the ExascaleDbStorageVault.
    #[prost(message, optional, tag = "4")]
    pub properties: ::core::option::Option<ExascaleDbStorageVaultProperties>,
    /// Output only. The date and time when the ExascaleDbStorageVault was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The ID of the subscription entitlement associated with the
    /// ExascaleDbStorageVault.
    #[prost(string, tag = "6")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Optional. The labels or tags associated with the ExascaleDbStorageVault.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// The properties of the ExascaleDbStorageVault.
/// next ID: 12
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExascaleDbStorageVaultProperties {
    /// Output only. The OCID for the ExascaleDbStorageVault.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Output only. The time zone of the ExascaleDbStorageVault.
    #[prost(message, optional, tag = "2")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Required. The storage details of the ExascaleDbStorageVault.
    #[prost(message, optional, tag = "3")]
    pub exascale_db_storage_details: ::core::option::Option<ExascaleDbStorageDetails>,
    /// Output only. The state of the ExascaleDbStorageVault.
    #[prost(enumeration = "exascale_db_storage_vault_properties::State", tag = "4")]
    pub state: i32,
    /// Optional. The description of the ExascaleDbStorageVault.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The list of VM cluster OCIDs associated with the
    /// ExascaleDbStorageVault.
    #[prost(string, repeated, tag = "6")]
    pub vm_cluster_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The number of VM clusters associated with the
    /// ExascaleDbStorageVault.
    #[prost(int32, tag = "9")]
    pub vm_cluster_count: i32,
    /// Optional. The size of additional flash cache in percentage of high capacity
    /// database storage.
    #[prost(int32, tag = "7")]
    pub additional_flash_cache_percent: i32,
    /// Output only. Deep link to the OCI console to view this resource.
    #[prost(string, tag = "8")]
    pub oci_uri: ::prost::alloc::string::String,
    /// Output only. The shape attributes of the VM clusters attached to the
    /// ExascaleDbStorageVault.
    #[prost(
        enumeration = "exascale_db_storage_vault_properties::ShapeAttribute",
        repeated,
        packed = "false",
        tag = "10"
    )]
    pub attached_shape_attributes: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The shape attributes available for the VM clusters to be
    /// attached to the ExascaleDbStorageVault.
    #[prost(
        enumeration = "exascale_db_storage_vault_properties::ShapeAttribute",
        repeated,
        packed = "false",
        tag = "11"
    )]
    pub available_shape_attributes: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `ExascaleDbStorageVaultProperties`.
pub mod exascale_db_storage_vault_properties {
    /// The state of the ExascaleDbStorageVault.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The state of the ExascaleDbStorageVault is unspecified.
        Unspecified = 0,
        /// The ExascaleDbStorageVault is being provisioned.
        Provisioning = 1,
        /// The ExascaleDbStorageVault is available.
        Available = 2,
        /// The ExascaleDbStorageVault is being updated.
        Updating = 3,
        /// The ExascaleDbStorageVault is being deleted.
        Terminating = 4,
        /// The ExascaleDbStorageVault has been deleted.
        Terminated = 5,
        /// The ExascaleDbStorageVault has failed.
        Failed = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// The shape attribute of the VM clusters attached to the
    /// ExascaleDbStorageVault.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShapeAttribute {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in smart storage.
        SmartStorage = 1,
        /// Indicates that the resource is in block storage.
        BlockStorage = 2,
    }
    impl ShapeAttribute {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHAPE_ATTRIBUTE_UNSPECIFIED",
                Self::SmartStorage => "SMART_STORAGE",
                Self::BlockStorage => "BLOCK_STORAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHAPE_ATTRIBUTE_UNSPECIFIED" => Some(Self::Unspecified),
                "SMART_STORAGE" => Some(Self::SmartStorage),
                "BLOCK_STORAGE" => Some(Self::BlockStorage),
                _ => None,
            }
        }
    }
}
/// The storage details of the ExascaleDbStorageVault.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExascaleDbStorageDetails {
    /// Output only. The available storage capacity for the ExascaleDbStorageVault,
    /// in gigabytes (GB).
    #[prost(int32, tag = "1")]
    pub available_size_gbs: i32,
    /// Required. The total storage allocation for the ExascaleDbStorageVault, in
    /// gigabytes (GB).
    #[prost(int32, tag = "2")]
    pub total_size_gbs: i32,
}
/// The request for `ExascaleDbStorageVault.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetExascaleDbStorageVaultRequest {
    /// Required. The name of the ExascaleDbStorageVault in the following format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `ExascaleDbStorageVault.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListExascaleDbStorageVaultsRequest {
    /// Required. The parent value for ExascaleDbStorageVault in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ExascaleDbStorageVaults will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Filter
    /// the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request. Order
    /// results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `ExascaleDbStorageVault.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExascaleDbStorageVaultsResponse {
    /// The ExascaleDbStorageVaults.
    #[prost(message, repeated, tag = "1")]
    pub exascale_db_storage_vaults: ::prost::alloc::vec::Vec<ExascaleDbStorageVault>,
    /// A token identifying a page of results the server should return. If present,
    /// the next page token can be provided to a subsequent
    /// ListExascaleDbStorageVaults call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `ExascaleDbStorageVault.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExascaleDbStorageVaultRequest {
    /// Required. The value for parent of the ExascaleDbStorageVault in the
    /// following format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the ExascaleDbStorageVault to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub exascale_db_storage_vault_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub exascale_db_storage_vault: ::core::option::Option<ExascaleDbStorageVault>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request message for `ExascaleDbStorageVault.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteExascaleDbStorageVaultRequest {
    /// Required. The name of the ExascaleDbStorageVault in the following format:
    /// projects/{project}/locations/{location}/exascaleDbStorageVaults/{exascale_db_storage_vault}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Details of the Oracle Grid Infrastructure (GI) version resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiVersionSummary/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GiVersion {
    /// Identifier. The name of the Oracle Grid Infrastructure (GI) version
    /// resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_versions}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. version
    #[prost(string, tag = "2")]
    pub version: ::prost::alloc::string::String,
}
/// Metadata for a given \[Location\]\[google.cloud.location.Location\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LocationMetadata {
    /// Output only. Google Cloud Platform Oracle zones in a location.
    #[prost(string, repeated, tag = "2")]
    pub gcp_oracle_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// MinorVersion represents a minor version of a GI.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/GiMinorVersionSummary/>
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MinorVersion {
    /// Identifier. The name of the MinorVersion resource with the format:
    /// projects/{project}/locations/{region}/giVersions/{gi_version}/minorVersions/{minor_version}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The ID of the Grid Image.
    #[prost(string, tag = "2")]
    pub grid_image_id: ::prost::alloc::string::String,
    /// Optional. The valid Oracle grid infrastructure software version.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
/// The request for `MinorVersion.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMinorVersionsRequest {
    /// Required. The parent value for the MinorVersion resource with the format:
    /// projects/{project}/locations/{location}/giVersions/{gi_version}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 System Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying the requested page of results to return. All
    /// fields except the filter should remain the same as in the request that
    /// provided this page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    /// Only shapeFamily and gcp_oracle_zone_id are supported in this format:
    /// `shape_family="{shapeFamily}" AND  gcp_oracle_zone_id="{gcp_oracle_zone_id}"`.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `MinorVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMinorVersionsResponse {
    /// The list of MinorVersions.
    #[prost(message, repeated, tag = "1")]
    pub minor_versions: ::prost::alloc::vec::Vec<MinorVersion>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents OdbNetwork resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OdbNetwork {
    /// Identifier. The name of the OdbNetwork resource in the following format:
    /// projects/{project}/locations/{region}/odbNetworks/{odb_network}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the VPC network in the following format:
    /// projects/{project}/global/networks/{network}
    #[prost(string, tag = "2")]
    pub network: ::prost::alloc::string::String,
    /// Optional. Labels or tags associated with the resource.
    #[prost(map = "string, string", tag = "3")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the OdbNetwork was created.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. State of the ODB Network.
    #[prost(enumeration = "odb_network::State", tag = "5")]
    pub state: i32,
    /// Output only. The ID of the subscription entitlement associated with the
    /// OdbNetwork.
    #[prost(string, tag = "6")]
    pub entitlement_id: ::prost::alloc::string::String,
    /// Optional. The GCP Oracle zone where OdbNetwork is hosted.
    /// Example: us-east4-b-r2.
    /// If not specified, the system will pick a zone based on availability.
    #[prost(string, tag = "7")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
}
/// Nested message and enum types in `OdbNetwork`.
pub mod odb_network {
    /// The various lifecycle states of the ODB Network.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in terminating state.
        Terminating = 3,
        /// Indicates that the resource is in failed state.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Terminating => "TERMINATING",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "TERMINATING" => Some(Self::Terminating),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// The request for `OdbNetwork.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOdbNetworkRequest {
    /// Required. The parent value for the OdbNetwork in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the OdbNetwork to create. This value is restricted
    /// to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    #[prost(string, tag = "2")]
    pub odb_network_id: ::prost::alloc::string::String,
    /// Required. Details of the OdbNetwork instance to create.
    #[prost(message, optional, tag = "3")]
    pub odb_network: ::core::option::Option<OdbNetwork>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `OdbNetwork.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteOdbNetworkRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `OdbNetwork.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListOdbNetworksRequest {
    /// Required. The parent value for the ODB Network in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ODB Networks will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `OdbNetwork.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOdbNetworksResponse {
    /// The list of ODB Networks.
    #[prost(message, repeated, tag = "1")]
    pub odb_networks: ::prost::alloc::vec::Vec<OdbNetwork>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unreachable locations when listing resources across all locations using
    /// wildcard location '-'.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request for `OdbNetwork.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOdbNetworkRequest {
    /// Required. The name of the OdbNetwork in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents OdbSubnet resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OdbSubnet {
    /// Identifier. The name of the OdbSubnet resource in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The CIDR range of the subnet.
    #[prost(string, tag = "2")]
    pub cidr_range: ::prost::alloc::string::String,
    /// Required. Purpose of the subnet.
    #[prost(enumeration = "odb_subnet::Purpose", tag = "3")]
    pub purpose: i32,
    /// Optional. Labels or tags associated with the resource.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the OdbNetwork was created.
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. State of the ODB Subnet.
    #[prost(enumeration = "odb_subnet::State", tag = "6")]
    pub state: i32,
}
/// Nested message and enum types in `OdbSubnet`.
pub mod odb_subnet {
    /// Purpose available for the subnet.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Purpose {
        /// Default unspecified value.
        Unspecified = 0,
        /// Subnet to be used for client connections.
        ClientSubnet = 1,
        /// Subnet to be used for backup.
        BackupSubnet = 2,
    }
    impl Purpose {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PURPOSE_UNSPECIFIED",
                Self::ClientSubnet => "CLIENT_SUBNET",
                Self::BackupSubnet => "BACKUP_SUBNET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PURPOSE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLIENT_SUBNET" => Some(Self::ClientSubnet),
                "BACKUP_SUBNET" => Some(Self::BackupSubnet),
                _ => None,
            }
        }
    }
    /// The various lifecycle states of the ODB Subnet.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in terminating state.
        Terminating = 3,
        /// Indicates that the resource is in failed state.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Terminating => "TERMINATING",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "TERMINATING" => Some(Self::Terminating),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// The request for `OdbSubnet.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateOdbSubnetRequest {
    /// Required. The parent value for the OdbSubnet in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the OdbSubnet to create. This value is restricted
    /// to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    #[prost(string, tag = "2")]
    pub odb_subnet_id: ::prost::alloc::string::String,
    /// Required. Details of the OdbSubnet instance to create.
    #[prost(message, optional, tag = "3")]
    pub odb_subnet: ::core::option::Option<OdbSubnet>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `OdbSubnet.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteOdbSubnetRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{region}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `OdbSubnet.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListOdbSubnetsRequest {
    /// Required. The parent value for the OdbSubnet in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ODB Networks will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `OdbSubnet.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOdbSubnetsResponse {
    /// The list of ODB Subnets.
    #[prost(message, repeated, tag = "1")]
    pub odb_subnets: ::prost::alloc::vec::Vec<OdbSubnet>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unreachable locations when listing resources across all locations using
    /// wildcard location '-'.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request for `OdbSubnet.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOdbSubnetRequest {
    /// Required. The name of the OdbSubnet in the following format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Details of the Cloud VM Cluster resource.
/// <https://docs.oracle.com/en-us/iaas/api/#/en/database/20160918/CloudVmCluster/>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudVmCluster {
    /// Identifier. The name of the VM Cluster resource with the format:
    /// projects/{project}/locations/{region}/cloudVmClusters/{cloud_vm_cluster}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the Exadata Infrastructure resource on which VM
    /// cluster resource is created, in the following format:
    /// projects/{project}/locations/{region}/cloudExadataInfrastuctures/{cloud_extradata_infrastructure}
    #[prost(string, tag = "2")]
    pub exadata_infrastructure: ::prost::alloc::string::String,
    /// Optional. User friendly name for this resource.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Various properties of the VM Cluster.
    #[prost(message, optional, tag = "6")]
    pub properties: ::core::option::Option<CloudVmClusterProperties>,
    /// Optional. Labels or tags associated with the VM Cluster.
    #[prost(map = "string, string", tag = "7")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The date and time that the VM cluster was created.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Network settings. CIDR to use for cluster IP allocation.
    #[prost(string, tag = "9")]
    pub cidr: ::prost::alloc::string::String,
    /// Optional. CIDR range of the backup subnet.
    #[prost(string, tag = "10")]
    pub backup_subnet_cidr: ::prost::alloc::string::String,
    /// Optional. The name of the VPC network.
    /// Format: projects/{project}/global/networks/{network}
    #[prost(string, tag = "11")]
    pub network: ::prost::alloc::string::String,
    /// Output only. The GCP Oracle zone where Oracle CloudVmCluster is hosted.
    /// This will be the same as the gcp_oracle_zone of the
    /// CloudExadataInfrastructure. Example: us-east4-b-r2.
    #[prost(string, tag = "12")]
    pub gcp_oracle_zone: ::prost::alloc::string::String,
    /// Optional. The name of the OdbNetwork associated with the VM Cluster.
    /// Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}
    /// It is optional but if specified, this should match the parent ODBNetwork of
    /// the odb_subnet and backup_odb_subnet.
    #[prost(string, tag = "13")]
    pub odb_network: ::prost::alloc::string::String,
    /// Optional. The name of the OdbSubnet associated with the VM Cluster for
    /// IP allocation. Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "14")]
    pub odb_subnet: ::prost::alloc::string::String,
    /// Optional. The name of the backup OdbSubnet associated with the VM Cluster.
    /// Format:
    /// projects/{project}/locations/{location}/odbNetworks/{odb_network}/odbSubnets/{odb_subnet}
    #[prost(string, tag = "15")]
    pub backup_odb_subnet: ::prost::alloc::string::String,
    /// Output only. The identity connector details which will allow OCI to
    /// securely access the resources in the customer project.
    #[prost(message, optional, tag = "16")]
    pub identity_connector: ::core::option::Option<IdentityConnector>,
}
/// Various properties and settings associated with Exadata VM cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudVmClusterProperties {
    /// Output only. Oracle Cloud Infrastructure ID of VM Cluster.
    #[prost(string, tag = "1")]
    pub ocid: ::prost::alloc::string::String,
    /// Required. License type of VM Cluster.
    #[prost(enumeration = "cloud_vm_cluster_properties::LicenseType", tag = "2")]
    pub license_type: i32,
    /// Optional. Grid Infrastructure Version.
    #[prost(string, tag = "3")]
    pub gi_version: ::prost::alloc::string::String,
    /// Optional. Time zone of VM Cluster to set. Defaults to UTC if not specified.
    #[prost(message, optional, tag = "4")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
    /// Optional. SSH public keys to be stored with cluster.
    #[prost(string, repeated, tag = "5")]
    pub ssh_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Number of database servers.
    #[prost(int32, tag = "6")]
    pub node_count: i32,
    /// Output only. Shape of VM Cluster.
    #[prost(string, tag = "7")]
    pub shape: ::prost::alloc::string::String,
    /// Optional. OCPU count per VM. Minimum is 0.1.
    #[prost(float, tag = "8")]
    pub ocpu_count: f32,
    /// Optional. Memory allocated in GBs.
    #[prost(int32, tag = "9")]
    pub memory_size_gb: i32,
    /// Optional. Local storage per VM.
    #[prost(int32, tag = "10")]
    pub db_node_storage_size_gb: i32,
    /// Output only. The storage allocation for the disk group, in gigabytes (GB).
    #[prost(int32, tag = "11")]
    pub storage_size_gb: i32,
    /// Optional. The data disk group size to be allocated in TBs.
    #[prost(double, tag = "12")]
    pub data_storage_size_tb: f64,
    /// Optional. The type of redundancy.
    #[prost(enumeration = "cloud_vm_cluster_properties::DiskRedundancy", tag = "13")]
    pub disk_redundancy: i32,
    /// Optional. Use exadata sparse snapshots.
    #[prost(bool, tag = "14")]
    pub sparse_diskgroup_enabled: bool,
    /// Optional. Use local backup.
    #[prost(bool, tag = "15")]
    pub local_backup_enabled: bool,
    /// Optional. Prefix for VM cluster host names.
    #[prost(string, tag = "16")]
    pub hostname_prefix: ::prost::alloc::string::String,
    /// Optional. Data collection options for diagnostics.
    #[prost(message, optional, tag = "19")]
    pub diagnostics_data_collection_options: ::core::option::Option<
        DataCollectionOptions,
    >,
    /// Output only. State of the cluster.
    #[prost(enumeration = "cloud_vm_cluster_properties::State", tag = "20")]
    pub state: i32,
    /// Output only. SCAN listener port - TCP
    #[prost(int32, tag = "21")]
    pub scan_listener_port_tcp: i32,
    /// Output only. SCAN listener port - TLS
    #[prost(int32, tag = "22")]
    pub scan_listener_port_tcp_ssl: i32,
    /// Output only. Parent DNS domain where SCAN DNS and hosts names are
    /// qualified. ex: ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[prost(string, tag = "23")]
    pub domain: ::prost::alloc::string::String,
    /// Output only. SCAN DNS name.
    /// ex: sp2-yi0xq-scan.ocispdelegated.ocisp10jvnet.oraclevcn.com
    #[prost(string, tag = "24")]
    pub scan_dns: ::prost::alloc::string::String,
    /// Output only. host name without domain.
    /// format: "\<hostname_prefix>-" with some suffix.
    /// ex: sp2-yi0xq where "sp2" is the hostname_prefix.
    #[prost(string, tag = "25")]
    pub hostname: ::prost::alloc::string::String,
    /// Required. Number of enabled CPU cores.
    #[prost(int32, tag = "26")]
    pub cpu_core_count: i32,
    /// Optional. Operating system version of the image.
    #[prost(string, tag = "27")]
    pub system_version: ::prost::alloc::string::String,
    /// Output only. OCIDs of scan IPs.
    #[prost(string, repeated, tag = "28")]
    pub scan_ip_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. OCID of scan DNS record.
    #[prost(string, tag = "29")]
    pub scan_dns_record_id: ::prost::alloc::string::String,
    /// Output only. Deep link to the OCI console to view this resource.
    #[prost(string, tag = "30")]
    pub oci_url: ::prost::alloc::string::String,
    /// Optional. OCID of database servers.
    #[prost(string, repeated, tag = "31")]
    pub db_server_ocids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Compartment ID of cluster.
    #[prost(string, tag = "32")]
    pub compartment_id: ::prost::alloc::string::String,
    /// Output only. DNS listener IP.
    #[prost(string, tag = "35")]
    pub dns_listener_ip: ::prost::alloc::string::String,
    /// Optional. OCI Cluster name.
    #[prost(string, tag = "36")]
    pub cluster_name: ::prost::alloc::string::String,
    /// Output only. The compute model of the VM Cluster.
    #[prost(enumeration = "ComputeModel", tag = "37")]
    pub compute_model: i32,
}
/// Nested message and enum types in `CloudVmClusterProperties`.
pub mod cloud_vm_cluster_properties {
    /// Different licenses supported.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseType {
        /// Unspecified
        Unspecified = 0,
        /// License included part of offer
        LicenseIncluded = 1,
        /// Bring your own license
        BringYourOwnLicense = 2,
    }
    impl LicenseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_TYPE_UNSPECIFIED",
                Self::LicenseIncluded => "LICENSE_INCLUDED",
                Self::BringYourOwnLicense => "BRING_YOUR_OWN_LICENSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE_INCLUDED" => Some(Self::LicenseIncluded),
                "BRING_YOUR_OWN_LICENSE" => Some(Self::BringYourOwnLicense),
                _ => None,
            }
        }
    }
    /// Types of disk redundancy provided by Oracle.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DiskRedundancy {
        /// Unspecified.
        Unspecified = 0,
        /// High -  3 way mirror.
        High = 1,
        /// Normal - 2 way mirror.
        Normal = 2,
    }
    impl DiskRedundancy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DISK_REDUNDANCY_UNSPECIFIED",
                Self::High => "HIGH",
                Self::Normal => "NORMAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DISK_REDUNDANCY_UNSPECIFIED" => Some(Self::Unspecified),
                "HIGH" => Some(Self::High),
                "NORMAL" => Some(Self::Normal),
                _ => None,
            }
        }
    }
    /// The various lifecycle states of the VM cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default unspecified value.
        Unspecified = 0,
        /// Indicates that the resource is in provisioning state.
        Provisioning = 1,
        /// Indicates that the resource is in available state.
        Available = 2,
        /// Indicates that the resource is in updating state.
        Updating = 3,
        /// Indicates that the resource is in terminating state.
        Terminating = 4,
        /// Indicates that the resource is in terminated state.
        Terminated = 5,
        /// Indicates that the resource is in failed state.
        Failed = 6,
        /// Indicates that the resource is in maintenance in progress state.
        MaintenanceInProgress = 7,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Provisioning => "PROVISIONING",
                Self::Available => "AVAILABLE",
                Self::Updating => "UPDATING",
                Self::Terminating => "TERMINATING",
                Self::Terminated => "TERMINATED",
                Self::Failed => "FAILED",
                Self::MaintenanceInProgress => "MAINTENANCE_IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING" => Some(Self::Provisioning),
                "AVAILABLE" => Some(Self::Available),
                "UPDATING" => Some(Self::Updating),
                "TERMINATING" => Some(Self::Terminating),
                "TERMINATED" => Some(Self::Terminated),
                "FAILED" => Some(Self::Failed),
                "MAINTENANCE_IN_PROGRESS" => Some(Self::MaintenanceInProgress),
                _ => None,
            }
        }
    }
}
/// Data collection options for diagnostics.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataCollectionOptions {
    /// Optional. Indicates whether diagnostic collection is enabled for the VM
    /// cluster
    #[prost(bool, tag = "1")]
    pub diagnostics_events_enabled: bool,
    /// Optional. Indicates whether health monitoring is enabled for the VM cluster
    #[prost(bool, tag = "2")]
    pub health_monitoring_enabled: bool,
    /// Optional. Indicates whether incident logs and trace collection are enabled
    /// for the VM cluster
    #[prost(bool, tag = "3")]
    pub incident_logs_enabled: bool,
}
/// The request for `CloudExadataInfrastructures.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudExadataInfrastructuresRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Exadata infrastructures will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `CloudExadataInfrastructures.list`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudExadataInfrastructuresResponse {
    /// The list of Exadata Infrastructures.
    #[prost(message, repeated, tag = "1")]
    pub cloud_exadata_infrastructures: ::prost::alloc::vec::Vec<
        CloudExadataInfrastructure,
    >,
    /// A token for fetching next page of response.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `CloudExadataInfrastructure.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `CloudExadataInfrastructure.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudExadataInfrastructureRequest {
    /// Required. The parent value for CloudExadataInfrastructure in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the Exadata Infrastructure to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub cloud_exadata_infrastructure_id: ::prost::alloc::string::String,
    /// Required. Details of the Exadata Infrastructure instance to create.
    #[prost(message, optional, tag = "3")]
    pub cloud_exadata_infrastructure: ::core::option::Option<CloudExadataInfrastructure>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `CloudExadataInfrastructure.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCloudExadataInfrastructureRequest {
    /// Required. The name of the Cloud Exadata Infrastructure in the following
    /// format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloud_exadata_infrastructure}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, all VM clusters for this Exadata Infrastructure
    /// will be deleted. An Exadata Infrastructure can only be deleted once all its
    /// VM clusters have been deleted.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// The request for `CloudVmCluster.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudVmClustersRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The number of VM clusters to return.
    /// If unspecified, at most 50 VM clusters will be returned.
    /// The maximum value is 1,000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying the page of results the server returns.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `CloudVmCluster.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudVmClustersResponse {
    /// The list of VM Clusters.
    #[prost(message, repeated, tag = "1")]
    pub cloud_vm_clusters: ::prost::alloc::vec::Vec<CloudVmCluster>,
    /// A token to fetch the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `CloudVmCluster.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `CloudVmCluster.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudVmClusterRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the VM Cluster to create. This value is restricted
    /// to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of 63
    /// characters in length. The value must start with a letter and end with
    /// a letter or a number.
    #[prost(string, tag = "2")]
    pub cloud_vm_cluster_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub cloud_vm_cluster: ::core::option::Option<CloudVmCluster>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `CloudVmCluster.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCloudVmClusterRequest {
    /// Required. The name of the Cloud VM Cluster in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloud_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
    /// Optional. If set to true, all child resources for the VM Cluster will be
    /// deleted. A VM Cluster can only be deleted once all its child resources have
    /// been deleted.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// The request for `Entitlement.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListEntitlementsRequest {
    /// Required. The parent value for the entitlement in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 entitlements will be returned.
    /// The maximum value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `Entitlement.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitlementsResponse {
    /// The list of Entitlements
    #[prost(message, repeated, tag = "1")]
    pub entitlements: ::prost::alloc::vec::Vec<Entitlement>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `DbServer.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDbServersRequest {
    /// Required. The parent value for database server in the following format:
    /// projects/{project}/locations/{location}/cloudExadataInfrastructures/{cloudExadataInfrastructure}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 db servers will be returned.
    /// The maximum value is 1000; values above 1000 will be reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `DbServer.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbServersResponse {
    /// The list of database servers.
    #[prost(message, repeated, tag = "1")]
    pub db_servers: ::prost::alloc::vec::Vec<DbServer>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `DbNode.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDbNodesRequest {
    /// Required. The parent value for database node in the following format:
    /// projects/{project}/locations/{location}/cloudVmClusters/{cloudVmCluster}.
    /// .
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 db nodes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the node should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `DbNode.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbNodesResponse {
    /// The list of DB Nodes
    #[prost(message, repeated, tag = "1")]
    pub db_nodes: ::prost::alloc::vec::Vec<DbNode>,
    /// A token identifying a page of results the node should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `GiVersion.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListGiVersionsRequest {
    /// Required. The parent value for Grid Infrastructure Version in the following
    /// format: Format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, a maximum of 50 Oracle Grid Infrastructure (GI) versions
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// reset to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// shape, gcp_oracle_zone and gi_version fields are supported in this format:
    /// `shape="{shape}"`.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `GiVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGiVersionsResponse {
    /// The list of Oracle Grid Infrastructure (GI) versions.
    #[prost(message, repeated, tag = "1")]
    pub gi_versions: ::prost::alloc::vec::Vec<GiVersion>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `DbSystemShape.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDbSystemShapesRequest {
    /// Required. The parent value for Database System Shapes in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 database system shapes will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// gcp_oracle_zone_id field is supported in this format:
    /// `gcp_oracle_zone_id="{gcp_oracle_zone_id}"`.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `DbSystemShape.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDbSystemShapesResponse {
    /// The list of Database System shapes.
    #[prost(message, repeated, tag = "1")]
    pub db_system_shapes: ::prost::alloc::vec::Vec<DbSystemShape>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. The status of the operation.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have \[Operation.error\]\[\] value with a
    /// \[google.rpc.Status.code\]\[google.rpc.Status.code\] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
    /// Output only. An estimated percentage of the operation that has been
    /// completed at a given moment of time, between 0 and 100.
    #[prost(double, tag = "8")]
    pub percent_complete: f64,
}
/// The request for `AutonomousDatabase.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAutonomousDatabasesRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous Database will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabase.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabasesResponse {
    /// The list of Autonomous Databases.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_databases: ::prost::alloc::vec::Vec<AutonomousDatabase>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAutonomousDatabaseRequest {
    /// Required. The name of the parent in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the Autonomous Database to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub autonomous_database_id: ::prost::alloc::string::String,
    /// Required. The Autonomous Database being created.
    #[prost(message, optional, tag = "3")]
    pub autonomous_database: ::core::option::Option<AutonomousDatabase>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Update`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAutonomousDatabaseRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Exadata resource by the update. The fields specified in the update_mask are
    /// relative to the resource, not the full request. A field will be overwritten
    /// if it is in the mask. If the user does not provide a mask then all fields
    /// will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub autonomous_database: ::core::option::Option<AutonomousDatabase>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAutonomousDatabaseRequest {
    /// Required. The name of the resource in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Restore`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestoreAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The time and date to restore the database to.
    #[prost(message, optional, tag = "2")]
    pub restore_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The request for `AutonomousDatabase.Stop`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StopAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Start`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.Restart`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RestartAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `OracleDatabase.SwitchoverAutonomousDatabase`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SwitchoverAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The peer database name to switch over to.
    #[prost(string, tag = "2")]
    pub peer_autonomous_database: ::prost::alloc::string::String,
}
/// The request for `OracleDatabase.FailoverAutonomousDatabase`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailoverAutonomousDatabaseRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The peer database name to fail over to.
    #[prost(string, tag = "2")]
    pub peer_autonomous_database: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateAutonomousDatabaseWalletRequest {
    /// Required. The name of the Autonomous Database in the following format:
    /// projects/{project}/locations/{location}/autonomousDatabases/{autonomous_database}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The type of wallet generation for the Autonomous Database. The
    /// default value is SINGLE.
    #[prost(enumeration = "GenerateType", tag = "2")]
    pub r#type: i32,
    /// Optional. True when requesting regional connection strings in PDB connect
    /// info, applicable to cross-region Data Guard only.
    #[prost(bool, tag = "3")]
    pub is_regional: bool,
    /// Required. The password used to encrypt the keys inside the wallet. The
    /// password must be a minimum of 8 characters.
    #[prost(string, tag = "4")]
    pub password: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabase.GenerateWallet`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateAutonomousDatabaseWalletResponse {
    /// Output only. The base64 encoded wallet files.
    #[prost(bytes = "vec", tag = "1")]
    pub archive_content: ::prost::alloc::vec::Vec<u8>,
}
/// The request for `AutonomousDbVersion.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAutonomousDbVersionsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Versions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `AutonomousDbVersion.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDbVersionsResponse {
    /// The list of Autonomous Database versions.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_db_versions: ::prost::alloc::vec::Vec<AutonomousDbVersion>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAutonomousDatabaseCharacterSetsRequest {
    /// Required. The parent value for the Autonomous Database in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Character Sets will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// **character_set_type** field is supported in the following format:
    /// `character_set_type="{characterSetType}"`. Accepted values include
    /// `DATABASE` and `NATIONAL`.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabaseCharacterSet.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabaseCharacterSetsResponse {
    /// The list of Autonomous Database Character Sets.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_database_character_sets: ::prost::alloc::vec::Vec<
        AutonomousDatabaseCharacterSet,
    >,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `AutonomousDatabaseBackup.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAutonomousDatabaseBackupsRequest {
    /// Required. The parent value for ListAutonomousDatabaseBackups in the
    /// following format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request. Only the
    /// **autonomous_database_id** field is supported in the following format:
    /// `autonomous_database_id="{autonomous_database_id}"`. The accepted values
    /// must be a valid Autonomous Database ID, limited to the naming
    /// restrictions of the ID: ^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$).
    /// The ID must start with a letter, end with a letter or a number, and be
    /// a maximum of 63 characters.
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 Autonomous DB Backups will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for `AutonomousDatabaseBackup.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutonomousDatabaseBackupsResponse {
    /// The list of Autonomous Database Backups.
    #[prost(message, repeated, tag = "1")]
    pub autonomous_database_backups: ::prost::alloc::vec::Vec<AutonomousDatabaseBackup>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `ExadbVmCluster.Create`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExadbVmClusterRequest {
    /// Required. The value for parent of the ExadbVmCluster in the following
    /// format: projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the ExadbVmCluster to create. This value is
    /// restricted to (^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$) and must be a maximum of
    /// 63 characters in length. The value must start with a letter and end with a
    /// letter or a number.
    #[prost(string, tag = "2")]
    pub exadb_vm_cluster_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub exadb_vm_cluster: ::core::option::Option<ExadbVmCluster>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `ExadbVmCluster.Delete`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteExadbVmClusterRequest {
    /// Required. The name of the ExadbVmCluster in the following format:
    /// projects/{project}/locations/{location}/exadbVmClusters/{exadb_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `ExadbVmCluster.Get`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetExadbVmClusterRequest {
    /// Required. The name of the ExadbVmCluster in the following format:
    /// projects/{project}/locations/{location}/exadbVmClusters/{exadb_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for `ExadbVmCluster.List`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListExadbVmClustersRequest {
    /// Required. The parent value for ExadbVmClusters in the following format:
    /// projects/{project}/locations/{location}.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of items to return.
    /// If unspecified, at most 50 ExadbVmClusters will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. An expression for ordering the results of the request.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response for `ExadbVmCluster.List`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExadbVmClustersResponse {
    /// The list of ExadbVmClusters.
    #[prost(message, repeated, tag = "1")]
    pub exadb_vm_clusters: ::prost::alloc::vec::Vec<ExadbVmCluster>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for `ExadbVmCluster.Update`. We only support adding the
/// Virtual Machine to the ExadbVmCluster. Rest of the fields in ExadbVmCluster
/// are immutable.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExadbVmClusterRequest {
    /// Optional. A mask specifying which fields in th VM Cluster should be
    /// updated. A field specified in the mask is overwritten. If a mask isn't
    /// provided then all the fields in the VM Cluster are overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated.
    #[prost(message, optional, tag = "2")]
    pub exadb_vm_cluster: ::core::option::Option<ExadbVmCluster>,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request for `ExadbVmCluster.RemoveVirtualMachine`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveVirtualMachineExadbVmClusterRequest {
    /// Required. The name of the ExadbVmCluster in the following format:
    /// projects/{project}/locations/{location}/exadbVmClusters/{exadb_vm_cluster}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional ID to identify the request. This value is used to
    /// identify duplicate requests. If you make a request with the same request ID
    /// and the original request is still in progress or completed, the server
    /// ignores the second request. This prevents clients from
    /// accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
    /// Required. The list of host names of db nodes to be removed from the
    /// ExadbVmCluster.
    #[prost(string, repeated, tag = "4")]
    pub hostnames: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod oracle_database_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct OracleDatabaseClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OracleDatabaseClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OracleDatabaseClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OracleDatabaseClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OracleDatabaseClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Exadata Infrastructures in a given project and location.
        pub async fn list_cloud_exadata_infrastructures(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListCloudExadataInfrastructuresRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudExadataInfrastructuresResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListCloudExadataInfrastructures",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListCloudExadataInfrastructures",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Exadata Infrastructure.
        pub async fn get_cloud_exadata_infrastructure(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudExadataInfrastructureRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloudExadataInfrastructure>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetCloudExadataInfrastructure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetCloudExadataInfrastructure",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Exadata Infrastructure in a given project and location.
        pub async fn create_cloud_exadata_infrastructure(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateCloudExadataInfrastructureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateCloudExadataInfrastructure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateCloudExadataInfrastructure",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Exadata Infrastructure.
        pub async fn delete_cloud_exadata_infrastructure(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteCloudExadataInfrastructureRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteCloudExadataInfrastructure",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteCloudExadataInfrastructure",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the VM Clusters in a given project and location.
        pub async fn list_cloud_vm_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudVmClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudVmClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListCloudVmClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListCloudVmClusters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single VM Cluster.
        pub async fn get_cloud_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudVmClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudVmCluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetCloudVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetCloudVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new VM Cluster in a given project and location.
        pub async fn create_cloud_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCloudVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateCloudVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateCloudVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single VM Cluster.
        pub async fn delete_cloud_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCloudVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteCloudVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteCloudVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the entitlements in a given project.
        pub async fn list_entitlements(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitlementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitlementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListEntitlements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListEntitlements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the database servers of an Exadata Infrastructure instance.
        pub async fn list_db_servers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbServersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbServersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbServers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbServers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the database nodes of a VM Cluster.
        pub async fn list_db_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbNodesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbNodesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbNodes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the valid Oracle Grid Infrastructure (GI) versions for the given
        /// project and location.
        pub async fn list_gi_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGiVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGiVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListGiVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListGiVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the valid minor versions for the given
        /// project, location, gi version and shape family.
        pub async fn list_minor_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMinorVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMinorVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListMinorVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListMinorVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the database system shapes available for the project and location.
        pub async fn list_db_system_shapes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbSystemShapesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbSystemShapesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbSystemShapes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbSystemShapes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Autonomous Databases in a given project and location.
        pub async fn list_autonomous_databases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutonomousDatabasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDatabasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDatabases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDatabases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a single Autonomous Database.
        pub async fn get_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AutonomousDatabase>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Autonomous Database in a given project and location.
        pub async fn create_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Autonomous Database.
        pub async fn update_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/UpdateAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "UpdateAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Autonomous Database.
        pub async fn delete_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restores a single Autonomous Database.
        pub async fn restore_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/RestoreAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "RestoreAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a wallet for an Autonomous Database.
        pub async fn generate_autonomous_database_wallet(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GenerateAutonomousDatabaseWalletRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GenerateAutonomousDatabaseWalletResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GenerateAutonomousDatabaseWallet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GenerateAutonomousDatabaseWallet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the available Autonomous Database versions for a project and
        /// location.
        pub async fn list_autonomous_db_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutonomousDbVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDbVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDbVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDbVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Autonomous Database Character Sets in a given project and location.
        pub async fn list_autonomous_database_character_sets(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListAutonomousDatabaseCharacterSetsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDatabaseCharacterSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDatabaseCharacterSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDatabaseCharacterSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the long-term and automatic backups of an Autonomous Database.
        pub async fn list_autonomous_database_backups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutonomousDatabaseBackupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAutonomousDatabaseBackupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListAutonomousDatabaseBackups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListAutonomousDatabaseBackups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops an Autonomous Database.
        pub async fn stop_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::StopAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/StopAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "StopAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts an Autonomous Database.
        pub async fn start_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::StartAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/StartAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "StartAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Restarts an Autonomous Database.
        pub async fn restart_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::RestartAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/RestartAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "RestartAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a switchover of specified autonomous database to the associated
        /// peer database.
        pub async fn switchover_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::SwitchoverAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/SwitchoverAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "SwitchoverAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a failover to target autonomous database from the associated
        /// primary database.
        pub async fn failover_autonomous_database(
            &mut self,
            request: impl tonic::IntoRequest<super::FailoverAutonomousDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/FailoverAutonomousDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "FailoverAutonomousDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the ODB Networks in a given project and location.
        pub async fn list_odb_networks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOdbNetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOdbNetworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListOdbNetworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListOdbNetworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ODB Network.
        pub async fn get_odb_network(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOdbNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::OdbNetwork>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetOdbNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetOdbNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ODB Network in a given project and location.
        pub async fn create_odb_network(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateOdbNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateOdbNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateOdbNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ODB Network.
        pub async fn delete_odb_network(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOdbNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteOdbNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteOdbNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the ODB Subnets in a given ODB Network.
        pub async fn list_odb_subnets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOdbSubnetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOdbSubnetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListOdbSubnets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListOdbSubnets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ODB Subnet.
        pub async fn get_odb_subnet(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOdbSubnetRequest>,
        ) -> std::result::Result<tonic::Response<super::OdbSubnet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetOdbSubnet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetOdbSubnet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ODB Subnet in a given ODB Network.
        pub async fn create_odb_subnet(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateOdbSubnetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateOdbSubnet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateOdbSubnet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ODB Subnet.
        pub async fn delete_odb_subnet(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteOdbSubnetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteOdbSubnet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteOdbSubnet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the Exadb (Exascale) VM Clusters for the given project and
        /// location.
        pub async fn list_exadb_vm_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExadbVmClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExadbVmClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListExadbVmClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListExadbVmClusters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Exadb (Exascale) VM Cluster.
        pub async fn get_exadb_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExadbVmClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::ExadbVmCluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetExadbVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetExadbVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Exadb (Exascale) VM Cluster resource.
        pub async fn create_exadb_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExadbVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateExadbVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateExadbVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Exadb (Exascale) VM Cluster.
        pub async fn delete_exadb_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExadbVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteExadbVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteExadbVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single Exadb (Exascale) VM Cluster. To add virtual machines to
        /// existing exadb vm cluster, only pass the node count.
        pub async fn update_exadb_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExadbVmClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/UpdateExadbVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "UpdateExadbVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes virtual machines from an existing exadb vm cluster.
        pub async fn remove_virtual_machine_exadb_vm_cluster(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveVirtualMachineExadbVmClusterRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/RemoveVirtualMachineExadbVmCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "RemoveVirtualMachineExadbVmCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the ExascaleDB Storage Vaults for the given project and
        /// location.
        pub async fn list_exascale_db_storage_vaults(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExascaleDbStorageVaultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExascaleDbStorageVaultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListExascaleDbStorageVaults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListExascaleDbStorageVaults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single ExascaleDB Storage Vault.
        pub async fn get_exascale_db_storage_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExascaleDbStorageVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExascaleDbStorageVault>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetExascaleDbStorageVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetExascaleDbStorageVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new ExascaleDB Storage Vault resource.
        pub async fn create_exascale_db_storage_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExascaleDbStorageVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateExascaleDbStorageVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateExascaleDbStorageVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single ExascaleDB Storage Vault.
        pub async fn delete_exascale_db_storage_vault(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExascaleDbStorageVaultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteExascaleDbStorageVault",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteExascaleDbStorageVault",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the DbSystemInitialStorageSizes for the given project and
        /// location.
        pub async fn list_db_system_initial_storage_sizes(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListDbSystemInitialStorageSizesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListDbSystemInitialStorageSizesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbSystemInitialStorageSizes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbSystemInitialStorageSizes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the Databases for the given project, location and DbSystem.
        pub async fn list_databases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDatabasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDatabasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDatabases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDatabases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Database.
        pub async fn get_database(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatabaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Database>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the PluggableDatabases for the given project, location and
        /// Container Database.
        pub async fn list_pluggable_databases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPluggableDatabasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPluggableDatabasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListPluggableDatabases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListPluggableDatabases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single PluggableDatabase.
        pub async fn get_pluggable_database(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPluggableDatabaseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PluggableDatabase>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetPluggableDatabase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetPluggableDatabase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the DbSystems for the given project and location.
        pub async fn list_db_systems(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbSystemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbSystemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbSystems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbSystems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single DbSystem.
        pub async fn get_db_system(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDbSystemRequest>,
        ) -> std::result::Result<tonic::Response<super::DbSystem>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/GetDbSystem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "GetDbSystem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new DbSystem in a given project and location.
        pub async fn create_db_system(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDbSystemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/CreateDbSystem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "CreateDbSystem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single DbSystem.
        pub async fn delete_db_system(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDbSystemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/DeleteDbSystem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "DeleteDbSystem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List DbVersions for the given project and location.
        pub async fn list_db_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDbVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDbVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDbVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDbVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List DatabaseCharacterSets for the given project and location.
        pub async fn list_database_character_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDatabaseCharacterSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDatabaseCharacterSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.oracledatabase.v1.OracleDatabase/ListDatabaseCharacterSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.oracledatabase.v1.OracleDatabase",
                        "ListDatabaseCharacterSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
