// This file is @generated by prost-build.
/// Safety rating corresponding to the generated content.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SafetyRating {
    /// Output only. Harm category.
    #[prost(enumeration = "HarmCategory", tag = "1")]
    pub category: i32,
    /// Output only. Harm probability levels in the content.
    #[prost(enumeration = "safety_rating::HarmProbability", tag = "2")]
    pub probability: i32,
    /// Output only. Harm probability score.
    #[prost(float, tag = "5")]
    pub probability_score: f32,
    /// Output only. Harm severity levels in the content.
    #[prost(enumeration = "safety_rating::HarmSeverity", tag = "6")]
    pub severity: i32,
    /// Output only. Harm severity score.
    #[prost(float, tag = "7")]
    pub severity_score: f32,
    /// Output only. Indicates whether the content was filtered out because of this
    /// rating.
    #[prost(bool, tag = "3")]
    pub blocked: bool,
}
/// Nested message and enum types in `SafetyRating`.
pub mod safety_rating {
    /// Harm probability levels in the content.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmProbability {
        /// Harm probability unspecified.
        Unspecified = 0,
        /// Negligible level of harm.
        Negligible = 1,
        /// Low level of harm.
        Low = 2,
        /// Medium level of harm.
        Medium = 3,
        /// High level of harm.
        High = 4,
    }
    impl HarmProbability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_PROBABILITY_UNSPECIFIED",
                Self::Negligible => "NEGLIGIBLE",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_PROBABILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "NEGLIGIBLE" => Some(Self::Negligible),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
    /// Harm severity levels.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HarmSeverity {
        /// Harm severity unspecified.
        Unspecified = 0,
        /// Negligible level of harm severity.
        Negligible = 1,
        /// Low level of harm severity.
        Low = 2,
        /// Medium level of harm severity.
        Medium = 3,
        /// High level of harm severity.
        High = 4,
    }
    impl HarmSeverity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HARM_SEVERITY_UNSPECIFIED",
                Self::Negligible => "HARM_SEVERITY_NEGLIGIBLE",
                Self::Low => "HARM_SEVERITY_LOW",
                Self::Medium => "HARM_SEVERITY_MEDIUM",
                Self::High => "HARM_SEVERITY_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HARM_SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
                "HARM_SEVERITY_NEGLIGIBLE" => Some(Self::Negligible),
                "HARM_SEVERITY_LOW" => Some(Self::Low),
                "HARM_SEVERITY_MEDIUM" => Some(Self::Medium),
                "HARM_SEVERITY_HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
/// Harm categories that will block the content.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HarmCategory {
    /// The harm category is unspecified.
    Unspecified = 0,
    /// The harm category is hate speech.
    HateSpeech = 1,
    /// The harm category is dangerous content.
    DangerousContent = 2,
    /// The harm category is harassment.
    Harassment = 3,
    /// The harm category is sexually explicit content.
    SexuallyExplicit = 4,
    /// The harm category is civic integrity.
    CivicIntegrity = 5,
}
impl HarmCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "HARM_CATEGORY_UNSPECIFIED",
            Self::HateSpeech => "HARM_CATEGORY_HATE_SPEECH",
            Self::DangerousContent => "HARM_CATEGORY_DANGEROUS_CONTENT",
            Self::Harassment => "HARM_CATEGORY_HARASSMENT",
            Self::SexuallyExplicit => "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            Self::CivicIntegrity => "HARM_CATEGORY_CIVIC_INTEGRITY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HARM_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "HARM_CATEGORY_HATE_SPEECH" => Some(Self::HateSpeech),
            "HARM_CATEGORY_DANGEROUS_CONTENT" => Some(Self::DangerousContent),
            "HARM_CATEGORY_HARASSMENT" => Some(Self::Harassment),
            "HARM_CATEGORY_SEXUALLY_EXPLICIT" => Some(Self::SexuallyExplicit),
            "HARM_CATEGORY_CIVIC_INTEGRITY" => Some(Self::CivicIntegrity),
            _ => None,
        }
    }
}
/// Defines an answer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Answer {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions/*/answers/*`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The state of the answer generation.
    #[prost(enumeration = "answer::State", tag = "2")]
    pub state: i32,
    /// The textual answer.
    #[prost(string, tag = "3")]
    pub answer_text: ::prost::alloc::string::String,
    /// A score in the range of \[0, 1\] describing how grounded the answer is by the
    /// reference chunks.
    #[prost(double, optional, tag = "12")]
    pub grounding_score: ::core::option::Option<f64>,
    /// Citations.
    #[prost(message, repeated, tag = "4")]
    pub citations: ::prost::alloc::vec::Vec<answer::Citation>,
    /// Optional. Grounding supports.
    #[prost(message, repeated, tag = "13")]
    pub grounding_supports: ::prost::alloc::vec::Vec<answer::GroundingSupport>,
    /// References.
    #[prost(message, repeated, tag = "5")]
    pub references: ::prost::alloc::vec::Vec<answer::Reference>,
    /// Suggested related questions.
    #[prost(string, repeated, tag = "6")]
    pub related_questions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Answer generation steps.
    #[prost(message, repeated, tag = "7")]
    pub steps: ::prost::alloc::vec::Vec<answer::Step>,
    /// Query understanding information.
    #[prost(message, optional, tag = "10")]
    pub query_understanding_info: ::core::option::Option<answer::QueryUnderstandingInfo>,
    /// Additional answer-skipped reasons. This provides the reason for ignored
    /// cases. If nothing is skipped, this field is not set.
    #[prost(enumeration = "answer::AnswerSkippedReason", repeated, tag = "11")]
    pub answer_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
    /// Output only. Answer creation timestamp.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Answer completed timestamp.
    #[prost(message, optional, tag = "9")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Safety ratings.
    #[prost(message, repeated, tag = "14")]
    pub safety_ratings: ::prost::alloc::vec::Vec<SafetyRating>,
}
/// Nested message and enum types in `Answer`.
pub mod answer {
    /// Citation info for a segment.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Citation {
        /// Index indicates the start of the segment, measured in bytes (UTF-8
        /// unicode). If there are multi-byte characters,such as non-ASCII
        /// characters, the index measurement is longer than the string length.
        #[prost(int64, tag = "1")]
        pub start_index: i64,
        /// End of the attributed segment, exclusive. Measured in bytes (UTF-8
        /// unicode). If there are multi-byte characters,such as non-ASCII
        /// characters, the index measurement is longer than the string length.
        #[prost(int64, tag = "2")]
        pub end_index: i64,
        /// Citation sources for the attributed segment.
        #[prost(message, repeated, tag = "3")]
        pub sources: ::prost::alloc::vec::Vec<CitationSource>,
    }
    /// Citation source.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CitationSource {
        /// ID of the citation source.
        #[prost(string, tag = "1")]
        pub reference_id: ::prost::alloc::string::String,
    }
    /// Grounding support for a claim in `answer_text`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroundingSupport {
        /// Required. Index indicates the start of the claim, measured in bytes
        /// (UTF-8 unicode).
        #[prost(int64, tag = "1")]
        pub start_index: i64,
        /// Required. End of the claim, exclusive.
        #[prost(int64, tag = "2")]
        pub end_index: i64,
        /// A score in the range of \[0, 1\] describing how grounded is a specific
        /// claim by the references.
        /// Higher value means that the claim is better supported by the reference
        /// chunks.
        #[prost(double, optional, tag = "3")]
        pub grounding_score: ::core::option::Option<f64>,
        /// Indicates that this claim required grounding check. When the
        /// system decided this claim didn't require attribution/grounding check,
        /// this field is set to false. In that case, no grounding check was
        /// done for the claim and therefore `grounding_score`, `sources` is not
        /// returned.
        #[prost(bool, optional, tag = "4")]
        pub grounding_check_required: ::core::option::Option<bool>,
        /// Optional. Citation sources for the claim.
        #[prost(message, repeated, tag = "5")]
        pub sources: ::prost::alloc::vec::Vec<CitationSource>,
    }
    /// Reference.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reference {
        /// Search result content.
        #[prost(oneof = "reference::Content", tags = "1, 2, 3")]
        pub content: ::core::option::Option<reference::Content>,
    }
    /// Nested message and enum types in `Reference`.
    pub mod reference {
        /// Unstructured document information.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UnstructuredDocumentInfo {
            /// Document resource name.
            #[prost(string, tag = "1")]
            pub document: ::prost::alloc::string::String,
            /// URI for the document.
            #[prost(string, tag = "2")]
            pub uri: ::prost::alloc::string::String,
            /// Title.
            #[prost(string, tag = "3")]
            pub title: ::prost::alloc::string::String,
            /// List of cited chunk contents derived from document content.
            #[prost(message, repeated, tag = "4")]
            pub chunk_contents: ::prost::alloc::vec::Vec<
                unstructured_document_info::ChunkContent,
            >,
            /// The structured JSON metadata for the document.
            /// It is populated from the struct data from the Chunk in search result.
            #[prost(message, optional, tag = "5")]
            pub struct_data: ::core::option::Option<::prost_types::Struct>,
        }
        /// Nested message and enum types in `UnstructuredDocumentInfo`.
        pub mod unstructured_document_info {
            /// Chunk content.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ChunkContent {
                /// Chunk textual content.
                #[prost(string, tag = "1")]
                pub content: ::prost::alloc::string::String,
                /// Page identifier.
                #[prost(string, tag = "2")]
                pub page_identifier: ::prost::alloc::string::String,
                /// The relevance of the chunk for a given query. Values range from 0.0
                /// (completely irrelevant) to 1.0 (completely relevant).
                /// This value is for informational purpose only. It may change for
                /// the same query and chunk at any time due to a model retraining or
                /// change in implementation.
                #[prost(float, optional, tag = "3")]
                pub relevance_score: ::core::option::Option<f32>,
            }
        }
        /// Chunk information.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ChunkInfo {
            /// Chunk resource name.
            #[prost(string, tag = "1")]
            pub chunk: ::prost::alloc::string::String,
            /// Chunk textual content.
            #[prost(string, tag = "2")]
            pub content: ::prost::alloc::string::String,
            /// The relevance of the chunk for a given query. Values range from 0.0
            /// (completely irrelevant) to 1.0 (completely relevant).
            /// This value is for informational purpose only. It may change for
            /// the same query and chunk at any time due to a model retraining or
            /// change in implementation.
            #[prost(float, optional, tag = "3")]
            pub relevance_score: ::core::option::Option<f32>,
            /// Document metadata.
            #[prost(message, optional, tag = "4")]
            pub document_metadata: ::core::option::Option<chunk_info::DocumentMetadata>,
        }
        /// Nested message and enum types in `ChunkInfo`.
        pub mod chunk_info {
            /// Document metadata.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct DocumentMetadata {
                /// Document resource name.
                #[prost(string, tag = "1")]
                pub document: ::prost::alloc::string::String,
                /// URI for the document.
                #[prost(string, tag = "2")]
                pub uri: ::prost::alloc::string::String,
                /// Title.
                #[prost(string, tag = "3")]
                pub title: ::prost::alloc::string::String,
                /// Page identifier.
                #[prost(string, tag = "4")]
                pub page_identifier: ::prost::alloc::string::String,
                /// The structured JSON metadata for the document.
                /// It is populated from the struct data from the Chunk in search result.
                #[prost(message, optional, tag = "5")]
                pub struct_data: ::core::option::Option<::prost_types::Struct>,
            }
        }
        /// Structured search information.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct StructuredDocumentInfo {
            /// Document resource name.
            #[prost(string, tag = "1")]
            pub document: ::prost::alloc::string::String,
            /// Structured search data.
            #[prost(message, optional, tag = "2")]
            pub struct_data: ::core::option::Option<::prost_types::Struct>,
            /// Output only. The title of the document.
            #[prost(string, tag = "3")]
            pub title: ::prost::alloc::string::String,
            /// Output only. The URI of the document.
            #[prost(string, tag = "4")]
            pub uri: ::prost::alloc::string::String,
        }
        /// Search result content.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Content {
            /// Unstructured document information.
            #[prost(message, tag = "1")]
            UnstructuredDocumentInfo(UnstructuredDocumentInfo),
            /// Chunk information.
            #[prost(message, tag = "2")]
            ChunkInfo(ChunkInfo),
            /// Structured document information.
            #[prost(message, tag = "3")]
            StructuredDocumentInfo(StructuredDocumentInfo),
        }
    }
    /// Step information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Step {
        /// The state of the step.
        #[prost(enumeration = "step::State", tag = "1")]
        pub state: i32,
        /// The description of the step.
        #[prost(string, tag = "2")]
        pub description: ::prost::alloc::string::String,
        /// The thought of the step.
        #[prost(string, tag = "3")]
        pub thought: ::prost::alloc::string::String,
        /// Actions.
        #[prost(message, repeated, tag = "4")]
        pub actions: ::prost::alloc::vec::Vec<step::Action>,
    }
    /// Nested message and enum types in `Step`.
    pub mod step {
        /// Action.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Action {
            /// Observation.
            #[prost(message, optional, tag = "3")]
            pub observation: ::core::option::Option<action::Observation>,
            /// The action.
            #[prost(oneof = "action::Action", tags = "2")]
            pub action: ::core::option::Option<action::Action>,
        }
        /// Nested message and enum types in `Action`.
        pub mod action {
            /// Search action.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SearchAction {
                /// The query to search.
                #[prost(string, tag = "1")]
                pub query: ::prost::alloc::string::String,
            }
            /// Observation.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Observation {
                /// Search results observed by the search action, it can be snippets info
                /// or chunk info, depending on the citation type set by the user.
                #[prost(message, repeated, tag = "2")]
                pub search_results: ::prost::alloc::vec::Vec<observation::SearchResult>,
            }
            /// Nested message and enum types in `Observation`.
            pub mod observation {
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct SearchResult {
                    /// Document resource name.
                    #[prost(string, tag = "1")]
                    pub document: ::prost::alloc::string::String,
                    /// URI for the document.
                    #[prost(string, tag = "2")]
                    pub uri: ::prost::alloc::string::String,
                    /// Title.
                    #[prost(string, tag = "3")]
                    pub title: ::prost::alloc::string::String,
                    /// If citation_type is DOCUMENT_LEVEL_CITATION, populate document
                    /// level snippets.
                    #[prost(message, repeated, tag = "4")]
                    pub snippet_info: ::prost::alloc::vec::Vec<
                        search_result::SnippetInfo,
                    >,
                    /// If citation_type is CHUNK_LEVEL_CITATION and chunk mode is on,
                    /// populate chunk info.
                    #[prost(message, repeated, tag = "5")]
                    pub chunk_info: ::prost::alloc::vec::Vec<search_result::ChunkInfo>,
                    /// Data representation.
                    /// The structured JSON data for the document.
                    /// It's populated from the struct data from the Document, or the
                    /// Chunk in search result.
                    #[prost(message, optional, tag = "6")]
                    pub struct_data: ::core::option::Option<::prost_types::Struct>,
                }
                /// Nested message and enum types in `SearchResult`.
                pub mod search_result {
                    /// Snippet information.
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct SnippetInfo {
                        /// Snippet content.
                        #[prost(string, tag = "1")]
                        pub snippet: ::prost::alloc::string::String,
                        /// Status of the snippet defined by the search team.
                        #[prost(string, tag = "2")]
                        pub snippet_status: ::prost::alloc::string::String,
                    }
                    /// Chunk information.
                    #[derive(Clone, PartialEq, ::prost::Message)]
                    pub struct ChunkInfo {
                        /// Chunk resource name.
                        #[prost(string, tag = "1")]
                        pub chunk: ::prost::alloc::string::String,
                        /// Chunk textual content.
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                        /// The relevance of the chunk for a given query. Values range from
                        /// 0.0 (completely irrelevant) to 1.0 (completely relevant).
                        /// This value is for informational purpose only. It may change for
                        /// the same query and chunk at any time due to a model retraining or
                        /// change in implementation.
                        #[prost(float, optional, tag = "3")]
                        pub relevance_score: ::core::option::Option<f32>,
                    }
                }
            }
            /// The action.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum Action {
                /// Search action.
                #[prost(message, tag = "2")]
                SearchAction(SearchAction),
            }
        }
        /// Enumeration of the state of the step.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// Unknown.
            Unspecified = 0,
            /// Step is currently in progress.
            InProgress = 1,
            /// Step currently failed.
            Failed = 2,
            /// Step has succeeded.
            Succeeded = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::InProgress => "IN_PROGRESS",
                    Self::Failed => "FAILED",
                    Self::Succeeded => "SUCCEEDED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "IN_PROGRESS" => Some(Self::InProgress),
                    "FAILED" => Some(Self::Failed),
                    "SUCCEEDED" => Some(Self::Succeeded),
                    _ => None,
                }
            }
        }
    }
    /// Query understanding information.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct QueryUnderstandingInfo {
        /// Query classification information.
        #[prost(message, repeated, tag = "1")]
        pub query_classification_info: ::prost::alloc::vec::Vec<
            query_understanding_info::QueryClassificationInfo,
        >,
    }
    /// Nested message and enum types in `QueryUnderstandingInfo`.
    pub mod query_understanding_info {
        /// Query classification information.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct QueryClassificationInfo {
            /// Query classification type.
            #[prost(enumeration = "query_classification_info::Type", tag = "1")]
            pub r#type: i32,
            /// Classification output.
            #[prost(bool, tag = "2")]
            pub positive: bool,
        }
        /// Nested message and enum types in `QueryClassificationInfo`.
        pub mod query_classification_info {
            /// Query classification types.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                /// Unspecified query classification type.
                Unspecified = 0,
                /// Adversarial query classification type.
                AdversarialQuery = 1,
                /// Non-answer-seeking query classification type, for chit chat.
                NonAnswerSeekingQuery = 2,
                /// Jail-breaking query classification type.
                JailBreakingQuery = 3,
                /// Non-answer-seeking query classification type, for no clear intent.
                NonAnswerSeekingQueryV2 = 4,
                /// User defined query classification type.
                UserDefinedClassificationQuery = 5,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "TYPE_UNSPECIFIED",
                        Self::AdversarialQuery => "ADVERSARIAL_QUERY",
                        Self::NonAnswerSeekingQuery => "NON_ANSWER_SEEKING_QUERY",
                        Self::JailBreakingQuery => "JAIL_BREAKING_QUERY",
                        Self::NonAnswerSeekingQueryV2 => "NON_ANSWER_SEEKING_QUERY_V2",
                        Self::UserDefinedClassificationQuery => {
                            "USER_DEFINED_CLASSIFICATION_QUERY"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "ADVERSARIAL_QUERY" => Some(Self::AdversarialQuery),
                        "NON_ANSWER_SEEKING_QUERY" => Some(Self::NonAnswerSeekingQuery),
                        "JAIL_BREAKING_QUERY" => Some(Self::JailBreakingQuery),
                        "NON_ANSWER_SEEKING_QUERY_V2" => {
                            Some(Self::NonAnswerSeekingQueryV2)
                        }
                        "USER_DEFINED_CLASSIFICATION_QUERY" => {
                            Some(Self::UserDefinedClassificationQuery)
                        }
                        _ => None,
                    }
                }
            }
        }
    }
    /// Enumeration of the state of the answer generation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unknown.
        Unspecified = 0,
        /// Answer generation is currently in progress.
        InProgress = 1,
        /// Answer generation currently failed.
        Failed = 2,
        /// Answer generation has succeeded.
        Succeeded = 3,
        /// Answer generation is currently in progress.
        Streaming = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::InProgress => "IN_PROGRESS",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
                Self::Streaming => "STREAMING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "STREAMING" => Some(Self::Streaming),
                _ => None,
            }
        }
    }
    /// An enum for answer skipped reasons.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AnswerSkippedReason {
        /// Default value. The answer skipped reason is not specified.
        Unspecified = 0,
        /// The adversarial query ignored case.
        AdversarialQueryIgnored = 1,
        /// The non-answer seeking query ignored case
        ///
        /// Google skips the answer if the query is chit chat.
        NonAnswerSeekingQueryIgnored = 2,
        /// The out-of-domain query ignored case.
        ///
        /// Google skips the answer if there are no high-relevance search results.
        OutOfDomainQueryIgnored = 3,
        /// The potential policy violation case.
        ///
        /// Google skips the answer if there is a potential policy violation
        /// detected. This includes content that may be violent or toxic.
        PotentialPolicyViolation = 4,
        /// The no relevant content case.
        ///
        /// Google skips the answer if there is no relevant content in the
        /// retrieved search results.
        NoRelevantContent = 5,
        /// The jail-breaking query ignored case.
        ///
        /// For example, "Reply in the tone of a competing company's CEO".
        /// Google skips the answer if the query is classified as a jail-breaking
        /// query.
        JailBreakingQueryIgnored = 6,
        /// The customer policy violation case.
        ///
        /// Google skips the summary if there is a customer policy violation
        /// detected. The policy is defined by the customer.
        CustomerPolicyViolation = 7,
        /// The non-answer seeking query ignored case.
        ///
        /// Google skips the answer if the query doesn't have clear intent.
        NonAnswerSeekingQueryIgnoredV2 = 8,
        /// The low-grounded answer case.
        ///
        /// Google skips the answer if a well grounded answer was unable to be
        /// generated.
        LowGroundedAnswer = 9,
        /// The user defined query classification ignored case.
        ///
        /// Google skips the answer if the query is classified as a user defined
        /// query classification.
        UserDefinedClassificationQueryIgnored = 10,
        /// The unhelpful answer case.
        ///
        /// Google skips the answer if the answer is not helpful. This can be due to
        /// a variety of factors, including but not limited to: the query is not
        /// answerable, the answer is not relevant to the query, or the answer is
        /// not well-formatted.
        UnhelpfulAnswer = 11,
    }
    impl AnswerSkippedReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ANSWER_SKIPPED_REASON_UNSPECIFIED",
                Self::AdversarialQueryIgnored => "ADVERSARIAL_QUERY_IGNORED",
                Self::NonAnswerSeekingQueryIgnored => "NON_ANSWER_SEEKING_QUERY_IGNORED",
                Self::OutOfDomainQueryIgnored => "OUT_OF_DOMAIN_QUERY_IGNORED",
                Self::PotentialPolicyViolation => "POTENTIAL_POLICY_VIOLATION",
                Self::NoRelevantContent => "NO_RELEVANT_CONTENT",
                Self::JailBreakingQueryIgnored => "JAIL_BREAKING_QUERY_IGNORED",
                Self::CustomerPolicyViolation => "CUSTOMER_POLICY_VIOLATION",
                Self::NonAnswerSeekingQueryIgnoredV2 => {
                    "NON_ANSWER_SEEKING_QUERY_IGNORED_V2"
                }
                Self::LowGroundedAnswer => "LOW_GROUNDED_ANSWER",
                Self::UserDefinedClassificationQueryIgnored => {
                    "USER_DEFINED_CLASSIFICATION_QUERY_IGNORED"
                }
                Self::UnhelpfulAnswer => "UNHELPFUL_ANSWER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ANSWER_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "ADVERSARIAL_QUERY_IGNORED" => Some(Self::AdversarialQueryIgnored),
                "NON_ANSWER_SEEKING_QUERY_IGNORED" => {
                    Some(Self::NonAnswerSeekingQueryIgnored)
                }
                "OUT_OF_DOMAIN_QUERY_IGNORED" => Some(Self::OutOfDomainQueryIgnored),
                "POTENTIAL_POLICY_VIOLATION" => Some(Self::PotentialPolicyViolation),
                "NO_RELEVANT_CONTENT" => Some(Self::NoRelevantContent),
                "JAIL_BREAKING_QUERY_IGNORED" => Some(Self::JailBreakingQueryIgnored),
                "CUSTOMER_POLICY_VIOLATION" => Some(Self::CustomerPolicyViolation),
                "NON_ANSWER_SEEKING_QUERY_IGNORED_V2" => {
                    Some(Self::NonAnswerSeekingQueryIgnoredV2)
                }
                "LOW_GROUNDED_ANSWER" => Some(Self::LowGroundedAnswer),
                "USER_DEFINED_CLASSIFICATION_QUERY_IGNORED" => {
                    Some(Self::UserDefinedClassificationQueryIgnored)
                }
                "UNHELPFUL_ANSWER" => Some(Self::UnhelpfulAnswer),
                _ => None,
            }
        }
    }
}
/// AssistAnswer resource, main part of
/// \[AssistResponse\]\[google.cloud.discoveryengine.v1.AssistResponse\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssistAnswer {
    /// Immutable. Resource name of the `AssistAnswer`.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}/assistAnswers/{assist_answer}`
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// State of the answer generation.
    #[prost(enumeration = "assist_answer::State", tag = "2")]
    pub state: i32,
    /// Replies of the assistant.
    #[prost(message, repeated, tag = "3")]
    pub replies: ::prost::alloc::vec::Vec<assist_answer::Reply>,
    /// Reasons for not answering the assist call.
    #[prost(enumeration = "assist_answer::AssistSkippedReason", repeated, tag = "5")]
    pub assist_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `AssistAnswer`.
pub mod assist_answer {
    /// One part of the multi-part response of the assist call.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reply {
        /// Alternatives for the assistant reply.
        #[prost(oneof = "reply::Reply", tags = "1")]
        pub reply: ::core::option::Option<reply::Reply>,
    }
    /// Nested message and enum types in `Reply`.
    pub mod reply {
        /// Alternatives for the assistant reply.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Reply {
            /// Possibly grounded response text or media from the assistant.
            #[prost(message, tag = "1")]
            GroundedContent(super::super::AssistantGroundedContent),
        }
    }
    /// State of the answer generation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unknown.
        Unspecified = 0,
        /// Assist operation is currently in progress.
        InProgress = 1,
        /// Assist operation has failed.
        Failed = 2,
        /// Assist operation has succeeded.
        Succeeded = 3,
        /// Assist operation has been skipped.
        Skipped = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::InProgress => "IN_PROGRESS",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
                Self::Skipped => "SKIPPED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "SKIPPED" => Some(Self::Skipped),
                _ => None,
            }
        }
    }
    /// Possible reasons for not answering an assist call.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssistSkippedReason {
        /// Default value. Skip reason is not specified.
        Unspecified = 0,
        /// The assistant ignored the query, because it did not appear to be
        /// answer-seeking.
        NonAssistSeekingQueryIgnored = 1,
        /// The assistant ignored the query or refused to answer because of a
        /// customer policy violation (e.g., the query or the answer contained a
        /// banned phrase).
        CustomerPolicyViolation = 2,
    }
    impl AssistSkippedReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ASSIST_SKIPPED_REASON_UNSPECIFIED",
                Self::NonAssistSeekingQueryIgnored => "NON_ASSIST_SEEKING_QUERY_IGNORED",
                Self::CustomerPolicyViolation => "CUSTOMER_POLICY_VIOLATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ASSIST_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "NON_ASSIST_SEEKING_QUERY_IGNORED" => {
                    Some(Self::NonAssistSeekingQueryIgnored)
                }
                "CUSTOMER_POLICY_VIOLATION" => Some(Self::CustomerPolicyViolation),
                _ => None,
            }
        }
    }
}
/// Multi-modal content.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssistantContent {
    /// The producer of the content. Can be "model" or "user".
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    /// Optional. Indicates if the part is thought from the model.
    #[prost(bool, tag = "6")]
    pub thought: bool,
    /// Contained data.
    #[prost(oneof = "assistant_content::Data", tags = "2, 3, 4, 7, 8")]
    pub data: ::core::option::Option<assistant_content::Data>,
}
/// Nested message and enum types in `AssistantContent`.
pub mod assistant_content {
    /// Inline blob.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Blob {
        /// Required. The media type (MIME type) of the generated data.
        #[prost(string, tag = "1")]
        pub mime_type: ::prost::alloc::string::String,
        /// Required. Raw bytes.
        #[prost(bytes = "vec", tag = "2")]
        pub data: ::prost::alloc::vec::Vec<u8>,
    }
    /// A file, e.g., an audio summary.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct File {
        /// Required. The media type (MIME type) of the file.
        #[prost(string, tag = "1")]
        pub mime_type: ::prost::alloc::string::String,
        /// Required. The file ID.
        #[prost(string, tag = "2")]
        pub file_id: ::prost::alloc::string::String,
    }
    /// Code generated by the model that is meant to be executed by the model.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ExecutableCode {
        /// Required. The code content. Currently only supports Python.
        #[prost(string, tag = "2")]
        pub code: ::prost::alloc::string::String,
    }
    /// Result of executing ExecutableCode.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CodeExecutionResult {
        /// Required. Outcome of the code execution.
        #[prost(enumeration = "code_execution_result::Outcome", tag = "1")]
        pub outcome: i32,
        /// Optional. Contains stdout when code execution is successful, stderr or
        /// other description otherwise.
        #[prost(string, tag = "2")]
        pub output: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `CodeExecutionResult`.
    pub mod code_execution_result {
        /// Enumeration of possible outcomes of the code execution.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Outcome {
            /// Unspecified status. This value should not be used.
            Unspecified = 0,
            /// Code execution completed successfully.
            Ok = 1,
            /// Code execution finished but with a failure. `stderr` should contain the
            /// reason.
            Failed = 2,
            /// Code execution ran for too long, and was cancelled. There may or may
            /// not be a partial output present.
            DeadlineExceeded = 3,
        }
        impl Outcome {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OUTCOME_UNSPECIFIED",
                    Self::Ok => "OUTCOME_OK",
                    Self::Failed => "OUTCOME_FAILED",
                    Self::DeadlineExceeded => "OUTCOME_DEADLINE_EXCEEDED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OUTCOME_UNSPECIFIED" => Some(Self::Unspecified),
                    "OUTCOME_OK" => Some(Self::Ok),
                    "OUTCOME_FAILED" => Some(Self::Failed),
                    "OUTCOME_DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                    _ => None,
                }
            }
        }
    }
    /// Contained data.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Data {
        /// Inline text.
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
        /// Inline binary data.
        #[prost(message, tag = "3")]
        InlineData(Blob),
        /// A file, e.g., an audio summary.
        #[prost(message, tag = "4")]
        File(File),
        /// Code generated by the model that is meant to be executed.
        #[prost(message, tag = "7")]
        ExecutableCode(ExecutableCode),
        /// Result of executing an ExecutableCode.
        #[prost(message, tag = "8")]
        CodeExecutionResult(CodeExecutionResult),
    }
}
/// A piece of content and possibly its grounding information.
///
/// Not all content needs grounding. Phrases like "Of course, I will gladly
/// search it for you." do not need grounding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssistantGroundedContent {
    /// The content.
    #[prost(message, optional, tag = "1")]
    pub content: ::core::option::Option<AssistantContent>,
    /// Grounding metadata for various modals. It only supports text for now.
    #[prost(oneof = "assistant_grounded_content::Metadata", tags = "3")]
    pub metadata: ::core::option::Option<assistant_grounded_content::Metadata>,
}
/// Nested message and enum types in `AssistantGroundedContent`.
pub mod assistant_grounded_content {
    /// Grounding details for text sources.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextGroundingMetadata {
        /// Grounding information for parts of the text.
        #[prost(message, repeated, tag = "4")]
        pub segments: ::prost::alloc::vec::Vec<text_grounding_metadata::Segment>,
        /// References for the grounded text.
        #[prost(message, repeated, tag = "2")]
        pub references: ::prost::alloc::vec::Vec<text_grounding_metadata::Reference>,
    }
    /// Nested message and enum types in `TextGroundingMetadata`.
    pub mod text_grounding_metadata {
        /// Grounding information for a segment of the text.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Segment {
            /// Zero-based index indicating the start of the segment, measured in bytes
            /// of a UTF-8 string (i.e. characters encoded on multiple bytes have a
            /// length of more than one).
            #[prost(int64, tag = "1")]
            pub start_index: i64,
            /// End of the segment, exclusive.
            #[prost(int64, tag = "2")]
            pub end_index: i64,
            /// References for the segment.
            #[prost(int32, repeated, tag = "4")]
            pub reference_indices: ::prost::alloc::vec::Vec<i32>,
            /// Score for the segment.
            #[prost(float, tag = "5")]
            pub grounding_score: f32,
            /// The text segment itself.
            #[prost(string, tag = "6")]
            pub text: ::prost::alloc::string::String,
        }
        /// Referenced content and related document metadata.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct Reference {
            /// Referenced text content.
            #[prost(string, tag = "1")]
            pub content: ::prost::alloc::string::String,
            /// Document metadata.
            #[prost(message, optional, tag = "2")]
            pub document_metadata: ::core::option::Option<reference::DocumentMetadata>,
        }
        /// Nested message and enum types in `Reference`.
        pub mod reference {
            /// Document metadata.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct DocumentMetadata {
                /// Document resource name.
                #[prost(string, optional, tag = "1")]
                pub document: ::core::option::Option<::prost::alloc::string::String>,
                /// URI for the document. It may contain a URL that redirects to the
                /// actual website.
                #[prost(string, optional, tag = "2")]
                pub uri: ::core::option::Option<::prost::alloc::string::String>,
                /// Title.
                #[prost(string, optional, tag = "3")]
                pub title: ::core::option::Option<::prost::alloc::string::String>,
                /// Page identifier.
                #[prost(string, optional, tag = "4")]
                pub page_identifier: ::core::option::Option<
                    ::prost::alloc::string::String,
                >,
                /// Domain name from the document URI. Note that the `uri` field may
                /// contain a URL that redirects to the actual website, in which case
                /// this will contain the domain name of the target site.
                #[prost(string, optional, tag = "5")]
                pub domain: ::core::option::Option<::prost::alloc::string::String>,
            }
        }
    }
    /// Grounding metadata for various modals. It only supports text for now.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// Metadata for grounding based on text sources.
        #[prost(message, tag = "3")]
        TextGroundingMetadata(TextGroundingMetadata),
    }
}
/// Discovery Engine Assistant resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Assistant {
    /// Immutable. Resource name of the assistant.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/assistants/{assistant}`
    ///
    /// It must be a UTF-8 encoded string with a length limit of 1024 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Chunk captures all raw metadata information of items to be recommended or
/// searched in the chunk mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Chunk {
    /// The full resource name of the chunk.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}/chunks/{chunk_id}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Unique chunk ID of the current chunk.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// Content is a string from a document (parsed content).
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    /// Output only. Represents the relevance score based on similarity.
    /// Higher score indicates higher chunk relevance.
    /// The score is in range \[-1.0, 1.0\].
    /// Only populated on
    /// \[SearchResponse\]\[google.cloud.discoveryengine.v1.SearchResponse\].
    #[prost(double, optional, tag = "8")]
    pub relevance_score: ::core::option::Option<f64>,
    /// Metadata of the document from the current chunk.
    #[prost(message, optional, tag = "5")]
    pub document_metadata: ::core::option::Option<chunk::DocumentMetadata>,
    /// Output only. This field is OUTPUT_ONLY.
    /// It contains derived data that are not in the original input document.
    #[prost(message, optional, tag = "4")]
    pub derived_struct_data: ::core::option::Option<::prost_types::Struct>,
    /// Page span of the chunk.
    #[prost(message, optional, tag = "6")]
    pub page_span: ::core::option::Option<chunk::PageSpan>,
    /// Output only. Metadata of the current chunk.
    #[prost(message, optional, tag = "7")]
    pub chunk_metadata: ::core::option::Option<chunk::ChunkMetadata>,
    /// Output only. Image Data URLs if the current chunk contains images.
    /// Data URLs are composed of four parts: a prefix (data:), a MIME type
    /// indicating the type of data, an optional base64 token if non-textual,
    /// and the data itself:
    /// data:\[<mediatype>\]\[;base64\],<data>
    #[prost(string, repeated, tag = "9")]
    pub data_urls: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Annotation contents if the current chunk contains annotations.
    #[prost(string, repeated, tag = "11")]
    pub annotation_contents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The annotation metadata includes structured content in the
    /// current chunk.
    #[prost(message, repeated, tag = "12")]
    pub annotation_metadata: ::prost::alloc::vec::Vec<chunk::AnnotationMetadata>,
}
/// Nested message and enum types in `Chunk`.
pub mod chunk {
    /// Document metadata contains the information of the document of the current
    /// chunk.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DocumentMetadata {
        /// Uri of the document.
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        /// Title of the document.
        #[prost(string, tag = "2")]
        pub title: ::prost::alloc::string::String,
        /// Data representation.
        /// The structured JSON data for the document. It should conform to the
        /// registered \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] or an
        /// `INVALID_ARGUMENT` error is thrown.
        #[prost(message, optional, tag = "3")]
        pub struct_data: ::core::option::Option<::prost_types::Struct>,
    }
    /// Page span of the chunk.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PageSpan {
        /// The start page of the chunk.
        #[prost(int32, tag = "1")]
        pub page_start: i32,
        /// The end page of the chunk.
        #[prost(int32, tag = "2")]
        pub page_end: i32,
    }
    /// Metadata of the current chunk. This field is only populated on
    /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
    /// API.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChunkMetadata {
        /// The previous chunks of the current chunk. The number is controlled by
        /// \[SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec.num_previous_chunks\].
        /// This field is only populated on
        /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
        /// API.
        #[prost(message, repeated, tag = "1")]
        pub previous_chunks: ::prost::alloc::vec::Vec<super::Chunk>,
        /// The next chunks of the current chunk. The number is controlled by
        /// \[SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.ChunkSpec.num_next_chunks\].
        /// This field is only populated on
        /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
        /// API.
        #[prost(message, repeated, tag = "2")]
        pub next_chunks: ::prost::alloc::vec::Vec<super::Chunk>,
    }
    /// The structured content information.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StructuredContent {
        /// Output only. The structure type of the structured content.
        #[prost(enumeration = "StructureType", tag = "1")]
        pub structure_type: i32,
        /// Output only. The content of the structured content.
        #[prost(string, tag = "2")]
        pub content: ::prost::alloc::string::String,
    }
    /// The annotation metadata includes structured content in the current chunk.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AnnotationMetadata {
        /// Output only. The structured content information.
        #[prost(message, optional, tag = "1")]
        pub structured_content: ::core::option::Option<StructuredContent>,
        /// Output only. Image id is provided if the structured content is based on
        /// an image.
        #[prost(string, tag = "2")]
        pub image_id: ::prost::alloc::string::String,
    }
    /// Defines the types of the structured content that can be extracted.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StructureType {
        /// Default value.
        Unspecified = 0,
        /// Shareholder structure.
        ShareholderStructure = 1,
        /// Signature structure.
        SignatureStructure = 2,
        /// Checkbox structure.
        CheckboxStructure = 3,
    }
    impl StructureType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STRUCTURE_TYPE_UNSPECIFIED",
                Self::ShareholderStructure => "SHAREHOLDER_STRUCTURE",
                Self::SignatureStructure => "SIGNATURE_STRUCTURE",
                Self::CheckboxStructure => "CHECKBOX_STRUCTURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STRUCTURE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SHAREHOLDER_STRUCTURE" => Some(Self::ShareholderStructure),
                "SIGNATURE_STRUCTURE" => Some(Self::SignatureStructure),
                "CHECKBOX_STRUCTURE" => Some(Self::CheckboxStructure),
                _ => None,
            }
        }
    }
}
/// A floating point interval.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Interval {
    /// The lower bound of the interval. If neither of the min fields are
    /// set, then the lower bound is negative infinity.
    ///
    /// This field must be not larger than max.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(oneof = "interval::Min", tags = "1, 2")]
    pub min: ::core::option::Option<interval::Min>,
    /// The upper bound of the interval. If neither of the max fields are
    /// set, then the upper bound is positive infinity.
    ///
    /// This field must be not smaller than min.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(oneof = "interval::Max", tags = "3, 4")]
    pub max: ::core::option::Option<interval::Max>,
}
/// Nested message and enum types in `Interval`.
pub mod interval {
    /// The lower bound of the interval. If neither of the min fields are
    /// set, then the lower bound is negative infinity.
    ///
    /// This field must be not larger than max.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Min {
        /// Inclusive lower bound.
        #[prost(double, tag = "1")]
        Minimum(f64),
        /// Exclusive lower bound.
        #[prost(double, tag = "2")]
        ExclusiveMinimum(f64),
    }
    /// The upper bound of the interval. If neither of the max fields are
    /// set, then the upper bound is positive infinity.
    ///
    /// This field must be not smaller than min.
    /// Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Max {
        /// Inclusive upper bound.
        #[prost(double, tag = "3")]
        Maximum(f64),
        /// Exclusive upper bound.
        #[prost(double, tag = "4")]
        ExclusiveMaximum(f64),
    }
}
/// A custom attribute that is not explicitly modeled in a resource, e.g.
/// \[UserEvent\]\[google.cloud.discoveryengine.v1.UserEvent\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomAttribute {
    /// The textual values of this custom attribute. For example, `\["yellow",  "green"\]` when the key is "color".
    ///
    /// Empty string is not allowed. Otherwise, an `INVALID_ARGUMENT` error is
    /// returned.
    ///
    /// Exactly one of
    /// \[CustomAttribute.text\]\[google.cloud.discoveryengine.v1.CustomAttribute.text\]
    /// or
    /// \[CustomAttribute.numbers\]\[google.cloud.discoveryengine.v1.CustomAttribute.numbers\]
    /// should be set. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, repeated, tag = "1")]
    pub text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The numerical values of this custom attribute. For example, `\[2.3, 15.4\]`
    /// when the key is "lengths_cm".
    ///
    /// Exactly one of
    /// \[CustomAttribute.text\]\[google.cloud.discoveryengine.v1.CustomAttribute.text\]
    /// or
    /// \[CustomAttribute.numbers\]\[google.cloud.discoveryengine.v1.CustomAttribute.numbers\]
    /// should be set. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(double, repeated, tag = "2")]
    pub numbers: ::prost::alloc::vec::Vec<f64>,
}
/// Information of an end user.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserInfo {
    /// Highly recommended for logged-in users. Unique identifier for logged-in
    /// user, such as a user name. Don't set for anonymous users.
    ///
    /// Always use a hashed value for this ID.
    ///
    /// Don't set the field to the same fixed ID for different users. This mixes
    /// the event history of those users together, which results in degraded
    /// model quality.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "1")]
    pub user_id: ::prost::alloc::string::String,
    /// User agent as included in the HTTP header.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// This should not be set when using the client side event reporting with
    /// GTM or JavaScript tag in
    /// \[UserEventService.CollectUserEvent\]\[google.cloud.discoveryengine.v1.UserEventService.CollectUserEvent\]
    /// or if
    /// \[UserEvent.direct_user_request\]\[google.cloud.discoveryengine.v1.UserEvent.direct_user_request\]
    /// is set.
    #[prost(string, tag = "2")]
    pub user_agent: ::prost::alloc::string::String,
    /// Optional. IANA time zone, e.g. Europe/Budapest.
    #[prost(string, tag = "3")]
    pub time_zone: ::prost::alloc::string::String,
}
/// Double list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DoubleList {
    /// Double values.
    #[prost(double, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f64>,
}
/// Principal identifier of a user or a group.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Principal {
    /// Union field principal. Principal can be a user or a group.
    #[prost(oneof = "principal::Principal", tags = "1, 2, 3")]
    pub principal: ::core::option::Option<principal::Principal>,
}
/// Nested message and enum types in `Principal`.
pub mod principal {
    /// Union field principal. Principal can be a user or a group.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Principal {
        /// User identifier.
        /// For Google Workspace user account, user_id should be the google workspace
        /// user email.
        /// For non-google identity provider user account, user_id is the mapped user
        /// identifier configured during the workforcepool config.
        #[prost(string, tag = "1")]
        UserId(::prost::alloc::string::String),
        /// Group identifier.
        /// For Google Workspace user account, group_id should be the google
        /// workspace group email.
        /// For non-google identity provider user account, group_id is the mapped
        /// group identifier configured during the workforcepool config.
        #[prost(string, tag = "2")]
        GroupId(::prost::alloc::string::String),
        /// For 3P application identities which are not present in the customer
        /// identity provider.
        #[prost(string, tag = "3")]
        ExternalEntityId(::prost::alloc::string::String),
    }
}
/// Config to data store for `HEALTHCARE_FHIR` vertical.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthcareFhirConfig {
    /// Whether to enable configurable schema for `HEALTHCARE_FHIR` vertical.
    ///
    /// If set to `true`, the predefined healthcare fhir schema can be extended
    /// for more customized searching and filtering.
    #[prost(bool, tag = "1")]
    pub enable_configurable_schema: bool,
    /// Whether to enable static indexing for `HEALTHCARE_FHIR` batch
    /// ingestion.
    ///
    /// If set to `true`, the batch ingestion will be processed in a static
    /// indexing mode which is slower but more capable of handling larger
    /// volume.
    #[prost(bool, tag = "2")]
    pub enable_static_indexing_for_batch_ingestion: bool,
}
/// Promotion proto includes uri and other helping information to display the
/// promotion.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchLinkPromotion {
    /// Required. The title of the promotion.
    /// Maximum length: 160 characters.
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// Optional. The URL for the page the user wants to promote. Must be set for
    /// site search. For other verticals, this is optional.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    /// Optional. The \[Document\]\[google.cloud.discoveryengine.v1.Document\] the user
    /// wants to promote. For site search, leave unset and only populate uri. Can
    /// be set along with uri.
    #[prost(string, tag = "6")]
    pub document: ::prost::alloc::string::String,
    /// Optional. The promotion thumbnail image url.
    #[prost(string, tag = "3")]
    pub image_uri: ::prost::alloc::string::String,
    /// Optional. The Promotion description.
    /// Maximum length: 200 characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The enabled promotion will be returned for any serving configs
    /// associated with the parent of the control this promotion is attached to.
    ///
    /// This flag is used for basic site search only.
    #[prost(bool, tag = "5")]
    pub enabled: bool,
}
/// The industry vertical associated with the
/// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndustryVertical {
    /// Value used when unset.
    Unspecified = 0,
    /// The generic vertical for documents that are not specific to any industry
    /// vertical.
    Generic = 1,
    /// The media industry vertical.
    Media = 2,
    /// The healthcare FHIR vertical.
    HealthcareFhir = 7,
}
impl IndustryVertical {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDUSTRY_VERTICAL_UNSPECIFIED",
            Self::Generic => "GENERIC",
            Self::Media => "MEDIA",
            Self::HealthcareFhir => "HEALTHCARE_FHIR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDUSTRY_VERTICAL_UNSPECIFIED" => Some(Self::Unspecified),
            "GENERIC" => Some(Self::Generic),
            "MEDIA" => Some(Self::Media),
            "HEALTHCARE_FHIR" => Some(Self::HealthcareFhir),
            _ => None,
        }
    }
}
/// The type of solution.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SolutionType {
    /// Default value.
    Unspecified = 0,
    /// Used for Recommendations AI.
    Recommendation = 1,
    /// Used for Discovery Search.
    Search = 2,
    /// Used for use cases related to the Generative AI agent.
    Chat = 3,
    /// Used for use cases related to the Generative Chat agent.
    /// It's used for Generative chat engine only, the associated data stores
    /// must enrolled with `SOLUTION_TYPE_CHAT` solution.
    GenerativeChat = 4,
}
impl SolutionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SOLUTION_TYPE_UNSPECIFIED",
            Self::Recommendation => "SOLUTION_TYPE_RECOMMENDATION",
            Self::Search => "SOLUTION_TYPE_SEARCH",
            Self::Chat => "SOLUTION_TYPE_CHAT",
            Self::GenerativeChat => "SOLUTION_TYPE_GENERATIVE_CHAT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SOLUTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "SOLUTION_TYPE_RECOMMENDATION" => Some(Self::Recommendation),
            "SOLUTION_TYPE_SEARCH" => Some(Self::Search),
            "SOLUTION_TYPE_CHAT" => Some(Self::Chat),
            "SOLUTION_TYPE_GENERATIVE_CHAT" => Some(Self::GenerativeChat),
            _ => None,
        }
    }
}
/// Defines a further subdivision of `SolutionType`.
/// Specifically applies to
/// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchUseCase {
    /// Value used when unset. Will not occur in CSS.
    Unspecified = 0,
    /// Search use case. Expects the traffic has a non-empty
    /// \[query\]\[google.cloud.discoveryengine.v1.SearchRequest.query\].
    Search = 1,
    /// Browse use case. Expects the traffic has an empty
    /// \[query\]\[google.cloud.discoveryengine.v1.SearchRequest.query\].
    Browse = 2,
}
impl SearchUseCase {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEARCH_USE_CASE_UNSPECIFIED",
            Self::Search => "SEARCH_USE_CASE_SEARCH",
            Self::Browse => "SEARCH_USE_CASE_BROWSE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_USE_CASE_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_USE_CASE_SEARCH" => Some(Self::Search),
            "SEARCH_USE_CASE_BROWSE" => Some(Self::Browse),
            _ => None,
        }
    }
}
/// Tiers of search features. Different tiers might have different
/// pricing. To learn more, check the pricing documentation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchTier {
    /// Default value when the enum is unspecified. This is invalid to use.
    Unspecified = 0,
    /// Standard tier.
    Standard = 1,
    /// Enterprise tier.
    Enterprise = 2,
}
impl SearchTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEARCH_TIER_UNSPECIFIED",
            Self::Standard => "SEARCH_TIER_STANDARD",
            Self::Enterprise => "SEARCH_TIER_ENTERPRISE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_TIER_STANDARD" => Some(Self::Standard),
            "SEARCH_TIER_ENTERPRISE" => Some(Self::Enterprise),
            _ => None,
        }
    }
}
/// Add-on that provides additional functionality for search.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SearchAddOn {
    /// Default value when the enum is unspecified. This is invalid to use.
    Unspecified = 0,
    /// Large language model add-on.
    Llm = 1,
}
impl SearchAddOn {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEARCH_ADD_ON_UNSPECIFIED",
            Self::Llm => "SEARCH_ADD_ON_LLM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEARCH_ADD_ON_UNSPECIFIED" => Some(Self::Unspecified),
            "SEARCH_ADD_ON_LLM" => Some(Self::Llm),
            _ => None,
        }
    }
}
/// Document captures all raw metadata information of items to be recommended or
/// searched.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    /// Immutable. The full resource name of the document.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document_id}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Immutable. The identifier of the document.
    ///
    /// Id should conform to [RFC-1034](<https://tools.ietf.org/html/rfc1034>)
    /// standard with a length limit of 128 characters.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    /// The identifier of the schema located in the same data store.
    #[prost(string, tag = "3")]
    pub schema_id: ::prost::alloc::string::String,
    /// The unstructured data linked to this document. Content can only be set
    /// and must be set if this document is under a `CONTENT_REQUIRED` data store.
    #[prost(message, optional, tag = "10")]
    pub content: ::core::option::Option<document::Content>,
    /// The identifier of the parent document. Currently supports at most two level
    /// document hierarchy.
    ///
    /// Id should conform to [RFC-1034](<https://tools.ietf.org/html/rfc1034>)
    /// standard with a length limit of 63 characters.
    #[prost(string, tag = "7")]
    pub parent_document_id: ::prost::alloc::string::String,
    /// Output only. This field is OUTPUT_ONLY.
    /// It contains derived data that are not in the original input document.
    #[prost(message, optional, tag = "6")]
    pub derived_struct_data: ::core::option::Option<::prost_types::Struct>,
    /// Access control information for the document.
    #[prost(message, optional, tag = "11")]
    pub acl_info: ::core::option::Option<document::AclInfo>,
    /// Output only. The last time the document was indexed. If this field is set,
    /// the document could be returned in search results.
    ///
    /// This field is OUTPUT_ONLY. If this field is not populated, it means the
    /// document has never been indexed.
    #[prost(message, optional, tag = "13")]
    pub index_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The index status of the document.
    ///
    /// * If document is indexed successfully, the index_time field is populated.
    /// * Otherwise, if document is not indexed due to errors, the error_samples
    ///   field is populated.
    /// * Otherwise, if document's index is in progress, the pending_message field
    ///   is populated.
    #[prost(message, optional, tag = "15")]
    pub index_status: ::core::option::Option<document::IndexStatus>,
    /// Data representation. One of
    /// \[struct_data\]\[google.cloud.discoveryengine.v1.Document.struct_data\] or
    /// \[json_data\]\[google.cloud.discoveryengine.v1.Document.json_data\] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    #[prost(oneof = "document::Data", tags = "4, 5")]
    pub data: ::core::option::Option<document::Data>,
}
/// Nested message and enum types in `Document`.
pub mod document {
    /// Unstructured data linked to this document.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Content {
        /// The MIME type of the content. Supported types:
        ///
        /// * `application/pdf` (PDF, only native PDFs are supported for now)
        /// * `text/html` (HTML)
        /// * `text/plain` (TXT)
        /// * `application/xml` or `text/xml` (XML)
        /// * `application/json` (JSON)
        /// * `application/vnd.openxmlformats-officedocument.wordprocessingml.document` (DOCX)
        /// * `application/vnd.openxmlformats-officedocument.presentationml.presentation` (PPTX)
        /// * `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
        ///   (XLSX)
        /// * `application/vnd.ms-excel.sheet.macroenabled.12` (XLSM)
        ///
        /// The following types are supported only if layout parser is enabled in the
        /// data store:
        ///
        /// * `image/bmp` (BMP)
        /// * `image/gif` (GIF)
        /// * `image/jpeg` (JPEG)
        /// * `image/png` (PNG)
        /// * `image/tiff` (TIFF)
        ///
        /// See <https://www.iana.org/assignments/media-types/media-types.xhtml.>
        #[prost(string, tag = "1")]
        pub mime_type: ::prost::alloc::string::String,
        /// The content of the unstructured document.
        #[prost(oneof = "content::Content", tags = "2, 3")]
        pub content: ::core::option::Option<content::Content>,
    }
    /// Nested message and enum types in `Content`.
    pub mod content {
        /// The content of the unstructured document.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Content {
            /// The content represented as a stream of bytes. The maximum length is
            /// 1,000,000 bytes (1 MB / ~0.95 MiB).
            ///
            /// Note: As with all `bytes` fields, this field is represented as pure
            /// binary in Protocol Buffers and base64-encoded string in JSON. For
            /// example, `abc123!?$*&()'-=@~` should be represented as
            /// `YWJjMTIzIT8kKiYoKSctPUB+` in JSON. See
            /// <https://developers.google.com/protocol-buffers/docs/proto3#json.>
            #[prost(bytes, tag = "2")]
            RawBytes(::prost::alloc::vec::Vec<u8>),
            /// The URI of the content. Only Cloud Storage URIs (e.g.
            /// `gs://bucket-name/path/to/file`) are supported. The maximum file size
            /// is 2.5 MB for text-based formats, 200 MB for other formats.
            #[prost(string, tag = "3")]
            Uri(::prost::alloc::string::String),
        }
    }
    /// ACL Information of the Document.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AclInfo {
        /// Readers of the document.
        #[prost(message, repeated, tag = "1")]
        pub readers: ::prost::alloc::vec::Vec<acl_info::AccessRestriction>,
    }
    /// Nested message and enum types in `AclInfo`.
    pub mod acl_info {
        /// AclRestriction to model complex inheritance restrictions.
        ///
        /// Example: Modeling a "Both Permit" inheritance, where to access a
        /// child document, user needs to have access to parent document.
        ///
        /// Document Hierarchy - Space_S --> Page_P.
        ///
        /// Readers:
        /// Space_S: group_1, user_1
        /// Page_P: group_2, group_3, user_2
        ///
        /// Space_S ACL Restriction -
        /// {
        /// "acl_info": {
        /// "readers": \[
        /// {
        /// "principals": \[
        /// {
        /// "group_id": "group_1"
        /// },
        /// {
        /// "user_id": "user_1"
        /// }
        /// \]
        /// }
        /// \]
        /// }
        /// }
        ///
        /// Page_P ACL Restriction.
        /// {
        /// "acl_info": {
        /// "readers": \[
        /// {
        /// "principals": \[
        /// {
        /// "group_id": "group_2"
        /// },
        /// {
        /// "group_id": "group_3"
        /// },
        /// {
        /// "user_id": "user_2"
        /// }
        /// \],
        /// },
        /// {
        /// "principals": \[
        /// {
        /// "group_id": "group_1"
        /// },
        /// {
        /// "user_id": "user_1"
        /// }
        /// \],
        /// }
        /// \]
        /// }
        /// }
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AccessRestriction {
            /// List of principals.
            #[prost(message, repeated, tag = "1")]
            pub principals: ::prost::alloc::vec::Vec<super::super::Principal>,
            /// All users within the Identity Provider.
            #[prost(bool, tag = "2")]
            pub idp_wide: bool,
        }
    }
    /// Index status of the document.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndexStatus {
        /// The time when the document was indexed.
        /// If this field is populated, it means the document has been indexed.
        #[prost(message, optional, tag = "1")]
        pub index_time: ::core::option::Option<::prost_types::Timestamp>,
        /// A sample of errors encountered while indexing the document.
        /// If this field is populated, the document is not indexed due to errors.
        #[prost(message, repeated, tag = "2")]
        pub error_samples: ::prost::alloc::vec::Vec<
            super::super::super::super::rpc::Status,
        >,
        /// Immutable. The message indicates the document index is in progress.
        /// If this field is populated, the document index is pending.
        #[prost(string, tag = "3")]
        pub pending_message: ::prost::alloc::string::String,
    }
    /// Data representation. One of
    /// \[struct_data\]\[google.cloud.discoveryengine.v1.Document.struct_data\] or
    /// \[json_data\]\[google.cloud.discoveryengine.v1.Document.json_data\] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Data {
        /// The structured JSON data for the document. It should conform to the
        /// registered \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] or an
        /// `INVALID_ARGUMENT` error is thrown.
        #[prost(message, tag = "4")]
        StructData(::prost_types::Struct),
        /// The JSON string representation of the document. It should conform to the
        /// registered \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] or an
        /// `INVALID_ARGUMENT` error is thrown.
        #[prost(string, tag = "5")]
        JsonData(::prost::alloc::string::String),
    }
}
/// Request message for
/// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
    /// Required. The resource name of the Search serving config, such as
    /// `projects/*/locations/global/collections/default_collection/engines/*/servingConfigs/default_serving_config`,
    /// or
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store/servingConfigs/default_serving_config`.
    /// This field is used to identify the serving configuration name, set
    /// of models used to make the search.
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    /// The branch resource name, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store/branches/0`.
    ///
    /// Use `default_branch` as the branch ID or leave this field empty, to search
    /// documents under the default branch.
    #[prost(string, tag = "2")]
    pub branch: ::prost::alloc::string::String,
    /// Raw search query.
    #[prost(string, tag = "3")]
    pub query: ::prost::alloc::string::String,
    /// Raw image query.
    #[prost(message, optional, tag = "19")]
    pub image_query: ::core::option::Option<search_request::ImageQuery>,
    /// Maximum number of \[Document\]\[google.cloud.discoveryengine.v1.Document\]s to
    /// return. The maximum allowed value depends on the data type. Values above
    /// the maximum value are coerced to the maximum value.
    ///
    /// * Websites with basic indexing: Default `10`, Maximum `25`.
    /// * Websites with advanced indexing: Default `25`, Maximum `50`.
    /// * Other: Default `50`, Maximum `100`.
    ///
    /// If this field is negative, an  `INVALID_ARGUMENT` is returned.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// A page token received from a previous
    /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
    /// must match the call that provided the page token. Otherwise, an
    /// `INVALID_ARGUMENT`  error is returned.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
    /// A 0-indexed integer that specifies the current offset (that is, starting
    /// result location, amongst the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s deemed by the API as
    /// relevant) in search results. This field is only considered if
    /// \[page_token\]\[google.cloud.discoveryengine.v1.SearchRequest.page_token\] is
    /// unset.
    ///
    /// If this field is negative, an  `INVALID_ARGUMENT`  is returned.
    #[prost(int32, tag = "6")]
    pub offset: i32,
    /// The maximum number of results to return for OneBox.
    /// This applies to each OneBox type individually.
    /// Default number is 10.
    #[prost(int32, tag = "47")]
    pub one_box_page_size: i32,
    /// Specifications that define the specific
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s to be searched,
    /// along with configurations for those data stores. This is only considered
    /// for \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]s with multiple data
    /// stores. For engines with a single data store, the specs directly under
    /// \[SearchRequest\]\[google.cloud.discoveryengine.v1.SearchRequest\] should be
    /// used.
    #[prost(message, repeated, tag = "32")]
    pub data_store_specs: ::prost::alloc::vec::Vec<search_request::DataStoreSpec>,
    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the documents being filtered. Filter
    /// expression is case-sensitive.
    ///
    /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
    ///
    /// Filtering in Vertex AI Search is done by mapping the LHS filter key to a
    /// key property defined in the Vertex AI Search backend -- this mapping is
    /// defined by the customer in their schema. For example a media customer might
    /// have a field 'name' in their schema. In this case the filter would look
    /// like this: filter --> name:'ANY("king kong")'
    ///
    /// For more information about filtering including syntax and filter
    /// operators, see
    /// [Filter](<https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata>)
    #[prost(string, tag = "7")]
    pub filter: ::prost::alloc::string::String,
    /// The default filter that is applied when a user performs a search without
    /// checking any filters on the search page.
    ///
    /// The filter applied to every search request when quality improvement such as
    /// query expansion is needed. In the case a query does not have a sufficient
    /// amount of results this filter will be used to determine whether or not to
    /// enable the query expansion flow. The original filter will still be used for
    /// the query expanded search.
    /// This field is strongly recommended to achieve high search quality.
    ///
    /// For more information about filter syntax, see
    /// \[SearchRequest.filter\]\[google.cloud.discoveryengine.v1.SearchRequest.filter\].
    #[prost(string, tag = "29")]
    pub canonical_filter: ::prost::alloc::string::String,
    /// The order in which documents are returned. Documents can be ordered by
    /// a field in an \[Document\]\[google.cloud.discoveryengine.v1.Document\] object.
    /// Leave it unset if ordered by relevance. `order_by` expression is
    /// case-sensitive.
    ///
    /// For more information on ordering the website search results, see
    /// [Order web search
    /// results](<https://cloud.google.com/generative-ai-app-builder/docs/order-web-search-results>).
    /// For more information on ordering the healthcare search results, see
    /// [Order healthcare search
    /// results](<https://cloud.google.com/generative-ai-app-builder/docs/order-hc-results>).
    /// If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
    #[prost(string, tag = "8")]
    pub order_by: ::prost::alloc::string::String,
    /// Information about the end user.
    /// Highly recommended for analytics and personalization.
    /// \[UserInfo.user_agent\]\[google.cloud.discoveryengine.v1.UserInfo.user_agent\]
    /// is used to deduce `device_type` for analytics.
    #[prost(message, optional, tag = "21")]
    pub user_info: ::core::option::Option<UserInfo>,
    /// The BCP-47 language code, such as "en-US" or "sr-Latn". For more
    /// information, see [Standard
    /// fields](<https://cloud.google.com/apis/design/standard_fields>). This field
    /// helps to better interpret the query. If a value isn't specified, the query
    /// language code is automatically detected, which may not be accurate.
    #[prost(string, tag = "35")]
    pub language_code: ::prost::alloc::string::String,
    /// Facet specifications for faceted search. If empty, no facets are returned.
    ///
    /// A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
    /// error is returned.
    #[prost(message, repeated, tag = "9")]
    pub facet_specs: ::prost::alloc::vec::Vec<search_request::FacetSpec>,
    /// Boost specification to boost certain documents.
    /// For more information on boosting, see
    /// [Boosting](<https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results>)
    #[prost(message, optional, tag = "10")]
    pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
    /// Additional search parameters.
    ///
    /// For public website search only, supported values are:
    ///
    /// * `user_country_code`: string. Default empty. If set to non-empty, results
    ///   are restricted or boosted based on the location provided.
    ///   For example, `user_country_code: "au"`
    ///
    ///   For available codes see [Country
    ///   Codes](<https://developers.google.com/custom-search/docs/json_api_reference#countryCodes>)
    ///
    /// * `search_type`: double. Default empty. Enables non-webpage searching
    ///   depending on the value. The only valid non-default value is 1,
    ///   which enables image searching.
    ///   For example, `search_type: 1`
    #[prost(map = "string, message", tag = "11")]
    pub params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    /// The query expansion specification that specifies the conditions under which
    /// query expansion occurs.
    #[prost(message, optional, tag = "13")]
    pub query_expansion_spec: ::core::option::Option<search_request::QueryExpansionSpec>,
    /// The spell correction specification that specifies the mode under
    /// which spell correction takes effect.
    #[prost(message, optional, tag = "14")]
    pub spell_correction_spec: ::core::option::Option<
        search_request::SpellCorrectionSpec,
    >,
    /// A unique identifier for tracking visitors. For example, this could be
    /// implemented with an HTTP cookie, which should be able to uniquely identify
    /// a visitor on a single device. This unique identifier should not change if
    /// the visitor logs in or out of the website.
    ///
    /// This field should NOT have a fixed value such as `unknown_visitor`.
    ///
    /// This should be the same identifier as
    /// \[UserEvent.user_pseudo_id\]\[google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id\]
    /// and
    /// \[CompleteQueryRequest.user_pseudo_id\]\[google.cloud.discoveryengine.v1.CompleteQueryRequest.user_pseudo_id\]
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an  `INVALID_ARGUMENT`  error is returned.
    #[prost(string, tag = "15")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    /// A specification for configuring the behavior of content search.
    #[prost(message, optional, tag = "24")]
    pub content_search_spec: ::core::option::Option<search_request::ContentSearchSpec>,
    /// Whether to turn on safe search. This is only supported for
    /// website search.
    #[prost(bool, tag = "20")]
    pub safe_search: bool,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "22")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Search as you type configuration. Only supported for the
    /// \[IndustryVertical.MEDIA\]\[google.cloud.discoveryengine.v1.IndustryVertical.MEDIA\]
    /// vertical.
    #[prost(message, optional, tag = "31")]
    pub search_as_you_type_spec: ::core::option::Option<
        search_request::SearchAsYouTypeSpec,
    >,
    /// Optional. Config for display feature, like match highlighting on search
    /// results.
    #[prost(message, optional, tag = "38")]
    pub display_spec: ::core::option::Option<search_request::DisplaySpec>,
    /// The session resource name. Optional.
    ///
    /// Session allows users to do multi-turn /search API calls or coordination
    /// between /search API calls and /answer API calls.
    ///
    /// Example #1 (multi-turn /search API calls):
    /// Call /search API with the session ID generated in the first call.
    /// Here, the previous search query gets considered in query
    /// standing. I.e., if the first query is "How did Alphabet do in 2022?"
    /// and the current query is "How about 2023?", the current query will
    /// be interpreted as "How did Alphabet do in 2023?".
    ///
    /// Example #2 (coordination between /search API calls and /answer API calls):
    /// Call /answer API with the session ID generated in the first call.
    /// Here, the answer generation happens in the context of the search
    /// results from the first search call.
    ///
    /// Multi-turn Search feature is currently at private GA stage. Please use
    /// v1alpha or v1beta version instead before we launch this feature to public
    /// GA. Or ask for allowlisting through Google Support team.
    #[prost(string, tag = "41")]
    pub session: ::prost::alloc::string::String,
    /// Session specification.
    ///
    /// Can be used only when `session` is set.
    #[prost(message, optional, tag = "42")]
    pub session_spec: ::core::option::Option<search_request::SessionSpec>,
    /// The relevance threshold of the search results.
    ///
    /// Default to Google defined threshold, leveraging a balance of
    /// precision and recall to deliver both highly accurate results and
    /// comprehensive coverage of relevant information.
    ///
    /// This feature is not supported for healthcare search.
    #[prost(enumeration = "search_request::RelevanceThreshold", tag = "44")]
    pub relevance_threshold: i32,
    /// Optional. The specification for returning the relevance score.
    #[prost(message, optional, tag = "52")]
    pub relevance_score_spec: ::core::option::Option<search_request::RelevanceScoreSpec>,
    /// The ranking expression controls the customized ranking on retrieval
    /// documents. This overrides
    /// \[ServingConfig.ranking_expression\]\[google.cloud.discoveryengine.v1.ServingConfig.ranking_expression\].
    /// The syntax and supported features depend on the
    /// `ranking_expression_backend` value. If `ranking_expression_backend` is not
    /// provided, it defaults to `RANK_BY_EMBEDDING`.
    ///
    /// If
    /// \[ranking_expression_backend\]\[google.cloud.discoveryengine.v1.SearchRequest.ranking_expression_backend\]
    /// is not provided or set to `RANK_BY_EMBEDDING`, it should be a single
    /// function or multiple functions that are joined by "+".
    ///
    /// * ranking_expression = function, { " + ", function };
    ///
    /// Supported functions:
    ///
    /// * double * relevance_score
    /// * double * dotProduct(embedding_field_path)
    ///
    /// Function variables:
    ///
    /// * `relevance_score`: pre-defined keywords, used for measure relevance
    ///   between query and document.
    /// * `embedding_field_path`: the document embedding field
    ///   used with query embedding vector.
    /// * `dotProduct`: embedding function between `embedding_field_path` and
    ///   query embedding vector.
    ///
    /// Example ranking expression:
    ///
    /// ```text
    /// If document has an embedding field doc_embedding, the ranking expression
    /// could be `0.5 * relevance_score + 0.3 * dotProduct(doc_embedding)`.
    /// ```
    ///
    /// If
    /// \[ranking_expression_backend\]\[google.cloud.discoveryengine.v1.SearchRequest.ranking_expression_backend\]
    /// is set to `RANK_BY_FORMULA`, the following expression types (and
    /// combinations of those chained using + or
    ///
    /// * operators) are supported:
    ///
    ///   * `double`
    ///   * `signal`
    ///   * `log(signal)`
    ///   * `exp(signal)`
    ///   * `rr(signal, double > 0)`  -- reciprocal rank transformation with second
    ///     argument being a denominator constant.
    ///   * `is_nan(signal)` -- returns 0 if signal is NaN, 1 otherwise.
    ///   * `fill_nan(signal1, signal2 | double)` -- if signal1 is NaN, returns
    ///     signal2 | double, else returns signal1.
    ///   Here are a few examples of ranking formulas that use the supported
    ///   ranking expression types:
    ///
    ///   * `0.2 * semantic_similarity_score + 0.8 * log(keyword_similarity_score)`
    ///     -- mostly rank by the logarithm of `keyword_similarity_score` with slight
    ///     `semantic_smilarity_score` adjustment.
    ///   * `0.2 * exp(fill_nan(semantic_similarity_score, 0)) + 0.3 * is_nan(keyword_similarity_score)` -- rank by the exponent of
    ///     `semantic_similarity_score` filling the value with 0 if it's NaN, also
    ///     add constant 0.3 adjustment to the final score if
    ///     `semantic_similarity_score` is NaN.
    ///   * `0.2 * rr(semantic_similarity_score, 16) + 0.8 * rr(keyword_similarity_score, 16)` -- mostly rank by the reciprocal rank
    ///     of `keyword_similarity_score` with slight adjustment of reciprocal rank
    ///     of `semantic_smilarity_score`.
    ///
    /// The following signals are supported:
    ///
    /// * `semantic_similarity_score`: semantic similarity adjustment that is
    ///   calculated using the embeddings generated by a proprietary Google model.
    ///   This score determines how semantically similar a search query is to a
    ///   document.
    /// * `keyword_similarity_score`: keyword match adjustment uses the Best
    ///   Match 25 (BM25) ranking function. This score is calculated using a
    ///   probabilistic model to estimate the probability that a document is
    ///   relevant to a given query.
    /// * `relevance_score`: semantic relevance adjustment that uses a
    ///   proprietary Google model to determine the meaning and intent behind a
    ///   user's query in context with the content in the documents.
    /// * `pctr_rank`: predicted conversion rate adjustment as a rank use
    ///   predicted Click-through rate (pCTR) to gauge the relevance and
    ///   attractiveness of a search result from a user's perspective. A higher
    ///   pCTR suggests that the result is more likely to satisfy the user's query
    ///   and intent, making it a valuable signal for ranking.
    /// * `freshness_rank`: freshness adjustment as a rank
    /// * `document_age`: The time in hours elapsed since the document was last
    ///   updated, a floating-point number (e.g., 0.25 means 15 minutes).
    /// * `topicality_rank`: topicality adjustment as a rank. Uses proprietary
    ///   Google model to determine the keyword-based overlap between the query and
    ///   the document.
    /// * `base_rank`: the default rank of the result
    #[prost(string, tag = "26")]
    pub ranking_expression: ::prost::alloc::string::String,
    /// The backend to use for the ranking expression evaluation.
    #[prost(enumeration = "search_request::RankingExpressionBackend", tag = "53")]
    pub ranking_expression_backend: i32,
}
/// Nested message and enum types in `SearchRequest`.
pub mod search_request {
    /// Specifies the image query input.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ImageQuery {
        #[prost(oneof = "image_query::Image", tags = "1")]
        pub image: ::core::option::Option<image_query::Image>,
    }
    /// Nested message and enum types in `ImageQuery`.
    pub mod image_query {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Image {
            /// Base64 encoded image bytes. Supported image formats: JPEG, PNG, and
            /// BMP.
            #[prost(string, tag = "1")]
            ImageBytes(::prost::alloc::string::String),
        }
    }
    /// A struct to define data stores to filter on in a search call and
    /// configurations for those data stores. Otherwise, an `INVALID_ARGUMENT`
    /// error is returned.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataStoreSpec {
        /// Required. Full resource name of
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], such as
        /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
        #[prost(string, tag = "1")]
        pub data_store: ::prost::alloc::string::String,
        /// Optional. Filter specification to filter documents in the data store
        /// specified by data_store field. For more information on filtering, see
        /// [Filtering](<https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata>)
        #[prost(string, tag = "5")]
        pub filter: ::prost::alloc::string::String,
        /// Optional. Boost specification to boost certain documents.
        /// For more information on boosting, see
        /// [Boosting](<https://cloud.google.com/generative-ai-app-builder/docs/boost-search-results>)
        #[prost(message, optional, tag = "6")]
        pub boost_spec: ::core::option::Option<BoostSpec>,
        /// Optional. Custom search operators which if specified will be used to
        /// filter results from workspace data stores. For more information on custom
        /// search operators, see
        /// [SearchOperators](<https://support.google.com/cloudsearch/answer/6172299>).
        #[prost(string, tag = "7")]
        pub custom_search_operators: ::prost::alloc::string::String,
    }
    /// A facet specification to perform faceted search.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FacetSpec {
        /// Required. The facet key specification.
        #[prost(message, optional, tag = "1")]
        pub facet_key: ::core::option::Option<facet_spec::FacetKey>,
        /// Maximum facet values that are returned for this facet. If
        /// unspecified, defaults to 20. The maximum allowed value is 300. Values
        /// above 300 are coerced to 300.
        /// For aggregation in healthcare search, when the \[FacetKey.key\] is
        /// "healthcare_aggregation_key", the limit will be overridden to
        /// 10,000 internally, regardless of the value set here.
        ///
        /// If this field is negative, an  `INVALID_ARGUMENT`  is returned.
        #[prost(int32, tag = "2")]
        pub limit: i32,
        /// List of keys to exclude when faceting.
        ///
        /// By default,
        /// \[FacetKey.key\]\[google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key\]
        /// is not excluded from the filter unless it is listed in this field.
        ///
        /// Listing a facet key in this field allows its values to appear as facet
        /// results, even when they are filtered out of search results. Using this
        /// field does not affect what search results are returned.
        ///
        /// For example, suppose there are 100 documents with the color facet "Red"
        /// and 200 documents with the color facet "Blue". A query containing the
        /// filter "color:ANY("Red")" and having "color" as
        /// \[FacetKey.key\]\[google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key\]
        /// would by default return only "Red" documents in the search results, and
        /// also return "Red" with count 100 as the only color facet. Although there
        /// are also blue documents available, "Blue" would not be shown as an
        /// available facet value.
        ///
        /// If "color" is listed in "excludedFilterKeys", then the query returns the
        /// facet values "Red" with count 100 and "Blue" with count 200, because the
        /// "color" key is now excluded from the filter. Because this field doesn't
        /// affect search results, the search results are still correctly filtered to
        /// return only "Red" documents.
        ///
        /// A maximum of 100 values are allowed. Otherwise, an  `INVALID_ARGUMENT`
        /// error is returned.
        #[prost(string, repeated, tag = "3")]
        pub excluded_filter_keys: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// Enables dynamic position for this facet. If set to true, the position of
        /// this facet among all facets in the response is determined automatically.
        /// If dynamic facets are enabled, it is ordered together.
        /// If set to false, the position of this facet in the
        /// response is the same as in the request, and it is ranked before
        /// the facets with dynamic position enable and all dynamic facets.
        ///
        /// For example, you may always want to have rating facet returned in
        /// the response, but it's not necessarily to always display the rating facet
        /// at the top. In that case, you can set enable_dynamic_position to true so
        /// that the position of rating facet in response is determined
        /// automatically.
        ///
        /// Another example, assuming you have the following facets in the request:
        ///
        /// * "rating", enable_dynamic_position = true
        ///
        /// * "price", enable_dynamic_position = false
        ///
        /// * "brands", enable_dynamic_position = false
        ///
        /// And also you have a dynamic facets enabled, which generates a facet
        /// `gender`. Then the final order of the facets in the response can be
        /// ("price", "brands", "rating", "gender") or ("price", "brands", "gender",
        /// "rating") depends on how API orders "gender" and "rating" facets.
        /// However, notice that "price" and "brands" are always
        /// ranked at first and second position because their enable_dynamic_position
        /// is false.
        #[prost(bool, tag = "4")]
        pub enable_dynamic_position: bool,
    }
    /// Nested message and enum types in `FacetSpec`.
    pub mod facet_spec {
        /// Specifies how a facet is computed.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetKey {
            /// Required. Supported textual and numerical facet keys in
            /// \[Document\]\[google.cloud.discoveryengine.v1.Document\] object, over which
            /// the facet values are computed. Facet key is case-sensitive.
            #[prost(string, tag = "1")]
            pub key: ::prost::alloc::string::String,
            /// Set only if values should be bucketed into intervals. Must be set
            /// for facets with numerical values. Must not be set for facet with text
            /// values. Maximum number of intervals is 30.
            #[prost(message, repeated, tag = "2")]
            pub intervals: ::prost::alloc::vec::Vec<super::super::Interval>,
            /// Only get facet for the given restricted values. Only supported on
            /// textual fields. For example, suppose "category" has three values
            /// "Action > 2022", "Action > 2021" and "Sci-Fi > 2022". If set
            /// "restricted_values" to "Action > 2022", the "category" facet only
            /// contains "Action > 2022". Only supported on textual fields. Maximum
            /// is 10.
            #[prost(string, repeated, tag = "3")]
            pub restricted_values: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Only get facet values that start with the given string prefix. For
            /// example, suppose "category" has three values "Action > 2022",
            /// "Action > 2021" and "Sci-Fi > 2022". If set "prefixes" to "Action", the
            /// "category" facet only contains "Action > 2022" and "Action > 2021".
            /// Only supported on textual fields. Maximum is 10.
            #[prost(string, repeated, tag = "4")]
            pub prefixes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// Only get facet values that contain the given strings. For example,
            /// suppose "category" has three values "Action > 2022",
            /// "Action > 2021" and "Sci-Fi > 2022". If set "contains" to "2022", the
            /// "category" facet only contains "Action > 2022" and "Sci-Fi > 2022".
            /// Only supported on textual fields. Maximum is 10.
            #[prost(string, repeated, tag = "5")]
            pub contains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// True to make facet keys case insensitive when getting faceting
            /// values with prefixes or contains; false otherwise.
            #[prost(bool, tag = "6")]
            pub case_insensitive: bool,
            /// The order in which documents are returned.
            ///
            /// Allowed values are:
            ///
            /// * "count desc", which means order by
            ///   \[SearchResponse.Facet.values.count\]\[google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.count\]
            ///   descending.
            ///
            /// * "value desc", which means order by
            ///   \[SearchResponse.Facet.values.value\]\[google.cloud.discoveryengine.v1.SearchResponse.Facet.FacetValue.value\]
            ///   descending.
            ///   Only applies to textual facets.
            ///
            /// If not set, textual values are sorted in [natural
            /// order](<https://en.wikipedia.org/wiki/Natural_sort_order>); numerical
            /// intervals are sorted in the order given by
            /// \[FacetSpec.FacetKey.intervals\]\[google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals\].
            #[prost(string, tag = "7")]
            pub order_by: ::prost::alloc::string::String,
        }
    }
    /// Boost specification to boost certain documents.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoostSpec {
        /// Condition boost specifications. If a document matches multiple conditions
        /// in the specifications, boost scores from these specifications are all
        /// applied and combined in a non-linear way. Maximum number of
        /// specifications is 20.
        #[prost(message, repeated, tag = "1")]
        pub condition_boost_specs: ::prost::alloc::vec::Vec<
            boost_spec::ConditionBoostSpec,
        >,
    }
    /// Nested message and enum types in `BoostSpec`.
    pub mod boost_spec {
        /// Boost applies to documents which match a condition.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ConditionBoostSpec {
            /// An expression which specifies a boost condition. The syntax and
            /// supported fields are the same as a filter expression. See
            /// \[SearchRequest.filter\]\[google.cloud.discoveryengine.v1.SearchRequest.filter\]
            /// for detail syntax and limitations.
            ///
            /// Examples:
            ///
            /// * To boost documents with document ID "doc_1" or "doc_2", and
            ///   color "Red" or "Blue":
            ///   `(document_id: ANY("doc_1", "doc_2")) AND (color: ANY("Red", "Blue"))`
            #[prost(string, tag = "1")]
            pub condition: ::prost::alloc::string::String,
            /// Strength of the condition boost, which should be in \[-1, 1\]. Negative
            /// boost means demotion. Default is 0.0.
            ///
            /// Setting to 1.0 gives the document a big promotion. However, it does
            /// not necessarily mean that the boosted document will be the top result
            /// at all times, nor that other documents will be excluded. Results
            /// could still be shown even when none of them matches the condition.
            /// And results that are significantly more relevant to the search query
            /// can still trump your heavily favored but irrelevant documents.
            ///
            /// Setting to -1.0 gives the document a big demotion. However, results
            /// that are deeply relevant might still be shown. The document will have
            /// an upstream battle to get a fairly high ranking, but it is not
            /// blocked out completely.
            ///
            /// Setting to 0.0 means no boost applied. The boosting condition is
            /// ignored. Only one of the (condition, boost) combination or the
            /// boost_control_spec below are set. If both are set then the global boost
            /// is ignored and the more fine-grained boost_control_spec is applied.
            #[prost(float, tag = "2")]
            pub boost: f32,
            /// Complex specification for custom ranking based on customer defined
            /// attribute value.
            #[prost(message, optional, tag = "3")]
            pub boost_control_spec: ::core::option::Option<
                condition_boost_spec::BoostControlSpec,
            >,
        }
        /// Nested message and enum types in `ConditionBoostSpec`.
        pub mod condition_boost_spec {
            /// Specification for custom ranking based on customer specified attribute
            /// value. It provides more controls for customized ranking than the simple
            /// (condition, boost) combination above.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct BoostControlSpec {
                /// The name of the field whose value will be used to determine the
                /// boost amount.
                #[prost(string, tag = "1")]
                pub field_name: ::prost::alloc::string::String,
                /// The attribute type to be used to determine the boost amount. The
                /// attribute value can be derived from the field value of the specified
                /// field_name. In the case of numerical it is straightforward i.e.
                /// attribute_value = numerical_field_value. In the case of freshness
                /// however, attribute_value = (time.now() - datetime_field_value).
                #[prost(enumeration = "boost_control_spec::AttributeType", tag = "2")]
                pub attribute_type: i32,
                /// The interpolation type to be applied to connect the control points
                /// listed below.
                #[prost(
                    enumeration = "boost_control_spec::InterpolationType",
                    tag = "3"
                )]
                pub interpolation_type: i32,
                /// The control points used to define the curve. The monotonic function
                /// (defined through the interpolation_type above) passes through the
                /// control points listed here.
                #[prost(message, repeated, tag = "4")]
                pub control_points: ::prost::alloc::vec::Vec<
                    boost_control_spec::ControlPoint,
                >,
            }
            /// Nested message and enum types in `BoostControlSpec`.
            pub mod boost_control_spec {
                /// The control points used to define the curve. The curve defined
                /// through these control points can only be monotonically increasing
                /// or decreasing(constant values are acceptable).
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct ControlPoint {
                    /// Can be one of:
                    ///
                    /// 1. The numerical field value.
                    /// 1. The duration spec for freshness:
                    ///    The value must be formatted as an XSD `dayTimeDuration` value (a
                    ///    restricted subset of an ISO 8601 duration value). The pattern for
                    ///    this is: `[nD][T[nH][nM][nS]]`.
                    #[prost(string, tag = "1")]
                    pub attribute_value: ::prost::alloc::string::String,
                    /// The value between -1 to 1 by which to boost the score if the
                    /// attribute_value evaluates to the value specified above.
                    #[prost(float, tag = "2")]
                    pub boost_amount: f32,
                }
                /// The attribute(or function) for which the custom ranking is to be
                /// applied.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum AttributeType {
                    /// Unspecified AttributeType.
                    Unspecified = 0,
                    /// The value of the numerical field will be used to dynamically update
                    /// the boost amount. In this case, the attribute_value (the x value)
                    /// of the control point will be the actual value of the numerical
                    /// field for which the boost_amount is specified.
                    Numerical = 1,
                    /// For the freshness use case the attribute value will be the duration
                    /// between the current time and the date in the datetime field
                    /// specified. The value must be formatted as an XSD `dayTimeDuration`
                    /// value (a restricted subset of an ISO 8601 duration value). The
                    /// pattern for this is: `[nD][T[nH][nM][nS]]`.
                    /// For example, `5D`, `3DT12H30M`, `T24H`.
                    Freshness = 2,
                }
                impl AttributeType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "ATTRIBUTE_TYPE_UNSPECIFIED",
                            Self::Numerical => "NUMERICAL",
                            Self::Freshness => "FRESHNESS",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "ATTRIBUTE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                            "NUMERICAL" => Some(Self::Numerical),
                            "FRESHNESS" => Some(Self::Freshness),
                            _ => None,
                        }
                    }
                }
                /// The interpolation type to be applied. Default will be linear
                /// (Piecewise Linear).
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum InterpolationType {
                    /// Interpolation type is unspecified. In this case, it defaults to
                    /// Linear.
                    Unspecified = 0,
                    /// Piecewise linear interpolation will be applied.
                    Linear = 1,
                }
                impl InterpolationType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "INTERPOLATION_TYPE_UNSPECIFIED",
                            Self::Linear => "LINEAR",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "INTERPOLATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                            "LINEAR" => Some(Self::Linear),
                            _ => None,
                        }
                    }
                }
            }
        }
    }
    /// Specification to determine under which conditions query expansion should
    /// occur.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QueryExpansionSpec {
        /// The condition under which query expansion should occur. Default to
        /// \[Condition.DISABLED\]\[google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED\].
        #[prost(enumeration = "query_expansion_spec::Condition", tag = "1")]
        pub condition: i32,
        /// Whether to pin unexpanded results. If this field is set to true,
        /// unexpanded products are always at the top of the search results, followed
        /// by the expanded results.
        #[prost(bool, tag = "2")]
        pub pin_unexpanded_results: bool,
    }
    /// Nested message and enum types in `QueryExpansionSpec`.
    pub mod query_expansion_spec {
        /// Enum describing under which condition query expansion should occur.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Condition {
            /// Unspecified query expansion condition. In this case, server behavior
            /// defaults to
            /// \[Condition.DISABLED\]\[google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.Condition.DISABLED\].
            Unspecified = 0,
            /// Disabled query expansion. Only the exact search query is used, even if
            /// \[SearchResponse.total_size\]\[google.cloud.discoveryengine.v1.SearchResponse.total_size\]
            /// is zero.
            Disabled = 1,
            /// Automatic query expansion built by the Search API.
            Auto = 2,
        }
        impl Condition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "CONDITION_UNSPECIFIED",
                    Self::Disabled => "DISABLED",
                    Self::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "DISABLED" => Some(Self::Disabled),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    /// The specification for query spell correction.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SpellCorrectionSpec {
        /// The mode under which spell correction
        /// replaces the original search query. Defaults to
        /// \[Mode.AUTO\]\[google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO\].
        #[prost(enumeration = "spell_correction_spec::Mode", tag = "1")]
        pub mode: i32,
    }
    /// Nested message and enum types in `SpellCorrectionSpec`.
    pub mod spell_correction_spec {
        /// Enum describing under which mode spell correction should occur.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Mode {
            /// Unspecified spell correction mode. In this case, server behavior
            /// defaults to
            /// \[Mode.AUTO\]\[google.cloud.discoveryengine.v1.SearchRequest.SpellCorrectionSpec.Mode.AUTO\].
            Unspecified = 0,
            /// Search API tries to find a spelling suggestion. If a suggestion is
            /// found, it is put in the
            /// \[SearchResponse.corrected_query\]\[google.cloud.discoveryengine.v1.SearchResponse.corrected_query\].
            /// The spelling suggestion won't be used as the search query.
            SuggestionOnly = 1,
            /// Automatic spell correction built by the Search API. Search will
            /// be based on the corrected query if found.
            Auto = 2,
        }
        impl Mode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "MODE_UNSPECIFIED",
                    Self::SuggestionOnly => "SUGGESTION_ONLY",
                    Self::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "SUGGESTION_ONLY" => Some(Self::SuggestionOnly),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    /// A specification for configuring the behavior of content search.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ContentSearchSpec {
        /// If `snippetSpec` is not specified, snippets are not included in the
        /// search response.
        #[prost(message, optional, tag = "1")]
        pub snippet_spec: ::core::option::Option<content_search_spec::SnippetSpec>,
        /// If `summarySpec` is not specified, summaries are not included in the
        /// search response.
        #[prost(message, optional, tag = "2")]
        pub summary_spec: ::core::option::Option<content_search_spec::SummarySpec>,
        /// If there is no extractive_content_spec provided, there will be no
        /// extractive answer in the search response.
        #[prost(message, optional, tag = "3")]
        pub extractive_content_spec: ::core::option::Option<
            content_search_spec::ExtractiveContentSpec,
        >,
        /// Specifies the search result mode. If unspecified, the
        /// search result mode defaults to `DOCUMENTS`.
        #[prost(enumeration = "content_search_spec::SearchResultMode", tag = "4")]
        pub search_result_mode: i32,
        /// Specifies the chunk spec to be returned from the search response.
        /// Only available if the
        /// \[SearchRequest.ContentSearchSpec.search_result_mode\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode\]
        /// is set to
        /// \[CHUNKS\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS\]
        #[prost(message, optional, tag = "5")]
        pub chunk_spec: ::core::option::Option<content_search_spec::ChunkSpec>,
    }
    /// Nested message and enum types in `ContentSearchSpec`.
    pub mod content_search_spec {
        /// A specification for configuring snippets in a search response.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SnippetSpec {
            /// \[DEPRECATED\] This field is deprecated. To control snippet return, use
            /// `return_snippet` field. For backwards compatibility, we will return
            /// snippet if max_snippet_count > 0.
            #[deprecated]
            #[prost(int32, tag = "1")]
            pub max_snippet_count: i32,
            /// \[DEPRECATED\] This field is deprecated and will have no affect on the
            /// snippet.
            #[deprecated]
            #[prost(bool, tag = "2")]
            pub reference_only: bool,
            /// If `true`, then return snippet. If no snippet can be generated, we
            /// return "No snippet is available for this page." A `snippet_status` with
            /// `SUCCESS` or `NO_SNIPPET_AVAILABLE` will also be returned.
            #[prost(bool, tag = "3")]
            pub return_snippet: bool,
        }
        /// A specification for configuring a summary returned in a search
        /// response.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SummarySpec {
            /// The number of top results to generate the summary from. If the number
            /// of results returned is less than `summaryResultCount`, the summary is
            /// generated from all of the results.
            ///
            /// At most 10 results for documents mode, or 50 for chunks mode, can be
            /// used to generate a summary. The chunks mode is used when
            /// \[SearchRequest.ContentSearchSpec.search_result_mode\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode\]
            /// is set to
            /// \[CHUNKS\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS\].
            #[prost(int32, tag = "1")]
            pub summary_result_count: i32,
            /// Specifies whether to include citations in the summary. The default
            /// value is `false`.
            ///
            /// When this field is set to `true`, summaries include in-line citation
            /// numbers.
            ///
            /// Example summary including citations:
            ///
            /// BigQuery is Google Cloud's fully managed and completely serverless
            /// enterprise data warehouse \[1\]. BigQuery supports all data types, works
            /// across clouds, and has built-in machine learning and business
            /// intelligence, all within a unified platform \[2, 3\].
            ///
            /// The citation numbers refer to the returned search results and are
            /// 1-indexed. For example, \[1\] means that the sentence is attributed to
            /// the first search result. \[2, 3\] means that the sentence is attributed
            /// to both the second and third search results.
            #[prost(bool, tag = "2")]
            pub include_citations: bool,
            /// Specifies whether to filter out adversarial queries. The default value
            /// is `false`.
            ///
            /// Google employs search-query classification to detect adversarial
            /// queries. No summary is returned if the search query is classified as an
            /// adversarial query. For example, a user might ask a question regarding
            /// negative comments about the company or submit a query designed to
            /// generate unsafe, policy-violating output. If this field is set to
            /// `true`, we skip generating summaries for adversarial queries and return
            /// fallback messages instead.
            #[prost(bool, tag = "3")]
            pub ignore_adversarial_query: bool,
            /// Specifies whether to filter out queries that are not summary-seeking.
            /// The default value is `false`.
            ///
            /// Google employs search-query classification to detect summary-seeking
            /// queries. No summary is returned if the search query is classified as a
            /// non-summary seeking query. For example, `why is the sky blue` and `Who  is the best soccer player in the world?` are summary-seeking queries,
            /// but `SFO airport` and `world cup 2026` are not. They are most likely
            /// navigational queries. If this field is set to `true`, we skip
            /// generating summaries for non-summary seeking queries and return
            /// fallback messages instead.
            #[prost(bool, tag = "4")]
            pub ignore_non_summary_seeking_query: bool,
            /// Specifies whether to filter out queries that have low relevance. The
            /// default value is `false`.
            ///
            /// If this field is set to `false`, all search results are used regardless
            /// of relevance to generate answers. If set to `true`, only queries with
            /// high relevance search results will generate answers.
            #[prost(bool, tag = "9")]
            pub ignore_low_relevant_content: bool,
            /// Optional. Specifies whether to filter out jail-breaking queries. The
            /// default value is `false`.
            ///
            /// Google employs search-query classification to detect jail-breaking
            /// queries. No summary is returned if the search query is classified as a
            /// jail-breaking query. A user might add instructions to the query to
            /// change the tone, style, language, content of the answer, or ask the
            /// model to act as a different entity, e.g. "Reply in the tone of a
            /// competing company's CEO". If this field is set to `true`, we skip
            /// generating summaries for jail-breaking queries and return fallback
            /// messages instead.
            #[prost(bool, tag = "10")]
            pub ignore_jail_breaking_query: bool,
            /// If specified, the spec will be used to modify the prompt provided to
            /// the LLM.
            #[prost(message, optional, tag = "5")]
            pub model_prompt_spec: ::core::option::Option<summary_spec::ModelPromptSpec>,
            /// Language code for Summary. Use language tags defined by
            /// [BCP47](<https://www.rfc-editor.org/rfc/bcp/bcp47.txt>).
            /// Note: This is an experimental feature.
            #[prost(string, tag = "6")]
            pub language_code: ::prost::alloc::string::String,
            /// If specified, the spec will be used to modify the model specification
            /// provided to the LLM.
            #[prost(message, optional, tag = "7")]
            pub model_spec: ::core::option::Option<summary_spec::ModelSpec>,
            /// If true, answer will be generated from most relevant chunks from top
            /// search results. This feature will improve summary quality.
            /// Note that with this feature enabled, not all top search results
            /// will be referenced and included in the reference list, so the citation
            /// source index only points to the search results listed in the reference
            /// list.
            #[prost(bool, tag = "8")]
            pub use_semantic_chunks: bool,
        }
        /// Nested message and enum types in `SummarySpec`.
        pub mod summary_spec {
            /// Specification of the prompt to use with the model.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ModelPromptSpec {
                /// Text at the beginning of the prompt that instructs the assistant.
                /// Examples are available in the user guide.
                #[prost(string, tag = "1")]
                pub preamble: ::prost::alloc::string::String,
            }
            /// Specification of the model.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ModelSpec {
                /// The model version used to generate the summary.
                ///
                /// Supported values are:
                ///
                /// * `stable`: string. Default value when no value is specified. Uses a
                ///   generally available, fine-tuned model. For more information, see
                ///   [Answer generation model versions and
                ///   lifecycle](<https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models>).
                /// * `preview`: string. (Public preview) Uses a preview model. For more
                ///   information, see
                ///   [Answer generation model versions and
                ///   lifecycle](<https://cloud.google.com/generative-ai-app-builder/docs/answer-generation-models>).
                #[prost(string, tag = "1")]
                pub version: ::prost::alloc::string::String,
            }
        }
        /// A specification for configuring the extractive content in a search
        /// response.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ExtractiveContentSpec {
            /// The maximum number of extractive answers returned in each search
            /// result.
            ///
            /// An extractive answer is a verbatim answer extracted from the original
            /// document, which provides a precise and contextually relevant answer to
            /// the search query.
            ///
            /// If the number of matching answers is less than the
            /// `max_extractive_answer_count`, return all of the answers. Otherwise,
            /// return the `max_extractive_answer_count`.
            ///
            /// At most five answers are returned for each
            /// \[SearchResult\]\[google.cloud.discoveryengine.v1.SearchResponse.SearchResult\].
            #[prost(int32, tag = "1")]
            pub max_extractive_answer_count: i32,
            /// The max number of extractive segments returned in each search result.
            /// Only applied if the
            /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] is set to
            /// \[DataStore.ContentConfig.CONTENT_REQUIRED\]\[google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED\]
            /// or
            /// \[DataStore.solution_types\]\[google.cloud.discoveryengine.v1.DataStore.solution_types\]
            /// is
            /// \[SOLUTION_TYPE_CHAT\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT\].
            ///
            /// An extractive segment is a text segment extracted from the original
            /// document that is relevant to the search query, and, in general, more
            /// verbose than an extractive answer. The segment could then be used as
            /// input for LLMs to generate summaries and answers.
            ///
            /// If the number of matching segments is less than
            /// `max_extractive_segment_count`, return all of the segments. Otherwise,
            /// return the `max_extractive_segment_count`.
            #[prost(int32, tag = "2")]
            pub max_extractive_segment_count: i32,
            /// Specifies whether to return the confidence score from the extractive
            /// segments in each search result. This feature is available only for new
            /// or allowlisted data stores. To allowlist your data store,
            /// contact your Customer Engineer. The default value is `false`.
            #[prost(bool, tag = "3")]
            pub return_extractive_segment_score: bool,
            /// Specifies whether to also include the adjacent from each selected
            /// segments.
            /// Return at most `num_previous_segments` segments before each selected
            /// segments.
            #[prost(int32, tag = "4")]
            pub num_previous_segments: i32,
            /// Return at most `num_next_segments` segments after each selected
            /// segments.
            #[prost(int32, tag = "5")]
            pub num_next_segments: i32,
        }
        /// Specifies the chunk spec to be returned from the search response.
        /// Only available if the
        /// \[SearchRequest.ContentSearchSpec.search_result_mode\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode\]
        /// is set to
        /// \[CHUNKS\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS\]
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChunkSpec {
            /// The number of previous chunks to be returned of the current chunk. The
            /// maximum allowed value is 3.
            /// If not specified, no previous chunks will be returned.
            #[prost(int32, tag = "1")]
            pub num_previous_chunks: i32,
            /// The number of next chunks to be returned of the current chunk. The
            /// maximum allowed value is 3.
            /// If not specified, no next chunks will be returned.
            #[prost(int32, tag = "2")]
            pub num_next_chunks: i32,
        }
        /// Specifies the search result mode. If unspecified, the
        /// search result mode defaults to `DOCUMENTS`.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SearchResultMode {
            /// Default value.
            Unspecified = 0,
            /// Returns documents in the search result.
            Documents = 1,
            /// Returns chunks in the search result. Only available if the
            /// \[DocumentProcessingConfig.chunking_config\]\[google.cloud.discoveryengine.v1.DocumentProcessingConfig.chunking_config\]
            /// is specified.
            Chunks = 2,
        }
        impl SearchResultMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SEARCH_RESULT_MODE_UNSPECIFIED",
                    Self::Documents => "DOCUMENTS",
                    Self::Chunks => "CHUNKS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SEARCH_RESULT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "DOCUMENTS" => Some(Self::Documents),
                    "CHUNKS" => Some(Self::Chunks),
                    _ => None,
                }
            }
        }
    }
    /// Specification for search as you type in search requests.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SearchAsYouTypeSpec {
        /// The condition under which search as you type should occur.
        /// Default to
        /// \[Condition.DISABLED\]\[google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED\].
        #[prost(enumeration = "search_as_you_type_spec::Condition", tag = "1")]
        pub condition: i32,
    }
    /// Nested message and enum types in `SearchAsYouTypeSpec`.
    pub mod search_as_you_type_spec {
        /// Enum describing under which condition search as you type should occur.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Condition {
            /// Server behavior defaults to
            /// \[Condition.DISABLED\]\[google.cloud.discoveryengine.v1.SearchRequest.SearchAsYouTypeSpec.Condition.DISABLED\].
            Unspecified = 0,
            /// Disables Search As You Type.
            Disabled = 1,
            /// Enables Search As You Type.
            Enabled = 2,
            /// Automatic switching between search-as-you-type and standard search
            /// modes, ideal for single-API implementations (e.g., debouncing).
            Auto = 3,
        }
        impl Condition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "CONDITION_UNSPECIFIED",
                    Self::Disabled => "DISABLED",
                    Self::Enabled => "ENABLED",
                    Self::Auto => "AUTO",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "DISABLED" => Some(Self::Disabled),
                    "ENABLED" => Some(Self::Enabled),
                    "AUTO" => Some(Self::Auto),
                    _ => None,
                }
            }
        }
    }
    /// Specifies features for display, like match highlighting.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DisplaySpec {
        /// The condition under which match highlighting should occur.
        #[prost(enumeration = "display_spec::MatchHighlightingCondition", tag = "1")]
        pub match_highlighting_condition: i32,
    }
    /// Nested message and enum types in `DisplaySpec`.
    pub mod display_spec {
        /// Enum describing under which condition match highlighting should occur.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MatchHighlightingCondition {
            /// Server behavior is the same as `MATCH_HIGHLIGHTING_DISABLED`.
            Unspecified = 0,
            /// Disables match highlighting on all documents.
            MatchHighlightingDisabled = 1,
            /// Enables match highlighting on all documents.
            MatchHighlightingEnabled = 2,
        }
        impl MatchHighlightingCondition {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "MATCH_HIGHLIGHTING_CONDITION_UNSPECIFIED",
                    Self::MatchHighlightingDisabled => "MATCH_HIGHLIGHTING_DISABLED",
                    Self::MatchHighlightingEnabled => "MATCH_HIGHLIGHTING_ENABLED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MATCH_HIGHLIGHTING_CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                    "MATCH_HIGHLIGHTING_DISABLED" => {
                        Some(Self::MatchHighlightingDisabled)
                    }
                    "MATCH_HIGHLIGHTING_ENABLED" => Some(Self::MatchHighlightingEnabled),
                    _ => None,
                }
            }
        }
    }
    /// Session specification.
    ///
    /// Multi-turn Search feature is currently at private GA stage. Please use
    /// v1alpha or v1beta version instead before we launch this feature to public
    /// GA. Or ask for allowlisting through Google Support team.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SessionSpec {
        /// If set, the search result gets stored to the "turn" specified by this
        /// query ID.
        ///
        /// Example: Let's say the session looks like this:
        /// session {
        /// name: ".../sessions/xxx"
        /// turns {
        /// query { text: "What is foo?" query_id: ".../questions/yyy" }
        /// answer: "Foo is ..."
        /// }
        /// turns {
        /// query { text: "How about bar then?" query_id: ".../questions/zzz" }
        /// }
        /// }
        ///
        /// The user can call /search API with a request like this:
        ///
        /// ```text
        /// session: ".../sessions/xxx"
        /// session_spec { query_id: ".../questions/zzz" }
        /// ```
        ///
        /// Then, the API stores the search result, associated with the last turn.
        /// The stored search result can be used by a subsequent /answer API call
        /// (with the session ID and the query ID specified). Also, it is possible
        /// to call /search and /answer in parallel with the same session ID & query
        /// ID.
        #[prost(string, tag = "1")]
        pub query_id: ::prost::alloc::string::String,
        /// The number of top search results to persist. The persisted search results
        /// can be used for the subsequent /answer api call.
        ///
        /// This field is similar to the `summary_result_count` field in
        /// \[SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.summary_result_count\].
        ///
        /// At most 10 results for documents mode, or 50 for chunks mode.
        #[prost(int32, optional, tag = "2")]
        pub search_result_persistence_count: ::core::option::Option<i32>,
    }
    /// The specification for returning the document relevance score.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RelevanceScoreSpec {
        /// Optional. Whether to return the relevance score for search results.
        /// The higher the score, the more relevant the document is to the query.
        #[prost(bool, tag = "1")]
        pub return_relevance_score: bool,
    }
    /// The relevance threshold of the search results. The higher relevance
    /// threshold is, the higher relevant results are shown and the less number of
    /// results are returned.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RelevanceThreshold {
        /// Default value. In this case, server behavior defaults to Google defined
        /// threshold.
        Unspecified = 0,
        /// Lowest relevance threshold.
        Lowest = 1,
        /// Low relevance threshold.
        Low = 2,
        /// Medium relevance threshold.
        Medium = 3,
        /// High relevance threshold.
        High = 4,
    }
    impl RelevanceThreshold {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RELEVANCE_THRESHOLD_UNSPECIFIED",
                Self::Lowest => "LOWEST",
                Self::Low => "LOW",
                Self::Medium => "MEDIUM",
                Self::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RELEVANCE_THRESHOLD_UNSPECIFIED" => Some(Self::Unspecified),
                "LOWEST" => Some(Self::Lowest),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
    /// The backend to use for the ranking expression evaluation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RankingExpressionBackend {
        /// Default option for unspecified/unknown values.
        Unspecified = 0,
        /// Ranking by custom embedding model, the default way to evaluate the
        /// ranking expression.
        RankByEmbedding = 3,
        /// Ranking by custom formula.
        RankByFormula = 4,
    }
    impl RankingExpressionBackend {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RANKING_EXPRESSION_BACKEND_UNSPECIFIED",
                Self::RankByEmbedding => "RANK_BY_EMBEDDING",
                Self::RankByFormula => "RANK_BY_FORMULA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RANKING_EXPRESSION_BACKEND_UNSPECIFIED" => Some(Self::Unspecified),
                "RANK_BY_EMBEDDING" => Some(Self::RankByEmbedding),
                "RANK_BY_FORMULA" => Some(Self::RankByFormula),
                _ => None,
            }
        }
    }
}
/// Response message for
/// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
    /// A list of matched documents. The order represents the ranking.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
    /// Results of facets requested by user.
    #[prost(message, repeated, tag = "2")]
    pub facets: ::prost::alloc::vec::Vec<search_response::Facet>,
    /// The estimated total count of matched items irrespective of pagination. The
    /// count of \[results\]\[google.cloud.discoveryengine.v1.SearchResponse.results\]
    /// returned by pagination may be less than the
    /// \[total_size\]\[google.cloud.discoveryengine.v1.SearchResponse.total_size\]
    /// that matches.
    #[prost(int32, tag = "3")]
    pub total_size: i32,
    /// A unique search token. This should be included in the
    /// \[UserEvent\]\[google.cloud.discoveryengine.v1.UserEvent\] logs resulting from
    /// this search, which enables accurate attribution of search model
    /// performance. This also helps to identify a request during the customer
    /// support scenarios.
    #[prost(string, tag = "4")]
    pub attribution_token: ::prost::alloc::string::String,
    /// The URI of a customer-defined redirect page. If redirect action is
    /// triggered, no search is performed, and only
    /// \[redirect_uri\]\[google.cloud.discoveryengine.v1.SearchResponse.redirect_uri\]
    /// and
    /// \[attribution_token\]\[google.cloud.discoveryengine.v1.SearchResponse.attribution_token\]
    /// are set in the response.
    #[prost(string, tag = "12")]
    pub redirect_uri: ::prost::alloc::string::String,
    /// A token that can be sent as
    /// \[SearchRequest.page_token\]\[google.cloud.discoveryengine.v1.SearchRequest.page_token\]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    #[prost(string, tag = "5")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Contains the spell corrected query, if found. If the spell correction type
    /// is AUTOMATIC, then the search results are based on corrected_query.
    /// Otherwise the original query is used for search.
    #[prost(string, tag = "7")]
    pub corrected_query: ::prost::alloc::string::String,
    /// A summary as part of the search results.
    /// This field is only returned if
    /// \[SearchRequest.ContentSearchSpec.summary_spec\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.summary_spec\]
    /// is set.
    #[prost(message, optional, tag = "9")]
    pub summary: ::core::option::Option<search_response::Summary>,
    /// Query expansion information for the returned results.
    #[prost(message, optional, tag = "14")]
    pub query_expansion_info: ::core::option::Option<
        search_response::QueryExpansionInfo,
    >,
    /// Session information.
    ///
    /// Only set if
    /// \[SearchRequest.session\]\[google.cloud.discoveryengine.v1.SearchRequest.session\]
    /// is provided. See its description for more details.
    #[prost(message, optional, tag = "19")]
    pub session_info: ::core::option::Option<search_response::SessionInfo>,
    /// Promotions for site search.
    #[prost(message, repeated, tag = "23")]
    pub search_link_promotions: ::prost::alloc::vec::Vec<SearchLinkPromotion>,
}
/// Nested message and enum types in `SearchResponse`.
pub mod search_response {
    /// Represents the search results.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SearchResult {
        /// \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\] of the
        /// searched \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The document data snippet in the search response. Only fields that are
        /// marked as `retrievable` are populated.
        #[prost(message, optional, tag = "2")]
        pub document: ::core::option::Option<super::Document>,
        /// The chunk data in the search response if the
        /// \[SearchRequest.ContentSearchSpec.search_result_mode\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.search_result_mode\]
        /// is set to
        /// \[CHUNKS\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SearchResultMode.CHUNKS\].
        #[prost(message, optional, tag = "18")]
        pub chunk: ::core::option::Option<super::Chunk>,
        /// Output only. Google provided available scores.
        #[prost(map = "string, message", tag = "4")]
        pub model_scores: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            super::DoubleList,
        >,
        /// A set of ranking signals associated with the result.
        #[prost(message, optional, tag = "7")]
        pub rank_signals: ::core::option::Option<search_result::RankSignals>,
    }
    /// Nested message and enum types in `SearchResult`.
    pub mod search_result {
        /// A set of ranking signals.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RankSignals {
            /// Keyword matching adjustment.
            #[prost(float, optional, tag = "1")]
            pub keyword_similarity_score: ::core::option::Option<f32>,
            /// Semantic relevance adjustment.
            #[prost(float, optional, tag = "2")]
            pub relevance_score: ::core::option::Option<f32>,
            /// Semantic similarity adjustment.
            #[prost(float, optional, tag = "3")]
            pub semantic_similarity_score: ::core::option::Option<f32>,
            /// Predicted conversion rate adjustment as a rank.
            #[prost(float, optional, tag = "4")]
            pub pctr_rank: ::core::option::Option<f32>,
            /// Topicality adjustment as a rank.
            #[prost(float, optional, tag = "6")]
            pub topicality_rank: ::core::option::Option<f32>,
            /// Age of the document in hours.
            #[prost(float, optional, tag = "7")]
            pub document_age: ::core::option::Option<f32>,
            /// Combined custom boosts for a doc.
            #[prost(float, optional, tag = "8")]
            pub boosting_factor: ::core::option::Option<f32>,
            /// The default rank of the result.
            #[prost(float, tag = "32")]
            pub default_rank: f32,
            /// A list of custom clearbox signals.
            #[prost(message, repeated, tag = "33")]
            pub custom_signals: ::prost::alloc::vec::Vec<rank_signals::CustomSignal>,
        }
        /// Nested message and enum types in `RankSignals`.
        pub mod rank_signals {
            /// Custom clearbox signal represented by name and value pair.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct CustomSignal {
                /// Name of the signal.
                #[prost(string, tag = "1")]
                pub name: ::prost::alloc::string::String,
                /// Float value representing the ranking signal (e.g. 1.25 for BM25).
                #[prost(float, tag = "2")]
                pub value: f32,
            }
        }
    }
    /// A facet result.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Facet {
        /// The key for this facet. For example, `"colors"` or `"price"`. It matches
        /// \[SearchRequest.FacetSpec.FacetKey.key\]\[google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.key\].
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// The facet values for this field.
        #[prost(message, repeated, tag = "2")]
        pub values: ::prost::alloc::vec::Vec<facet::FacetValue>,
        /// Whether the facet is dynamically generated.
        #[prost(bool, tag = "3")]
        pub dynamic_facet: bool,
    }
    /// Nested message and enum types in `Facet`.
    pub mod facet {
        /// A facet value which contains value names and their count.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FacetValue {
            /// Number of items that have this facet value.
            #[prost(int64, tag = "3")]
            pub count: i64,
            /// A facet value which contains values.
            #[prost(oneof = "facet_value::FacetValue", tags = "1, 2")]
            pub facet_value: ::core::option::Option<facet_value::FacetValue>,
        }
        /// Nested message and enum types in `FacetValue`.
        pub mod facet_value {
            /// A facet value which contains values.
            #[derive(Clone, PartialEq, ::prost::Oneof)]
            pub enum FacetValue {
                /// Text value of a facet, such as "Black" for facet "colors".
                #[prost(string, tag = "1")]
                Value(::prost::alloc::string::String),
                /// Interval value for a facet, such as \[10, 20) for facet "price". It
                /// matches
                /// \[SearchRequest.FacetSpec.FacetKey.intervals\]\[google.cloud.discoveryengine.v1.SearchRequest.FacetSpec.FacetKey.intervals\].
                #[prost(message, tag = "2")]
                Interval(super::super::super::Interval),
            }
        }
    }
    /// Summary of the top N search results specified by the summary spec.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Summary {
        /// The summary content.
        #[prost(string, tag = "1")]
        pub summary_text: ::prost::alloc::string::String,
        /// Additional summary-skipped reasons. This provides the reason for ignored
        /// cases. If nothing is skipped, this field is not set.
        #[prost(enumeration = "summary::SummarySkippedReason", repeated, tag = "2")]
        pub summary_skipped_reasons: ::prost::alloc::vec::Vec<i32>,
        /// A collection of Safety Attribute categories and their associated
        /// confidence scores.
        #[prost(message, optional, tag = "3")]
        pub safety_attributes: ::core::option::Option<summary::SafetyAttributes>,
        /// Summary with metadata information.
        #[prost(message, optional, tag = "4")]
        pub summary_with_metadata: ::core::option::Option<summary::SummaryWithMetadata>,
    }
    /// Nested message and enum types in `Summary`.
    pub mod summary {
        /// Safety Attribute categories and their associated confidence scores.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SafetyAttributes {
            /// The display names of Safety Attribute categories associated with the
            /// generated content. Order matches the Scores.
            #[prost(string, repeated, tag = "1")]
            pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
            /// The confidence scores of the each category, higher
            /// value means higher confidence. Order matches the Categories.
            #[prost(float, repeated, tag = "2")]
            pub scores: ::prost::alloc::vec::Vec<f32>,
        }
        /// Citation metadata.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct CitationMetadata {
            /// Citations for segments.
            #[prost(message, repeated, tag = "1")]
            pub citations: ::prost::alloc::vec::Vec<Citation>,
        }
        /// Citation info for a segment.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Citation {
            /// Index indicates the start of the segment, measured in bytes/unicode.
            #[prost(int64, tag = "1")]
            pub start_index: i64,
            /// End of the attributed segment, exclusive.
            #[prost(int64, tag = "2")]
            pub end_index: i64,
            /// Citation sources for the attributed segment.
            #[prost(message, repeated, tag = "3")]
            pub sources: ::prost::alloc::vec::Vec<CitationSource>,
        }
        /// Citation source.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct CitationSource {
            /// Document reference index from SummaryWithMetadata.references.
            /// It is 0-indexed and the value will be zero if the reference_index is
            /// not set explicitly.
            #[prost(int64, tag = "4")]
            pub reference_index: i64,
        }
        /// Document reference.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Reference {
            /// Title of the document.
            #[prost(string, tag = "1")]
            pub title: ::prost::alloc::string::String,
            /// Required.
            /// \[Document.name\]\[google.cloud.discoveryengine.v1.Document.name\] of the
            /// document. Full resource name of the referenced document, in the format
            /// `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
            #[prost(string, tag = "2")]
            pub document: ::prost::alloc::string::String,
            /// Cloud Storage or HTTP uri for the document.
            #[prost(string, tag = "3")]
            pub uri: ::prost::alloc::string::String,
            /// List of cited chunk contents derived from document content.
            #[prost(message, repeated, tag = "4")]
            pub chunk_contents: ::prost::alloc::vec::Vec<reference::ChunkContent>,
        }
        /// Nested message and enum types in `Reference`.
        pub mod reference {
            /// Chunk content.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ChunkContent {
                /// Chunk textual content.
                #[prost(string, tag = "1")]
                pub content: ::prost::alloc::string::String,
                /// Page identifier.
                #[prost(string, tag = "2")]
                pub page_identifier: ::prost::alloc::string::String,
            }
        }
        /// Summary with metadata information.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SummaryWithMetadata {
            /// Summary text with no citation information.
            #[prost(string, tag = "1")]
            pub summary: ::prost::alloc::string::String,
            /// Citation metadata for given summary.
            #[prost(message, optional, tag = "2")]
            pub citation_metadata: ::core::option::Option<CitationMetadata>,
            /// Document References.
            #[prost(message, repeated, tag = "3")]
            pub references: ::prost::alloc::vec::Vec<Reference>,
        }
        /// An Enum for summary-skipped reasons.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum SummarySkippedReason {
            /// Default value. The summary skipped reason is not specified.
            Unspecified = 0,
            /// The adversarial query ignored case.
            ///
            /// Only used when
            /// \[SummarySpec.ignore_adversarial_query\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_adversarial_query\]
            /// is set to `true`.
            AdversarialQueryIgnored = 1,
            /// The non-summary seeking query ignored case.
            ///
            /// Google skips the summary if the query is chit chat.
            /// Only used when
            /// \[SummarySpec.ignore_non_summary_seeking_query\]\[google.cloud.discoveryengine.v1.SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_summary_seeking_query\]
            /// is set to `true`.
            NonSummarySeekingQueryIgnored = 2,
            /// The out-of-domain query ignored case.
            ///
            /// Google skips the summary if there are no high-relevance search results.
            /// For example, the data store contains facts about company A but the
            /// user query is asking questions about company B.
            OutOfDomainQueryIgnored = 3,
            /// The potential policy violation case.
            ///
            /// Google skips the summary if there is a potential policy violation
            /// detected. This includes content that may be violent or toxic.
            PotentialPolicyViolation = 4,
            /// The LLM addon not enabled case.
            ///
            /// Google skips the summary if the LLM addon is not enabled.
            LlmAddonNotEnabled = 5,
            /// The no relevant content case.
            ///
            /// Google skips the summary if there is no relevant content in the
            /// retrieved search results.
            NoRelevantContent = 6,
            /// The jail-breaking query ignored case.
            ///
            /// For example, "Reply in the tone of a competing company's CEO".
            /// Only used when
            /// \[SearchRequest.ContentSearchSpec.SummarySpec.ignore_jail_breaking_query\]
            /// is set to `true`.
            JailBreakingQueryIgnored = 7,
            /// The customer policy violation case.
            ///
            /// Google skips the summary if there is a customer policy violation
            /// detected. The policy is defined by the customer.
            CustomerPolicyViolation = 8,
            /// The non-answer seeking query ignored case.
            ///
            /// Google skips the summary if the query doesn't have clear intent.
            /// Only used when
            /// \[SearchRequest.ContentSearchSpec.SummarySpec.ignore_non_answer_seeking_query\]
            /// is set to `true`.
            NonSummarySeekingQueryIgnoredV2 = 9,
            /// The time out case.
            ///
            /// Google skips the summary if the time out.
            TimeOut = 10,
        }
        impl SummarySkippedReason {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SUMMARY_SKIPPED_REASON_UNSPECIFIED",
                    Self::AdversarialQueryIgnored => "ADVERSARIAL_QUERY_IGNORED",
                    Self::NonSummarySeekingQueryIgnored => {
                        "NON_SUMMARY_SEEKING_QUERY_IGNORED"
                    }
                    Self::OutOfDomainQueryIgnored => "OUT_OF_DOMAIN_QUERY_IGNORED",
                    Self::PotentialPolicyViolation => "POTENTIAL_POLICY_VIOLATION",
                    Self::LlmAddonNotEnabled => "LLM_ADDON_NOT_ENABLED",
                    Self::NoRelevantContent => "NO_RELEVANT_CONTENT",
                    Self::JailBreakingQueryIgnored => "JAIL_BREAKING_QUERY_IGNORED",
                    Self::CustomerPolicyViolation => "CUSTOMER_POLICY_VIOLATION",
                    Self::NonSummarySeekingQueryIgnoredV2 => {
                        "NON_SUMMARY_SEEKING_QUERY_IGNORED_V2"
                    }
                    Self::TimeOut => "TIME_OUT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SUMMARY_SKIPPED_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                    "ADVERSARIAL_QUERY_IGNORED" => Some(Self::AdversarialQueryIgnored),
                    "NON_SUMMARY_SEEKING_QUERY_IGNORED" => {
                        Some(Self::NonSummarySeekingQueryIgnored)
                    }
                    "OUT_OF_DOMAIN_QUERY_IGNORED" => Some(Self::OutOfDomainQueryIgnored),
                    "POTENTIAL_POLICY_VIOLATION" => Some(Self::PotentialPolicyViolation),
                    "LLM_ADDON_NOT_ENABLED" => Some(Self::LlmAddonNotEnabled),
                    "NO_RELEVANT_CONTENT" => Some(Self::NoRelevantContent),
                    "JAIL_BREAKING_QUERY_IGNORED" => Some(Self::JailBreakingQueryIgnored),
                    "CUSTOMER_POLICY_VIOLATION" => Some(Self::CustomerPolicyViolation),
                    "NON_SUMMARY_SEEKING_QUERY_IGNORED_V2" => {
                        Some(Self::NonSummarySeekingQueryIgnoredV2)
                    }
                    "TIME_OUT" => Some(Self::TimeOut),
                    _ => None,
                }
            }
        }
    }
    /// Information describing query expansion including whether expansion has
    /// occurred.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QueryExpansionInfo {
        /// Bool describing whether query expansion has occurred.
        #[prost(bool, tag = "1")]
        pub expanded_query: bool,
        /// Number of pinned results. This field will only be set when expansion
        /// happens and
        /// \[SearchRequest.QueryExpansionSpec.pin_unexpanded_results\]\[google.cloud.discoveryengine.v1.SearchRequest.QueryExpansionSpec.pin_unexpanded_results\]
        /// is set to true.
        #[prost(int64, tag = "2")]
        pub pinned_result_count: i64,
    }
    /// Information about the session.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SessionInfo {
        /// Name of the session.
        /// If the auto-session mode is used (when
        /// \[SearchRequest.session\]\[google.cloud.discoveryengine.v1.SearchRequest.session\]
        /// ends with "-"), this field holds the newly generated session name.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Query ID that corresponds to this search API call.
        /// One session can have multiple turns, each with a unique query ID.
        ///
        /// By specifying the session name and this query ID in the Answer API call,
        /// the answer generation happens in the context of the search results from
        /// this search call.
        #[prost(string, tag = "2")]
        pub query_id: ::prost::alloc::string::String,
    }
}
/// Generated client implementations.
pub mod search_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for search.
    #[derive(Debug, Clone)]
    pub struct SearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SearchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SearchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Performs a search.
        pub async fn search(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SearchService/Search",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SearchService",
                        "Search",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Performs a search. Similar to the
        /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
        /// method, but a lite version that allows API key for authentication, where
        /// OAuth and IAM checks are not required.
        ///
        /// Only public website search is supported by this method. If data stores and
        /// engines not associated with public website search are specified, a
        /// `FAILED_PRECONDITION` error is returned.
        ///
        /// This method can be used for easy onboarding without having to implement an
        /// authentication backend. However, it is strongly recommended to use
        /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
        /// instead with required OAuth and IAM checks to provide better data security.
        pub async fn search_lite(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchRequest>,
        ) -> std::result::Result<tonic::Response<super::SearchResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SearchService/SearchLite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SearchService",
                        "SearchLite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// External session proto definition.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Session {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/global/collections/{collection}/engines/{engine}/sessions/*`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The display name of the session.
    ///
    /// This field is used to identify the session in the UI.
    /// By default, the display name is the first turn query text in the session.
    #[prost(string, tag = "7")]
    pub display_name: ::prost::alloc::string::String,
    /// The state of the session.
    #[prost(enumeration = "session::State", tag = "2")]
    pub state: i32,
    /// A unique identifier for tracking users.
    #[prost(string, tag = "3")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    /// Turns.
    #[prost(message, repeated, tag = "4")]
    pub turns: ::prost::alloc::vec::Vec<session::Turn>,
    /// Optional. The labels for the session.
    /// Can be set as filter in ListSessionsRequest.
    #[prost(string, repeated, tag = "9")]
    pub labels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The time the session started.
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the session finished.
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Whether the session is pinned, pinned session will be displayed
    /// on the top of the session list.
    #[prost(bool, tag = "8")]
    pub is_pinned: bool,
}
/// Nested message and enum types in `Session`.
pub mod session {
    /// Represents a turn, including a query from the user and a
    /// answer from service.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Turn {
        /// Optional. The user query. May not be set if this turn is merely
        /// regenerating an answer to a different turn
        #[prost(message, optional, tag = "1")]
        pub query: ::core::option::Option<super::Query>,
        /// Optional. The resource name of the answer to the user query.
        ///
        /// Only set if the answer generation (/answer API call) happened in this
        /// turn.
        #[prost(string, tag = "2")]
        pub answer: ::prost::alloc::string::String,
        /// Output only. In
        /// \[ConversationalSearchService.GetSession\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession\]
        /// API, if
        /// \[GetSessionRequest.include_answer_details\]\[google.cloud.discoveryengine.v1.GetSessionRequest.include_answer_details\]
        /// is set to true, this field will be populated when getting answer query
        /// session.
        #[prost(message, optional, tag = "7")]
        pub detailed_answer: ::core::option::Option<super::Answer>,
        /// Output only. In
        /// \[ConversationalSearchService.GetSession\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession\]
        /// API, if
        /// \[GetSessionRequest.include_answer_details\]\[google.cloud.discoveryengine.v1.GetSessionRequest.include_answer_details\]
        /// is set to true, this field will be populated when getting assistant
        /// session.
        #[prost(message, optional, tag = "8")]
        pub detailed_assist_answer: ::core::option::Option<super::AssistAnswer>,
        /// Optional. Represents metadata related to the query config, for example
        /// LLM model and version used, model parameters (temperature, grounding
        /// parameters, etc.). The prefix "google." is reserved for Google-developed
        /// functionality.
        #[prost(map = "string, string", tag = "16")]
        pub query_config: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    /// Enumeration of the state of the session.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified.
        Unspecified = 0,
        /// The session is currently open.
        InProgress = 1,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::InProgress => "IN_PROGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                _ => None,
            }
        }
    }
}
/// Defines a user inputed query.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Query {
    /// Output only. Unique Id for the query.
    #[prost(string, tag = "1")]
    pub query_id: ::prost::alloc::string::String,
    /// Query content.
    #[prost(oneof = "query::Content", tags = "2")]
    pub content: ::core::option::Option<query::Content>,
}
/// Nested message and enum types in `Query`.
pub mod query {
    /// Query content.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Content {
        /// Plain text.
        #[prost(string, tag = "2")]
        Text(::prost::alloc::string::String),
    }
}
/// User metadata of the request.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AssistUserMetadata {
    /// Optional. IANA time zone, e.g. Europe/Budapest.
    #[prost(string, tag = "1")]
    pub time_zone: ::prost::alloc::string::String,
    /// Optional. Preferred language to be used for answering if language detection
    /// fails. Also used as the language of error messages created by actions,
    /// regardless of language detection results.
    #[prost(string, tag = "2")]
    pub preferred_language_code: ::prost::alloc::string::String,
}
/// Request for the
/// \[AssistantService.StreamAssist\]\[google.cloud.discoveryengine.v1.AssistantService.StreamAssist\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAssistRequest {
    /// Required. The resource name of the
    /// \[Assistant\]\[google.cloud.discoveryengine.v1.Assistant\]. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/assistants/{assistant}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Current user query.
    ///
    /// Empty query is only supported if `file_ids` are provided. In this case, the
    /// answer will be generated based on those context files.
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<Query>,
    /// Optional. The session to use for the request. If specified, the assistant
    /// has access to the session history, and the query and the answer are stored
    /// there.
    ///
    /// If `-` is specified as the session ID, or it is left empty, then a new
    /// session is created with an automatically generated ID.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}`
    #[prost(string, tag = "3")]
    pub session: ::prost::alloc::string::String,
    /// Optional. Information about the user initiating the query.
    #[prost(message, optional, tag = "6")]
    pub user_metadata: ::core::option::Option<AssistUserMetadata>,
    /// Optional. Specification of tools that are used to serve the request.
    #[prost(message, optional, tag = "18")]
    pub tools_spec: ::core::option::Option<stream_assist_request::ToolsSpec>,
    /// Optional. Specification of the generation configuration for the request.
    #[prost(message, optional, tag = "19")]
    pub generation_spec: ::core::option::Option<stream_assist_request::GenerationSpec>,
}
/// Nested message and enum types in `StreamAssistRequest`.
pub mod stream_assist_request {
    /// Specification of tools that are used to serve the request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ToolsSpec {
        /// Optional. Specification of the Vertex AI Search tool.
        #[prost(message, optional, tag = "1")]
        pub vertex_ai_search_spec: ::core::option::Option<
            tools_spec::VertexAiSearchSpec,
        >,
        /// Optional. Specification of the web grounding tool.
        /// If field is present, enables grounding with web search. Works only if
        /// \[Assistant.web_grounding_type\]\[google.cloud.discoveryengine.v1.Assistant.web_grounding_type\]
        /// is \[WEB_GROUNDING_TYPE_GOOGLE_SEARCH\]\[\] or
        /// \[WEB_GROUNDING_TYPE_ENTERPRISE_WEB_SEARCH\]\[\].
        #[prost(message, optional, tag = "2")]
        pub web_grounding_spec: ::core::option::Option<tools_spec::WebGroundingSpec>,
        /// Optional. Specification of the image generation tool.
        #[prost(message, optional, tag = "3")]
        pub image_generation_spec: ::core::option::Option<
            tools_spec::ImageGenerationSpec,
        >,
        /// Optional. Specification of the video generation tool.
        #[prost(message, optional, tag = "4")]
        pub video_generation_spec: ::core::option::Option<
            tools_spec::VideoGenerationSpec,
        >,
    }
    /// Nested message and enum types in `ToolsSpec`.
    pub mod tools_spec {
        /// Specification of the Vertex AI Search tool.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct VertexAiSearchSpec {
            /// Optional. Specs defining
            /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s to filter on in
            /// a search call and configurations for those data stores. This is only
            /// considered for \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]s with
            /// multiple data stores.
            #[prost(message, repeated, tag = "2")]
            pub data_store_specs: ::prost::alloc::vec::Vec<
                super::super::search_request::DataStoreSpec,
            >,
            /// Optional. The filter syntax consists of an expression language for
            /// constructing a predicate from one or more fields of the documents being
            /// filtered. Filter expression is case-sensitive.
            ///
            /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
            ///
            /// Filtering in Vertex AI Search is done by mapping the LHS filter key to
            /// a key property defined in the Vertex AI Search backend -- this mapping
            /// is defined by the customer in their schema. For example a media
            /// customer might have a field 'name' in their schema. In this case the
            /// filter would look like this: filter --> name:'ANY("king kong")'
            ///
            /// For more information about filtering including syntax and filter
            /// operators, see
            /// [Filter](<https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata>)
            #[prost(string, tag = "4")]
            pub filter: ::prost::alloc::string::String,
        }
        /// Specification of the web grounding tool.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct WebGroundingSpec {}
        /// Specification of the image generation tool.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ImageGenerationSpec {}
        /// Specification of the video generation tool.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct VideoGenerationSpec {}
    }
    /// Assistant generation specification for the request.
    /// This allows to override the default generation configuration at the engine
    /// level.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GenerationSpec {
        /// Optional. The Vertex AI model_id used for the generative model. If not
        /// set, the default Assistant model will be used.
        #[prost(string, tag = "1")]
        pub model_id: ::prost::alloc::string::String,
    }
}
/// Response for the
/// \[AssistantService.StreamAssist\]\[google.cloud.discoveryengine.v1.AssistantService.StreamAssist\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAssistResponse {
    /// Assist answer resource object containing parts of the assistant's final
    /// answer for the user's query.
    ///
    /// Not present if the current response doesn't add anything to previously
    /// sent
    /// \[AssistAnswer.replies\]\[google.cloud.discoveryengine.v1.AssistAnswer.replies\].
    ///
    /// Observe
    /// \[AssistAnswer.state\]\[google.cloud.discoveryengine.v1.AssistAnswer.state\] to
    /// see if more parts are to be expected. While the state is `IN_PROGRESS`, the
    /// \[AssistAnswer.replies\]\[google.cloud.discoveryengine.v1.AssistAnswer.replies\]
    /// field in each response will contain replies (reply fragments) to be
    /// appended to the ones received in previous responses. \[AssistAnswer.name\]\[\]
    /// won't be filled.
    ///
    /// If the state is `SUCCEEDED`, `FAILED` or `SKIPPED`, the response
    /// is the last response and \[AssistAnswer.name\]\[\] will have a value.
    #[prost(message, optional, tag = "1")]
    pub answer: ::core::option::Option<AssistAnswer>,
    /// Session information.
    #[prost(message, optional, tag = "2")]
    pub session_info: ::core::option::Option<stream_assist_response::SessionInfo>,
    /// A global unique ID that identifies the current pair of request and stream
    /// of responses. Used for feedback and support.
    #[prost(string, tag = "4")]
    pub assist_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StreamAssistResponse`.
pub mod stream_assist_response {
    /// Information about the session.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SessionInfo {
        /// Name of the newly generated or continued session.
        ///
        /// Format:
        /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/sessions/{session}`.
        #[prost(string, tag = "1")]
        pub session: ::prost::alloc::string::String,
    }
}
/// Generated client implementations.
pub mod assistant_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing Assistant configuration and assisting users.
    #[derive(Debug, Clone)]
    pub struct AssistantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AssistantServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AssistantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AssistantServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AssistantServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Assists the user with a query in a streaming fashion.
        pub async fn stream_assist(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamAssistRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamAssistResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.AssistantService/StreamAssist",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.AssistantService",
                        "StreamAssist",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Request message for UpdateCmekConfig method.
/// rpc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCmekConfigRequest {
    /// Required. The CmekConfig resource.
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<CmekConfig>,
    /// Set the following CmekConfig as the default to be used for child
    /// resources if one is not specified.
    #[prost(bool, tag = "2")]
    pub set_default: bool,
}
/// Request message for GetCmekConfigRequest method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCmekConfigRequest {
    /// Required. Resource name of
    /// \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\], such as
    /// `projects/*/locations/*/cmekConfig` or
    /// `projects/*/locations/*/cmekConfigs/*`.
    ///
    /// If the caller does not have permission to access the
    /// \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata for single-regional CMEKs.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SingleRegionKey {
    /// Required. Single-regional kms key resource name which will be used to
    /// encrypt resources
    /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
    #[prost(string, tag = "1")]
    pub kms_key: ::prost::alloc::string::String,
}
/// Configurations used to enable CMEK data encryption with Cloud KMS keys.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmekConfig {
    /// Required. The name of the CmekConfig of the form
    /// `projects/{project}/locations/{location}/cmekConfig` or
    /// `projects/{project}/locations/{location}/cmekConfigs/{cmek_config}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// KMS key resource name which will be used to encrypt resources
    /// `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
    #[prost(string, tag = "2")]
    pub kms_key: ::prost::alloc::string::String,
    /// KMS key version resource name which will be used to encrypt resources
    /// `<kms_key>/cryptoKeyVersions/{keyVersion}`.
    #[prost(string, tag = "6")]
    pub kms_key_version: ::prost::alloc::string::String,
    /// Output only. The states of the CmekConfig.
    #[prost(enumeration = "cmek_config::State", tag = "3")]
    pub state: i32,
    /// Output only. The default CmekConfig for the Customer.
    #[prost(bool, tag = "4")]
    pub is_default: bool,
    /// Output only. The timestamp of the last key rotation.
    #[prost(int64, tag = "5")]
    pub last_rotation_timestamp_micros: i64,
    /// Optional. Single-regional CMEKs that are required for some VAIS features.
    #[prost(message, repeated, tag = "7")]
    pub single_region_keys: ::prost::alloc::vec::Vec<SingleRegionKey>,
    /// Output only. Whether the NotebookLM Corpus is ready to be used.
    #[prost(enumeration = "cmek_config::NotebookLmState", tag = "8")]
    pub notebooklm_state: i32,
}
/// Nested message and enum types in `CmekConfig`.
pub mod cmek_config {
    /// States of the CmekConfig.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The CmekConfig state is unknown.
        Unspecified = 0,
        /// The CmekConfig is creating.
        Creating = 1,
        /// The CmekConfig can be used with DataStores.
        Active = 2,
        /// The CmekConfig is unavailable, most likely due to the KMS Key being
        /// revoked.
        KeyIssue = 3,
        /// The CmekConfig is deleting.
        Deleting = 4,
        /// The CmekConfig deletion process failed.
        DeleteFailed = 7,
        /// The CmekConfig is not usable, most likely due to some internal issue.
        Unusable = 5,
        /// The KMS key version is being rotated.
        ActiveRotating = 6,
        /// The KMS key is soft deleted. Some cleanup policy will eventually be
        /// applied.
        Deleted = 8,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::KeyIssue => "KEY_ISSUE",
                Self::Deleting => "DELETING",
                Self::DeleteFailed => "DELETE_FAILED",
                Self::Unusable => "UNUSABLE",
                Self::ActiveRotating => "ACTIVE_ROTATING",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "KEY_ISSUE" => Some(Self::KeyIssue),
                "DELETING" => Some(Self::Deleting),
                "DELETE_FAILED" => Some(Self::DeleteFailed),
                "UNUSABLE" => Some(Self::Unusable),
                "ACTIVE_ROTATING" => Some(Self::ActiveRotating),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
    /// States of NotebookLM.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NotebookLmState {
        /// The NotebookLM state is unknown.
        Unspecified = 0,
        /// The NotebookLM is not ready.
        NotebookLmNotReady = 1,
        /// The NotebookLM is ready to be used.
        NotebookLmReady = 2,
        /// The NotebookLM is not enabled.
        NotebookLmNotEnabled = 3,
    }
    impl NotebookLmState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NOTEBOOK_LM_STATE_UNSPECIFIED",
                Self::NotebookLmNotReady => "NOTEBOOK_LM_NOT_READY",
                Self::NotebookLmReady => "NOTEBOOK_LM_READY",
                Self::NotebookLmNotEnabled => "NOTEBOOK_LM_NOT_ENABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NOTEBOOK_LM_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOTEBOOK_LM_NOT_READY" => Some(Self::NotebookLmNotReady),
                "NOTEBOOK_LM_READY" => Some(Self::NotebookLmReady),
                "NOTEBOOK_LM_NOT_ENABLED" => Some(Self::NotebookLmNotEnabled),
                _ => None,
            }
        }
    }
}
/// Metadata related to the progress of the
/// \[CmekConfigService.UpdateCmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfigService.UpdateCmekConfig\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateCmekConfigMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[CmekConfigService.ListCmekConfigs\]\[google.cloud.discoveryengine.v1.CmekConfigService.ListCmekConfigs\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCmekConfigsRequest {
    /// Required. The parent location resource name, such as
    /// `projects/{project}/locations/{location}`.
    ///
    /// If the caller does not have permission to list
    /// \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\]s under this
    /// location, regardless of whether or not a CmekConfig exists, a
    /// PERMISSION_DENIED error is returned.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Response message for
/// \[CmekConfigService.ListCmekConfigs\]\[google.cloud.discoveryengine.v1.CmekConfigService.ListCmekConfigs\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCmekConfigsResponse {
    /// All the customer's
    /// \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\]s.
    #[prost(message, repeated, tag = "1")]
    pub cmek_configs: ::prost::alloc::vec::Vec<CmekConfig>,
}
/// Request message for
/// \[CmekConfigService.DeleteCmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfigService.DeleteCmekConfig\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCmekConfigRequest {
    /// Required. The resource name of the
    /// \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\] to delete, such as
    /// `projects/{project}/locations/{location}/cmekConfigs/{cmek_config}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata related to the progress of the
/// \[CmekConfigService.DeleteCmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfigService.DeleteCmekConfig\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCmekConfigMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod cmek_config_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing CMEK related tasks
    #[derive(Debug, Clone)]
    pub struct CmekConfigServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CmekConfigServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CmekConfigServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CmekConfigServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CmekConfigServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Provisions a CMEK key for use in a location of a customer's project.
        /// This method will also conduct location validation on the provided
        /// cmekConfig to make sure the key is valid and can be used in the
        /// selected location.
        pub async fn update_cmek_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCmekConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CmekConfigService/UpdateCmekConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CmekConfigService",
                        "UpdateCmekConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\].
        pub async fn get_cmek_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCmekConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::CmekConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CmekConfigService/GetCmekConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CmekConfigService",
                        "GetCmekConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the \[CmekConfig\]\[google.cloud.discoveryengine.v1.CmekConfig\]s
        /// with the project.
        pub async fn list_cmek_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCmekConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCmekConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CmekConfigService/ListCmekConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CmekConfigService",
                        "ListCmekConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// De-provisions a CmekConfig.
        pub async fn delete_cmek_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCmekConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CmekConfigService/DeleteCmekConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CmekConfigService",
                        "DeleteCmekConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Suggestion deny list entry identifying the phrase to block from suggestions
/// and the applied operation for the phrase.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SuggestionDenyListEntry {
    /// Required. Phrase to block from suggestions served. Can be maximum 125
    /// characters.
    #[prost(string, tag = "1")]
    pub block_phrase: ::prost::alloc::string::String,
    /// Required. The match operator to apply for this phrase. Whether to block the
    /// exact phrase, or block any suggestions containing this phrase.
    #[prost(enumeration = "suggestion_deny_list_entry::MatchOperator", tag = "2")]
    pub match_operator: i32,
}
/// Nested message and enum types in `SuggestionDenyListEntry`.
pub mod suggestion_deny_list_entry {
    /// Operator for matching with the generated suggestions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchOperator {
        /// Default value. Should not be used
        Unspecified = 0,
        /// If the suggestion is an exact match to the block_phrase, then block it.
        ExactMatch = 1,
        /// If the suggestion contains the block_phrase, then block it.
        Contains = 2,
    }
    impl MatchOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MATCH_OPERATOR_UNSPECIFIED",
                Self::ExactMatch => "EXACT_MATCH",
                Self::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MATCH_OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                "EXACT_MATCH" => Some(Self::ExactMatch),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
/// Autocomplete suggestions that are imported from Customer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompletionSuggestion {
    /// Required. The suggestion text.
    #[prost(string, tag = "1")]
    pub suggestion: ::prost::alloc::string::String,
    /// BCP-47 language code of this suggestion.
    #[prost(string, tag = "4")]
    pub language_code: ::prost::alloc::string::String,
    /// If two suggestions have the same groupId, they will not be
    /// returned together. Instead the one ranked higher will be returned. This can
    /// be used to deduplicate semantically identical suggestions.
    #[prost(string, tag = "5")]
    pub group_id: ::prost::alloc::string::String,
    /// The score of this suggestion within its group.
    #[prost(double, tag = "6")]
    pub group_score: f64,
    /// Alternative matching phrases for this suggestion.
    #[prost(string, repeated, tag = "7")]
    pub alternative_phrases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ranking metrics of this suggestion.
    #[prost(oneof = "completion_suggestion::RankingInfo", tags = "2, 3")]
    pub ranking_info: ::core::option::Option<completion_suggestion::RankingInfo>,
}
/// Nested message and enum types in `CompletionSuggestion`.
pub mod completion_suggestion {
    /// Ranking metrics of this suggestion.
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum RankingInfo {
        /// Global score of this suggestion. Control how this suggestion would be
        /// scored / ranked.
        #[prost(double, tag = "2")]
        GlobalScore(f64),
        /// Frequency of this suggestion. Will be used to rank suggestions when score
        /// is not available.
        #[prost(int64, tag = "3")]
        Frequency(i64),
    }
}
/// UserEvent captures all metadata information Discovery Engine API needs to
/// know about how end users interact with your website.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserEvent {
    /// Required. User event type. Allowed values are:
    ///
    /// Generic values:
    ///
    /// * `search`: Search for Documents.
    /// * `view-item`: Detailed page view of a Document.
    /// * `view-item-list`: View of a panel or ordered list of Documents.
    /// * `view-home-page`: View of the home page.
    /// * `view-category-page`: View of a category page, e.g. Home > Men > Jeans
    /// * `add-feedback`: Add a user feedback.
    ///
    /// Retail-related values:
    ///
    /// * `add-to-cart`: Add an item(s) to cart, e.g. in Retail online shopping
    /// * `purchase`: Purchase an item(s)
    ///
    /// Media-related values:
    ///
    /// * `media-play`: Start/resume watching a video, playing a song, etc.
    /// * `media-complete`: Finished or stopped midway through a video, song, etc.
    ///
    /// Custom conversion value:
    ///
    /// * `conversion`: Customer defined conversion event.
    #[prost(string, tag = "1")]
    pub event_type: ::prost::alloc::string::String,
    /// Optional. Conversion type.
    ///
    /// Required if
    /// \[UserEvent.event_type\]\[google.cloud.discoveryengine.v1.UserEvent.event_type\]
    /// is `conversion`. This is a customer-defined conversion name in lowercase
    /// letters or numbers separated by "-", such as "watch", "good-visit" etc.
    ///
    /// Do not set the field if
    /// \[UserEvent.event_type\]\[google.cloud.discoveryengine.v1.UserEvent.event_type\]
    /// is not `conversion`. This mixes the custom conversion event with predefined
    /// events like `search`, `view-item` etc.
    #[prost(string, tag = "21")]
    pub conversion_type: ::prost::alloc::string::String,
    /// Required. A unique identifier for tracking visitors.
    ///
    /// For example, this could be implemented with an HTTP cookie, which should be
    /// able to uniquely identify a visitor on a single device. This unique
    /// identifier should not change if the visitor log in/out of the website.
    ///
    /// Do not set the field to the same fixed ID for different users. This mixes
    /// the event history of those users together, which results in degraded model
    /// quality.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// The field should not contain PII or user-data. We recommend to use Google
    /// Analytics [Client
    /// ID](<https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#clientId>)
    /// for this field.
    #[prost(string, tag = "2")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    /// The \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] resource name, in the
    /// form of
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    ///
    /// Optional. Only required for
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] produced user events. For
    /// example, user events from blended search.
    #[prost(string, tag = "19")]
    pub engine: ::prost::alloc::string::String,
    /// The \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] resource full
    /// name, of the form
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// Optional. Only required for user events whose data store can't by
    /// determined by
    /// \[UserEvent.engine\]\[google.cloud.discoveryengine.v1.UserEvent.engine\] or
    /// \[UserEvent.documents\]\[google.cloud.discoveryengine.v1.UserEvent.documents\].
    /// If data store is set in the parent of write/import/collect user event
    /// requests, this field can be omitted.
    #[prost(string, tag = "20")]
    pub data_store: ::prost::alloc::string::String,
    /// Only required for
    /// \[UserEventService.ImportUserEvents\]\[google.cloud.discoveryengine.v1.UserEventService.ImportUserEvents\]
    /// method. Timestamp of when the user event happened.
    #[prost(message, optional, tag = "3")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Information about the end user.
    #[prost(message, optional, tag = "4")]
    pub user_info: ::core::option::Option<UserInfo>,
    /// Should set to true if the request is made directly from the end user, in
    /// which case the
    /// \[UserEvent.user_info.user_agent\]\[google.cloud.discoveryengine.v1.UserInfo.user_agent\]
    /// can be populated from the HTTP request.
    ///
    /// This flag should be set only if the API request is made directly from the
    /// end user such as a mobile app (and not if a gateway or a server is
    /// processing and pushing the user events).
    ///
    /// This should not be set when using the JavaScript tag in
    /// \[UserEventService.CollectUserEvent\]\[google.cloud.discoveryengine.v1.UserEventService.CollectUserEvent\].
    #[prost(bool, tag = "5")]
    pub direct_user_request: bool,
    /// A unique identifier for tracking a visitor session with a length limit of
    /// 128 bytes. A session is an aggregation of an end user behavior in a time
    /// span.
    ///
    /// A general guideline to populate the session_id:
    ///
    /// 1. If user has no activity for 30 min, a new session_id should be assigned.
    /// 1. The session_id should be unique across users, suggest use uuid or add
    ///    \[UserEvent.user_pseudo_id\]\[google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id\]
    ///    as prefix.
    #[prost(string, tag = "6")]
    pub session_id: ::prost::alloc::string::String,
    /// Page metadata such as categories and other critical information for certain
    /// event types such as `view-category-page`.
    #[prost(message, optional, tag = "7")]
    pub page_info: ::core::option::Option<PageInfo>,
    /// Token to attribute an API response to user action(s) to trigger the event.
    ///
    /// Highly recommended for user events that are the result of
    /// \[RecommendationService.Recommend\]\[google.cloud.discoveryengine.v1.RecommendationService.Recommend\].
    /// This field enables accurate attribution of recommendation model
    /// performance.
    ///
    /// The value must be one of:
    ///
    /// * \[RecommendResponse.attribution_token\]\[google.cloud.discoveryengine.v1.RecommendResponse.attribution_token\] for events that are the result of
    ///   \[RecommendationService.Recommend\]\[google.cloud.discoveryengine.v1.RecommendationService.Recommend\].
    /// * \[SearchResponse.attribution_token\]\[google.cloud.discoveryengine.v1.SearchResponse.attribution_token\] for events that are the result of
    ///   \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\].
    ///
    /// This token enables us to accurately attribute page view or conversion
    /// completion back to the event and the particular predict response containing
    /// this clicked/purchased product. If user clicks on product K in the
    /// recommendation results, pass
    /// \[RecommendResponse.attribution_token\]\[google.cloud.discoveryengine.v1.RecommendResponse.attribution_token\]
    /// as a URL parameter to product K's page. When recording events on product
    /// K's page, log the
    /// \[RecommendResponse.attribution_token\]\[google.cloud.discoveryengine.v1.RecommendResponse.attribution_token\]
    /// to this field.
    #[prost(string, tag = "8")]
    pub attribution_token: ::prost::alloc::string::String,
    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the documents being filtered.
    ///
    /// One example is for `search` events, the associated
    /// \[SearchRequest\]\[google.cloud.discoveryengine.v1.SearchRequest\] may contain
    /// a filter expression in
    /// \[SearchRequest.filter\]\[google.cloud.discoveryengine.v1.SearchRequest.filter\]
    /// conforming to <https://google.aip.dev/160#filtering.>
    ///
    /// Similarly, for `view-item-list` events that are generated from a
    /// \[RecommendRequest\]\[google.cloud.discoveryengine.v1.RecommendRequest\], this
    /// field may be populated directly from
    /// \[RecommendRequest.filter\]\[google.cloud.discoveryengine.v1.RecommendRequest.filter\]
    /// conforming to <https://google.aip.dev/160#filtering.>
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "9")]
    pub filter: ::prost::alloc::string::String,
    /// List of \[Document\]\[google.cloud.discoveryengine.v1.Document\]s associated
    /// with this user event.
    ///
    /// This field is optional except for the following event types:
    ///
    /// * `view-item`
    /// * `add-to-cart`
    /// * `purchase`
    /// * `media-play`
    /// * `media-complete`
    ///
    /// In a `search` event, this field represents the documents returned to the
    /// end user on the current page (the end user may have not finished browsing
    /// the whole page yet). When a new page is returned to the end user, after
    /// pagination/filtering/ordering even for the same query, a new `search` event
    /// with different
    /// \[UserEvent.documents\]\[google.cloud.discoveryengine.v1.UserEvent.documents\]
    /// is desired.
    #[prost(message, repeated, tag = "10")]
    pub documents: ::prost::alloc::vec::Vec<DocumentInfo>,
    /// Panel metadata associated with this user event.
    #[prost(message, optional, tag = "11")]
    pub panel: ::core::option::Option<PanelInfo>,
    /// \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
    /// details related to the event.
    ///
    /// This field should be set for `search` event.
    #[prost(message, optional, tag = "12")]
    pub search_info: ::core::option::Option<SearchInfo>,
    /// \[CompletionService.CompleteQuery\]\[google.cloud.discoveryengine.v1.CompletionService.CompleteQuery\]
    /// details related to the event.
    ///
    /// This field should be set for `search` event when autocomplete function is
    /// enabled and the user clicks a suggestion for search.
    #[prost(message, optional, tag = "13")]
    pub completion_info: ::core::option::Option<CompletionInfo>,
    /// The transaction metadata (if any) associated with this user event.
    #[prost(message, optional, tag = "14")]
    pub transaction_info: ::core::option::Option<TransactionInfo>,
    /// A list of identifiers for the independent experiment groups this user event
    /// belongs to. This is used to distinguish between user events associated with
    /// different experiment setups.
    #[prost(string, repeated, tag = "15")]
    pub tag_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The promotion IDs if this is an event associated with promotions.
    /// Currently, this field is restricted to at most one ID.
    #[prost(string, repeated, tag = "16")]
    pub promotion_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Extra user event features to include in the recommendation model.
    /// These attributes must NOT contain data that needs to be parsed or processed
    /// further, e.g. JSON or other encodings.
    ///
    /// If you provide custom attributes for ingested user events, also include
    /// them in the user events that you associate with prediction requests. Custom
    /// attribute formatting must be consistent between imported events and events
    /// provided with prediction requests. This lets the Discovery Engine API use
    /// those custom attributes when training models and serving predictions, which
    /// helps improve recommendation quality.
    ///
    /// This field needs to pass all below criteria, otherwise an
    /// `INVALID_ARGUMENT` error is returned:
    ///
    /// * The key must be a UTF-8 encoded string with a length limit of 5,000
    ///   characters.
    /// * For text attributes, at most 400 values are allowed. Empty values are not
    ///   allowed. Each value must be a UTF-8 encoded string with a length limit of
    ///   256 characters.
    /// * For number attributes, at most 400 values are allowed.
    ///
    /// For product recommendations, an example of extra user information is
    /// `traffic_channel`, which is how a user arrives at the site. Users can
    /// arrive
    /// at the site by coming to the site directly, coming through Google
    /// search, or in other ways.
    #[prost(map = "string, message", tag = "17")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        CustomAttribute,
    >,
    /// Media-specific info.
    #[prost(message, optional, tag = "18")]
    pub media_info: ::core::option::Option<MediaInfo>,
    /// Optional. List of panels associated with this event.
    /// Used for page-level impression data.
    #[prost(message, repeated, tag = "22")]
    pub panels: ::prost::alloc::vec::Vec<PanelInfo>,
}
/// Detailed page information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PageInfo {
    /// A unique ID of a web page view.
    ///
    /// This should be kept the same for all user events triggered from the same
    /// pageview. For example, an item detail page view could trigger multiple
    /// events as the user is browsing the page. The `pageview_id` property should
    /// be kept the same for all these events so that they can be grouped together
    /// properly.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically.
    #[prost(string, tag = "1")]
    pub pageview_id: ::prost::alloc::string::String,
    /// The most specific category associated with a category page.
    ///
    /// To represent full path of category, use '>' sign to separate different
    /// hierarchies. If '>' is part of the category name, replace it with
    /// other character(s).
    ///
    /// Category pages include special pages such as sales or promotions. For
    /// instance, a special sale page may have the category hierarchy:
    /// `"pageCategory" : "Sales > 2017 Black Friday Deals"`.
    ///
    /// Required for `view-category-page` events. Other event types should not set
    /// this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "2")]
    pub page_category: ::prost::alloc::string::String,
    /// Complete URL (window.location.href) of the user's current page.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically. Maximum length 5,000
    /// characters.
    #[prost(string, tag = "3")]
    pub uri: ::prost::alloc::string::String,
    /// The referrer URL of the current page.
    ///
    /// When using the client side event reporting with JavaScript pixel and Google
    /// Tag Manager, this value is filled in automatically. However, some browser
    /// privacy restrictions may cause this field to be empty.
    #[prost(string, tag = "4")]
    pub referrer_uri: ::prost::alloc::string::String,
}
/// Detailed search information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchInfo {
    /// The user's search query.
    ///
    /// See
    /// \[SearchRequest.query\]\[google.cloud.discoveryengine.v1.SearchRequest.query\]
    /// for definition.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 5,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// At least one of
    /// \[search_query\]\[google.cloud.discoveryengine.v1.SearchInfo.search_query\] or
    /// \[PageInfo.page_category\]\[google.cloud.discoveryengine.v1.PageInfo.page_category\]
    /// is required for `search` events. Other event types should not set this
    /// field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "1")]
    pub search_query: ::prost::alloc::string::String,
    /// The order in which products are returned, if applicable.
    ///
    /// See
    /// \[SearchRequest.order_by\]\[google.cloud.discoveryengine.v1.SearchRequest.order_by\]
    /// for definition and syntax.
    ///
    /// The value must be a UTF-8 encoded string with a length limit of 1,000
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    ///
    /// This can only be set for `search` events. Other event types should not set
    /// this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "2")]
    pub order_by: ::prost::alloc::string::String,
    /// An integer that specifies the current offset for pagination (the 0-indexed
    /// starting location, amongst the products deemed by the API as relevant).
    ///
    /// See
    /// \[SearchRequest.offset\]\[google.cloud.discoveryengine.v1.SearchRequest.offset\]
    /// for definition.
    ///
    /// If this field is negative, an `INVALID_ARGUMENT` is returned.
    ///
    /// This can only be set for `search` events. Other event types should not set
    /// this field. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(int32, optional, tag = "3")]
    pub offset: ::core::option::Option<i32>,
}
/// Detailed completion information including completion attribution token and
/// clicked completion info.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompletionInfo {
    /// End user selected
    /// \[CompleteQueryResponse.QuerySuggestion.suggestion\]\[google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion.suggestion\].
    #[prost(string, tag = "1")]
    pub selected_suggestion: ::prost::alloc::string::String,
    /// End user selected
    /// \[CompleteQueryResponse.QuerySuggestion.suggestion\]\[google.cloud.discoveryengine.v1.CompleteQueryResponse.QuerySuggestion.suggestion\]
    /// position, starting from 0.
    #[prost(int32, tag = "2")]
    pub selected_position: i32,
}
/// A transaction represents the entire purchase transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
    /// Required. Total non-zero value associated with the transaction. This value
    /// may include shipping, tax, or other adjustments to the total value that you
    /// want to include.
    #[prost(float, optional, tag = "1")]
    pub value: ::core::option::Option<f32>,
    /// Required. Currency code. Use three-character ISO-4217 code.
    #[prost(string, tag = "2")]
    pub currency: ::prost::alloc::string::String,
    /// The transaction ID with a length limit of 128 characters.
    #[prost(string, tag = "3")]
    pub transaction_id: ::prost::alloc::string::String,
    /// All the taxes associated with the transaction.
    #[prost(float, optional, tag = "4")]
    pub tax: ::core::option::Option<f32>,
    /// All the costs associated with the products. These can be manufacturing
    /// costs, shipping expenses not borne by the end user, or any other costs,
    /// such that:
    ///
    /// * Profit = \[value\]\[google.cloud.discoveryengine.v1.TransactionInfo.value\] -
    ///   \[tax\]\[google.cloud.discoveryengine.v1.TransactionInfo.tax\] -
    ///   \[cost\]\[google.cloud.discoveryengine.v1.TransactionInfo.cost\]
    #[prost(float, optional, tag = "5")]
    pub cost: ::core::option::Option<f32>,
    /// The total discount(s) value applied to this transaction.
    /// This figure should be excluded from
    /// \[TransactionInfo.value\]\[google.cloud.discoveryengine.v1.TransactionInfo.value\]
    ///
    /// For example, if a user paid
    /// \[TransactionInfo.value\]\[google.cloud.discoveryengine.v1.TransactionInfo.value\]
    /// amount, then nominal (pre-discount) value of the transaction is the sum of
    /// \[TransactionInfo.value\]\[google.cloud.discoveryengine.v1.TransactionInfo.value\]
    /// and
    /// \[TransactionInfo.discount_value\]\[google.cloud.discoveryengine.v1.TransactionInfo.discount_value\]
    ///
    /// This means that profit is calculated the same way, regardless of the
    /// discount value, and that
    /// \[TransactionInfo.discount_value\]\[google.cloud.discoveryengine.v1.TransactionInfo.discount_value\]
    /// can be larger than
    /// \[TransactionInfo.value\]\[google.cloud.discoveryengine.v1.TransactionInfo.value\]:
    ///
    /// * Profit = \[value\]\[google.cloud.discoveryengine.v1.TransactionInfo.value\] -
    ///   \[tax\]\[google.cloud.discoveryengine.v1.TransactionInfo.tax\] -
    ///   \[cost\]\[google.cloud.discoveryengine.v1.TransactionInfo.cost\]
    #[prost(float, optional, tag = "6")]
    pub discount_value: ::core::option::Option<f32>,
}
/// Detailed document information associated with a user event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentInfo {
    /// Quantity of the Document associated with the user event. Defaults to 1.
    ///
    /// For example, this field is 2 if two quantities of the same Document
    /// are involved in a `add-to-cart` event.
    ///
    /// Required for events of the following event types:
    ///
    /// * `add-to-cart`
    /// * `purchase`
    #[prost(int32, optional, tag = "3")]
    pub quantity: ::core::option::Option<i32>,
    /// The promotion IDs associated with this Document.
    /// Currently, this field is restricted to at most one ID.
    #[prost(string, repeated, tag = "4")]
    pub promotion_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Whether the referenced Document can be found in the data
    /// store.
    #[prost(bool, tag = "5")]
    pub joined: bool,
    /// Optional. The conversion value associated with this Document.
    /// Must be set if
    /// \[UserEvent.event_type\]\[google.cloud.discoveryengine.v1.UserEvent.event_type\]
    /// is "conversion".
    ///
    /// For example, a value of 1000 signifies that 1000 seconds were spent viewing
    /// a Document for the `watch` conversion type.
    #[prost(float, optional, tag = "7")]
    pub conversion_value: ::core::option::Option<f32>,
    /// A required descriptor of the associated
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
    ///
    /// * If \[id\]\[google.cloud.discoveryengine.v1.DocumentInfo.id\] is specified,
    ///   then the default values for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and `{branch_id}` are
    ///   used when annotating with the stored Document.
    ///
    /// * If \[name\]\[google.cloud.discoveryengine.v1.DocumentInfo.name\] is
    ///   specified, then the provided values (default values allowed) for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and
    ///   `{branch_id}` are used when annotating with the stored Document.
    #[prost(oneof = "document_info::DocumentDescriptor", tags = "1, 2, 6")]
    pub document_descriptor: ::core::option::Option<document_info::DocumentDescriptor>,
}
/// Nested message and enum types in `DocumentInfo`.
pub mod document_info {
    /// A required descriptor of the associated
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
    ///
    /// * If \[id\]\[google.cloud.discoveryengine.v1.DocumentInfo.id\] is specified,
    ///   then the default values for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and `{branch_id}` are
    ///   used when annotating with the stored Document.
    ///
    /// * If \[name\]\[google.cloud.discoveryengine.v1.DocumentInfo.name\] is
    ///   specified, then the provided values (default values allowed) for
    ///   `{location}`, `{collection_id}`, `{data_store_id}`, and
    ///   `{branch_id}` are used when annotating with the stored Document.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DocumentDescriptor {
        /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\] resource ID.
        #[prost(string, tag = "1")]
        Id(::prost::alloc::string::String),
        /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\] resource full
        /// name, of the form:
        /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/branches/{branch_id}/documents/{document_id}`
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\] URI - only
        /// allowed for website data stores.
        #[prost(string, tag = "6")]
        Uri(::prost::alloc::string::String),
    }
}
/// Detailed panel information associated with a user event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PanelInfo {
    /// Required. The panel ID.
    #[prost(string, tag = "2")]
    pub panel_id: ::prost::alloc::string::String,
    /// The display name of the panel.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// The ordered position of the panel, if shown to the user with other panels.
    /// If set, then
    /// \[total_panels\]\[google.cloud.discoveryengine.v1.PanelInfo.total_panels\] must
    /// also be set.
    #[prost(int32, optional, tag = "4")]
    pub panel_position: ::core::option::Option<i32>,
    /// The total number of panels, including this one, shown to the user.
    /// Must be set if
    /// \[panel_position\]\[google.cloud.discoveryengine.v1.PanelInfo.panel_position\]
    /// is set.
    #[prost(int32, optional, tag = "5")]
    pub total_panels: ::core::option::Option<i32>,
    /// Optional. The document IDs associated with this panel.
    #[prost(message, repeated, tag = "6")]
    pub documents: ::prost::alloc::vec::Vec<DocumentInfo>,
}
/// Media-specific user event information.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaInfo {
    /// The media progress time in seconds, if applicable.
    /// For example, if the end user has finished 90 seconds of a playback video,
    /// then
    /// \[MediaInfo.media_progress_duration.seconds\]\[google.protobuf.Duration.seconds\]
    /// should be set to 90.
    #[prost(message, optional, tag = "1")]
    pub media_progress_duration: ::core::option::Option<::prost_types::Duration>,
    /// Media progress should be computed using only the
    /// \[media_progress_duration\]\[google.cloud.discoveryengine.v1.MediaInfo.media_progress_duration\]
    /// relative to the media total length.
    ///
    /// This value must be between `\[0, 1.0\]` inclusive.
    ///
    /// If this is not a playback or the progress cannot be computed (e.g. ongoing
    /// livestream), this field should be unset.
    #[prost(float, optional, tag = "2")]
    pub media_progress_percentage: ::core::option::Option<f32>,
}
/// Cloud Storage location for input content.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcsSource {
    /// Required. Cloud Storage URIs to input files. Each URI can be up to
    /// 2000 characters long. URIs can match the full object path (for example,
    /// `gs://bucket/directory/object.json`) or a pattern matching one or more
    /// files, such as `gs://bucket/directory/*.json`.
    ///
    /// A request can contain at most 100 files (or 100,000 files if `data_schema`
    /// is `content`). Each file can be up to 2 GB (or 100 MB if `data_schema` is
    /// `content`).
    #[prost(string, repeated, tag = "1")]
    pub input_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The schema to use when parsing the data from the source.
    ///
    /// Supported values for document imports:
    ///
    /// * `document` (default): One JSON
    ///   \[Document\]\[google.cloud.discoveryengine.v1.Document\] per line. Each
    ///   document must
    ///   have a valid \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\].
    /// * `content`: Unstructured data (e.g. PDF, HTML). Each file matched by
    ///   `input_uris` becomes a document, with the ID set to the first 128
    ///   bits of SHA256(URI) encoded as a hex string.
    /// * `custom`: One custom data JSON per row in arbitrary format that conforms
    ///   to the defined \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] of the
    ///   data store. This can only be used by the GENERIC Data Store vertical.
    /// * `csv`: A CSV file with header conforming to the defined
    ///   \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] of the
    ///   data store. Each entry after the header is imported as a Document.
    ///   This can only be used by the GENERIC Data Store vertical.
    ///
    /// Supported values for user event imports:
    ///
    /// * `user_event` (default): One JSON
    ///   \[UserEvent\]\[google.cloud.discoveryengine.v1.UserEvent\] per line.
    #[prost(string, tag = "2")]
    pub data_schema: ::prost::alloc::string::String,
}
/// BigQuery source import data from.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BigQuerySource {
    /// The project ID or the project number that contains the BigQuery source. Has
    /// a length limit of 128 characters. If not specified, inherits the project
    /// ID from the parent request.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The BigQuery data set to copy the data from with a length limit
    /// of 1,024 characters.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. The BigQuery table to copy the data from with a length limit of
    /// 1,024 characters.
    #[prost(string, tag = "3")]
    pub table_id: ::prost::alloc::string::String,
    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// BigQuery export to a specific Cloud Storage directory.
    #[prost(string, tag = "4")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
    /// The schema to use when parsing the data from the source.
    ///
    /// Supported values for user event imports:
    ///
    /// * `user_event` (default): One
    ///   \[UserEvent\]\[google.cloud.discoveryengine.v1.UserEvent\] per row.
    ///
    /// Supported values for document imports:
    ///
    /// * `document` (default): One
    ///   \[Document\]\[google.cloud.discoveryengine.v1.Document\] format per
    ///   row. Each document must have a valid
    ///   \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\] and one of
    ///   \[Document.json_data\]\[google.cloud.discoveryengine.v1.Document.json_data\]
    ///   or
    ///   \[Document.struct_data\]\[google.cloud.discoveryengine.v1.Document.struct_data\].
    /// * `custom`: One custom data per row in arbitrary format that conforms to
    ///   the defined \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] of the data
    ///   store. This can only be used by the GENERIC Data Store vertical.
    #[prost(string, tag = "6")]
    pub data_schema: ::prost::alloc::string::String,
    /// BigQuery table partition info. Leave this empty if the BigQuery table
    /// is not partitioned.
    #[prost(oneof = "big_query_source::Partition", tags = "5")]
    pub partition: ::core::option::Option<big_query_source::Partition>,
}
/// Nested message and enum types in `BigQuerySource`.
pub mod big_query_source {
    /// BigQuery table partition info. Leave this empty if the BigQuery table
    /// is not partitioned.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Partition {
        /// BigQuery time partitioned table's \_PARTITIONDATE in YYYY-MM-DD format.
        #[prost(message, tag = "5")]
        PartitionDate(super::super::super::super::r#type::Date),
    }
}
/// The Spanner source for importing data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SpannerSource {
    /// The project ID that contains the Spanner source. Has a length limit of 128
    /// characters. If not specified, inherits the project ID from the parent
    /// request.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The instance ID of the source Spanner table.
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    /// Required. The database ID of the source Spanner table.
    #[prost(string, tag = "3")]
    pub database_id: ::prost::alloc::string::String,
    /// Required. The table name of the Spanner database that needs to be imported.
    #[prost(string, tag = "4")]
    pub table_id: ::prost::alloc::string::String,
    /// Whether to apply data boost on Spanner export. Enabling this option will
    /// incur additional cost. More info can be found
    /// [here](<https://cloud.google.com/spanner/docs/databoost/databoost-overview#billing_and_quotas>).
    #[prost(bool, tag = "5")]
    pub enable_data_boost: bool,
}
/// The Bigtable Options object that contains information to support
/// the import.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableOptions {
    /// The field name used for saving row key value in the document. The name has
    /// to match the pattern `[a-zA-Z0-9][a-zA-Z0-9-_]*`.
    #[prost(string, tag = "1")]
    pub key_field_name: ::prost::alloc::string::String,
    /// The mapping from family names to an object that contains column families
    /// level information for the given column family. If a family is not present
    /// in this map it will be ignored.
    #[prost(map = "string, message", tag = "2")]
    pub families: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        bigtable_options::BigtableColumnFamily,
    >,
}
/// Nested message and enum types in `BigtableOptions`.
pub mod bigtable_options {
    /// The column family of the Bigtable.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BigtableColumnFamily {
        /// The field name to use for this column family in the document. The
        /// name has to match the pattern `[a-zA-Z0-9][a-zA-Z0-9-_]*`. If not set,
        /// it is parsed from the family name with best effort. However, due to
        /// different naming patterns, field name collisions could happen, where
        /// parsing behavior is undefined.
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        /// The encoding mode of the values when the type is not STRING.
        /// Acceptable encoding values are:
        ///
        /// * `TEXT`: indicates values are alphanumeric text strings.
        /// * `BINARY`: indicates values are encoded using `HBase Bytes.toBytes`
        ///   family of functions. This can be overridden for a specific column
        ///   by listing that column in `columns` and specifying an encoding for it.
        #[prost(enumeration = "Encoding", tag = "2")]
        pub encoding: i32,
        /// The type of values in this column family.
        /// The values are expected to be encoded using `HBase Bytes.toBytes`
        /// function when the encoding value is set to `BINARY`.
        #[prost(enumeration = "Type", tag = "3")]
        pub r#type: i32,
        /// The list of objects that contains column level information for each
        /// column. If a column is not present in this list it will be ignored.
        #[prost(message, repeated, tag = "4")]
        pub columns: ::prost::alloc::vec::Vec<BigtableColumn>,
    }
    /// The column of the Bigtable.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BigtableColumn {
        /// Required. Qualifier of the column. If it cannot be decoded with utf-8,
        /// use a base-64 encoded string instead.
        #[prost(bytes = "vec", tag = "1")]
        pub qualifier: ::prost::alloc::vec::Vec<u8>,
        /// The field name to use for this column in the document. The name has to
        /// match the pattern `[a-zA-Z0-9][a-zA-Z0-9-_]*`.
        /// If not set, it is parsed from the qualifier bytes with best effort.
        /// However, due to different naming patterns, field name collisions could
        /// happen, where parsing behavior is undefined.
        #[prost(string, tag = "2")]
        pub field_name: ::prost::alloc::string::String,
        /// The encoding mode of the values when the type is not `STRING`.
        /// Acceptable encoding values are:
        ///
        /// * `TEXT`: indicates values are alphanumeric text strings.
        /// * `BINARY`: indicates values are encoded using `HBase Bytes.toBytes`
        ///   family of functions. This can be overridden for a specific column
        ///   by listing that column in `columns` and specifying an encoding for it.
        #[prost(enumeration = "Encoding", tag = "3")]
        pub encoding: i32,
        /// The type of values in this column family.
        /// The values are expected to be encoded using `HBase Bytes.toBytes`
        /// function when the encoding value is set to `BINARY`.
        #[prost(enumeration = "Type", tag = "4")]
        pub r#type: i32,
    }
    /// The type of values in a Bigtable column or column family.
    /// The values are expected to be encoded using
    /// [HBase
    /// Bytes.toBytes](<https://hbase.apache.org/1.4/apidocs/org/apache/hadoop/hbase/util/Bytes.html>)
    /// function when the encoding value is set to `BINARY`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// The type is unspecified.
        Unspecified = 0,
        /// String type.
        String = 1,
        /// Numerical type.
        Number = 2,
        /// Integer type.
        Integer = 3,
        /// Variable length integer type.
        VarInteger = 4,
        /// BigDecimal type.
        BigNumeric = 5,
        /// Boolean type.
        Boolean = 6,
        /// JSON type.
        Json = 7,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::String => "STRING",
                Self::Number => "NUMBER",
                Self::Integer => "INTEGER",
                Self::VarInteger => "VAR_INTEGER",
                Self::BigNumeric => "BIG_NUMERIC",
                Self::Boolean => "BOOLEAN",
                Self::Json => "JSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "NUMBER" => Some(Self::Number),
                "INTEGER" => Some(Self::Integer),
                "VAR_INTEGER" => Some(Self::VarInteger),
                "BIG_NUMERIC" => Some(Self::BigNumeric),
                "BOOLEAN" => Some(Self::Boolean),
                "JSON" => Some(Self::Json),
                _ => None,
            }
        }
    }
    /// The encoding mode of a Bigtable column or column family.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Encoding {
        /// The encoding is unspecified.
        Unspecified = 0,
        /// Text encoding.
        Text = 1,
        /// Binary encoding.
        Binary = 2,
    }
    impl Encoding {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENCODING_UNSPECIFIED",
                Self::Text => "TEXT",
                Self::Binary => "BINARY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENCODING_UNSPECIFIED" => Some(Self::Unspecified),
                "TEXT" => Some(Self::Text),
                "BINARY" => Some(Self::Binary),
                _ => None,
            }
        }
    }
}
/// The Cloud Bigtable source for importing data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigtableSource {
    /// The project ID that contains the Bigtable source. Has a length limit of 128
    /// characters. If not specified, inherits the project ID from the parent
    /// request.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The instance ID of the Cloud Bigtable that needs to be imported.
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    /// Required. The table ID of the Cloud Bigtable that needs to be imported.
    #[prost(string, tag = "3")]
    pub table_id: ::prost::alloc::string::String,
    /// Required. Bigtable options that contains information needed when parsing
    /// data into typed structures. For example, column type annotations.
    #[prost(message, optional, tag = "4")]
    pub bigtable_options: ::core::option::Option<BigtableOptions>,
}
/// Cloud FhirStore source import data from.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FhirStoreSource {
    /// Required. The full resource name of the FHIR store to import data from, in
    /// the format of
    /// `projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}`.
    #[prost(string, tag = "1")]
    pub fhir_store: ::prost::alloc::string::String,
    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// FhirStore export to a specific Cloud Storage directory.
    #[prost(string, tag = "2")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
    /// The FHIR resource types to import. The resource types should be a subset of
    /// all [supported FHIR resource
    /// types](<https://cloud.google.com/generative-ai-app-builder/docs/fhir-schema-reference#resource-level-specification>).
    /// Default to all supported FHIR resource types if empty.
    #[prost(string, repeated, tag = "3")]
    pub resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Whether to update the DataStore schema to the latest predefined
    /// schema.
    ///
    /// If true, the DataStore schema will be updated to include any FHIR fields
    /// or resource types that have been added since the last import and
    /// corresponding FHIR resources will be imported from the FHIR store.
    ///
    /// Note this field cannot be used in conjunction with `resource_types`. It
    /// should be used after initial import.
    #[prost(bool, tag = "4")]
    pub update_from_latest_predefined_schema: bool,
}
/// Cloud SQL source import data from.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudSqlSource {
    /// The project ID that contains the Cloud SQL source. Has a length limit of
    /// 128 characters. If not specified, inherits the project ID from the parent
    /// request.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The Cloud SQL instance to copy the data from with a length limit
    /// of 256 characters.
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    /// Required. The Cloud SQL database to copy the data from with a length limit
    /// of 256 characters.
    #[prost(string, tag = "3")]
    pub database_id: ::prost::alloc::string::String,
    /// Required. The Cloud SQL table to copy the data from with a length limit of
    /// 256 characters.
    #[prost(string, tag = "4")]
    pub table_id: ::prost::alloc::string::String,
    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// Cloud SQL export to a specific Cloud Storage directory.
    ///
    /// Ensure that the Cloud SQL service account has the necessary Cloud
    /// Storage Admin permissions to access the specified Cloud Storage directory.
    #[prost(string, tag = "5")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
    /// Option for serverless export. Enabling this option will incur additional
    /// cost. More info can be found
    /// [here](<https://cloud.google.com/sql/pricing#serverless>).
    #[prost(bool, tag = "6")]
    pub offload: bool,
}
/// AlloyDB source import data from.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AlloyDbSource {
    /// The project ID that contains the AlloyDB source.
    /// Has a length limit of 128 characters. If not specified, inherits the
    /// project ID from the parent request.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The AlloyDB location to copy the data from with a length limit of
    /// 256 characters.
    #[prost(string, tag = "2")]
    pub location_id: ::prost::alloc::string::String,
    /// Required. The AlloyDB cluster to copy the data from with a length limit of
    /// 256 characters.
    #[prost(string, tag = "3")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. The AlloyDB database to copy the data from with a length limit of
    /// 256 characters.
    #[prost(string, tag = "4")]
    pub database_id: ::prost::alloc::string::String,
    /// Required. The AlloyDB table to copy the data from with a length limit of
    /// 256 characters.
    #[prost(string, tag = "5")]
    pub table_id: ::prost::alloc::string::String,
    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// AlloyDB export to a specific Cloud Storage directory.
    ///
    /// Ensure that the AlloyDB service account has the necessary Cloud
    /// Storage Admin permissions to access the specified Cloud Storage directory.
    #[prost(string, tag = "6")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
}
/// Firestore source import data from.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FirestoreSource {
    /// The project ID that the Cloud SQL source is in with a length limit of 128
    /// characters. If not specified, inherits the project ID from the parent
    /// request.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The Firestore database to copy the data from with a length limit
    /// of 256 characters.
    #[prost(string, tag = "2")]
    pub database_id: ::prost::alloc::string::String,
    /// Required. The Firestore collection (or entity) to copy the data from with a
    /// length limit of 1,500 characters.
    #[prost(string, tag = "3")]
    pub collection_id: ::prost::alloc::string::String,
    /// Intermediate Cloud Storage directory used for the import with a length
    /// limit of 2,000 characters. Can be specified if one wants to have the
    /// Firestore export to a specific Cloud Storage directory.
    ///
    /// Ensure that the Firestore service account has the necessary Cloud
    /// Storage Admin permissions to access the specified Cloud Storage directory.
    #[prost(string, tag = "4")]
    pub gcs_staging_dir: ::prost::alloc::string::String,
}
/// Configuration of destination for Import related errors.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportErrorConfig {
    /// Required. Errors destination.
    #[prost(oneof = "import_error_config::Destination", tags = "1")]
    pub destination: ::core::option::Option<import_error_config::Destination>,
}
/// Nested message and enum types in `ImportErrorConfig`.
pub mod import_error_config {
    /// Required. Errors destination.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Destination {
        /// Cloud Storage prefix for import errors. This must be an empty,
        /// existing Cloud Storage directory. Import errors are written to
        /// sharded files in this directory, one per line, as a JSON-encoded
        /// `google.rpc.Status` message.
        #[prost(string, tag = "1")]
        GcsPrefix(::prost::alloc::string::String),
    }
}
/// Request message for the ImportUserEvents request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsRequest {
    /// Required. Parent DataStore resource name, of the form
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The desired location of errors incurred during the Import. Cannot be set
    /// for inline user event imports.
    #[prost(message, optional, tag = "5")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    /// Required - The desired input source of the user event data.
    #[prost(oneof = "import_user_events_request::Source", tags = "2, 3, 4")]
    pub source: ::core::option::Option<import_user_events_request::Source>,
}
/// Nested message and enum types in `ImportUserEventsRequest`.
pub mod import_user_events_request {
    /// The inline source for the input config for ImportUserEvents method.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// Required. A list of user events to import. Recommended max of 10k items.
        #[prost(message, repeated, tag = "1")]
        pub user_events: ::prost::alloc::vec::Vec<super::UserEvent>,
    }
    /// Required - The desired input source of the user event data.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The Inline source for the input content for UserEvents.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        /// Cloud Storage location for the input content.
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
        /// BigQuery input source.
        #[prost(message, tag = "4")]
        BigquerySource(super::BigQuerySource),
    }
}
/// Response of the ImportUserEventsRequest. If the long running
/// operation was successful, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportUserEventsResponse {
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Echoes the destination for the complete errors if this field was set in
    /// the request.
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    /// Count of user events imported with complete existing Documents.
    #[prost(int64, tag = "3")]
    pub joined_events_count: i64,
    /// Count of user events imported, but with Document information not found
    /// in the existing Branch.
    #[prost(int64, tag = "4")]
    pub unjoined_events_count: i64,
}
/// Metadata related to the progress of the Import operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportUserEventsMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Count of entries that were processed successfully.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Count of entries that encountered errors while processing.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
/// Metadata related to the progress of the ImportDocuments operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportDocumentsMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Count of entries that were processed successfully.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Count of entries that encountered errors while processing.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
    /// Total count of entries that were processed.
    #[prost(int64, tag = "5")]
    pub total_count: i64,
}
/// Request message for Import methods.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    /// Requires create/update permission.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The desired location of errors incurred during the Import.
    #[prost(message, optional, tag = "5")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    /// The mode of reconciliation between existing documents and the documents to
    /// be imported. Defaults to
    /// \[ReconciliationMode.INCREMENTAL\]\[google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode.INCREMENTAL\].
    #[prost(enumeration = "import_documents_request::ReconciliationMode", tag = "6")]
    pub reconciliation_mode: i32,
    /// Indicates which fields in the provided imported documents to update. If
    /// not set, the default is to update all fields.
    #[prost(message, optional, tag = "7")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Whether to automatically generate IDs for the documents if absent.
    ///
    /// If set to `true`,
    /// \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\]s are
    /// automatically generated based on the hash of the payload, where IDs may not
    /// be consistent during multiple imports. In which case
    /// \[ReconciliationMode.FULL\]\[google.cloud.discoveryengine.v1.ImportDocumentsRequest.ReconciliationMode.FULL\]
    /// is highly recommended to avoid duplicate contents. If unset or set to
    /// `false`, \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\]s have
    /// to be specified using
    /// \[id_field\]\[google.cloud.discoveryengine.v1.ImportDocumentsRequest.id_field\],
    /// otherwise, documents without IDs fail to be imported.
    ///
    /// Supported data sources:
    ///
    /// * \[GcsSource\]\[google.cloud.discoveryengine.v1.GcsSource\].
    ///   \[GcsSource.data_schema\]\[google.cloud.discoveryengine.v1.GcsSource.data_schema\]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * \[BigQuerySource\]\[google.cloud.discoveryengine.v1.BigQuerySource\].
    ///   \[BigQuerySource.data_schema\]\[google.cloud.discoveryengine.v1.BigQuerySource.data_schema\]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * \[SpannerSource\]\[google.cloud.discoveryengine.v1.SpannerSource\].
    /// * \[CloudSqlSource\]\[google.cloud.discoveryengine.v1.CloudSqlSource\].
    /// * \[FirestoreSource\]\[google.cloud.discoveryengine.v1.FirestoreSource\].
    /// * \[BigtableSource\]\[google.cloud.discoveryengine.v1.BigtableSource\].
    #[prost(bool, tag = "8")]
    pub auto_generate_ids: bool,
    /// The field indicates the ID field or column to be used as unique IDs of
    /// the documents.
    ///
    /// For \[GcsSource\]\[google.cloud.discoveryengine.v1.GcsSource\] it is the key of
    /// the JSON field. For instance, `my_id` for JSON `{"my_id": "some_uuid"}`.
    /// For others, it may be the column name of the table where the unique ids are
    /// stored.
    ///
    /// The values of the JSON field or the table column are used as the
    /// \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\]s. The JSON field
    /// or the table column must be of string type, and the values must be set as
    /// valid strings conform to [RFC-1034](<https://tools.ietf.org/html/rfc1034>)
    /// with 1-63 characters. Otherwise, documents without valid IDs fail to be
    /// imported.
    ///
    /// Only set this field when
    /// \[auto_generate_ids\]\[google.cloud.discoveryengine.v1.ImportDocumentsRequest.auto_generate_ids\]
    /// is unset or set as `false`. Otherwise, an INVALID_ARGUMENT error is thrown.
    ///
    /// If it is unset, a default value `_id` is used when importing from the
    /// allowed data sources.
    ///
    /// Supported data sources:
    ///
    /// * \[GcsSource\]\[google.cloud.discoveryengine.v1.GcsSource\].
    ///   \[GcsSource.data_schema\]\[google.cloud.discoveryengine.v1.GcsSource.data_schema\]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * \[BigQuerySource\]\[google.cloud.discoveryengine.v1.BigQuerySource\].
    ///   \[BigQuerySource.data_schema\]\[google.cloud.discoveryengine.v1.BigQuerySource.data_schema\]
    ///   must be `custom` or `csv`. Otherwise, an INVALID_ARGUMENT error is thrown.
    /// * \[SpannerSource\]\[google.cloud.discoveryengine.v1.SpannerSource\].
    /// * \[CloudSqlSource\]\[google.cloud.discoveryengine.v1.CloudSqlSource\].
    /// * \[FirestoreSource\]\[google.cloud.discoveryengine.v1.FirestoreSource\].
    /// * \[BigtableSource\]\[google.cloud.discoveryengine.v1.BigtableSource\].
    #[prost(string, tag = "9")]
    pub id_field: ::prost::alloc::string::String,
    /// Optional. Whether to force refresh the unstructured content of the
    /// documents.
    ///
    /// If set to `true`, the content part of the documents will be refreshed
    /// regardless of the update status of the referencing content.
    #[prost(bool, tag = "16")]
    pub force_refresh_content: bool,
    /// Required. The source of the input.
    #[prost(
        oneof = "import_documents_request::Source",
        tags = "2, 3, 4, 10, 11, 12, 13, 14, 15"
    )]
    pub source: ::core::option::Option<import_documents_request::Source>,
}
/// Nested message and enum types in `ImportDocumentsRequest`.
pub mod import_documents_request {
    /// The inline source for the input config for ImportDocuments method.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// Required. A list of documents to update/create. Each document must have a
        /// valid \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\].
        /// Recommended max of 100 items.
        #[prost(message, repeated, tag = "1")]
        pub documents: ::prost::alloc::vec::Vec<super::Document>,
    }
    /// Indicates how imported documents are reconciled with the existing documents
    /// created or imported before.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReconciliationMode {
        /// Defaults to `INCREMENTAL`.
        Unspecified = 0,
        /// Inserts new documents or updates existing documents.
        Incremental = 1,
        /// Calculates diff and replaces the entire document dataset. Existing
        /// documents may be deleted if they are not present in the source location.
        Full = 2,
    }
    impl ReconciliationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RECONCILIATION_MODE_UNSPECIFIED",
                Self::Incremental => "INCREMENTAL",
                Self::Full => "FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECONCILIATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCREMENTAL" => Some(Self::Incremental),
                "FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
    /// Required. The source of the input.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The Inline source for the input content for documents.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        /// Cloud Storage location for the input content.
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
        /// BigQuery input source.
        #[prost(message, tag = "4")]
        BigquerySource(super::BigQuerySource),
        /// FhirStore input source.
        #[prost(message, tag = "10")]
        FhirStoreSource(super::FhirStoreSource),
        /// Spanner input source.
        #[prost(message, tag = "11")]
        SpannerSource(super::SpannerSource),
        /// Cloud SQL input source.
        #[prost(message, tag = "12")]
        CloudSqlSource(super::CloudSqlSource),
        /// Firestore input source.
        #[prost(message, tag = "13")]
        FirestoreSource(super::FirestoreSource),
        /// AlloyDB input source.
        #[prost(message, tag = "14")]
        AlloyDbSource(super::AlloyDbSource),
        /// Cloud Bigtable input source.
        #[prost(message, tag = "15")]
        BigtableSource(super::BigtableSource),
    }
}
/// Response of the
/// \[ImportDocumentsRequest\]\[google.cloud.discoveryengine.v1.ImportDocumentsRequest\].
/// If the long running operation is done, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDocumentsResponse {
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Echoes the destination for the complete errors in the request if set.
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
}
/// Request message for
/// \[CompletionService.ImportSuggestionDenyListEntries\]\[google.cloud.discoveryengine.v1.CompletionService.ImportSuggestionDenyListEntries\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesRequest {
    /// Required. The parent data store resource name for which to import denylist
    /// entries. Follows pattern projects/*/locations/*/collections/*/dataStores/*.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The source of the updated SuggestionDenyList.
    #[prost(
        oneof = "import_suggestion_deny_list_entries_request::Source",
        tags = "2, 3"
    )]
    pub source: ::core::option::Option<
        import_suggestion_deny_list_entries_request::Source,
    >,
}
/// Nested message and enum types in `ImportSuggestionDenyListEntriesRequest`.
pub mod import_suggestion_deny_list_entries_request {
    /// The inline source for SuggestionDenyListEntry.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// Required. A list of all denylist entries to import. Max of 1000 items.
        #[prost(message, repeated, tag = "1")]
        pub entries: ::prost::alloc::vec::Vec<super::SuggestionDenyListEntry>,
    }
    /// The source of the updated SuggestionDenyList.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The Inline source for the input content for suggestion deny list entries.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        /// Cloud Storage location for the input content.
        ///
        /// Only 1 file can be specified that contains all entries to import.
        /// Supported values `gcs_source.schema` for autocomplete suggestion deny
        /// list entry imports:
        ///
        /// * `suggestion_deny_list` (default): One JSON \[SuggestionDenyListEntry\]
        ///   per line.
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
    }
}
/// Response message for
/// \[CompletionService.ImportSuggestionDenyListEntries\]\[google.cloud.discoveryengine.v1.CompletionService.ImportSuggestionDenyListEntries\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesResponse {
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Count of deny list entries successfully imported.
    #[prost(int64, tag = "2")]
    pub imported_entries_count: i64,
    /// Count of deny list entries that failed to be imported.
    #[prost(int64, tag = "3")]
    pub failed_entries_count: i64,
}
/// Metadata related to the progress of the ImportSuggestionDenyListEntries
/// operation. This is returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportSuggestionDenyListEntriesMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[CompletionService.ImportCompletionSuggestions\]\[google.cloud.discoveryengine.v1.CompletionService.ImportCompletionSuggestions\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCompletionSuggestionsRequest {
    /// Required. The parent data store resource name for which to import customer
    /// autocomplete suggestions.
    ///
    /// Follows pattern `projects/*/locations/*/collections/*/dataStores/*`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The desired location of errors incurred during the Import.
    #[prost(message, optional, tag = "5")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    /// The source of the autocomplete suggestions.
    #[prost(oneof = "import_completion_suggestions_request::Source", tags = "2, 3, 4")]
    pub source: ::core::option::Option<import_completion_suggestions_request::Source>,
}
/// Nested message and enum types in `ImportCompletionSuggestionsRequest`.
pub mod import_completion_suggestions_request {
    /// The inline source for CompletionSuggestions.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// Required. A list of all denylist entries to import. Max of 1000 items.
        #[prost(message, repeated, tag = "1")]
        pub suggestions: ::prost::alloc::vec::Vec<super::CompletionSuggestion>,
    }
    /// The source of the autocomplete suggestions.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The Inline source for suggestion entries.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
        /// Cloud Storage location for the input content.
        #[prost(message, tag = "3")]
        GcsSource(super::GcsSource),
        /// BigQuery input source.
        #[prost(message, tag = "4")]
        BigquerySource(super::BigQuerySource),
    }
}
/// Response of the
/// \[CompletionService.ImportCompletionSuggestions\]\[google.cloud.discoveryengine.v1.CompletionService.ImportCompletionSuggestions\]
/// method. If the long running operation is done, this message is returned by
/// the google.longrunning.Operations.response field if the operation is
/// successful.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportCompletionSuggestionsResponse {
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// The desired location of errors incurred during the Import.
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
}
/// Metadata related to the progress of the ImportCompletionSuggestions
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportCompletionSuggestionsMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Count of
    /// \[CompletionSuggestion\]\[google.cloud.discoveryengine.v1.CompletionSuggestion\]s
    /// successfully imported.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Count of
    /// \[CompletionSuggestion\]\[google.cloud.discoveryengine.v1.CompletionSuggestion\]s
    /// that failed to be imported.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
/// Request message for PurgeUserEvents method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeUserEventsRequest {
    /// Required. The resource name of the catalog under which the events are
    /// created. The format is
    /// `projects/{project}/locations/global/collections/{collection}/dataStores/{dataStore}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The filter string to specify the events to be deleted with a
    /// length limit of 5,000 characters. The eligible fields for filtering are:
    ///
    /// * `eventType`: Double quoted
    ///   \[UserEvent.event_type\]\[google.cloud.discoveryengine.v1.UserEvent.event_type\]
    ///   string.
    /// * `eventTime`: in ISO 8601 "zulu" format.
    /// * `userPseudoId`: Double quoted string. Specifying this will delete all
    ///   events associated with a visitor.
    /// * `userId`: Double quoted string. Specifying this will delete all events
    ///   associated with a user.
    ///
    /// Note: This API only supports purging a max range of 30 days.
    ///
    /// Examples:
    ///
    /// * Deleting all events in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z" eventTime < "2012-04-23T18:30:43.511Z"`
    /// * Deleting specific eventType in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z" eventTime < "2012-04-23T18:30:43.511Z" eventType = "search"`
    /// * Deleting all events for a specific visitor in a time range:
    ///   `eventTime > "2012-04-23T18:25:43.511Z" eventTime < "2012-04-23T18:30:43.511Z" userPseudoId = "visitor1024"`
    /// * Deleting the past 30 days of events inside a DataStore:
    ///   `*`
    ///
    /// The filtering fields are assumed to have an implicit AND.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The `force` field is currently not supported. Purge user event requests
    /// will permanently delete all purgeable events. Once the development is
    /// complete:
    /// If `force` is set to false, the method will return the expected
    /// purge count without deleting any user events. This field will default to
    /// false if not included in the request.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// Response of the PurgeUserEventsRequest. If the long running operation is
/// successfully done, then this message is returned by the
/// google.longrunning.Operations.response field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeUserEventsResponse {
    /// The total count of events purged as a result of the operation.
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
}
/// Metadata related to the progress of the PurgeUserEvents operation.
/// This will be returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeUserEventsMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Count of entries that were deleted successfully.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Count of entries that encountered errors while processing.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
/// Configuration of destination for Purge related errors.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeErrorConfig {
    /// Required. Errors destination.
    #[prost(oneof = "purge_error_config::Destination", tags = "1")]
    pub destination: ::core::option::Option<purge_error_config::Destination>,
}
/// Nested message and enum types in `PurgeErrorConfig`.
pub mod purge_error_config {
    /// Required. Errors destination.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Destination {
        /// Cloud Storage prefix for purge errors. This must be an empty,
        /// existing Cloud Storage directory. Purge errors are written to
        /// sharded files in this directory, one per line, as a JSON-encoded
        /// `google.rpc.Status` message.
        #[prost(string, tag = "1")]
        GcsPrefix(::prost::alloc::string::String),
    }
}
/// Request message for
/// \[DocumentService.PurgeDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeDocumentsRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Filter matching documents to purge. Only currently supported
    /// value is
    /// `*` (all items).
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The desired location of errors incurred during the purge.
    #[prost(message, optional, tag = "7")]
    pub error_config: ::core::option::Option<PurgeErrorConfig>,
    /// Actually performs the purge. If `force` is set to false, return the
    /// expected purge count without deleting any documents.
    #[prost(bool, tag = "3")]
    pub force: bool,
    /// The desired input source for the purging documents based on document IDs.
    #[prost(oneof = "purge_documents_request::Source", tags = "5, 6")]
    pub source: ::core::option::Option<purge_documents_request::Source>,
}
/// Nested message and enum types in `PurgeDocumentsRequest`.
pub mod purge_documents_request {
    /// The inline source for the input config for
    /// \[DocumentService.PurgeDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments\]
    /// method.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct InlineSource {
        /// Required. A list of full resource name of documents to purge. In the
        /// format
        /// `projects/*/locations/*/collections/*/dataStores/*/branches/*/documents/*`.
        /// Recommended max of 100 items.
        #[prost(string, repeated, tag = "1")]
        pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// The desired input source for the purging documents based on document IDs.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Source {
        /// Cloud Storage location for the input content.
        /// Supported `data_schema`:
        ///
        /// * `document_id`: One valid
        ///   \[Document.id\]\[google.cloud.discoveryengine.v1.Document.id\] per line.
        #[prost(message, tag = "5")]
        GcsSource(super::GcsSource),
        /// Inline source for the input content for purge.
        #[prost(message, tag = "6")]
        InlineSource(InlineSource),
    }
}
/// Response message for
/// \[DocumentService.PurgeDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.PurgeDocuments\]
/// method. If the long running operation is successfully done, then this message
/// is returned by the google.longrunning.Operations.response field.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeDocumentsResponse {
    /// The total count of documents purged as a result of the operation.
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    /// A sample of document names that will be deleted. Only populated if `force`
    /// is set to false. A max of 100 names will be returned and the names are
    /// chosen at random.
    #[prost(string, repeated, tag = "2")]
    pub purge_sample: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Metadata related to the progress of the PurgeDocuments operation.
/// This will be returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeDocumentsMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Count of entries that were deleted successfully.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Count of entries that encountered errors while processing.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
    /// Count of entries that were ignored as entries were not found.
    #[prost(int64, tag = "5")]
    pub ignored_count: i64,
}
/// Request message for
/// \[CompletionService.PurgeSuggestionDenyListEntries\]\[google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesRequest {
    /// Required. The parent data store resource name for which to import denylist
    /// entries. Follows pattern projects/*/locations/*/collections/*/dataStores/*.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Response message for
/// \[CompletionService.PurgeSuggestionDenyListEntries\]\[google.cloud.discoveryengine.v1.CompletionService.PurgeSuggestionDenyListEntries\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesResponse {
    /// Number of suggestion deny list entries purged.
    #[prost(int64, tag = "1")]
    pub purge_count: i64,
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "2")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// Metadata related to the progress of the PurgeSuggestionDenyListEntries
/// operation. This is returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeSuggestionDenyListEntriesMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[CompletionService.PurgeCompletionSuggestions\]\[google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeCompletionSuggestionsRequest {
    /// Required. The parent data store resource name for which to purge completion
    /// suggestions. Follows pattern
    /// projects/*/locations/*/collections/*/dataStores/*.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Response message for
/// \[CompletionService.PurgeCompletionSuggestions\]\[google.cloud.discoveryengine.v1.CompletionService.PurgeCompletionSuggestions\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeCompletionSuggestionsResponse {
    /// Whether the completion suggestions were successfully purged.
    #[prost(bool, tag = "1")]
    pub purge_succeeded: bool,
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "2")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// Metadata related to the progress of the PurgeCompletionSuggestions
/// operation. This is returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PurgeCompletionSuggestionsMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[CompletionService.CompleteQuery\]\[google.cloud.discoveryengine.v1.CompletionService.CompleteQuery\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompleteQueryRequest {
    /// Required. The parent data store resource name for which the completion is
    /// performed, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    #[prost(string, tag = "1")]
    pub data_store: ::prost::alloc::string::String,
    /// Required. The typeahead input used to fetch suggestions. Maximum length is
    /// 128 characters.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Specifies the autocomplete data model. This overrides any model specified
    /// in the Configuration > Autocomplete section of the Cloud console. Currently
    /// supported values:
    ///
    /// * `document` - Using suggestions generated from user-imported documents.
    /// * `search-history` - Using suggestions generated from the past history of
    ///   \[SearchService.Search\]\[google.cloud.discoveryengine.v1.SearchService.Search\]
    ///   API calls. Do not use it when there is no traffic for Search API.
    /// * `user-event` - Using suggestions generated from user-imported search
    ///   events.
    /// * `document-completable` - Using suggestions taken directly from
    ///   user-imported document fields marked as completable.
    ///
    /// Default values:
    ///
    /// * `document` is the default model for regular dataStores.
    /// * `search-history` is the default model for site search dataStores.
    #[prost(string, tag = "3")]
    pub query_model: ::prost::alloc::string::String,
    /// A unique identifier for tracking visitors. For example, this could be
    /// implemented with an HTTP cookie, which should be able to uniquely identify
    /// a visitor on a single device. This unique identifier should not change if
    /// the visitor logs in or out of the website.
    ///
    /// This field should NOT have a fixed value such as `unknown_visitor`.
    ///
    /// This should be the same identifier as
    /// \[UserEvent.user_pseudo_id\]\[google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id\]
    /// and
    /// \[SearchRequest.user_pseudo_id\]\[google.cloud.discoveryengine.v1.SearchRequest.user_pseudo_id\].
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "4")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    /// Indicates if tail suggestions should be returned if there are no
    /// suggestions that match the full query. Even if set to true, if there are
    /// suggestions that match the full query, those are returned and no
    /// tail suggestions are returned.
    #[prost(bool, tag = "5")]
    pub include_tail_suggestions: bool,
}
/// Response message for
/// \[CompletionService.CompleteQuery\]\[google.cloud.discoveryengine.v1.CompletionService.CompleteQuery\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteQueryResponse {
    /// Results of the matched query suggestions. The result list is ordered and
    /// the first result is a top suggestion.
    #[prost(message, repeated, tag = "1")]
    pub query_suggestions: ::prost::alloc::vec::Vec<
        complete_query_response::QuerySuggestion,
    >,
    /// True if the returned suggestions are all tail suggestions.
    ///
    /// For tail matching to be triggered, include_tail_suggestions in the request
    /// must be true and there must be no suggestions that match the full query.
    #[prost(bool, tag = "2")]
    pub tail_match_triggered: bool,
}
/// Nested message and enum types in `CompleteQueryResponse`.
pub mod complete_query_response {
    /// Suggestions as search queries.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QuerySuggestion {
        /// The suggestion for the query.
        #[prost(string, tag = "1")]
        pub suggestion: ::prost::alloc::string::String,
        /// The unique document field paths that serve as the source of this
        /// suggestion if it was generated from completable fields.
        ///
        /// This field is only populated for the document-completable model.
        #[prost(string, repeated, tag = "2")]
        pub completable_field_paths: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
}
/// Generated client implementations.
pub mod completion_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for Auto-Completion.
    #[derive(Debug, Clone)]
    pub struct CompletionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CompletionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CompletionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CompletionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CompletionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Completes the specified user input with keyword suggestions.
        pub async fn complete_query(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CompleteQueryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/CompleteQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "CompleteQuery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports all
        /// \[SuggestionDenyListEntry\]\[google.cloud.discoveryengine.v1.SuggestionDenyListEntry\]
        /// for a DataStore.
        pub async fn import_suggestion_deny_list_entries(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ImportSuggestionDenyListEntriesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/ImportSuggestionDenyListEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "ImportSuggestionDenyListEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all
        /// \[SuggestionDenyListEntry\]\[google.cloud.discoveryengine.v1.SuggestionDenyListEntry\]
        /// for a DataStore.
        pub async fn purge_suggestion_deny_list_entries(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PurgeSuggestionDenyListEntriesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/PurgeSuggestionDenyListEntries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "PurgeSuggestionDenyListEntries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports
        /// \[CompletionSuggestion\]\[google.cloud.discoveryengine.v1.CompletionSuggestion\]s
        /// for a DataStore.
        pub async fn import_completion_suggestions(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportCompletionSuggestionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/ImportCompletionSuggestions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "ImportCompletionSuggestions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all
        /// \[CompletionSuggestion\]\[google.cloud.discoveryengine.v1.CompletionSuggestion\]s
        /// for a DataStore.
        pub async fn purge_completion_suggestions(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeCompletionSuggestionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.CompletionService/PurgeCompletionSuggestions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.CompletionService",
                        "PurgeCompletionSuggestions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Defines circumstances to be checked before allowing a behavior
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    /// Search only
    /// A list of terms to match the query on.
    /// Cannot be set when
    /// \[Condition.query_regex\]\[google.cloud.discoveryengine.v1.Condition.query_regex\]
    /// is set.
    ///
    /// Maximum of 10 query terms.
    #[prost(message, repeated, tag = "2")]
    pub query_terms: ::prost::alloc::vec::Vec<condition::QueryTerm>,
    /// Range of time(s) specifying when condition is active.
    ///
    /// Maximum of 10 time ranges.
    #[prost(message, repeated, tag = "3")]
    pub active_time_range: ::prost::alloc::vec::Vec<condition::TimeRange>,
    /// Optional. Query regex to match the whole search query.
    /// Cannot be set when
    /// \[Condition.query_terms\]\[google.cloud.discoveryengine.v1.Condition.query_terms\]
    /// is set. Only supported for Basic Site Search promotion serving controls.
    #[prost(string, tag = "4")]
    pub query_regex: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    /// Matcher for search request query
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QueryTerm {
        /// The specific query value to match against
        ///
        /// Must be lowercase, must be UTF-8.
        /// Can have at most 3 space separated terms if full_match is true.
        /// Cannot be an empty string.
        /// Maximum length of 5000 characters.
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
        /// Whether the search query needs to exactly match the query term.
        #[prost(bool, tag = "2")]
        pub full_match: bool,
    }
    /// Used for time-dependent conditions.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TimeRange {
        /// Start of time range.
        ///
        /// Range is inclusive.
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// End of time range.
        ///
        /// Range is inclusive.
        /// Must be in the future.
        #[prost(message, optional, tag = "2")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
}
/// Defines a conditioned behavior to employ during serving.
/// Must be attached to a
/// \[ServingConfig\]\[google.cloud.discoveryengine.v1.ServingConfig\] to be
/// considered at serving time. Permitted actions dependent on `SolutionType`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Control {
    /// Immutable. Fully qualified name
    /// `projects/*/locations/global/dataStore/*/controls/*`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Human readable name. The identifier used in UI views.
    ///
    /// Must be UTF-8 encoded string. Length limit is 128 characters.
    /// Otherwise an INVALID ARGUMENT error is thrown.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. List of all
    /// \[ServingConfig\]\[google.cloud.discoveryengine.v1.ServingConfig\] IDs this
    /// control is attached to. May take up to 10 minutes to update after changes.
    #[prost(string, repeated, tag = "3")]
    pub associated_serving_config_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Required. Immutable. What solution the control belongs to.
    ///
    /// Must be compatible with vertical of resource.
    /// Otherwise an INVALID ARGUMENT error is thrown.
    #[prost(enumeration = "SolutionType", tag = "4")]
    pub solution_type: i32,
    /// Specifies the use case for the control.
    /// Affects what condition fields can be set.
    /// Only applies to
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    /// Currently only allow one use case per control.
    /// Must be set when solution_type is
    /// \[SolutionType.SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    #[prost(enumeration = "SearchUseCase", repeated, tag = "8")]
    pub use_cases: ::prost::alloc::vec::Vec<i32>,
    /// Determines when the associated action will trigger.
    ///
    /// Omit to always apply the action.
    /// Currently only a single condition may be specified.
    /// Otherwise an INVALID ARGUMENT error is thrown.
    #[prost(message, repeated, tag = "5")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
    /// Actions are restricted by Vertical and Solution
    ///
    /// Required.
    #[prost(oneof = "control::Action", tags = "6, 7, 9, 10, 15")]
    pub action: ::core::option::Option<control::Action>,
}
/// Nested message and enum types in `Control`.
pub mod control {
    /// Adjusts order of products in returned list.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BoostAction {
        /// Strength of the boost, which should be in \[-1, 1\]. Negative
        /// boost means demotion. Default is 0.0 (No-op).
        #[deprecated]
        #[prost(float, tag = "1")]
        pub boost: f32,
        /// Required. Specifies which products to apply the boost to.
        ///
        /// If no filter is provided all products will be boosted (No-op).
        /// Syntax documentation:
        /// <https://cloud.google.com/retail/docs/filter-and-order>
        /// Maximum length is 5000 characters.
        /// Otherwise an INVALID ARGUMENT error is thrown.
        #[prost(string, tag = "2")]
        pub filter: ::prost::alloc::string::String,
        /// Required. Specifies which data store's documents can be boosted by this
        /// control. Full data store name e.g.
        /// projects/123/locations/global/collections/default_collection/dataStores/default_data_store
        #[prost(string, tag = "3")]
        pub data_store: ::prost::alloc::string::String,
        /// Constant value boost or custom ranking based boost specifications.
        #[prost(oneof = "boost_action::BoostSpec", tags = "4, 5")]
        pub boost_spec: ::core::option::Option<boost_action::BoostSpec>,
    }
    /// Nested message and enum types in `BoostAction`.
    pub mod boost_action {
        /// Specification for custom ranking based on customer specified attribute
        /// value. It provides more controls for customized ranking than the simple
        /// (condition, boost) combination above.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct InterpolationBoostSpec {
            /// Optional. The name of the field whose value will be used to determine
            /// the boost amount.
            #[prost(string, tag = "1")]
            pub field_name: ::prost::alloc::string::String,
            /// Optional. The attribute type to be used to determine the boost amount.
            /// The attribute value can be derived from the field value of the
            /// specified field_name. In the case of numerical it is straightforward
            /// i.e. attribute_value = numerical_field_value. In the case of freshness
            /// however, attribute_value = (time.now() - datetime_field_value).
            #[prost(enumeration = "interpolation_boost_spec::AttributeType", tag = "2")]
            pub attribute_type: i32,
            /// Optional. The interpolation type to be applied to connect the control
            /// points listed below.
            #[prost(
                enumeration = "interpolation_boost_spec::InterpolationType",
                tag = "3"
            )]
            pub interpolation_type: i32,
            /// Optional. The control points used to define the curve. The monotonic
            /// function (defined through the interpolation_type above) passes through
            /// the control points listed here.
            #[prost(message, repeated, tag = "4")]
            pub control_points: ::prost::alloc::vec::Vec<
                interpolation_boost_spec::ControlPoint,
            >,
        }
        /// Nested message and enum types in `InterpolationBoostSpec`.
        pub mod interpolation_boost_spec {
            /// The control points used to define the curve. The curve defined
            /// through these control points can only be monotonically increasing
            /// or decreasing(constant values are acceptable).
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct ControlPoint {
                /// Optional. Can be one of:
                ///
                /// 1. The numerical field value.
                /// 1. The duration spec for freshness:
                ///    The value must be formatted as an XSD `dayTimeDuration` value (a
                ///    restricted subset of an ISO 8601 duration value). The pattern for
                ///    this is: `[nD][T[nH][nM][nS]]`.
                #[prost(string, tag = "1")]
                pub attribute_value: ::prost::alloc::string::String,
                /// Optional. The value between -1 to 1 by which to boost the score if
                /// the attribute_value evaluates to the value specified above.
                #[prost(float, tag = "2")]
                pub boost_amount: f32,
            }
            /// The attribute(or function) for which the custom ranking is to be
            /// applied.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum AttributeType {
                /// Unspecified AttributeType.
                Unspecified = 0,
                /// The value of the numerical field will be used to dynamically update
                /// the boost amount. In this case, the attribute_value (the x value)
                /// of the control point will be the actual value of the numerical
                /// field for which the boost_amount is specified.
                Numerical = 1,
                /// For the freshness use case the attribute value will be the duration
                /// between the current time and the date in the datetime field
                /// specified. The value must be formatted as an XSD `dayTimeDuration`
                /// value (a restricted subset of an ISO 8601 duration value). The
                /// pattern for this is: `[nD][T[nH][nM][nS]]`.
                /// For example, `5D`, `3DT12H30M`, `T24H`.
                Freshness = 2,
            }
            impl AttributeType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "ATTRIBUTE_TYPE_UNSPECIFIED",
                        Self::Numerical => "NUMERICAL",
                        Self::Freshness => "FRESHNESS",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "ATTRIBUTE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "NUMERICAL" => Some(Self::Numerical),
                        "FRESHNESS" => Some(Self::Freshness),
                        _ => None,
                    }
                }
            }
            /// The interpolation type to be applied. Default will be linear
            /// (Piecewise Linear).
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum InterpolationType {
                /// Interpolation type is unspecified. In this case, it defaults to
                /// Linear.
                Unspecified = 0,
                /// Piecewise linear interpolation will be applied.
                Linear = 1,
            }
            impl InterpolationType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "INTERPOLATION_TYPE_UNSPECIFIED",
                        Self::Linear => "LINEAR",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "INTERPOLATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "LINEAR" => Some(Self::Linear),
                        _ => None,
                    }
                }
            }
        }
        /// Constant value boost or custom ranking based boost specifications.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum BoostSpec {
            /// Optional. Strength of the boost, which should be in \[-1, 1\]. Negative
            /// boost means demotion. Default is 0.0 (No-op).
            #[prost(float, tag = "4")]
            FixedBoost(f32),
            /// Optional. Complex specification for custom ranking based on customer
            /// defined attribute value.
            #[prost(message, tag = "5")]
            InterpolationBoostSpec(InterpolationBoostSpec),
        }
    }
    /// Specified which products may be included in results.
    /// Uses same filter as boost.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FilterAction {
        /// Required. A filter to apply on the matching condition results.
        ///
        /// Required
        /// Syntax documentation:
        /// <https://cloud.google.com/retail/docs/filter-and-order>
        /// Maximum length is 5000 characters. Otherwise an INVALID
        /// ARGUMENT error is thrown.
        #[prost(string, tag = "1")]
        pub filter: ::prost::alloc::string::String,
        /// Required. Specifies which data store's documents can be filtered by this
        /// control. Full data store name e.g.
        /// projects/123/locations/global/collections/default_collection/dataStores/default_data_store
        #[prost(string, tag = "2")]
        pub data_store: ::prost::alloc::string::String,
    }
    /// Redirects a shopper to the provided URI.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RedirectAction {
        /// Required. The URI to which the shopper will be redirected.
        ///
        /// Required.
        /// URI must have length equal or less than 2000 characters.
        /// Otherwise an INVALID ARGUMENT error is thrown.
        #[prost(string, tag = "1")]
        pub redirect_uri: ::prost::alloc::string::String,
    }
    /// Creates a set of terms that will act as synonyms of one another.
    ///
    /// Example: "happy" will also be considered as "glad", "glad" will also be
    /// considered as "happy".
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SynonymsAction {
        /// Defines a set of synonyms.
        /// Can specify up to 100 synonyms.
        /// Must specify at least 2 synonyms. Otherwise an INVALID ARGUMENT error is
        /// thrown.
        #[prost(string, repeated, tag = "1")]
        pub synonyms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Promote certain links based on some trigger queries.
    ///
    /// Example: Promote shoe store link when searching for `shoe` keyword.
    /// The link can be outside of associated data store.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PromoteAction {
        /// Required. Data store with which this promotion is attached to.
        #[prost(string, tag = "1")]
        pub data_store: ::prost::alloc::string::String,
        /// Required. Promotion attached to this action.
        #[prost(message, optional, tag = "2")]
        pub search_link_promotion: ::core::option::Option<super::SearchLinkPromotion>,
    }
    /// Actions are restricted by Vertical and Solution
    ///
    /// Required.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        /// Defines a boost-type control
        #[prost(message, tag = "6")]
        BoostAction(BoostAction),
        /// Defines a filter-type control
        /// Currently not supported by Recommendation
        #[prost(message, tag = "7")]
        FilterAction(FilterAction),
        /// Defines a redirect-type control.
        #[prost(message, tag = "9")]
        RedirectAction(RedirectAction),
        /// Treats a group of terms as synonyms of one another.
        #[prost(message, tag = "10")]
        SynonymsAction(SynonymsAction),
        /// Promote certain links based on predefined trigger queries.
        #[prost(message, tag = "15")]
        PromoteAction(PromoteAction),
    }
}
/// Request for CreateControl method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateControlRequest {
    /// Required. Full resource name of parent data store. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
    /// or
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The Control to create.
    #[prost(message, optional, tag = "2")]
    pub control: ::core::option::Option<Control>,
    /// Required. The ID to use for the Control, which will become the final
    /// component of the Control's resource name.
    ///
    /// This value must be within 1-63 characters.
    /// Valid characters are /\[a-z\]\[0-9\]-\_/.
    #[prost(string, tag = "3")]
    pub control_id: ::prost::alloc::string::String,
}
/// Request for UpdateControl method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateControlRequest {
    /// Required. The Control to update.
    #[prost(message, optional, tag = "1")]
    pub control: ::core::option::Option<Control>,
    /// Optional. Indicates which fields in the provided
    /// \[Control\]\[google.cloud.discoveryengine.v1.Control\] to update. The following
    /// are NOT supported:
    ///
    /// * \[Control.name\]\[google.cloud.discoveryengine.v1.Control.name\]
    /// * \[Control.solution_type\]\[google.cloud.discoveryengine.v1.Control.solution_type\]
    ///
    /// If not set or empty, all supported fields are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for DeleteControl method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteControlRequest {
    /// Required. The resource name of the Control to delete. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for GetControl method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetControlRequest {
    /// Required. The resource name of the Control to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/controls/{control_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListControls method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListControlsRequest {
    /// Required. The data store resource name. Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`
    /// or
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListControls` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. A filter to apply on the list results. Supported features:
    ///
    /// * List all the products under the parent branch if
    ///   \[filter\]\[google.cloud.discoveryengine.v1.ListControlsRequest.filter\] is
    ///   unset. Currently this field is unsupported.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Response for ListControls method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsResponse {
    /// All the Controls for a given data store.
    #[prost(message, repeated, tag = "1")]
    pub controls: ::prost::alloc::vec::Vec<Control>,
    /// Pagination token, if not returned indicates the last page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod control_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for performing CRUD operations on Controls.
    /// Controls allow for custom logic to be implemented in the serving path.
    /// Controls need to be attached to a Serving Config to be considered during a
    /// request.
    #[derive(Debug, Clone)]
    pub struct ControlServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ControlServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ControlServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ControlServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ControlServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a Control.
        ///
        /// By default 1000 controls are allowed for a data store.
        /// A request can be submitted to adjust this limit.
        /// If the \[Control\]\[google.cloud.discoveryengine.v1.Control\] to create already
        /// exists, an ALREADY_EXISTS error is returned.
        pub async fn create_control(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/CreateControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "CreateControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Control.
        ///
        /// If the \[Control\]\[google.cloud.discoveryengine.v1.Control\] to delete does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn delete_control(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteControlRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/DeleteControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "DeleteControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Control.
        ///
        /// \[Control\]\[google.cloud.discoveryengine.v1.Control\] action type cannot be
        /// changed. If the \[Control\]\[google.cloud.discoveryengine.v1.Control\] to
        /// update does not exist, a NOT_FOUND error is returned.
        pub async fn update_control(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/UpdateControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "UpdateControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Control.
        pub async fn get_control(
            &mut self,
            request: impl tonic::IntoRequest<super::GetControlRequest>,
        ) -> std::result::Result<tonic::Response<super::Control>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/GetControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "GetControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Controls by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListControlsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListControlsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ControlService/ListControls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ControlService",
                        "ListControls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// External conversation proto definition.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/global/collections/{collection}/dataStore/*/conversations/*`
    /// or
    /// `projects/{project}/locations/global/collections/{collection}/engines/*/conversations/*`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The state of the Conversation.
    #[prost(enumeration = "conversation::State", tag = "2")]
    pub state: i32,
    /// A unique identifier for tracking users.
    #[prost(string, tag = "3")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    /// Conversation messages.
    #[prost(message, repeated, tag = "4")]
    pub messages: ::prost::alloc::vec::Vec<ConversationMessage>,
    /// Output only. The time the conversation started.
    #[prost(message, optional, tag = "5")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the conversation finished.
    #[prost(message, optional, tag = "6")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Conversation`.
pub mod conversation {
    /// Enumeration of the state of the conversation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Unknown.
        Unspecified = 0,
        /// Conversation is currently open.
        InProgress = 1,
        /// Conversation has been completed.
        Completed = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::InProgress => "IN_PROGRESS",
                Self::Completed => "COMPLETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                _ => None,
            }
        }
    }
}
/// Defines a reply message to user.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reply {
    /// Summary based on search results.
    #[prost(message, optional, tag = "3")]
    pub summary: ::core::option::Option<search_response::Summary>,
}
/// Defines context of the conversation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ConversationContext {
    /// The current list of documents the user is seeing.
    /// It contains the document resource references.
    #[prost(string, repeated, tag = "1")]
    pub context_documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The current active document the user opened.
    /// It contains the document resource reference.
    #[prost(string, tag = "2")]
    pub active_document: ::prost::alloc::string::String,
}
/// Defines text input.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TextInput {
    /// Text input.
    #[prost(string, tag = "1")]
    pub input: ::prost::alloc::string::String,
    /// Conversation context of the input.
    #[prost(message, optional, tag = "2")]
    pub context: ::core::option::Option<ConversationContext>,
}
/// Defines a conversation message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationMessage {
    /// Output only. Message creation timestamp.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "conversation_message::Message", tags = "1, 2")]
    pub message: ::core::option::Option<conversation_message::Message>,
}
/// Nested message and enum types in `ConversationMessage`.
pub mod conversation_message {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Message {
        /// User text input.
        #[prost(message, tag = "1")]
        UserInput(super::TextInput),
        /// Search reply.
        #[prost(message, tag = "2")]
        Reply(super::Reply),
    }
}
/// Request message for
/// \[ConversationalSearchService.ConverseConversation\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.ConverseConversation\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConverseConversationRequest {
    /// Required. The resource name of the Conversation to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`.
    /// Use
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/-`
    /// to activate auto session mode, which automatically creates a new
    /// conversation inside a ConverseConversation session.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Current user input.
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<TextInput>,
    /// The resource name of the Serving Config to use. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/servingConfigs/{serving_config_id}`
    /// If this is not set, the default serving config will be used.
    #[prost(string, tag = "3")]
    pub serving_config: ::prost::alloc::string::String,
    /// The conversation to be used by auto session only. The name field will be
    /// ignored as we automatically assign new name for the conversation in auto
    /// session.
    #[prost(message, optional, tag = "5")]
    pub conversation: ::core::option::Option<Conversation>,
    /// Whether to turn on safe search.
    #[prost(bool, tag = "6")]
    pub safe_search: bool,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "7")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// A specification for configuring the summary returned in the response.
    #[prost(message, optional, tag = "8")]
    pub summary_spec: ::core::option::Option<
        search_request::content_search_spec::SummarySpec,
    >,
    /// The filter syntax consists of an expression language for constructing a
    /// predicate from one or more fields of the documents being filtered. Filter
    /// expression is case-sensitive. This will be used to filter search results
    /// which may affect the summary response.
    ///
    /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
    ///
    /// Filtering in Vertex AI Search is done by mapping the LHS filter key to a
    /// key property defined in the Vertex AI Search backend -- this mapping is
    /// defined by the customer in their schema. For example a media customer might
    /// have a field 'name' in their schema. In this case the filter would look
    /// like this: filter --> name:'ANY("king kong")'
    ///
    /// For more information about filtering including syntax and filter
    /// operators, see
    /// [Filter](<https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata>)
    #[prost(string, tag = "9")]
    pub filter: ::prost::alloc::string::String,
    /// Boost specification to boost certain documents in search results which may
    /// affect the converse response. For more information on boosting, see
    /// [Boosting](<https://cloud.google.com/retail/docs/boosting#boost>)
    #[prost(message, optional, tag = "10")]
    pub boost_spec: ::core::option::Option<search_request::BoostSpec>,
}
/// Response message for
/// \[ConversationalSearchService.ConverseConversation\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.ConverseConversation\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConverseConversationResponse {
    /// Answer to the current query.
    #[prost(message, optional, tag = "1")]
    pub reply: ::core::option::Option<Reply>,
    /// Updated conversation including the answer.
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
    /// Search Results.
    #[prost(message, repeated, tag = "3")]
    pub search_results: ::prost::alloc::vec::Vec<search_response::SearchResult>,
}
/// Request for CreateConversation method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
    /// Required. Full resource name of parent data store. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The conversation to create.
    #[prost(message, optional, tag = "2")]
    pub conversation: ::core::option::Option<Conversation>,
}
/// Request for UpdateConversation method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversationRequest {
    /// Required. The Conversation to update.
    #[prost(message, optional, tag = "1")]
    pub conversation: ::core::option::Option<Conversation>,
    /// Indicates which fields in the provided
    /// \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to update. The
    /// following are NOT supported:
    ///
    /// * \[Conversation.name\]\[google.cloud.discoveryengine.v1.Conversation.name\]
    ///
    /// If not set or empty, all supported fields are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for DeleteConversation method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteConversationRequest {
    /// Required. The resource name of the Conversation to delete. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for GetConversation method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetConversationRequest {
    /// Required. The resource name of the Conversation to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/conversations/{conversation_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListConversations method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListConversationsRequest {
    /// Required. The data store resource name. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListConversations` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// A filter to apply on the list results. The supported features are:
    /// user_pseudo_id, state.
    ///
    /// Example:
    /// "user_pseudo_id = some_id"
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `update_time`
    /// * `create_time`
    /// * `conversation_name`
    ///
    /// Example:
    /// "update_time desc"
    /// "create_time"
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for ListConversations method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
    /// All the Conversations for a given data store.
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
    /// Pagination token, if not returned indicates the last page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[ConversationalSearchService.AnswerQuery\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.AnswerQuery\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQueryRequest {
    /// Required. The resource name of the Search serving config, such as
    /// `projects/*/locations/global/collections/default_collection/engines/*/servingConfigs/default_serving_config`,
    /// or
    /// `projects/*/locations/global/collections/default_collection/dataStores/*/servingConfigs/default_serving_config`.
    /// This field is used to identify the serving configuration name, set
    /// of models used to make the search.
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    /// Required. Current user query.
    #[prost(message, optional, tag = "2")]
    pub query: ::core::option::Option<Query>,
    /// The session resource name. Not required.
    ///
    /// When session field is not set, the API is in sessionless mode.
    ///
    /// We support auto session mode: users can use the wildcard symbol `-` as
    /// session ID.  A new ID will be automatically generated and assigned.
    #[prost(string, tag = "3")]
    pub session: ::prost::alloc::string::String,
    /// Model specification.
    #[prost(message, optional, tag = "4")]
    pub safety_spec: ::core::option::Option<answer_query_request::SafetySpec>,
    /// Related questions specification.
    #[prost(message, optional, tag = "5")]
    pub related_questions_spec: ::core::option::Option<
        answer_query_request::RelatedQuestionsSpec,
    >,
    /// Optional. Grounding specification.
    #[prost(message, optional, tag = "6")]
    pub grounding_spec: ::core::option::Option<answer_query_request::GroundingSpec>,
    /// Answer generation specification.
    #[prost(message, optional, tag = "7")]
    pub answer_generation_spec: ::core::option::Option<
        answer_query_request::AnswerGenerationSpec,
    >,
    /// Search specification.
    #[prost(message, optional, tag = "8")]
    pub search_spec: ::core::option::Option<answer_query_request::SearchSpec>,
    /// Query understanding specification.
    #[prost(message, optional, tag = "9")]
    pub query_understanding_spec: ::core::option::Option<
        answer_query_request::QueryUnderstandingSpec,
    >,
    /// Deprecated: This field is deprecated. Streaming Answer API will be
    /// supported.
    ///
    /// Asynchronous mode control.
    ///
    /// If enabled, the response will be returned with answer/session resource
    /// name without final answer. The API users need to do the polling to get
    /// the latest status of answer/session by calling
    /// \[ConversationalSearchService.GetAnswer\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.GetAnswer\]
    /// or
    /// \[ConversationalSearchService.GetSession\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.GetSession\]
    /// method.
    #[deprecated]
    #[prost(bool, tag = "10")]
    pub asynchronous_mode: bool,
    /// A unique identifier for tracking visitors. For example, this could be
    /// implemented with an HTTP cookie, which should be able to uniquely identify
    /// a visitor on a single device. This unique identifier should not change if
    /// the visitor logs in or out of the website.
    ///
    /// This field should NOT have a fixed value such as `unknown_visitor`.
    ///
    /// The field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an  `INVALID_ARGUMENT`  error is returned.
    #[prost(string, tag = "12")]
    pub user_pseudo_id: ::prost::alloc::string::String,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "13")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. End user specification.
    #[prost(message, optional, tag = "14")]
    pub end_user_spec: ::core::option::Option<answer_query_request::EndUserSpec>,
}
/// Nested message and enum types in `AnswerQueryRequest`.
pub mod answer_query_request {
    /// Safety specification.
    /// There are two use cases:
    ///
    /// 1. when only safety_spec.enable is set, the BLOCK_LOW_AND_ABOVE threshold
    ///    will be applied for all categories.
    /// 1. when safety_spec.enable is set and some safety_settings are set, only
    ///    specified safety_settings are applied.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SafetySpec {
        /// Enable the safety filtering on the answer response. It is false by
        /// default.
        #[prost(bool, tag = "1")]
        pub enable: bool,
        /// Optional. Safety settings.
        /// This settings are effective only when the safety_spec.enable is true.
        #[prost(message, repeated, tag = "2")]
        pub safety_settings: ::prost::alloc::vec::Vec<safety_spec::SafetySetting>,
    }
    /// Nested message and enum types in `SafetySpec`.
    pub mod safety_spec {
        /// Safety settings.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SafetySetting {
            /// Required. Harm category.
            #[prost(enumeration = "super::super::HarmCategory", tag = "1")]
            pub category: i32,
            /// Required. The harm block threshold.
            #[prost(enumeration = "safety_setting::HarmBlockThreshold", tag = "2")]
            pub threshold: i32,
        }
        /// Nested message and enum types in `SafetySetting`.
        pub mod safety_setting {
            /// Probability based thresholds levels for blocking.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum HarmBlockThreshold {
                /// Unspecified harm block threshold.
                Unspecified = 0,
                /// Block low threshold and above (i.e. block more).
                BlockLowAndAbove = 1,
                /// Block medium threshold and above.
                BlockMediumAndAbove = 2,
                /// Block only high threshold (i.e. block less).
                BlockOnlyHigh = 3,
                /// Block none.
                BlockNone = 4,
                /// Turn off the safety filter.
                Off = 5,
            }
            impl HarmBlockThreshold {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                        Self::BlockLowAndAbove => "BLOCK_LOW_AND_ABOVE",
                        Self::BlockMediumAndAbove => "BLOCK_MEDIUM_AND_ABOVE",
                        Self::BlockOnlyHigh => "BLOCK_ONLY_HIGH",
                        Self::BlockNone => "BLOCK_NONE",
                        Self::Off => "OFF",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "HARM_BLOCK_THRESHOLD_UNSPECIFIED" => Some(Self::Unspecified),
                        "BLOCK_LOW_AND_ABOVE" => Some(Self::BlockLowAndAbove),
                        "BLOCK_MEDIUM_AND_ABOVE" => Some(Self::BlockMediumAndAbove),
                        "BLOCK_ONLY_HIGH" => Some(Self::BlockOnlyHigh),
                        "BLOCK_NONE" => Some(Self::BlockNone),
                        "OFF" => Some(Self::Off),
                        _ => None,
                    }
                }
            }
        }
    }
    /// Related questions specification.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RelatedQuestionsSpec {
        /// Enable related questions feature if true.
        #[prost(bool, tag = "1")]
        pub enable: bool,
    }
    /// Grounding specification.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GroundingSpec {
        /// Optional. Specifies whether to include grounding_supports in the answer.
        /// The default value is `false`.
        ///
        /// When this field is set to `true`, returned answer will have
        /// `grounding_score` and will contain GroundingSupports for each claim.
        #[prost(bool, tag = "2")]
        pub include_grounding_supports: bool,
        /// Optional. Specifies whether to enable the filtering based on grounding
        /// score and at what level.
        #[prost(enumeration = "grounding_spec::FilteringLevel", tag = "3")]
        pub filtering_level: i32,
    }
    /// Nested message and enum types in `GroundingSpec`.
    pub mod grounding_spec {
        /// Level to filter based on answer grounding.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum FilteringLevel {
            /// Default is no filter
            Unspecified = 0,
            /// Filter answers based on a low threshold.
            Low = 1,
            /// Filter answers based on a high threshold.
            High = 2,
        }
        impl FilteringLevel {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FILTERING_LEVEL_UNSPECIFIED",
                    Self::Low => "FILTERING_LEVEL_LOW",
                    Self::High => "FILTERING_LEVEL_HIGH",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FILTERING_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                    "FILTERING_LEVEL_LOW" => Some(Self::Low),
                    "FILTERING_LEVEL_HIGH" => Some(Self::High),
                    _ => None,
                }
            }
        }
    }
    /// Answer generation specification.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AnswerGenerationSpec {
        /// Answer generation model specification.
        #[prost(message, optional, tag = "1")]
        pub model_spec: ::core::option::Option<answer_generation_spec::ModelSpec>,
        /// Answer generation prompt specification.
        #[prost(message, optional, tag = "2")]
        pub prompt_spec: ::core::option::Option<answer_generation_spec::PromptSpec>,
        /// Specifies whether to include citation metadata in the answer. The default
        /// value is `false`.
        #[prost(bool, tag = "3")]
        pub include_citations: bool,
        /// Language code for Answer. Use language tags defined by
        /// [BCP47](<https://www.rfc-editor.org/rfc/bcp/bcp47.txt>).
        /// Note: This is an experimental feature.
        #[prost(string, tag = "4")]
        pub answer_language_code: ::prost::alloc::string::String,
        /// Specifies whether to filter out adversarial queries. The default value
        /// is `false`.
        ///
        /// Google employs search-query classification to detect adversarial
        /// queries. No answer is returned if the search query is classified as an
        /// adversarial query. For example, a user might ask a question regarding
        /// negative comments about the company or submit a query designed to
        /// generate unsafe, policy-violating output. If this field is set to
        /// `true`, we skip generating answers for adversarial queries and return
        /// fallback messages instead.
        #[prost(bool, tag = "5")]
        pub ignore_adversarial_query: bool,
        /// Specifies whether to filter out queries that are not answer-seeking.
        /// The default value is `false`.
        ///
        /// Google employs search-query classification to detect answer-seeking
        /// queries. No answer is returned if the search query is classified as a
        /// non-answer seeking query. If this field is set to `true`, we skip
        /// generating answers for non-answer seeking queries and return
        /// fallback messages instead.
        #[prost(bool, tag = "6")]
        pub ignore_non_answer_seeking_query: bool,
        /// Specifies whether to filter out queries that have low relevance.
        ///
        /// If this field is set to `false`, all search results are used regardless
        /// of relevance to generate answers. If set to `true` or unset, the behavior
        /// will be determined automatically by the service.
        #[prost(bool, optional, tag = "7")]
        pub ignore_low_relevant_content: ::core::option::Option<bool>,
        /// Optional. Specifies whether to filter out jail-breaking queries. The
        /// default value is `false`.
        ///
        /// Google employs search-query classification to detect jail-breaking
        /// queries. No summary is returned if the search query is classified as a
        /// jail-breaking query. A user might add instructions to the query to
        /// change the tone, style, language, content of the answer, or ask the
        /// model to act as a different entity, e.g. "Reply in the tone of a
        /// competing company's CEO". If this field is set to `true`, we skip
        /// generating summaries for jail-breaking queries and return fallback
        /// messages instead.
        #[prost(bool, tag = "8")]
        pub ignore_jail_breaking_query: bool,
    }
    /// Nested message and enum types in `AnswerGenerationSpec`.
    pub mod answer_generation_spec {
        /// Answer Generation Model specification.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ModelSpec {
            /// Model version. If not set, it will use the default stable model.
            /// Allowed values are: stable, preview.
            #[prost(string, tag = "1")]
            pub model_version: ::prost::alloc::string::String,
        }
        /// Answer generation prompt specification.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct PromptSpec {
            /// Customized preamble.
            #[prost(string, tag = "1")]
            pub preamble: ::prost::alloc::string::String,
        }
    }
    /// Search specification.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SearchSpec {
        /// Search parameters to control the search behavior.
        /// Or provide search result list to generate answer.
        #[prost(oneof = "search_spec::Input", tags = "1, 2")]
        pub input: ::core::option::Option<search_spec::Input>,
    }
    /// Nested message and enum types in `SearchSpec`.
    pub mod search_spec {
        /// Search parameters.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SearchParams {
            /// Number of search results to return.
            /// The default value is 10.
            #[prost(int32, tag = "1")]
            pub max_return_results: i32,
            /// The filter syntax consists of an expression language for constructing
            /// a predicate from one or more fields of the documents being filtered.
            /// Filter expression is case-sensitive. This will be used to filter
            /// search results which may affect the Answer response.
            ///
            /// If this field is unrecognizable, an  `INVALID_ARGUMENT`  is returned.
            ///
            /// Filtering in Vertex AI Search is done by mapping the LHS filter key
            /// to a key property defined in the Vertex AI Search backend -- this
            /// mapping is defined by the customer in their schema. For example a
            /// media customers might have a field 'name' in their schema. In this
            /// case the filter would look like this: filter --> name:'ANY("king
            /// kong")'
            ///
            /// For more information about filtering including syntax and filter
            /// operators, see
            /// [Filter](<https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata>)
            #[prost(string, tag = "2")]
            pub filter: ::prost::alloc::string::String,
            /// Boost specification to boost certain documents in search results which
            /// may affect the answer query response. For more information on boosting,
            /// see [Boosting](<https://cloud.google.com/retail/docs/boosting#boost>)
            #[prost(message, optional, tag = "3")]
            pub boost_spec: ::core::option::Option<
                super::super::search_request::BoostSpec,
            >,
            /// The order in which documents are returned. Documents can be ordered
            /// by a field in an \[Document\]\[google.cloud.discoveryengine.v1.Document\]
            /// object. Leave it unset if ordered by relevance. `order_by` expression
            /// is case-sensitive. For more information on ordering, see
            /// [Ordering](<https://cloud.google.com/retail/docs/filter-and-order#order>)
            ///
            /// If this field is unrecognizable, an `INVALID_ARGUMENT` is returned.
            #[prost(string, tag = "4")]
            pub order_by: ::prost::alloc::string::String,
            /// Specifies the search result mode. If unspecified, the
            /// search result mode defaults to `DOCUMENTS`.
            /// See [parse and chunk
            /// documents](<https://cloud.google.com/generative-ai-app-builder/docs/parse-chunk-documents>)
            #[prost(
                enumeration = "super::super::search_request::content_search_spec::SearchResultMode",
                tag = "5"
            )]
            pub search_result_mode: i32,
            /// Specs defining dataStores to filter on in a search call and
            /// configurations for those dataStores. This is only considered for
            /// engines with multiple dataStores use case. For single dataStore within
            /// an engine, they should use the specs at the top level.
            #[prost(message, repeated, tag = "7")]
            pub data_store_specs: ::prost::alloc::vec::Vec<
                super::super::search_request::DataStoreSpec,
            >,
        }
        /// Search result list.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SearchResultList {
            /// Search results.
            #[prost(message, repeated, tag = "1")]
            pub search_results: ::prost::alloc::vec::Vec<
                search_result_list::SearchResult,
            >,
        }
        /// Nested message and enum types in `SearchResultList`.
        pub mod search_result_list {
            /// Search result.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct SearchResult {
                /// Search result content.
                #[prost(oneof = "search_result::Content", tags = "1, 2")]
                pub content: ::core::option::Option<search_result::Content>,
            }
            /// Nested message and enum types in `SearchResult`.
            pub mod search_result {
                /// Unstructured document information.
                #[derive(Clone, PartialEq, ::prost::Message)]
                pub struct UnstructuredDocumentInfo {
                    /// Document resource name.
                    #[prost(string, tag = "1")]
                    pub document: ::prost::alloc::string::String,
                    /// URI for the document.
                    #[prost(string, tag = "2")]
                    pub uri: ::prost::alloc::string::String,
                    /// Title.
                    #[prost(string, tag = "3")]
                    pub title: ::prost::alloc::string::String,
                    /// List of document contexts. The content will be used for Answer
                    /// Generation. This is supposed to be the main content of the document
                    /// that can be long and comprehensive.
                    #[prost(message, repeated, tag = "4")]
                    pub document_contexts: ::prost::alloc::vec::Vec<
                        unstructured_document_info::DocumentContext,
                    >,
                    /// List of extractive segments.
                    #[prost(message, repeated, tag = "5")]
                    pub extractive_segments: ::prost::alloc::vec::Vec<
                        unstructured_document_info::ExtractiveSegment,
                    >,
                    /// Deprecated: This field is deprecated and will have no effect on
                    /// the Answer generation.
                    /// Please use document_contexts and extractive_segments fields.
                    /// List of extractive answers.
                    #[deprecated]
                    #[prost(message, repeated, tag = "6")]
                    pub extractive_answers: ::prost::alloc::vec::Vec<
                        unstructured_document_info::ExtractiveAnswer,
                    >,
                }
                /// Nested message and enum types in `UnstructuredDocumentInfo`.
                pub mod unstructured_document_info {
                    /// Document context.
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct DocumentContext {
                        /// Page identifier.
                        #[prost(string, tag = "1")]
                        pub page_identifier: ::prost::alloc::string::String,
                        /// Document content to be used for answer generation.
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                    }
                    /// Extractive segment.
                    /// [Guide](<https://cloud.google.com/generative-ai-app-builder/docs/snippets#extractive-segments>)
                    /// Answer generation will only use it if document_contexts is empty.
                    /// This is supposed to be shorter snippets.
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct ExtractiveSegment {
                        /// Page identifier.
                        #[prost(string, tag = "1")]
                        pub page_identifier: ::prost::alloc::string::String,
                        /// Extractive segment content.
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                    }
                    /// Extractive answer.
                    /// [Guide](<https://cloud.google.com/generative-ai-app-builder/docs/snippets#get-answers>)
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct ExtractiveAnswer {
                        /// Page identifier.
                        #[prost(string, tag = "1")]
                        pub page_identifier: ::prost::alloc::string::String,
                        /// Extractive answer content.
                        #[prost(string, tag = "2")]
                        pub content: ::prost::alloc::string::String,
                    }
                }
                /// Chunk information.
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct ChunkInfo {
                    /// Chunk resource name.
                    #[prost(string, tag = "1")]
                    pub chunk: ::prost::alloc::string::String,
                    /// Chunk textual content.
                    #[prost(string, tag = "2")]
                    pub content: ::prost::alloc::string::String,
                    /// Metadata of the document from the current chunk.
                    #[prost(message, optional, tag = "4")]
                    pub document_metadata: ::core::option::Option<
                        chunk_info::DocumentMetadata,
                    >,
                }
                /// Nested message and enum types in `ChunkInfo`.
                pub mod chunk_info {
                    /// Document metadata contains the information of the document of the
                    /// current chunk.
                    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                    pub struct DocumentMetadata {
                        /// Uri of the document.
                        #[prost(string, tag = "1")]
                        pub uri: ::prost::alloc::string::String,
                        /// Title of the document.
                        #[prost(string, tag = "2")]
                        pub title: ::prost::alloc::string::String,
                    }
                }
                /// Search result content.
                #[derive(Clone, PartialEq, ::prost::Oneof)]
                pub enum Content {
                    /// Unstructured document information.
                    #[prost(message, tag = "1")]
                    UnstructuredDocumentInfo(UnstructuredDocumentInfo),
                    /// Chunk information.
                    #[prost(message, tag = "2")]
                    ChunkInfo(ChunkInfo),
                }
            }
        }
        /// Search parameters to control the search behavior.
        /// Or provide search result list to generate answer.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Input {
            /// Search parameters.
            #[prost(message, tag = "1")]
            SearchParams(SearchParams),
            /// Search result list.
            #[prost(message, tag = "2")]
            SearchResultList(SearchResultList),
        }
    }
    /// Query understanding specification.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QueryUnderstandingSpec {
        /// Query classification specification.
        #[prost(message, optional, tag = "1")]
        pub query_classification_spec: ::core::option::Option<
            query_understanding_spec::QueryClassificationSpec,
        >,
        /// Query rephraser specification.
        #[prost(message, optional, tag = "2")]
        pub query_rephraser_spec: ::core::option::Option<
            query_understanding_spec::QueryRephraserSpec,
        >,
        /// Optional. Whether to disable spell correction.
        /// The default value is `false`.
        #[prost(bool, tag = "3")]
        pub disable_spell_correction: bool,
    }
    /// Nested message and enum types in `QueryUnderstandingSpec`.
    pub mod query_understanding_spec {
        /// Query classification specification.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct QueryClassificationSpec {
            /// Enabled query classification types.
            #[prost(
                enumeration = "query_classification_spec::Type",
                repeated,
                tag = "1"
            )]
            pub types: ::prost::alloc::vec::Vec<i32>,
        }
        /// Nested message and enum types in `QueryClassificationSpec`.
        pub mod query_classification_spec {
            /// Query classification types.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Type {
                /// Unspecified query classification type.
                Unspecified = 0,
                /// Adversarial query classification type.
                AdversarialQuery = 1,
                /// Non-answer-seeking query classification type, for chit chat.
                NonAnswerSeekingQuery = 2,
                /// Jail-breaking query classification type.
                JailBreakingQuery = 3,
                /// Non-answer-seeking query classification type, for no clear intent.
                NonAnswerSeekingQueryV2 = 4,
                /// User defined query classification type.
                UserDefinedClassificationQuery = 5,
            }
            impl Type {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "TYPE_UNSPECIFIED",
                        Self::AdversarialQuery => "ADVERSARIAL_QUERY",
                        Self::NonAnswerSeekingQuery => "NON_ANSWER_SEEKING_QUERY",
                        Self::JailBreakingQuery => "JAIL_BREAKING_QUERY",
                        Self::NonAnswerSeekingQueryV2 => "NON_ANSWER_SEEKING_QUERY_V2",
                        Self::UserDefinedClassificationQuery => {
                            "USER_DEFINED_CLASSIFICATION_QUERY"
                        }
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "ADVERSARIAL_QUERY" => Some(Self::AdversarialQuery),
                        "NON_ANSWER_SEEKING_QUERY" => Some(Self::NonAnswerSeekingQuery),
                        "JAIL_BREAKING_QUERY" => Some(Self::JailBreakingQuery),
                        "NON_ANSWER_SEEKING_QUERY_V2" => {
                            Some(Self::NonAnswerSeekingQueryV2)
                        }
                        "USER_DEFINED_CLASSIFICATION_QUERY" => {
                            Some(Self::UserDefinedClassificationQuery)
                        }
                        _ => None,
                    }
                }
            }
        }
        /// Query rephraser specification.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct QueryRephraserSpec {
            /// Disable query rephraser.
            #[prost(bool, tag = "1")]
            pub disable: bool,
            /// Max rephrase steps.
            /// The max number is 5 steps.
            /// If not set or set to \< 1, it will be set to 1 by default.
            #[prost(int32, tag = "2")]
            pub max_rephrase_steps: i32,
            /// Optional. Query Rephraser Model specification.
            #[prost(message, optional, tag = "3")]
            pub model_spec: ::core::option::Option<query_rephraser_spec::ModelSpec>,
        }
        /// Nested message and enum types in `QueryRephraserSpec`.
        pub mod query_rephraser_spec {
            /// Query Rephraser Model specification.
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ModelSpec {
                /// Optional. Enabled query rephraser model type. If not set, it will use
                /// LARGE by default.
                #[prost(enumeration = "model_spec::ModelType", tag = "1")]
                pub model_type: i32,
            }
            /// Nested message and enum types in `ModelSpec`.
            pub mod model_spec {
                /// Query rephraser types. Currently only supports single-hop
                /// (max_rephrase_steps = 1) model selections. For multi-hop
                /// (max_rephrase_steps > 1), there is only one default model.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum ModelType {
                    /// Unspecified model type.
                    Unspecified = 0,
                    /// Small query rephraser model. Gemini 1.0 XS model.
                    Small = 1,
                    /// Large query rephraser model. Gemini 1.0 Pro model.
                    Large = 2,
                }
                impl ModelType {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "MODEL_TYPE_UNSPECIFIED",
                            Self::Small => "SMALL",
                            Self::Large => "LARGE",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "MODEL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                            "SMALL" => Some(Self::Small),
                            "LARGE" => Some(Self::Large),
                            _ => None,
                        }
                    }
                }
            }
        }
    }
    /// End user specification.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EndUserSpec {
        /// Optional. End user metadata.
        #[prost(message, repeated, tag = "1")]
        pub end_user_metadata: ::prost::alloc::vec::Vec<end_user_spec::EndUserMetaData>,
    }
    /// Nested message and enum types in `EndUserSpec`.
    pub mod end_user_spec {
        /// End user metadata.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EndUserMetaData {
            /// Search result content.
            #[prost(oneof = "end_user_meta_data::Content", tags = "1")]
            pub content: ::core::option::Option<end_user_meta_data::Content>,
        }
        /// Nested message and enum types in `EndUserMetaData`.
        pub mod end_user_meta_data {
            /// Chunk information.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ChunkInfo {
                /// Chunk textual content. It is limited to 8000 characters.
                #[prost(string, tag = "1")]
                pub content: ::prost::alloc::string::String,
                /// Metadata of the document from the current chunk.
                #[prost(message, optional, tag = "2")]
                pub document_metadata: ::core::option::Option<
                    chunk_info::DocumentMetadata,
                >,
            }
            /// Nested message and enum types in `ChunkInfo`.
            pub mod chunk_info {
                /// Document metadata contains the information of the document of
                /// the current chunk.
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct DocumentMetadata {
                    /// Title of the document.
                    #[prost(string, tag = "1")]
                    pub title: ::prost::alloc::string::String,
                }
            }
            /// Search result content.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum Content {
                /// Chunk information.
                #[prost(message, tag = "1")]
                ChunkInfo(ChunkInfo),
            }
        }
    }
}
/// Response message for
/// \[ConversationalSearchService.AnswerQuery\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.AnswerQuery\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnswerQueryResponse {
    /// Answer resource object.
    /// If
    /// \[AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.max_rephrase_steps\]\[google.cloud.discoveryengine.v1.AnswerQueryRequest.QueryUnderstandingSpec.QueryRephraserSpec.max_rephrase_steps\]
    /// is greater than 1, use
    /// \[Answer.name\]\[google.cloud.discoveryengine.v1.Answer.name\] to fetch answer
    /// information using
    /// \[ConversationalSearchService.GetAnswer\]\[google.cloud.discoveryengine.v1.ConversationalSearchService.GetAnswer\]
    /// API.
    #[prost(message, optional, tag = "1")]
    pub answer: ::core::option::Option<Answer>,
    /// Session resource object.
    /// It will be only available when session field is set and valid in the
    /// \[AnswerQueryRequest\]\[google.cloud.discoveryengine.v1.AnswerQueryRequest\]
    /// request.
    #[prost(message, optional, tag = "2")]
    pub session: ::core::option::Option<Session>,
    /// A global unique ID used for logging.
    #[prost(string, tag = "3")]
    pub answer_query_token: ::prost::alloc::string::String,
}
/// Request for GetAnswer method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAnswerRequest {
    /// Required. The resource name of the Answer to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine_id}/sessions/{session_id}/answers/{answer_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for CreateSession method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSessionRequest {
    /// Required. Full resource name of parent data store. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The session to create.
    #[prost(message, optional, tag = "2")]
    pub session: ::core::option::Option<Session>,
}
/// Request for UpdateSession method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSessionRequest {
    /// Required. The Session to update.
    #[prost(message, optional, tag = "1")]
    pub session: ::core::option::Option<Session>,
    /// Indicates which fields in the provided
    /// \[Session\]\[google.cloud.discoveryengine.v1.Session\] to update. The following
    /// are NOT supported:
    ///
    /// * \[Session.name\]\[google.cloud.discoveryengine.v1.Session.name\]
    ///
    /// If not set or empty, all supported fields are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request for DeleteSession method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSessionRequest {
    /// Required. The resource name of the Session to delete. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for GetSession method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSessionRequest {
    /// Required. The resource name of the Session to get. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}/sessions/{session_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If set to true, the full session including all answer details
    /// will be returned.
    #[prost(bool, tag = "2")]
    pub include_answer_details: bool,
}
/// Request for ListSessions method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSessionsRequest {
    /// Required. The data store resource name. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of results to return. If unspecified, defaults
    /// to 50. Max allowed value is 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListSessions` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// A comma-separated list of fields to filter by, in EBNF grammar.
    /// The supported fields are:
    ///
    /// * `user_pseudo_id`
    /// * `state`
    /// * `display_name`
    /// * `starred`
    /// * `is_pinned`
    /// * `labels`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Examples:
    /// "user_pseudo_id = some_id"
    /// "display_name = "some_name""
    /// "starred = true"
    /// "is_pinned=true AND (NOT labels:hidden)"
    /// "create_time > "1970-01-01T12:00:00Z""
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// A comma-separated list of fields to order by, sorted in ascending order.
    /// Use "desc" after a field name for descending.
    /// Supported fields:
    ///
    /// * `update_time`
    /// * `create_time`
    /// * `session_name`
    /// * `is_pinned`
    ///
    /// Example:
    ///
    /// * "update_time desc"
    /// * "create_time"
    /// * "is_pinned desc,update_time desc": list sessions by is_pinned first, then
    ///   by update_time.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for ListSessions method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSessionsResponse {
    /// All the Sessions for a given data store.
    #[prost(message, repeated, tag = "1")]
    pub sessions: ::prost::alloc::vec::Vec<Session>,
    /// Pagination token, if not returned indicates the last page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod conversational_search_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for conversational search.
    #[derive(Debug, Clone)]
    pub struct ConversationalSearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConversationalSearchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConversationalSearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConversationalSearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConversationalSearchServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Converses a conversation.
        pub async fn converse_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::ConverseConversationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConverseConversationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/ConverseConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "ConverseConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Conversation.
        ///
        /// If the \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to
        /// create already exists, an ALREADY_EXISTS error is returned.
        pub async fn create_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/CreateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "CreateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Conversation.
        ///
        /// If the \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to
        /// delete does not exist, a NOT_FOUND error is returned.
        pub async fn delete_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConversationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/DeleteConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "DeleteConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Conversation.
        ///
        /// \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] action type
        /// cannot be changed. If the
        /// \[Conversation\]\[google.cloud.discoveryengine.v1.Conversation\] to update does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn update_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/UpdateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "UpdateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Conversation.
        pub async fn get_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/GetConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "GetConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Conversations by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/ListConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "ListConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Answer query method.
        pub async fn answer_query(
            &mut self,
            request: impl tonic::IntoRequest<super::AnswerQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AnswerQueryResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/AnswerQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "AnswerQuery",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Answer query method (streaming).
        ///
        /// It takes one
        /// \[AnswerQueryRequest\]\[google.cloud.discoveryengine.v1.AnswerQueryRequest\]
        /// and returns multiple
        /// \[AnswerQueryResponse\]\[google.cloud.discoveryengine.v1.AnswerQueryResponse\]
        /// messages in a stream.
        pub async fn stream_answer_query(
            &mut self,
            request: impl tonic::IntoRequest<super::AnswerQueryRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AnswerQueryResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/StreamAnswerQuery",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "StreamAnswerQuery",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Gets a Answer.
        pub async fn get_answer(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnswerRequest>,
        ) -> std::result::Result<tonic::Response<super::Answer>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/GetAnswer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "GetAnswer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Session.
        ///
        /// If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to create already
        /// exists, an ALREADY_EXISTS error is returned.
        pub async fn create_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/CreateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "CreateSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Session.
        ///
        /// If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to delete does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn delete_session(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSessionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/DeleteSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "DeleteSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Session.
        ///
        /// \[Session\]\[google.cloud.discoveryengine.v1.Session\] action type cannot be
        /// changed. If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to
        /// update does not exist, a NOT_FOUND error is returned.
        pub async fn update_session(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/UpdateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "UpdateSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Session.
        pub async fn get_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/GetSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "GetSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Sessions by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ConversationalSearchService/ListSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ConversationalSearchService",
                        "ListSessions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Metadata that describes a custom tuned model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTuningModel {
    /// Required. The fully qualified resource name of the model.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/customTuningModels/{custom_tuning_model}`.
    ///
    /// Model must be an alpha-numerical string with limit of 40 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The display name of the model.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The version of the model.
    #[prost(int64, tag = "3")]
    pub model_version: i64,
    /// The state that the model is in (e.g.`TRAINING` or `TRAINING_FAILED`).
    #[prost(enumeration = "custom_tuning_model::ModelState", tag = "4")]
    pub model_state: i32,
    /// Deprecated: Timestamp the Model was created at.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Timestamp the model training was initiated.
    #[prost(message, optional, tag = "6")]
    pub training_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The metrics of the trained model.
    #[prost(map = "string, double", tag = "7")]
    pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
    /// Currently this is only populated if the model state is
    /// `INPUT_VALIDATION_FAILED`.
    #[prost(string, tag = "8")]
    pub error_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CustomTuningModel`.
pub mod custom_tuning_model {
    /// The state of the model.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ModelState {
        /// Default value.
        Unspecified = 0,
        /// The model is in a paused training state.
        TrainingPaused = 1,
        /// The model is currently training.
        Training = 2,
        /// The model has successfully completed training.
        TrainingComplete = 3,
        /// The model is ready for serving.
        ReadyForServing = 4,
        /// The model training failed.
        TrainingFailed = 5,
        /// The model training finished successfully but metrics did not improve.
        NoImprovement = 6,
        /// Input data validation failed. Model training didn't start.
        InputValidationFailed = 7,
    }
    impl ModelState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MODEL_STATE_UNSPECIFIED",
                Self::TrainingPaused => "TRAINING_PAUSED",
                Self::Training => "TRAINING",
                Self::TrainingComplete => "TRAINING_COMPLETE",
                Self::ReadyForServing => "READY_FOR_SERVING",
                Self::TrainingFailed => "TRAINING_FAILED",
                Self::NoImprovement => "NO_IMPROVEMENT",
                Self::InputValidationFailed => "INPUT_VALIDATION_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MODEL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "TRAINING_PAUSED" => Some(Self::TrainingPaused),
                "TRAINING" => Some(Self::Training),
                "TRAINING_COMPLETE" => Some(Self::TrainingComplete),
                "READY_FOR_SERVING" => Some(Self::ReadyForServing),
                "TRAINING_FAILED" => Some(Self::TrainingFailed),
                "NO_IMPROVEMENT" => Some(Self::NoImprovement),
                "INPUT_VALIDATION_FAILED" => Some(Self::InputValidationFailed),
                _ => None,
            }
        }
    }
}
/// A singleton resource of
/// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]. If it's empty when
/// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] is created and
/// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] is set to
/// \[DataStore.ContentConfig.CONTENT_REQUIRED\]\[google.cloud.discoveryengine.v1.DataStore.ContentConfig.CONTENT_REQUIRED\],
/// the default parser will default to digital parser.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentProcessingConfig {
    /// The full resource name of the Document Processing Config.
    /// Format:
    /// `projects/*/locations/*/collections/*/dataStores/*/documentProcessingConfig`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Whether chunking mode is enabled.
    #[prost(message, optional, tag = "3")]
    pub chunking_config: ::core::option::Option<
        document_processing_config::ChunkingConfig,
    >,
    /// Configurations for default Document parser.
    /// If not specified, we will configure it as default DigitalParsingConfig, and
    /// the default parsing config will be applied to all file types for Document
    /// parsing.
    #[prost(message, optional, tag = "4")]
    pub default_parsing_config: ::core::option::Option<
        document_processing_config::ParsingConfig,
    >,
    /// Map from file type to override the default parsing configuration based on
    /// the file type. Supported keys:
    ///
    /// * `pdf`: Override parsing config for PDF files, either digital parsing, ocr
    ///   parsing or layout parsing is supported.
    /// * `html`: Override parsing config for HTML files, only digital parsing and
    ///   layout parsing are supported.
    /// * `docx`: Override parsing config for DOCX files, only digital parsing and
    ///   layout parsing are supported.
    /// * `pptx`: Override parsing config for PPTX files, only digital parsing and
    ///   layout parsing are supported.
    /// * `xlsm`: Override parsing config for XLSM files, only digital parsing and
    ///   layout parsing are supported.
    /// * `xlsx`: Override parsing config for XLSX files, only digital parsing and
    ///   layout parsing are supported.
    #[prost(map = "string, message", tag = "5")]
    pub parsing_config_overrides: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        document_processing_config::ParsingConfig,
    >,
}
/// Nested message and enum types in `DocumentProcessingConfig`.
pub mod document_processing_config {
    /// Configuration for chunking config.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChunkingConfig {
        /// Additional configs that defines the behavior of the chunking.
        #[prost(oneof = "chunking_config::ChunkMode", tags = "1")]
        pub chunk_mode: ::core::option::Option<chunking_config::ChunkMode>,
    }
    /// Nested message and enum types in `ChunkingConfig`.
    pub mod chunking_config {
        /// Configuration for the layout based chunking.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LayoutBasedChunkingConfig {
            /// The token size limit for each chunk.
            ///
            /// Supported values: 100-500 (inclusive).
            /// Default value: 500.
            #[prost(int32, tag = "1")]
            pub chunk_size: i32,
            /// Whether to include appending different levels of headings to chunks
            /// from the middle of the document to prevent context loss.
            ///
            /// Default value: False.
            #[prost(bool, tag = "2")]
            pub include_ancestor_headings: bool,
        }
        /// Additional configs that defines the behavior of the chunking.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum ChunkMode {
            /// Configuration for the layout based chunking.
            #[prost(message, tag = "1")]
            LayoutBasedChunkingConfig(LayoutBasedChunkingConfig),
        }
    }
    /// Related configurations applied to a specific type of document parser.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ParsingConfig {
        /// Configs for document processing types.
        #[prost(oneof = "parsing_config::TypeDedicatedConfig", tags = "1, 2, 3")]
        pub type_dedicated_config: ::core::option::Option<
            parsing_config::TypeDedicatedConfig,
        >,
    }
    /// Nested message and enum types in `ParsingConfig`.
    pub mod parsing_config {
        /// The digital parsing configurations for documents.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct DigitalParsingConfig {}
        /// The OCR parsing configurations for documents.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct OcrParsingConfig {
            /// \[DEPRECATED\] This field is deprecated. To use the additional enhanced
            /// document elements processing, please switch to `layout_parsing_config`.
            #[deprecated]
            #[prost(string, repeated, tag = "1")]
            pub enhanced_document_elements: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// If true, will use native text instead of OCR text on pages containing
            /// native text.
            #[prost(bool, tag = "2")]
            pub use_native_text: bool,
        }
        /// The layout parsing configurations for documents.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct LayoutParsingConfig {
            /// Optional. If true, the LLM based annotation is added to the table
            /// during parsing.
            #[prost(bool, tag = "1")]
            pub enable_table_annotation: bool,
            /// Optional. If true, the LLM based annotation is added to the image
            /// during parsing.
            #[prost(bool, tag = "2")]
            pub enable_image_annotation: bool,
            /// Optional. Contains the required structure types to extract from the
            /// document. Supported values:
            ///
            /// * `shareholder-structure`
            #[prost(string, repeated, tag = "9")]
            pub structured_content_types: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. List of HTML elements to exclude from the parsed content.
            #[prost(string, repeated, tag = "10")]
            pub exclude_html_elements: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. List of HTML classes to exclude from the parsed content.
            #[prost(string, repeated, tag = "11")]
            pub exclude_html_classes: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Optional. List of HTML ids to exclude from the parsed content.
            #[prost(string, repeated, tag = "12")]
            pub exclude_html_ids: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
        }
        /// Configs for document processing types.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum TypeDedicatedConfig {
            /// Configurations applied to digital parser.
            #[prost(message, tag = "1")]
            DigitalParsingConfig(DigitalParsingConfig),
            /// Configurations applied to OCR parser. Currently it only applies to
            /// PDFs.
            #[prost(message, tag = "2")]
            OcrParsingConfig(OcrParsingConfig),
            /// Configurations applied to layout parser.
            #[prost(message, tag = "3")]
            LayoutParsingConfig(LayoutParsingConfig),
        }
    }
}
/// Defines the structure and layout of a type of document data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// Immutable. The full resource name of the schema, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Schema representation. One of
    /// \[struct_schema\]\[google.cloud.discoveryengine.v1.Schema.struct_schema\] or
    /// \[json_schema\]\[google.cloud.discoveryengine.v1.Schema.json_schema\] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    #[prost(oneof = "schema::Schema", tags = "2, 3")]
    pub schema: ::core::option::Option<schema::Schema>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    /// Schema representation. One of
    /// \[struct_schema\]\[google.cloud.discoveryengine.v1.Schema.struct_schema\] or
    /// \[json_schema\]\[google.cloud.discoveryengine.v1.Schema.json_schema\] should be
    /// provided otherwise an `INVALID_ARGUMENT` error is thrown.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Schema {
        /// The structured representation of the schema.
        #[prost(message, tag = "2")]
        StructSchema(::prost_types::Struct),
        /// The JSON representation of the schema.
        #[prost(string, tag = "3")]
        JsonSchema(::prost::alloc::string::String),
    }
}
/// DataStore captures global settings and configs at the DataStore level.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStore {
    /// Immutable. Identifier. The full resource name of the data store.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The data store display name.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Immutable. The industry vertical that the data store registers.
    #[prost(enumeration = "IndustryVertical", tag = "3")]
    pub industry_vertical: i32,
    /// The solutions that the data store enrolls. Available solutions for each
    /// \[industry_vertical\]\[google.cloud.discoveryengine.v1.DataStore.industry_vertical\]:
    ///
    /// * `MEDIA`: `SOLUTION_TYPE_RECOMMENDATION` and `SOLUTION_TYPE_SEARCH`.
    /// * `SITE_SEARCH`: `SOLUTION_TYPE_SEARCH` is automatically enrolled. Other
    ///   solutions cannot be enrolled.
    #[prost(enumeration = "SolutionType", repeated, tag = "5")]
    pub solution_types: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The id of the default
    /// \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] associated to this data
    /// store.
    #[prost(string, tag = "7")]
    pub default_schema_id: ::prost::alloc::string::String,
    /// Immutable. The content config of the data store. If this field is unset,
    /// the server behavior defaults to
    /// \[ContentConfig.NO_CONTENT\]\[google.cloud.discoveryengine.v1.DataStore.ContentConfig.NO_CONTENT\].
    #[prost(enumeration = "data_store::ContentConfig", tag = "6")]
    pub content_config: i32,
    /// Output only. Timestamp the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] was created at.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Configuration for advanced site search.
    #[prost(message, optional, tag = "12")]
    pub advanced_site_search_config: ::core::option::Option<AdvancedSiteSearchConfig>,
    /// Input only. The KMS key to be used to protect this DataStore at creation
    /// time.
    ///
    /// Must be set for requests that need to comply with CMEK Org Policy
    /// protections.
    ///
    /// If this field is set and processed successfully, the DataStore will be
    /// protected by the KMS key, as indicated in the cmek_config field.
    #[prost(string, tag = "32")]
    pub kms_key_name: ::prost::alloc::string::String,
    /// Output only. CMEK-related information for the DataStore.
    #[prost(message, optional, tag = "18")]
    pub cmek_config: ::core::option::Option<CmekConfig>,
    /// Output only. Data size estimation for billing.
    #[prost(message, optional, tag = "23")]
    pub billing_estimation: ::core::option::Option<data_store::BillingEstimation>,
    /// Immutable. Whether data in the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] has ACL information.
    /// If set to `true`, the source data must have ACL. ACL will be ingested when
    /// data is ingested by
    /// \[DocumentService.ImportDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ImportDocuments\]
    /// methods.
    ///
    /// When ACL is enabled for the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\],
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\] can't be accessed by
    /// calling
    /// \[DocumentService.GetDocument\]\[google.cloud.discoveryengine.v1.DocumentService.GetDocument\]
    /// or
    /// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\].
    ///
    /// Currently ACL is only supported in `GENERIC` industry vertical with
    /// non-`PUBLIC_WEBSITE` content config.
    #[prost(bool, tag = "24")]
    pub acl_enabled: bool,
    /// Config to store data store type configuration for workspace data. This
    /// must be set when
    /// \[DataStore.content_config\]\[google.cloud.discoveryengine.v1.DataStore.content_config\]
    /// is set as
    /// \[DataStore.ContentConfig.GOOGLE_WORKSPACE\]\[google.cloud.discoveryengine.v1.DataStore.ContentConfig.GOOGLE_WORKSPACE\].
    #[prost(message, optional, tag = "25")]
    pub workspace_config: ::core::option::Option<WorkspaceConfig>,
    /// Configuration for Document understanding and enrichment.
    #[prost(message, optional, tag = "27")]
    pub document_processing_config: ::core::option::Option<DocumentProcessingConfig>,
    /// The start schema to use for this
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] when provisioning
    /// it. If unset, a default vertical specialized schema will be used.
    ///
    /// This field is only used by
    /// \[CreateDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore\]
    /// API, and will be ignored if used in other APIs. This field will be omitted
    /// from all API responses including
    /// \[CreateDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore\]
    /// API. To retrieve a schema of a
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], use
    /// \[SchemaService.GetSchema\]\[google.cloud.discoveryengine.v1.SchemaService.GetSchema\]
    /// API instead.
    ///
    /// The provided schema will be validated against certain rules on schema.
    /// Learn more from [this
    /// doc](<https://cloud.google.com/generative-ai-app-builder/docs/provide-schema>).
    #[prost(message, optional, tag = "28")]
    pub starting_schema: ::core::option::Option<Schema>,
    /// Optional. Configuration for `HEALTHCARE_FHIR` vertical.
    #[prost(message, optional, tag = "29")]
    pub healthcare_fhir_config: ::core::option::Option<HealthcareFhirConfig>,
    /// Immutable. The fully qualified resource name of the associated
    /// \[IdentityMappingStore\]\[google.cloud.discoveryengine.v1.IdentityMappingStore\].
    /// This field can only be set for acl_enabled DataStores with `THIRD_PARTY` or
    /// `GSUITE` IdP. Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identity_mapping_store}`.
    #[prost(string, tag = "31")]
    pub identity_mapping_store: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DataStore`.
pub mod data_store {
    /// Estimation of data size per data store.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BillingEstimation {
        /// Data size for structured data in terms of bytes.
        #[prost(int64, tag = "1")]
        pub structured_data_size: i64,
        /// Data size for unstructured data in terms of bytes.
        #[prost(int64, tag = "2")]
        pub unstructured_data_size: i64,
        /// Data size for websites in terms of bytes.
        #[prost(int64, tag = "3")]
        pub website_data_size: i64,
        /// Last updated timestamp for structured data.
        #[prost(message, optional, tag = "4")]
        pub structured_data_update_time: ::core::option::Option<
            ::prost_types::Timestamp,
        >,
        /// Last updated timestamp for unstructured data.
        #[prost(message, optional, tag = "5")]
        pub unstructured_data_update_time: ::core::option::Option<
            ::prost_types::Timestamp,
        >,
        /// Last updated timestamp for websites.
        #[prost(message, optional, tag = "6")]
        pub website_data_update_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Content config of the data store.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentConfig {
        /// Default value.
        Unspecified = 0,
        /// Only contains documents without any
        /// \[Document.content\]\[google.cloud.discoveryengine.v1.Document.content\].
        NoContent = 1,
        /// Only contains documents with
        /// \[Document.content\]\[google.cloud.discoveryengine.v1.Document.content\].
        ContentRequired = 2,
        /// The data store is used for public website search.
        PublicWebsite = 3,
        /// The data store is used for workspace search. Details of workspace
        /// data store are specified in the
        /// \[WorkspaceConfig\]\[google.cloud.discoveryengine.v1.WorkspaceConfig\].
        GoogleWorkspace = 4,
    }
    impl ContentConfig {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONTENT_CONFIG_UNSPECIFIED",
                Self::NoContent => "NO_CONTENT",
                Self::ContentRequired => "CONTENT_REQUIRED",
                Self::PublicWebsite => "PUBLIC_WEBSITE",
                Self::GoogleWorkspace => "GOOGLE_WORKSPACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTENT_CONFIG_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_CONTENT" => Some(Self::NoContent),
                "CONTENT_REQUIRED" => Some(Self::ContentRequired),
                "PUBLIC_WEBSITE" => Some(Self::PublicWebsite),
                "GOOGLE_WORKSPACE" => Some(Self::GoogleWorkspace),
                _ => None,
            }
        }
    }
}
/// Configuration data for advance site search.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdvancedSiteSearchConfig {
    /// If set true, initial indexing is disabled for the DataStore.
    #[prost(bool, optional, tag = "3")]
    pub disable_initial_index: ::core::option::Option<bool>,
    /// If set true, automatic refresh is disabled for the DataStore.
    #[prost(bool, optional, tag = "4")]
    pub disable_automatic_refresh: ::core::option::Option<bool>,
}
/// Config to store data store type configuration for workspace data
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WorkspaceConfig {
    /// The Google Workspace data source.
    #[prost(enumeration = "workspace_config::Type", tag = "1")]
    pub r#type: i32,
    /// Obfuscated Dasher customer ID.
    #[prost(string, tag = "2")]
    pub dasher_customer_id: ::prost::alloc::string::String,
    /// Optional. The super admin service account for the workspace that will be
    /// used for access token generation. For now we only use it for Native Google
    /// Drive connector data ingestion.
    #[prost(string, tag = "4")]
    pub super_admin_service_account: ::prost::alloc::string::String,
    /// Optional. The super admin email address for the workspace that will be used
    /// for access token generation. For now we only use it for Native Google Drive
    /// connector data ingestion.
    #[prost(string, tag = "5")]
    pub super_admin_email_address: ::prost::alloc::string::String,
}
/// Nested message and enum types in `WorkspaceConfig`.
pub mod workspace_config {
    /// Specifies the type of Workspace App supported by this DataStore
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Defaults to an unspecified Workspace type.
        Unspecified = 0,
        /// Workspace Data Store contains Drive data
        GoogleDrive = 1,
        /// Workspace Data Store contains Mail data
        GoogleMail = 2,
        /// Workspace Data Store contains Sites data
        GoogleSites = 3,
        /// Workspace Data Store contains Calendar data
        GoogleCalendar = 4,
        /// Workspace Data Store contains Chat data
        GoogleChat = 5,
        /// Workspace Data Store contains Groups data
        GoogleGroups = 6,
        /// Workspace Data Store contains Keep data
        GoogleKeep = 7,
        /// Workspace Data Store contains People data
        GooglePeople = 8,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::GoogleDrive => "GOOGLE_DRIVE",
                Self::GoogleMail => "GOOGLE_MAIL",
                Self::GoogleSites => "GOOGLE_SITES",
                Self::GoogleCalendar => "GOOGLE_CALENDAR",
                Self::GoogleChat => "GOOGLE_CHAT",
                Self::GoogleGroups => "GOOGLE_GROUPS",
                Self::GoogleKeep => "GOOGLE_KEEP",
                Self::GooglePeople => "GOOGLE_PEOPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GOOGLE_DRIVE" => Some(Self::GoogleDrive),
                "GOOGLE_MAIL" => Some(Self::GoogleMail),
                "GOOGLE_SITES" => Some(Self::GoogleSites),
                "GOOGLE_CALENDAR" => Some(Self::GoogleCalendar),
                "GOOGLE_CHAT" => Some(Self::GoogleChat),
                "GOOGLE_GROUPS" => Some(Self::GoogleGroups),
                "GOOGLE_KEEP" => Some(Self::GoogleKeep),
                "GOOGLE_PEOPLE" => Some(Self::GooglePeople),
                _ => None,
            }
        }
    }
}
/// Request for
/// \[DataStoreService.CreateDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataStoreRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] to
    /// create.
    #[prost(message, optional, tag = "2")]
    pub data_store: ::core::option::Option<DataStore>,
    /// Required. The ID to use for the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], which will become
    /// the final component of the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]'s resource name.
    ///
    /// This field must conform to [RFC-1034](<https://tools.ietf.org/html/rfc1034>)
    /// standard with a length limit of 63 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    #[prost(string, tag = "3")]
    pub data_store_id: ::prost::alloc::string::String,
    /// A boolean flag indicating whether user want to directly create an advanced
    /// data store for site search.
    /// If the data store is not configured as site
    /// search (GENERIC vertical and PUBLIC_WEBSITE content_config), this flag will
    /// be ignored.
    #[prost(bool, tag = "4")]
    pub create_advanced_site_search: bool,
    /// A boolean flag indicating whether to skip the default schema creation for
    /// the data store. Only enable this flag if you are certain that the default
    /// schema is incompatible with your use case.
    ///
    /// If set to true, you must manually create a schema for the data store before
    /// any documents can be ingested.
    ///
    /// This flag cannot be specified if `data_store.starting_schema` is specified.
    #[prost(bool, tag = "7")]
    pub skip_default_schema_creation: bool,
    /// CMEK options for the DataStore. Setting this field will override the
    /// default CmekConfig if one is set for the project.
    #[prost(oneof = "create_data_store_request::CmekOptions", tags = "5, 6")]
    pub cmek_options: ::core::option::Option<create_data_store_request::CmekOptions>,
}
/// Nested message and enum types in `CreateDataStoreRequest`.
pub mod create_data_store_request {
    /// CMEK options for the DataStore. Setting this field will override the
    /// default CmekConfig if one is set for the project.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum CmekOptions {
        /// Resource name of the CmekConfig to use for protecting this DataStore.
        #[prost(string, tag = "5")]
        CmekConfigName(::prost::alloc::string::String),
        /// DataStore without CMEK protections. If a default CmekConfig is set for
        /// the project, setting this field will override the default CmekConfig as
        /// well.
        #[prost(bool, tag = "6")]
        DisableCmek(bool),
    }
}
/// Request message for
/// \[DataStoreService.GetDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.GetDataStore\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDataStoreRequest {
    /// Required. Full resource name of
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// If the caller does not have permission to access the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]
    /// does not exist, a NOT_FOUND error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata related to the progress of the
/// \[DataStoreService.CreateDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.CreateDataStore\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateDataStoreMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[DataStoreService.ListDataStores\]\[google.cloud.discoveryengine.v1.DataStoreService.ListDataStores\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDataStoresRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}`.
    ///
    /// If the caller does not have permission to list
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s under this
    /// location, regardless of whether or not this data store exists, a
    /// PERMISSION_DENIED error is returned.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s
    /// to return. If unspecified, defaults to 10. The maximum allowed value is 50.
    /// Values above 50 will be coerced to 50.
    ///
    /// If this field is negative, an INVALID_ARGUMENT is returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token
    /// \[ListDataStoresResponse.next_page_token\]\[google.cloud.discoveryengine.v1.ListDataStoresResponse.next_page_token\],
    /// received from a previous
    /// \[DataStoreService.ListDataStores\]\[google.cloud.discoveryengine.v1.DataStoreService.ListDataStores\]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// \[DataStoreService.ListDataStores\]\[google.cloud.discoveryengine.v1.DataStoreService.ListDataStores\]
    /// must match the call that provided the page token. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter by solution type .
    /// For example: `filter = 'solution_type:SOLUTION_TYPE_SEARCH'`
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Response message for
/// \[DataStoreService.ListDataStores\]\[google.cloud.discoveryengine.v1.DataStoreService.ListDataStores\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStoresResponse {
    /// All the customer's \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s.
    #[prost(message, repeated, tag = "1")]
    pub data_stores: ::prost::alloc::vec::Vec<DataStore>,
    /// A token that can be sent as
    /// \[ListDataStoresRequest.page_token\]\[google.cloud.discoveryengine.v1.ListDataStoresRequest.page_token\]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[DataStoreService.DeleteDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.DeleteDataStore\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDataStoreRequest {
    /// Required. Full resource name of
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}`.
    ///
    /// If the caller does not have permission to delete the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] to delete
    /// does not exist, a NOT_FOUND error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[DataStoreService.UpdateDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.UpdateDataStore\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataStoreRequest {
    /// Required. The \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] to
    /// update.
    ///
    /// If the caller does not have permission to update the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] to update
    /// does not exist, a NOT_FOUND error is returned.
    #[prost(message, optional, tag = "1")]
    pub data_store: ::core::option::Option<DataStore>,
    /// Indicates which fields in the provided
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] to update.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Metadata related to the progress of the
/// \[DataStoreService.DeleteDataStore\]\[google.cloud.discoveryengine.v1.DataStoreService.DeleteDataStore\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDataStoreMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod data_store_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]
    /// configuration.
    #[derive(Debug, Clone)]
    pub struct DataStoreServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataStoreServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataStoreServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataStoreServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataStoreServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        ///
        /// DataStore is for storing
        /// \[Documents\]\[google.cloud.discoveryengine.v1.Document\]. To serve these
        /// documents for Search, or Recommendation use case, an
        /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] needs to be created
        /// separately.
        pub async fn create_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/CreateDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "CreateDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn get_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStore>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/GetDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "GetDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s
        /// associated with the project.
        pub async fn list_data_stores(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataStoresRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataStoresResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/ListDataStores",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "ListDataStores",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn delete_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/DeleteDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "DeleteDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]
        pub async fn update_data_store(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataStoreRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStore>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DataStoreService/UpdateDataStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DataStoreService",
                        "UpdateDataStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for
/// \[DocumentService.GetDocument\]\[google.cloud.discoveryengine.v1.DocumentService.GetDocument\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDocumentRequest {
    /// Required. Full resource name of
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
    ///
    /// If the caller does not have permission to access the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// If the requested \[Document\]\[google.cloud.discoveryengine.v1.Document\] does
    /// not exist, a `NOT_FOUND` error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDocumentsRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    /// Use `default_branch` as the branch ID, to list documents under the default
    /// branch.
    ///
    /// If the caller does not have permission to list
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s under this branch,
    /// regardless of whether or not this branch exists, a `PERMISSION_DENIED`
    /// error is returned.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of \[Document\]\[google.cloud.discoveryengine.v1.Document\]s to
    /// return. If unspecified, defaults to 100. The maximum allowed value is 1000.
    /// Values above 1000 are set to 1000.
    ///
    /// If this field is negative, an `INVALID_ARGUMENT` error is returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token
    /// \[ListDocumentsResponse.next_page_token\]\[google.cloud.discoveryengine.v1.ListDocumentsResponse.next_page_token\],
    /// received from a previous
    /// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\]
    /// must match the call that provided the page token. Otherwise, an
    /// `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentsResponse {
    /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
    #[prost(message, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<Document>,
    /// A token that can be sent as
    /// \[ListDocumentsRequest.page_token\]\[google.cloud.discoveryengine.v1.ListDocumentsRequest.page_token\]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[DocumentService.CreateDocument\]\[google.cloud.discoveryengine.v1.DocumentService.CreateDocument\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The \[Document\]\[google.cloud.discoveryengine.v1.Document\] to
    /// create.
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    /// Required. The ID to use for the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], which becomes the
    /// final component of the
    /// \[Document.name\]\[google.cloud.discoveryengine.v1.Document.name\].
    ///
    /// If the caller does not have permission to create the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// This field must be unique among all
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s with the same
    /// \[parent\]\[google.cloud.discoveryengine.v1.CreateDocumentRequest.parent\].
    /// Otherwise, an `ALREADY_EXISTS` error is returned.
    ///
    /// This field must conform to [RFC-1034](<https://tools.ietf.org/html/rfc1034>)
    /// standard with a length limit of 128 characters. Otherwise, an
    /// `INVALID_ARGUMENT` error is returned.
    #[prost(string, tag = "3")]
    pub document_id: ::prost::alloc::string::String,
}
/// Request message for
/// \[DocumentService.UpdateDocument\]\[google.cloud.discoveryengine.v1.DocumentService.UpdateDocument\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    /// Required. The document to update/create.
    ///
    /// If the caller does not have permission to update the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// If the \[Document\]\[google.cloud.discoveryengine.v1.Document\] to update does
    /// not exist and
    /// \[allow_missing\]\[google.cloud.discoveryengine.v1.UpdateDocumentRequest.allow_missing\]
    /// is not set, a `NOT_FOUND` error is returned.
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    /// If set to `true` and the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\] is not found, a new
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\] is be created.
    #[prost(bool, tag = "2")]
    pub allow_missing: bool,
    /// Indicates which fields in the provided imported 'document' to update. If
    /// not set, by default updates all fields.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for
/// \[DocumentService.DeleteDocument\]\[google.cloud.discoveryengine.v1.DocumentService.DeleteDocument\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDocumentRequest {
    /// Required. Full resource name of
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}/documents/{document}`.
    ///
    /// If the caller does not have permission to delete the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\], regardless of whether
    /// or not it exists, a `PERMISSION_DENIED` error is returned.
    ///
    /// If the \[Document\]\[google.cloud.discoveryengine.v1.Document\] to delete does
    /// not exist, a `NOT_FOUND` error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[DocumentService.BatchGetDocumentsMetadata\]\[google.cloud.discoveryengine.v1.DocumentService.BatchGetDocumentsMetadata\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchGetDocumentsMetadataRequest {
    /// Required. The parent branch resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/branches/{branch}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Matcher for the
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
    #[prost(message, optional, tag = "2")]
    pub matcher: ::core::option::Option<batch_get_documents_metadata_request::Matcher>,
}
/// Nested message and enum types in `BatchGetDocumentsMetadataRequest`.
pub mod batch_get_documents_metadata_request {
    /// Matcher for the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s by
    /// exact uris.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UrisMatcher {
        /// The exact URIs to match by.
        #[prost(string, repeated, tag = "1")]
        pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Matcher for the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s by
    /// FHIR resource names.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FhirMatcher {
        /// Required. The FHIR resources to match by.
        /// Format:
        /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
        #[prost(string, repeated, tag = "1")]
        pub fhir_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Matcher for the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
    /// Currently supports matching by exact URIs.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Matcher {
        /// Matcher for the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
        #[prost(oneof = "matcher::Matcher", tags = "1, 2")]
        pub matcher: ::core::option::Option<matcher::Matcher>,
    }
    /// Nested message and enum types in `Matcher`.
    pub mod matcher {
        /// Matcher for the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Matcher {
            /// Matcher by exact URIs.
            #[prost(message, tag = "1")]
            UrisMatcher(super::UrisMatcher),
            /// Matcher by FHIR resource names.
            #[prost(message, tag = "2")]
            FhirMatcher(super::FhirMatcher),
        }
    }
}
/// Response message for
/// \[DocumentService.BatchGetDocumentsMetadata\]\[google.cloud.discoveryengine.v1.DocumentService.BatchGetDocumentsMetadata\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetDocumentsMetadataResponse {
    /// The metadata of the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
    #[prost(message, repeated, tag = "1")]
    pub documents_metadata: ::prost::alloc::vec::Vec<
        batch_get_documents_metadata_response::DocumentMetadata,
    >,
}
/// Nested message and enum types in `BatchGetDocumentsMetadataResponse`.
pub mod batch_get_documents_metadata_response {
    /// The metadata of a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DocumentMetadata {
        /// The value of the matcher that was used to match the
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        #[prost(message, optional, tag = "2")]
        pub matcher_value: ::core::option::Option<document_metadata::MatcherValue>,
        /// The state of the document.
        #[prost(enumeration = "State", tag = "3")]
        pub state: i32,
        /// The timestamp of the last time the
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\] was last indexed.
        #[prost(message, optional, tag = "4")]
        pub last_refreshed_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The data ingestion source of the
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        ///
        /// Allowed values are:
        ///
        /// * `batch`: Data ingested via Batch API, e.g., ImportDocuments.
        /// * `streaming` Data ingested via Streaming API, e.g., FHIR streaming.
        #[prost(string, tag = "5")]
        pub data_ingestion_source: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `DocumentMetadata`.
    pub mod document_metadata {
        /// The value of the matcher that was used to match the
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MatcherValue {
            /// The value of the matcher that was used to match the
            /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
            #[prost(oneof = "matcher_value::MatcherValue", tags = "1, 2")]
            pub matcher_value: ::core::option::Option<matcher_value::MatcherValue>,
        }
        /// Nested message and enum types in `MatcherValue`.
        pub mod matcher_value {
            /// The value of the matcher that was used to match the
            /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum MatcherValue {
                /// If match by URI, the URI of the
                /// \[Document\]\[google.cloud.discoveryengine.v1.Document\].
                #[prost(string, tag = "1")]
                Uri(::prost::alloc::string::String),
                /// Format:
                /// projects/{project}/locations/{location}/datasets/{dataset}/fhirStores/{fhir_store}/fhir/{resource_type}/{fhir_resource_id}
                #[prost(string, tag = "2")]
                FhirResource(::prost::alloc::string::String),
            }
        }
    }
    /// The state of the \[Document\]\[google.cloud.discoveryengine.v1.Document\].
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Should never be set.
        Unspecified = 0,
        /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\] is indexed.
        Indexed = 1,
        /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\] is not indexed
        /// because its URI is not in the
        /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        NotInTargetSite = 2,
        /// The \[Document\]\[google.cloud.discoveryengine.v1.Document\] is not indexed.
        NotInIndex = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Indexed => "INDEXED",
                Self::NotInTargetSite => "NOT_IN_TARGET_SITE",
                Self::NotInIndex => "NOT_IN_INDEX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INDEXED" => Some(Self::Indexed),
                "NOT_IN_TARGET_SITE" => Some(Self::NotInTargetSite),
                "NOT_IN_INDEX" => Some(Self::NotInIndex),
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod document_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for ingesting \[Document\]\[google.cloud.discoveryengine.v1.Document\]
    /// information of the customer's website.
    #[derive(Debug, Clone)]
    pub struct DocumentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DocumentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DocumentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DocumentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DocumentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn get_document(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/GetDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "GetDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of \[Document\]\[google.cloud.discoveryengine.v1.Document\]s.
        pub async fn list_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/ListDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "ListDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn create_document(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/CreateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "CreateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "UpdateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Document\]\[google.cloud.discoveryengine.v1.Document\].
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "DeleteDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of multiple
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s. Request processing
        /// may be synchronous. Non-existing items are created.
        ///
        /// Note: It is possible for a subset of the
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s to be successfully
        /// updated.
        pub async fn import_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/ImportDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "ImportDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Permanently deletes all selected
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s in a branch.
        ///
        /// This process is asynchronous. Depending on the number of
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s to be deleted, this
        /// operation can take hours to complete. Before the delete operation
        /// completes, some \[Document\]\[google.cloud.discoveryengine.v1.Document\]s might
        /// still be returned by
        /// \[DocumentService.GetDocument\]\[google.cloud.discoveryengine.v1.DocumentService.GetDocument\]
        /// or
        /// \[DocumentService.ListDocuments\]\[google.cloud.discoveryengine.v1.DocumentService.ListDocuments\].
        ///
        /// To get a list of the \[Document\]\[google.cloud.discoveryengine.v1.Document\]s
        /// to be deleted, set
        /// \[PurgeDocumentsRequest.force\]\[google.cloud.discoveryengine.v1.PurgeDocumentsRequest.force\]
        /// to false.
        pub async fn purge_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/PurgeDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "PurgeDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets index freshness metadata for
        /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s. Supported for
        /// website search only.
        pub async fn batch_get_documents_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetDocumentsMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetDocumentsMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.DocumentService/BatchGetDocumentsMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.DocumentService",
                        "BatchGetDocumentsMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Metadata that describes the training and serving parameters of an
/// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Engine {
    /// Immutable. Identifier. The fully qualified resource name of the engine.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
    /// engine should be 1-63 characters, and valid characters are
    /// /\[a-z0-9\]\[a-z0-9-\_\]\*/. Otherwise, an INVALID_ARGUMENT error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the engine. Should be human readable. UTF-8
    /// encoded string with limit of 1024 characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Timestamp the Recommendation Engine was created at.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp the Recommendation Engine was last updated.
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The data stores associated with this engine.
    ///
    /// For
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\]
    /// and
    /// \[SOLUTION_TYPE_RECOMMENDATION\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION\]
    /// type of engines, they can only associate with at most one data store.
    ///
    /// If \[solution_type\]\[google.cloud.discoveryengine.v1.Engine.solution_type\] is
    /// \[SOLUTION_TYPE_CHAT\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT\],
    /// multiple \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]s in the
    /// same \[Collection\]\[google.cloud.discoveryengine.v1.Collection\] can be
    /// associated here.
    ///
    /// Note that when used in
    /// \[CreateEngineRequest\]\[google.cloud.discoveryengine.v1.CreateEngineRequest\],
    /// one DataStore id must be provided as the system will use it for necessary
    /// initializations.
    #[prost(string, repeated, tag = "5")]
    pub data_store_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. The solutions of the engine.
    #[prost(enumeration = "SolutionType", tag = "6")]
    pub solution_type: i32,
    /// Optional. The industry vertical that the engine registers.
    /// The restriction of the Engine industry vertical is based on
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\]: Vertical on Engine
    /// has to match vertical of the DataStore linked to the engine.
    #[prost(enumeration = "IndustryVertical", tag = "16")]
    pub industry_vertical: i32,
    /// Common config spec that specifies the metadata of the engine.
    #[prost(message, optional, tag = "15")]
    pub common_config: ::core::option::Option<engine::CommonConfig>,
    /// Optional. Whether to disable analytics for searches performed on this
    /// engine.
    #[prost(bool, tag = "26")]
    pub disable_analytics: bool,
    /// Additional config specs that defines the behavior of the engine.
    #[prost(oneof = "engine::EngineConfig", tags = "11, 13, 14")]
    pub engine_config: ::core::option::Option<engine::EngineConfig>,
    /// Engine metadata to monitor the status of the engine.
    #[prost(oneof = "engine::EngineMetadata", tags = "12")]
    pub engine_metadata: ::core::option::Option<engine::EngineMetadata>,
}
/// Nested message and enum types in `Engine`.
pub mod engine {
    /// Configurations for a Search Engine.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SearchEngineConfig {
        /// The search feature tier of this engine.
        ///
        /// Different tiers might have different
        /// pricing. To learn more, check the pricing documentation.
        ///
        /// Defaults to
        /// \[SearchTier.SEARCH_TIER_STANDARD\]\[google.cloud.discoveryengine.v1.SearchTier.SEARCH_TIER_STANDARD\]
        /// if not specified.
        #[prost(enumeration = "super::SearchTier", tag = "1")]
        pub search_tier: i32,
        /// The add-on that this search engine enables.
        #[prost(enumeration = "super::SearchAddOn", repeated, tag = "2")]
        pub search_add_ons: ::prost::alloc::vec::Vec<i32>,
    }
    /// Additional config specs for a Media Recommendation engine.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MediaRecommendationEngineConfig {
        /// Required. The type of engine. e.g., `recommended-for-you`.
        ///
        /// This field together with
        /// \[optimization_objective\]\[google.cloud.discoveryengine.v1.Engine.MediaRecommendationEngineConfig.optimization_objective\]
        /// describe engine metadata to use to control engine training and serving.
        ///
        /// Currently supported values: `recommended-for-you`, `others-you-may-like`,
        /// `more-like-this`, `most-popular-items`.
        #[prost(string, tag = "1")]
        pub r#type: ::prost::alloc::string::String,
        /// The optimization objective. e.g., `cvr`.
        ///
        /// This field together with
        /// \[optimization_objective\]\[google.cloud.discoveryengine.v1.Engine.MediaRecommendationEngineConfig.type\]
        /// describe engine metadata to use to control engine training and serving.
        ///
        /// Currently supported
        /// values: `ctr`, `cvr`.
        ///
        /// If not specified, we choose default based on engine type.
        /// Default depends on type of recommendation:
        ///
        /// `recommended-for-you` => `ctr`
        ///
        /// `others-you-may-like` => `ctr`
        #[prost(string, tag = "2")]
        pub optimization_objective: ::prost::alloc::string::String,
        /// Name and value of the custom threshold for cvr optimization_objective.
        /// For target_field `watch-time`, target_field_value must be an integer
        /// value indicating the media progress time in seconds between (0, 86400\]
        /// (excludes 0, includes 86400) (e.g., 90).
        /// For target_field `watch-percentage`, the target_field_value must be a
        /// valid float value between (0, 1.0\] (excludes 0, includes 1.0) (e.g.,
        /// 0.5).
        #[prost(message, optional, tag = "3")]
        pub optimization_objective_config: ::core::option::Option<
            media_recommendation_engine_config::OptimizationObjectiveConfig,
        >,
        /// The training state that the engine is in (e.g.
        /// `TRAINING` or `PAUSED`).
        ///
        /// Since part of the cost of running the service
        /// is frequency of training - this can be used to determine when to train
        /// engine in order to control cost. If not specified: the default value for
        /// `CreateEngine` method is `TRAINING`. The default value for
        /// `UpdateEngine` method is to keep the state the same as before.
        #[prost(
            enumeration = "media_recommendation_engine_config::TrainingState",
            tag = "4"
        )]
        pub training_state: i32,
        /// Optional. Additional engine features config.
        #[prost(message, optional, tag = "5")]
        pub engine_features_config: ::core::option::Option<
            media_recommendation_engine_config::EngineFeaturesConfig,
        >,
    }
    /// Nested message and enum types in `MediaRecommendationEngineConfig`.
    pub mod media_recommendation_engine_config {
        /// Custom threshold for `cvr` optimization_objective.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct OptimizationObjectiveConfig {
            /// Required. The name of the field to target. Currently supported
            /// values: `watch-percentage`, `watch-time`.
            #[prost(string, tag = "1")]
            pub target_field: ::prost::alloc::string::String,
            /// Required. The threshold to be applied to the target (e.g., 0.5).
            #[prost(float, tag = "2")]
            pub target_field_value_float: f32,
        }
        /// More feature configs of the selected engine type.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EngineFeaturesConfig {
            /// Feature related configurations applied to a specific type of meida
            /// recommendation engines.
            #[prost(
                oneof = "engine_features_config::TypeDedicatedConfig",
                tags = "1, 2"
            )]
            pub type_dedicated_config: ::core::option::Option<
                engine_features_config::TypeDedicatedConfig,
            >,
        }
        /// Nested message and enum types in `EngineFeaturesConfig`.
        pub mod engine_features_config {
            /// Feature related configurations applied to a specific type of meida
            /// recommendation engines.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
            pub enum TypeDedicatedConfig {
                /// Recommended for you engine feature config.
                #[prost(message, tag = "1")]
                RecommendedForYouConfig(super::RecommendedForYouFeatureConfig),
                /// Most popular engine feature config.
                #[prost(message, tag = "2")]
                MostPopularConfig(super::MostPopularFeatureConfig),
            }
        }
        /// Additional feature configurations for creating a `recommended-for-you`
        /// engine.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct RecommendedForYouFeatureConfig {
            /// The type of event with which the engine is queried at prediction time.
            /// If set to `generic`, only `view-item`, `media-play`,and
            /// `media-complete` will be used as `context-event` in engine training. If
            /// set to `view-home-page`, `view-home-page` will also be used as
            /// `context-events` in addition to `view-item`, `media-play`, and
            /// `media-complete`. Currently supported for the `recommended-for-you`
            /// engine. Currently supported values: `view-home-page`, `generic`.
            #[prost(string, tag = "1")]
            pub context_event_type: ::prost::alloc::string::String,
        }
        /// Feature configurations that are required for creating a Most Popular
        /// engine.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MostPopularFeatureConfig {
            /// The time window of which the engine is queried at training and
            /// prediction time. Positive integers only. The value translates to the
            /// last X days of events. Currently required for the `most-popular-items`
            /// engine.
            #[prost(int64, tag = "1")]
            pub time_window_days: i64,
        }
        /// The training state of the engine.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TrainingState {
            /// Unspecified training state.
            Unspecified = 0,
            /// The engine training is paused.
            Paused = 1,
            /// The engine is training.
            Training = 2,
        }
        impl TrainingState {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TRAINING_STATE_UNSPECIFIED",
                    Self::Paused => "PAUSED",
                    Self::Training => "TRAINING",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TRAINING_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PAUSED" => Some(Self::Paused),
                    "TRAINING" => Some(Self::Training),
                    _ => None,
                }
            }
        }
    }
    /// Configurations for a Chat Engine.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChatEngineConfig {
        /// The configurationt generate the Dialogflow agent that is associated to
        /// this Engine.
        ///
        /// Note that these configurations are one-time consumed by
        /// and passed to Dialogflow service. It means they cannot be retrieved using
        /// \[EngineService.GetEngine\]\[google.cloud.discoveryengine.v1.EngineService.GetEngine\]
        /// or
        /// \[EngineService.ListEngines\]\[google.cloud.discoveryengine.v1.EngineService.ListEngines\]
        /// API after engine creation.
        #[prost(message, optional, tag = "1")]
        pub agent_creation_config: ::core::option::Option<
            chat_engine_config::AgentCreationConfig,
        >,
        /// The resource name of an exist Dialogflow agent to link to this Chat
        /// Engine. Customers can either provide `agent_creation_config` to create
        /// agent or provide an agent name that links the agent with the Chat engine.
        ///
        /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent  ID>`.
        ///
        /// Note that the `dialogflow_agent_to_link` are one-time consumed by and
        /// passed to Dialogflow service. It means they cannot be retrieved using
        /// \[EngineService.GetEngine\]\[google.cloud.discoveryengine.v1.EngineService.GetEngine\]
        /// or
        /// \[EngineService.ListEngines\]\[google.cloud.discoveryengine.v1.EngineService.ListEngines\]
        /// API after engine creation. Use
        /// \[ChatEngineMetadata.dialogflow_agent\]\[google.cloud.discoveryengine.v1.Engine.ChatEngineMetadata.dialogflow_agent\]
        /// for actual agent association after Engine is created.
        #[prost(string, tag = "2")]
        pub dialogflow_agent_to_link: ::prost::alloc::string::String,
        /// Optional. If the flag set to true, we allow the agent and engine are in
        /// different locations, otherwise the agent and engine are required to be in
        /// the same location. The flag is set to false by default.
        ///
        /// Note that the `allow_cross_region` are one-time consumed by and
        /// passed to
        /// \[EngineService.CreateEngine\]\[google.cloud.discoveryengine.v1.EngineService.CreateEngine\].
        /// It means they cannot be retrieved using
        /// \[EngineService.GetEngine\]\[google.cloud.discoveryengine.v1.EngineService.GetEngine\]
        /// or
        /// \[EngineService.ListEngines\]\[google.cloud.discoveryengine.v1.EngineService.ListEngines\]
        /// API after engine creation.
        #[prost(bool, tag = "3")]
        pub allow_cross_region: bool,
    }
    /// Nested message and enum types in `ChatEngineConfig`.
    pub mod chat_engine_config {
        /// Configurations for generating a Dialogflow agent.
        ///
        /// Note that these configurations are one-time consumed by
        /// and passed to Dialogflow service. It means they cannot be retrieved using
        /// \[EngineService.GetEngine\]\[google.cloud.discoveryengine.v1.EngineService.GetEngine\]
        /// or
        /// \[EngineService.ListEngines\]\[google.cloud.discoveryengine.v1.EngineService.ListEngines\]
        /// API after engine creation.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AgentCreationConfig {
            /// Name of the company, organization or other entity that the agent
            /// represents. Used for knowledge connector LLM prompt and for knowledge
            /// search.
            #[prost(string, tag = "1")]
            pub business: ::prost::alloc::string::String,
            /// Required. The default language of the agent as a language tag.
            /// See [Language
            /// Support](<https://cloud.google.com/dialogflow/docs/reference/language>)
            /// for a list of the currently supported language codes.
            #[prost(string, tag = "2")]
            pub default_language_code: ::prost::alloc::string::String,
            /// Required. The time zone of the agent from the [time zone
            /// database](<https://www.iana.org/time-zones>), e.g., America/New_York,
            /// Europe/Paris.
            #[prost(string, tag = "3")]
            pub time_zone: ::prost::alloc::string::String,
            /// Agent location for Agent creation, supported values: global/us/eu.
            /// If not provided, us Engine will create Agent using us-central-1 by
            /// default; eu Engine will create Agent using eu-west-1 by default.
            #[prost(string, tag = "4")]
            pub location: ::prost::alloc::string::String,
        }
    }
    /// Common configurations for an Engine.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CommonConfig {
        /// The name of the company, business or entity that is associated with the
        /// engine. Setting this may help improve LLM related features.
        #[prost(string, tag = "1")]
        pub company_name: ::prost::alloc::string::String,
    }
    /// Additional information of a Chat Engine.
    /// Fields in this message are output only.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ChatEngineMetadata {
        /// The resource name of a Dialogflow agent, that this Chat Engine refers
        /// to.
        ///
        /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent  ID>`.
        #[prost(string, tag = "1")]
        pub dialogflow_agent: ::prost::alloc::string::String,
    }
    /// Additional config specs that defines the behavior of the engine.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum EngineConfig {
        /// Configurations for the Chat Engine. Only applicable if
        /// \[solution_type\]\[google.cloud.discoveryengine.v1.Engine.solution_type\] is
        /// \[SOLUTION_TYPE_CHAT\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT\].
        #[prost(message, tag = "11")]
        ChatEngineConfig(ChatEngineConfig),
        /// Configurations for the Search Engine. Only applicable if
        /// \[solution_type\]\[google.cloud.discoveryengine.v1.Engine.solution_type\] is
        /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
        #[prost(message, tag = "13")]
        SearchEngineConfig(SearchEngineConfig),
        /// Configurations for the Media Engine. Only applicable on the data
        /// stores with
        /// \[solution_type\]\[google.cloud.discoveryengine.v1.Engine.solution_type\]
        /// \[SOLUTION_TYPE_RECOMMENDATION\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION\]
        /// and
        /// \[IndustryVertical.MEDIA\]\[google.cloud.discoveryengine.v1.IndustryVertical.MEDIA\]
        /// vertical.
        #[prost(message, tag = "14")]
        MediaRecommendationEngineConfig(MediaRecommendationEngineConfig),
    }
    /// Engine metadata to monitor the status of the engine.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum EngineMetadata {
        /// Output only. Additional information of the Chat Engine. Only applicable
        /// if \[solution_type\]\[google.cloud.discoveryengine.v1.Engine.solution_type\]
        /// is
        /// \[SOLUTION_TYPE_CHAT\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_CHAT\].
        #[prost(message, tag = "12")]
        ChatEngineMetadata(ChatEngineMetadata),
    }
}
/// Request for
/// \[EngineService.CreateEngine\]\[google.cloud.discoveryengine.v1.EngineService.CreateEngine\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEngineRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] to create.
    #[prost(message, optional, tag = "2")]
    pub engine: ::core::option::Option<Engine>,
    /// Required. The ID to use for the
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\], which will become the
    /// final component of the \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]'s
    /// resource name.
    ///
    /// This field must conform to [RFC-1034](<https://tools.ietf.org/html/rfc1034>)
    /// standard with a length limit of 63 characters. Otherwise, an
    /// INVALID_ARGUMENT error is returned.
    #[prost(string, tag = "3")]
    pub engine_id: ::prost::alloc::string::String,
}
/// Metadata related to the progress of the
/// \[EngineService.CreateEngine\]\[google.cloud.discoveryengine.v1.EngineService.CreateEngine\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateEngineMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[EngineService.DeleteEngine\]\[google.cloud.discoveryengine.v1.EngineService.DeleteEngine\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteEngineRequest {
    /// Required. Full resource name of
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    ///
    /// If the caller does not have permission to delete the
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\], regardless of whether or
    /// not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] to delete does not
    /// exist, a NOT_FOUND error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata related to the progress of the
/// \[EngineService.DeleteEngine\]\[google.cloud.discoveryengine.v1.EngineService.DeleteEngine\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteEngineMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[EngineService.GetEngine\]\[google.cloud.discoveryengine.v1.EngineService.GetEngine\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetEngineRequest {
    /// Required. Full resource name of
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\], such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[EngineService.ListEngines\]\[google.cloud.discoveryengine.v1.EngineService.ListEngines\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListEnginesRequest {
    /// Required. The parent resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Not supported.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. Not supported.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter by solution type. For example:
    /// solution_type=SOLUTION_TYPE_SEARCH
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Response message for
/// \[EngineService.ListEngines\]\[google.cloud.discoveryengine.v1.EngineService.ListEngines\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEnginesResponse {
    /// All the customer's \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]s.
    #[prost(message, repeated, tag = "1")]
    pub engines: ::prost::alloc::vec::Vec<Engine>,
    /// Not supported.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[EngineService.UpdateEngine\]\[google.cloud.discoveryengine.v1.EngineService.UpdateEngine\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEngineRequest {
    /// Required. The \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] to update.
    ///
    /// If the caller does not have permission to update the
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\], regardless of whether or
    /// not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] to update does not
    /// exist, a NOT_FOUND error is returned.
    #[prost(message, optional, tag = "1")]
    pub engine: ::core::option::Option<Engine>,
    /// Indicates which fields in the provided
    /// \[Engine\]\[google.cloud.discoveryengine.v1.Engine\] to update.
    ///
    /// If an unsupported or unknown field is provided, an INVALID_ARGUMENT error
    /// is returned.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod engine_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]
    /// configuration.
    #[derive(Debug, Clone)]
    pub struct EngineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EngineServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EngineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EngineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EngineServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
        pub async fn create_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEngineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/CreateEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "CreateEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
        pub async fn delete_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEngineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/DeleteEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "DeleteEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]
        pub async fn update_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEngineRequest>,
        ) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/UpdateEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "UpdateEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[Engine\]\[google.cloud.discoveryengine.v1.Engine\].
        pub async fn get_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEngineRequest>,
        ) -> std::result::Result<tonic::Response<super::Engine>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/GetEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "GetEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the \[Engine\]\[google.cloud.discoveryengine.v1.Engine\]s associated
        /// with the project.
        pub async fn list_engines(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEnginesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEnginesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.EngineService/ListEngines",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.EngineService",
                        "ListEngines",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Grounding Fact.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundingFact {
    /// Text content of the fact. Can be at most 10K characters long.
    #[prost(string, tag = "1")]
    pub fact_text: ::prost::alloc::string::String,
    /// Attributes associated with the fact.
    /// Common attributes include `source` (indicating where the fact was sourced
    /// from), `author` (indicating the author of the fact), and so on.
    #[prost(map = "string, string", tag = "2")]
    pub attributes: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Fact Chunk.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FactChunk {
    /// Text content of the fact chunk. Can be at most 10K characters long.
    #[prost(string, tag = "1")]
    pub chunk_text: ::prost::alloc::string::String,
    /// Source from which this fact chunk was retrieved. If it was retrieved
    /// from the GroundingFacts provided in the request then this field will
    /// contain the index of the specific fact from which this chunk was
    /// retrieved.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// The index of this chunk. Currently, only used for the streaming mode.
    #[prost(int32, tag = "4")]
    pub index: i32,
    /// More fine-grained information for the source reference.
    #[prost(map = "string, string", tag = "3")]
    pub source_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// The URI of the source.
    #[prost(string, tag = "5")]
    pub uri: ::prost::alloc::string::String,
    /// The title of the source.
    #[prost(string, tag = "6")]
    pub title: ::prost::alloc::string::String,
    /// The domain of the source.
    #[prost(string, tag = "7")]
    pub domain: ::prost::alloc::string::String,
}
/// Base structured datatype containing multi-part content of a message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroundedGenerationContent {
    /// Producer of the content. Must be either `user` or `model`.
    ///
    /// Intended to be used for multi-turn conversations. Otherwise, it can be left
    /// unset.
    #[prost(string, tag = "1")]
    pub role: ::prost::alloc::string::String,
    /// Ordered `Parts` that constitute a single message.
    #[prost(message, repeated, tag = "2")]
    pub parts: ::prost::alloc::vec::Vec<grounded_generation_content::Part>,
}
/// Nested message and enum types in `GroundedGenerationContent`.
pub mod grounded_generation_content {
    /// Single part of content.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Part {
        /// Holder of data. It only supports text for now.
        #[prost(oneof = "part::Data", tags = "1")]
        pub data: ::core::option::Option<part::Data>,
    }
    /// Nested message and enum types in `Part`.
    pub mod part {
        /// Holder of data. It only supports text for now.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Data {
            /// Inline text.
            #[prost(string, tag = "1")]
            Text(::prost::alloc::string::String),
        }
    }
}
/// Top-level message sent by the client for the `GenerateGroundedContent`
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateGroundedContentRequest {
    /// Required. Location resource.
    ///
    /// Format: `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub location: ::prost::alloc::string::String,
    /// Content of the system instruction for the current API.
    ///
    /// These instructions will take priority over any other prompt instructions
    /// if the selected model is supporting them.
    #[prost(message, optional, tag = "5")]
    pub system_instruction: ::core::option::Option<GroundedGenerationContent>,
    /// Content of the current conversation with the model.
    ///
    /// For single-turn queries, this is a single instance. For multi-turn queries,
    /// this is a repeated field that contains conversation history + latest
    /// request.
    #[prost(message, repeated, tag = "2")]
    pub contents: ::prost::alloc::vec::Vec<GroundedGenerationContent>,
    /// Content generation specification.
    #[prost(message, optional, tag = "3")]
    pub generation_spec: ::core::option::Option<
        generate_grounded_content_request::GenerationSpec,
    >,
    /// Grounding specification.
    #[prost(message, optional, tag = "4")]
    pub grounding_spec: ::core::option::Option<
        generate_grounded_content_request::GroundingSpec,
    >,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "6")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `GenerateGroundedContentRequest`.
pub mod generate_grounded_content_request {
    /// Content generation specification.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GenerationSpec {
        /// Specifies which Vertex model id to use for generation.
        #[prost(string, tag = "3")]
        pub model_id: ::prost::alloc::string::String,
        /// Language code for content. Use language tags defined by
        /// [BCP47](<https://www.rfc-editor.org/rfc/bcp/bcp47.txt>).
        #[prost(string, tag = "2")]
        pub language_code: ::prost::alloc::string::String,
        /// If specified, custom value for the temperature will be used.
        #[prost(float, optional, tag = "4")]
        pub temperature: ::core::option::Option<f32>,
        /// If specified, custom value for nucleus sampling will be used.
        #[prost(float, optional, tag = "5")]
        pub top_p: ::core::option::Option<f32>,
        /// If specified, custom value for top-k sampling will be used.
        #[prost(int32, optional, tag = "7")]
        pub top_k: ::core::option::Option<i32>,
        /// If specified, custom value for frequency penalty will be used.
        #[prost(float, optional, tag = "8")]
        pub frequency_penalty: ::core::option::Option<f32>,
        /// If specified, custom value for the seed will be used.
        #[prost(int32, optional, tag = "12")]
        pub seed: ::core::option::Option<i32>,
        /// If specified, custom value for presence penalty will be used.
        #[prost(float, optional, tag = "9")]
        pub presence_penalty: ::core::option::Option<f32>,
        /// If specified, custom value for max output tokens will be used.
        #[prost(int32, optional, tag = "10")]
        pub max_output_tokens: ::core::option::Option<i32>,
    }
    /// Describes the options to customize dynamic retrieval.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct DynamicRetrievalConfiguration {
        /// Specification for the predictor for dynamic retrieval.
        #[prost(message, optional, tag = "1")]
        pub predictor: ::core::option::Option<
            dynamic_retrieval_configuration::DynamicRetrievalPredictor,
        >,
    }
    /// Nested message and enum types in `DynamicRetrievalConfiguration`.
    pub mod dynamic_retrieval_configuration {
        /// Describes the predictor settings for dynamic retrieval.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct DynamicRetrievalPredictor {
            /// The version of the predictor to be used in dynamic retrieval.
            #[prost(enumeration = "dynamic_retrieval_predictor::Version", tag = "1")]
            pub version: i32,
            /// The value of the threshold. If the predictor will predict a
            /// value smaller than this, it would suppress grounding in the source.
            #[prost(float, optional, tag = "2")]
            pub threshold: ::core::option::Option<f32>,
        }
        /// Nested message and enum types in `DynamicRetrievalPredictor`.
        pub mod dynamic_retrieval_predictor {
            /// The version of the predictor to be used in dynamic retrieval.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Version {
                /// Automatically choose the best version of the retrieval predictor.
                Unspecified = 0,
                /// The V1 model which is evaluating each source independently.
                V1Independent = 1,
            }
            impl Version {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "VERSION_UNSPECIFIED",
                        Self::V1Independent => "V1_INDEPENDENT",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                        "V1_INDEPENDENT" => Some(Self::V1Independent),
                        _ => None,
                    }
                }
            }
        }
    }
    /// Grounding source.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroundingSource {
        /// Sources.
        #[prost(oneof = "grounding_source::Source", tags = "1, 2, 3, 8")]
        pub source: ::core::option::Option<grounding_source::Source>,
    }
    /// Nested message and enum types in `GroundingSource`.
    pub mod grounding_source {
        /// Message to be used for grounding based on inline content.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct InlineSource {
            /// List of facts to be used for grounding.
            #[prost(message, repeated, tag = "1")]
            pub grounding_facts: ::prost::alloc::vec::Vec<super::super::GroundingFact>,
            /// Attributes associated with the content.
            ///
            /// Common attributes include `source` (indicating where the content was
            /// sourced from) and `author` (indicating the author of the content).
            #[prost(map = "string, string", tag = "2")]
            pub attributes: ::std::collections::HashMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
        /// Message to be used for grounding with Vertex AI Search.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct SearchSource {
            /// The resource name of the Engine to use.
            ///
            /// Format:
            /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
            #[prost(string, tag = "1")]
            pub serving_config: ::prost::alloc::string::String,
            /// Number of search results to return.
            ///
            /// The default value is 10. The maximumm allowed value is 10.
            #[prost(int32, tag = "2")]
            pub max_result_count: i32,
            /// Filter expression to be applied to the search.
            ///
            /// The syntax is the same as
            /// \[SearchRequest.filter\]\[google.cloud.discoveryengine.v1.SearchRequest.filter\].
            #[prost(string, tag = "3")]
            pub filter: ::prost::alloc::string::String,
            /// If set, safe search is enabled in Vertex AI Search requests.
            #[prost(bool, tag = "5")]
            pub safe_search: bool,
        }
        /// Google Search config parameters.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct GoogleSearchSource {
            /// Optional. Specifies the dynamic retrieval configuration for the given
            /// source.
            #[prost(message, optional, tag = "2")]
            pub dynamic_retrieval_config: ::core::option::Option<
                super::DynamicRetrievalConfiguration,
            >,
        }
        /// Params for using enterprise web retrieval as grounding source.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct EnterpriseWebRetrievalSource {}
        /// Sources.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Source {
            /// If set, grounding is performed with inline content.
            #[prost(message, tag = "1")]
            InlineSource(InlineSource),
            /// If set, grounding is performed with Vertex AI Search.
            #[prost(message, tag = "2")]
            SearchSource(SearchSource),
            /// If set, grounding is performed with Google Search.
            #[prost(message, tag = "3")]
            GoogleSearchSource(GoogleSearchSource),
            /// If set, grounding is performed with enterprise web retrieval.
            #[prost(message, tag = "8")]
            EnterpriseWebRetrievalSource(EnterpriseWebRetrievalSource),
        }
    }
    /// Grounding specification.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GroundingSpec {
        /// Grounding sources.
        #[prost(message, repeated, tag = "1")]
        pub grounding_sources: ::prost::alloc::vec::Vec<GroundingSource>,
    }
}
/// Response for the `GenerateGroundedContent` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenerateGroundedContentResponse {
    /// Generated candidates.
    #[prost(message, repeated, tag = "1")]
    pub candidates: ::prost::alloc::vec::Vec<
        generate_grounded_content_response::Candidate,
    >,
}
/// Nested message and enum types in `GenerateGroundedContentResponse`.
pub mod generate_grounded_content_response {
    /// A response candidate generated from the model.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Candidate {
        /// Index of the candidate.
        #[prost(int32, tag = "1")]
        pub index: i32,
        /// Content of the candidate.
        #[prost(message, optional, tag = "2")]
        pub content: ::core::option::Option<super::GroundedGenerationContent>,
        /// The overall grounding score for the candidate, in the range of \[0, 1\].
        #[prost(float, optional, tag = "3")]
        pub grounding_score: ::core::option::Option<f32>,
        /// Grounding metadata for the generated content.
        #[prost(message, optional, tag = "4")]
        pub grounding_metadata: ::core::option::Option<candidate::GroundingMetadata>,
    }
    /// Nested message and enum types in `Candidate`.
    pub mod candidate {
        /// Citation for the generated content.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GroundingMetadata {
            /// Retrieval metadata to provide an understanding in the
            /// retrieval steps performed by the model. There can be multiple such
            /// messages which can correspond to different parts of the retrieval. This
            /// is a mechanism used to ensure transparency to our users.
            #[prost(message, repeated, tag = "5")]
            pub retrieval_metadata: ::prost::alloc::vec::Vec<
                grounding_metadata::RetrievalMetadata,
            >,
            /// List of chunks to be attributed across all claims in the candidate.
            /// These are derived from the grounding sources supplied in the request.
            #[prost(message, repeated, tag = "1")]
            pub support_chunks: ::prost::alloc::vec::Vec<super::super::FactChunk>,
            /// Web search queries for the following-up web search.
            #[prost(string, repeated, tag = "3")]
            pub web_search_queries: ::prost::alloc::vec::Vec<
                ::prost::alloc::string::String,
            >,
            /// Google search entry for the following-up web searches.
            #[prost(message, optional, tag = "4")]
            pub search_entry_point: ::core::option::Option<
                grounding_metadata::SearchEntryPoint,
            >,
            /// GroundingSupport across all claims in the answer candidate.
            /// An support to a fact indicates that the claim is supported by
            /// the fact.
            #[prost(message, repeated, tag = "2")]
            pub grounding_support: ::prost::alloc::vec::Vec<
                grounding_metadata::GroundingSupport,
            >,
            /// Images from the web search.
            #[prost(message, repeated, tag = "9")]
            pub images: ::prost::alloc::vec::Vec<grounding_metadata::ImageMetadata>,
        }
        /// Nested message and enum types in `GroundingMetadata`.
        pub mod grounding_metadata {
            /// Describes the metadata associated with a retrieval step.
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct RetrievalMetadata {
                /// Describes the source to which the metadata is referring to.
                #[prost(enumeration = "retrieval_metadata::Source", tag = "1")]
                pub source: i32,
                /// Metadata for dynamic retrieval.
                #[prost(message, optional, tag = "2")]
                pub dynamic_retrieval_metadata: ::core::option::Option<
                    DynamicRetrievalMetadata,
                >,
            }
            /// Nested message and enum types in `RetrievalMetadata`.
            pub mod retrieval_metadata {
                /// Describes the source to which the metadata is associated to.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Source {
                    /// Unspecified source.
                    Unspecified = 0,
                    /// Vertex AI search.
                    VertexAiSearch = 1,
                    /// Google Search.
                    GoogleSearch = 3,
                    /// User inline provided content.
                    InlineContent = 2,
                    /// Google Maps.
                    GoogleMaps = 4,
                }
                impl Source {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "SOURCE_UNSPECIFIED",
                            Self::VertexAiSearch => "VERTEX_AI_SEARCH",
                            Self::GoogleSearch => "GOOGLE_SEARCH",
                            Self::InlineContent => "INLINE_CONTENT",
                            Self::GoogleMaps => "GOOGLE_MAPS",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                            "VERTEX_AI_SEARCH" => Some(Self::VertexAiSearch),
                            "GOOGLE_SEARCH" => Some(Self::GoogleSearch),
                            "INLINE_CONTENT" => Some(Self::InlineContent),
                            "GOOGLE_MAPS" => Some(Self::GoogleMaps),
                            _ => None,
                        }
                    }
                }
            }
            /// Describes the metadata about dynamic retrieval.
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct DynamicRetrievalMetadata {
                /// Metadata for the dynamic retrieval predictor.
                #[prost(message, optional, tag = "1")]
                pub predictor_metadata: ::core::option::Option<
                    DynamicRetrievalPredictorMetadata,
                >,
            }
            /// Describes the metadata about the dynamic retrieval predictor.
            #[derive(Clone, Copy, PartialEq, ::prost::Message)]
            pub struct DynamicRetrievalPredictorMetadata {
                /// The version of the predictor which was used in dynamic retrieval.
                #[prost(
                    enumeration = "dynamic_retrieval_predictor_metadata::Version",
                    tag = "1"
                )]
                pub version: i32,
                /// The value of the predictor. This should be between \[0, 1\] where
                /// a value of 0 means that the query would not benefit from grounding,
                /// while a value of 1.0 means that the query would benefit the most.
                /// In between values allow to differentiate between different usefulness
                /// scores for grounding.
                #[prost(float, optional, tag = "2")]
                pub prediction: ::core::option::Option<f32>,
            }
            /// Nested message and enum types in `DynamicRetrievalPredictorMetadata`.
            pub mod dynamic_retrieval_predictor_metadata {
                /// The version of the predictor which was used in dynamic retrieval.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum Version {
                    /// Unspecified version, should never be used.
                    Unspecified = 0,
                    /// The V1 model which is evaluating each source independently.
                    V1Independent = 1,
                }
                impl Version {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "VERSION_UNSPECIFIED",
                            Self::V1Independent => "V1_INDEPENDENT",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                            "V1_INDEPENDENT" => Some(Self::V1Independent),
                            _ => None,
                        }
                    }
                }
            }
            /// Google search entry point.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct SearchEntryPoint {
                /// Web content snippet that can be embedded in a web page or an app
                /// webview.
                #[prost(string, tag = "1")]
                pub rendered_content: ::prost::alloc::string::String,
                /// Base64 encoded JSON representing array of \<search term, search url>
                /// tuple.
                #[prost(bytes = "vec", tag = "2")]
                pub sdk_blob: ::prost::alloc::vec::Vec<u8>,
            }
            /// Grounding info for a claim in the candidate and its support.
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct GroundingSupport {
                /// Text for the claim in the candidate. Always provided when a
                /// support is found.
                #[prost(string, tag = "1")]
                pub claim_text: ::prost::alloc::string::String,
                /// A list of indices (into 'support_chunks') specifying the
                /// citations associated with the claim. For instance \[1,3,4\] means
                /// that support_chunks\[1\], support_chunks\[3\],
                /// support_chunks\[4\] are the chunks attributed to the claim.
                #[prost(int32, repeated, tag = "3")]
                pub support_chunk_indices: ::prost::alloc::vec::Vec<i32>,
                /// A score in the range of \[0, 1\] describing how grounded is a specific
                /// claim in the support chunks indicated.
                /// Higher value means that the claim is better supported by the chunks.
                #[prost(float, optional, tag = "2")]
                pub support_score: ::core::option::Option<f32>,
            }
            /// Metadata about an image from the web search.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct ImageMetadata {
                /// Metadata about the full size image.
                #[prost(message, optional, tag = "1")]
                pub image: ::core::option::Option<image_metadata::Image>,
                /// Metadata about the thumbnail.
                #[prost(message, optional, tag = "2")]
                pub thumbnail: ::core::option::Option<image_metadata::Image>,
                /// The details about the website that the image is from.
                #[prost(message, optional, tag = "3")]
                pub source: ::core::option::Option<image_metadata::WebsiteInfo>,
            }
            /// Nested message and enum types in `ImageMetadata`.
            pub mod image_metadata {
                /// Metadata about the website that the image is from.
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct WebsiteInfo {
                    /// The url of the website.
                    #[prost(string, tag = "1")]
                    pub uri: ::prost::alloc::string::String,
                    /// The title of the website.
                    #[prost(string, tag = "2")]
                    pub title: ::prost::alloc::string::String,
                }
                /// Metadata about the image.
                #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
                pub struct Image {
                    /// The url of the image.
                    #[prost(string, tag = "1")]
                    pub uri: ::prost::alloc::string::String,
                    /// The width of the image in pixels.
                    #[prost(int32, tag = "2")]
                    pub width: i32,
                    /// The height of the image in pixels.
                    #[prost(int32, tag = "3")]
                    pub height: i32,
                }
            }
        }
    }
}
/// Specification for the grounding check.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CheckGroundingSpec {
    /// The threshold (in \[0,1\]) used for determining whether a fact must be
    /// cited for a claim in the answer candidate. Choosing a higher threshold
    /// will lead to fewer but very strong citations, while choosing a lower
    /// threshold may lead to more but somewhat weaker citations. If unset, the
    /// threshold will default to 0.6.
    #[prost(double, optional, tag = "1")]
    pub citation_threshold: ::core::option::Option<f64>,
    /// The control flag that enables claim-level grounding score in the response.
    #[prost(bool, optional, tag = "4")]
    pub enable_claim_level_score: ::core::option::Option<bool>,
}
/// Request message for
/// \[GroundedGenerationService.CheckGrounding\]\[google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroundingRequest {
    /// Required. The resource name of the grounding config, such as
    /// `projects/*/locations/global/groundingConfigs/default_grounding_config`.
    #[prost(string, tag = "1")]
    pub grounding_config: ::prost::alloc::string::String,
    /// Answer candidate to check. It can have a maximum length of 4096 tokens.
    #[prost(string, tag = "2")]
    pub answer_candidate: ::prost::alloc::string::String,
    /// List of facts for the grounding check.
    /// We support up to 200 facts.
    #[prost(message, repeated, tag = "3")]
    pub facts: ::prost::alloc::vec::Vec<GroundingFact>,
    /// Configuration of the grounding check.
    #[prost(message, optional, tag = "4")]
    pub grounding_spec: ::core::option::Option<CheckGroundingSpec>,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "5")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Response message for the
/// \[GroundedGenerationService.CheckGrounding\]\[google.cloud.discoveryengine.v1.GroundedGenerationService.CheckGrounding\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckGroundingResponse {
    /// The support score for the input answer candidate.
    /// Higher the score, higher is the fraction of claims that are supported by
    /// the provided facts. This is always set when a response is returned.
    #[prost(float, optional, tag = "1")]
    pub support_score: ::core::option::Option<f32>,
    /// List of facts cited across all claims in the answer candidate.
    /// These are derived from the facts supplied in the request.
    #[prost(message, repeated, tag = "3")]
    pub cited_chunks: ::prost::alloc::vec::Vec<FactChunk>,
    /// List of facts cited across all claims in the answer candidate.
    /// These are derived from the facts supplied in the request.
    #[prost(message, repeated, tag = "6")]
    pub cited_facts: ::prost::alloc::vec::Vec<
        check_grounding_response::CheckGroundingFactChunk,
    >,
    /// Claim texts and citation info across all claims in the answer candidate.
    #[prost(message, repeated, tag = "4")]
    pub claims: ::prost::alloc::vec::Vec<check_grounding_response::Claim>,
}
/// Nested message and enum types in `CheckGroundingResponse`.
pub mod check_grounding_response {
    /// Fact chunk for grounding check.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CheckGroundingFactChunk {
        /// Text content of the fact chunk. Can be at most 10K characters long.
        #[prost(string, tag = "1")]
        pub chunk_text: ::prost::alloc::string::String,
    }
    /// Text and citation info for a claim in the answer candidate.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Claim {
        /// Position indicating the start of the claim in the answer candidate,
        /// measured in bytes. Note that this is not measured in characters and,
        /// therefore, must be rendered in the user interface keeping in mind that
        /// some characters may take more than one byte. For example,
        /// if the claim text contains non-ASCII characters, the start and end
        /// positions vary when measured in characters
        /// (programming-language-dependent) and when measured in bytes
        /// (programming-language-independent).
        #[prost(int32, optional, tag = "1")]
        pub start_pos: ::core::option::Option<i32>,
        /// Position indicating the end of the claim in the answer candidate,
        /// exclusive, in bytes. Note that this is not measured in characters and,
        /// therefore, must be rendered as such. For example, if the claim text
        /// contains non-ASCII characters, the start and end positions vary when
        /// measured in characters (programming-language-dependent) and when measured
        /// in bytes (programming-language-independent).
        #[prost(int32, optional, tag = "2")]
        pub end_pos: ::core::option::Option<i32>,
        /// Text for the claim in the answer candidate. Always provided regardless of
        /// whether citations or anti-citations are found.
        #[prost(string, tag = "3")]
        pub claim_text: ::prost::alloc::string::String,
        /// A list of indices (into 'cited_chunks') specifying the citations
        /// associated with the claim. For instance \[1,3,4\] means that
        /// cited_chunks\[1\], cited_chunks\[3\], cited_chunks\[4\] are the facts cited
        /// supporting for the claim. A citation to a fact indicates that the claim
        /// is supported by the fact.
        #[prost(int32, repeated, tag = "4")]
        pub citation_indices: ::prost::alloc::vec::Vec<i32>,
        /// Indicates that this claim required grounding check. When the system
        /// decided this claim doesn't require attribution/grounding check, this
        /// field will be set to false. In that case, no grounding check was done for
        /// the claim and therefore
        /// \[citation_indices\]\[google.cloud.discoveryengine.v1.CheckGroundingResponse.Claim.citation_indices\]
        /// should not be returned.
        #[prost(bool, optional, tag = "6")]
        pub grounding_check_required: ::core::option::Option<bool>,
        /// Confidence score for the claim in the answer candidate, in the range of
        /// \[0, 1\]. This is set only when
        /// `CheckGroundingRequest.grounding_spec.enable_claim_level_score` is true.
        #[prost(double, optional, tag = "7")]
        pub score: ::core::option::Option<f64>,
    }
}
/// Generated client implementations.
pub mod grounded_generation_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for grounded generation.
    #[derive(Debug, Clone)]
    pub struct GroundedGenerationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GroundedGenerationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GroundedGenerationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GroundedGenerationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GroundedGenerationServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Generates grounded content in a streaming fashion.
        pub async fn stream_generate_grounded_content(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::GenerateGroundedContentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::GenerateGroundedContentResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.GroundedGenerationService/StreamGenerateGroundedContent",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.GroundedGenerationService",
                        "StreamGenerateGroundedContent",
                    ),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Generates grounded content.
        pub async fn generate_grounded_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateGroundedContentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GenerateGroundedContentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.GroundedGenerationService/GenerateGroundedContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.GroundedGenerationService",
                        "GenerateGroundedContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Performs a grounding check.
        pub async fn check_grounding(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckGroundingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckGroundingResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.GroundedGenerationService/CheckGrounding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.GroundedGenerationService",
                        "CheckGrounding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Identity Mapping Store which contains Identity Mapping Entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IdentityMappingStore {
    /// Immutable. The full resource name of the identity mapping store.
    /// Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identity_mapping_store}`.
    /// This field must be a UTF-8 encoded string with a length limit of 1024
    /// characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Input only. The KMS key to be used to protect this Identity Mapping Store
    /// at creation time.
    ///
    /// Must be set for requests that need to comply with CMEK Org Policy
    /// protections.
    ///
    /// If this field is set and processed successfully, the Identity Mapping Store
    /// will be protected by the KMS key, as indicated in the cmek_config field.
    #[prost(string, tag = "3")]
    pub kms_key_name: ::prost::alloc::string::String,
    /// Output only. CMEK-related information for the Identity Mapping Store.
    #[prost(message, optional, tag = "4")]
    pub cmek_config: ::core::option::Option<CmekConfig>,
}
/// Identity Mapping Entry that maps an external identity to an internal
/// identity.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdentityMappingEntry {
    /// Required. Identity outside the customer identity provider.
    /// The length limit of external identity will be of 100 characters.
    #[prost(string, tag = "1")]
    pub external_identity: ::prost::alloc::string::String,
    /// Union field identity_provider_id. Identity Provider id can be a user or a
    /// group.
    #[prost(oneof = "identity_mapping_entry::IdentityProviderId", tags = "2, 3")]
    pub identity_provider_id: ::core::option::Option<
        identity_mapping_entry::IdentityProviderId,
    >,
}
/// Nested message and enum types in `IdentityMappingEntry`.
pub mod identity_mapping_entry {
    /// Union field identity_provider_id. Identity Provider id can be a user or a
    /// group.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum IdentityProviderId {
        /// User identifier.
        /// For Google Workspace user account, user_id should be the google workspace
        /// user email.
        /// For non-google identity provider, user_id is the mapped user identifier
        /// configured during the workforcepool config.
        #[prost(string, tag = "2")]
        UserId(::prost::alloc::string::String),
        /// Group identifier.
        /// For Google Workspace user account, group_id should be the google
        /// workspace group email.
        /// For non-google identity provider, group_id is the mapped group identifier
        /// configured during the workforcepool config.
        #[prost(string, tag = "3")]
        GroupId(::prost::alloc::string::String),
    }
}
/// Request message for
/// \[IdentityMappingStoreService.CreateIdentityMappingStore\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.CreateIdentityMappingStore\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIdentityMappingStoreRequest {
    /// Required. The parent collection resource name, such as
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID of the Identity Mapping Store to create.
    ///
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), underscores
    /// (\_), and hyphens (-). The maximum length is 63 characters.
    #[prost(string, tag = "2")]
    pub identity_mapping_store_id: ::prost::alloc::string::String,
    /// Required. The Identity Mapping Store to create.
    #[prost(message, optional, tag = "3")]
    pub identity_mapping_store: ::core::option::Option<IdentityMappingStore>,
    /// CMEK options for the Identity Mapping Store. Setting this field will
    /// override the default CmekConfig if one is set for the project.
    #[prost(oneof = "create_identity_mapping_store_request::CmekOptions", tags = "5, 6")]
    pub cmek_options: ::core::option::Option<
        create_identity_mapping_store_request::CmekOptions,
    >,
}
/// Nested message and enum types in `CreateIdentityMappingStoreRequest`.
pub mod create_identity_mapping_store_request {
    /// CMEK options for the Identity Mapping Store. Setting this field will
    /// override the default CmekConfig if one is set for the project.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum CmekOptions {
        /// Resource name of the CmekConfig to use for protecting this Identity
        /// Mapping Store.
        #[prost(string, tag = "5")]
        CmekConfigName(::prost::alloc::string::String),
        /// Identity Mapping Store without CMEK protections. If a default CmekConfig
        /// is set for the project, setting this field will override the default
        /// CmekConfig as well.
        #[prost(bool, tag = "6")]
        DisableCmek(bool),
    }
}
/// Request message for
/// \[IdentityMappingStoreService.GetIdentityMappingStore\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.GetIdentityMappingStore\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIdentityMappingStoreRequest {
    /// Required. The name of the Identity Mapping Store to get.
    /// Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[IdentityMappingStoreService.DeleteIdentityMappingStore\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.DeleteIdentityMappingStore\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIdentityMappingStoreRequest {
    /// Required. The name of the Identity Mapping Store to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[IdentityMappingStoreService.ImportIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ImportIdentityMappings\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportIdentityMappingsRequest {
    /// Required. The name of the Identity Mapping Store to import Identity Mapping
    /// Entries to. Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
    #[prost(string, tag = "1")]
    pub identity_mapping_store: ::prost::alloc::string::String,
    /// The source of the input.
    #[prost(oneof = "import_identity_mappings_request::Source", tags = "2")]
    pub source: ::core::option::Option<import_identity_mappings_request::Source>,
}
/// Nested message and enum types in `ImportIdentityMappingsRequest`.
pub mod import_identity_mappings_request {
    /// The inline source to import identity mapping entries from.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// A maximum of 10000 entries can be imported at one time
        #[prost(message, repeated, tag = "1")]
        pub identity_mapping_entries: ::prost::alloc::vec::Vec<
            super::IdentityMappingEntry,
        >,
    }
    /// The source of the input.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The inline source to import identity mapping entries from.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
    }
}
/// Response message for
/// \[IdentityMappingStoreService.ImportIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ImportIdentityMappings\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportIdentityMappingsResponse {
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// Request message for
/// \[IdentityMappingStoreService.PurgeIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.PurgeIdentityMappings\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PurgeIdentityMappingsRequest {
    /// Required. The name of the Identity Mapping Store to purge Identity Mapping
    /// Entries from. Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
    #[prost(string, tag = "1")]
    pub identity_mapping_store: ::prost::alloc::string::String,
    /// Filter matching identity mappings to purge.
    /// The eligible field for filtering is:
    ///
    /// * `update_time`: in ISO 8601 "zulu" format.
    /// * `external_id`
    ///
    /// Examples:
    ///
    /// * Deleting all identity mappings updated in a time range:
    ///   `update_time > "2012-04-23T18:25:43.511Z" AND update_time < "2012-04-23T18:30:43.511Z"`
    /// * Deleting all identity mappings for a given external_id:
    ///   `external_id = "id1"`
    /// * Deleting all identity mappings inside an identity mapping store:
    ///   `*`
    ///
    /// The filtering fields are assumed to have an implicit AND.
    /// Should not be used with source. An error will be thrown, if both are
    /// provided.
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
    /// Actually performs the purge. If `force` is set to false, return the
    /// expected purge count without deleting any identity mappings. This field is
    /// only supported for purge with filter. For input source this field is
    /// ignored and data will be purged regardless of the value of this field.
    #[prost(bool, optional, tag = "4")]
    pub force: ::core::option::Option<bool>,
    /// The source of the input.
    #[prost(oneof = "purge_identity_mappings_request::Source", tags = "2")]
    pub source: ::core::option::Option<purge_identity_mappings_request::Source>,
}
/// Nested message and enum types in `PurgeIdentityMappingsRequest`.
pub mod purge_identity_mappings_request {
    /// The inline source to purge identity mapping entries from.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// A maximum of 10000 entries can be purged at one time
        #[prost(message, repeated, tag = "1")]
        pub identity_mapping_entries: ::prost::alloc::vec::Vec<
            super::IdentityMappingEntry,
        >,
    }
    /// The source of the input.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The inline source to purge identity mapping entries from.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
    }
}
/// Request message for
/// \[IdentityMappingStoreService.ListIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ListIdentityMappings\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIdentityMappingsRequest {
    /// Required. The name of the Identity Mapping Store to list Identity Mapping
    /// Entries in. Format:
    /// `projects/{project}/locations/{location}/identityMappingStores/{identityMappingStore}`
    #[prost(string, tag = "1")]
    pub identity_mapping_store: ::prost::alloc::string::String,
    /// Maximum number of IdentityMappings to return. If unspecified, defaults
    /// to 2000. The maximum allowed value is 10000. Values above 10000 will be
    /// coerced to 10000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListIdentityMappings` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListIdentityMappings` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[IdentityMappingStoreService.ListIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ListIdentityMappings\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIdentityMappingsResponse {
    /// The Identity Mapping Entries.
    #[prost(message, repeated, tag = "1")]
    pub identity_mapping_entries: ::prost::alloc::vec::Vec<IdentityMappingEntry>,
    /// A token that can be sent as `page_token` to retrieve the next page. If this
    /// field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[IdentityMappingStoreService.ListIdentityMappingStores\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ListIdentityMappingStores\]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIdentityMappingStoresRequest {
    /// Required. The parent of the Identity Mapping Stores to list.
    /// Format:
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Maximum number of IdentityMappingStores to return. If unspecified, defaults
    /// to 100. The maximum allowed value is 1000. Values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListIdentityMappingStores` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListIdentityMappingStores` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[IdentityMappingStoreService.ListIdentityMappingStores\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ListIdentityMappingStores\]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIdentityMappingStoresResponse {
    /// The Identity Mapping Stores.
    #[prost(message, repeated, tag = "1")]
    pub identity_mapping_stores: ::prost::alloc::vec::Vec<IdentityMappingStore>,
    /// A token that can be sent as `page_token` to retrieve the next page. If this
    /// field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// IdentityMappingEntry LongRunningOperation metadata for
/// \[IdentityMappingStoreService.ImportIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.ImportIdentityMappings\]
/// and
/// \[IdentityMappingStoreService.PurgeIdentityMappings\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.PurgeIdentityMappings\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IdentityMappingEntryOperationMetadata {
    /// The number of IdentityMappingEntries that were successfully processed.
    #[prost(int64, tag = "1")]
    pub success_count: i64,
    /// The number of IdentityMappingEntries that failed to be processed.
    #[prost(int64, tag = "2")]
    pub failure_count: i64,
    /// The total number of IdentityMappingEntries that were processed.
    #[prost(int64, tag = "3")]
    pub total_count: i64,
}
/// Metadata related to the progress of the
/// \[IdentityMappingStoreService.DeleteIdentityMappingStore\]\[google.cloud.discoveryengine.v1.IdentityMappingStoreService.DeleteIdentityMappingStore\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIdentityMappingStoreMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod identity_mapping_store_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing Identity Mapping Stores.
    #[derive(Debug, Clone)]
    pub struct IdentityMappingStoreServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IdentityMappingStoreServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IdentityMappingStoreServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IdentityMappingStoreServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IdentityMappingStoreServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new Identity Mapping Store.
        pub async fn create_identity_mapping_store(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIdentityMappingStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IdentityMappingStore>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/CreateIdentityMappingStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "CreateIdentityMappingStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the Identity Mapping Store.
        pub async fn get_identity_mapping_store(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIdentityMappingStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IdentityMappingStore>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/GetIdentityMappingStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "GetIdentityMappingStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the Identity Mapping Store.
        pub async fn delete_identity_mapping_store(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIdentityMappingStoreRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/DeleteIdentityMappingStore",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "DeleteIdentityMappingStore",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports a list of Identity Mapping Entries to an Identity Mapping Store.
        pub async fn import_identity_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportIdentityMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/ImportIdentityMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "ImportIdentityMappings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Purges specified or all Identity Mapping Entries from an Identity Mapping
        /// Store.
        pub async fn purge_identity_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeIdentityMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/PurgeIdentityMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "PurgeIdentityMappings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Identity Mappings in an Identity Mapping Store.
        pub async fn list_identity_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIdentityMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIdentityMappingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/ListIdentityMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "ListIdentityMappings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Identity Mapping Stores.
        pub async fn list_identity_mapping_stores(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIdentityMappingStoresRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIdentityMappingStoresResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.IdentityMappingStoreService/ListIdentityMappingStores",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.IdentityMappingStoreService",
                        "ListIdentityMappingStores",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Metadata and configurations for a Google Cloud project in the service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    /// Output only. Full resource name of the project, for example
    /// `projects/{project}`.
    /// Note that when making requests, project number and project id are both
    /// acceptable, but the server will always respond in project number.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp when this project is created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when this project is successfully provisioned.
    /// Empty value means this project is still provisioning and is not ready for
    /// use.
    #[prost(message, optional, tag = "3")]
    pub provision_completion_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. A map of terms of services. The key is the `id` of
    /// \[ServiceTerms\]\[google.cloud.discoveryengine.v1.Project.ServiceTerms\].
    #[prost(map = "string, message", tag = "4")]
    pub service_terms_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        project::ServiceTerms,
    >,
}
/// Nested message and enum types in `Project`.
pub mod project {
    /// Metadata about the terms of service.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ServiceTerms {
        /// The unique identifier of this terms of service.
        /// Available terms:
        ///
        /// * `GA_DATA_USE_TERMS`: [Terms for data
        ///   use](<https://cloud.google.com/retail/data-use-terms>). When using this as
        ///   `id`, the acceptable
        ///   \[version\]\[google.cloud.discoveryengine.v1.Project.ServiceTerms.version\]
        ///   to provide is `2022-11-23`.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// The version string of the terms of service.
        /// For acceptable values, see the comments for
        /// \[id\]\[google.cloud.discoveryengine.v1.Project.ServiceTerms.id\] above.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
        /// Whether the project has accepted/rejected the service terms or it is
        /// still pending.
        #[prost(enumeration = "service_terms::State", tag = "4")]
        pub state: i32,
        /// The last time when the project agreed to the terms of service.
        #[prost(message, optional, tag = "5")]
        pub accept_time: ::core::option::Option<::prost_types::Timestamp>,
        /// The last time when the project declined or revoked the agreement to terms
        /// of service.
        #[prost(message, optional, tag = "6")]
        pub decline_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Nested message and enum types in `ServiceTerms`.
    pub mod service_terms {
        /// The agreement states this terms of service.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum State {
            /// The default value of the enum. This value is not actually used.
            Unspecified = 0,
            /// The project has given consent to the terms of service.
            TermsAccepted = 1,
            /// The project is pending to review and accept the terms of service.
            TermsPending = 2,
            /// The project has declined or revoked the agreement to terms of service.
            TermsDeclined = 3,
        }
        impl State {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "STATE_UNSPECIFIED",
                    Self::TermsAccepted => "TERMS_ACCEPTED",
                    Self::TermsPending => "TERMS_PENDING",
                    Self::TermsDeclined => "TERMS_DECLINED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TERMS_ACCEPTED" => Some(Self::TermsAccepted),
                    "TERMS_PENDING" => Some(Self::TermsPending),
                    "TERMS_DECLINED" => Some(Self::TermsDeclined),
                    _ => None,
                }
            }
        }
    }
}
/// Request for
/// \[ProjectService.ProvisionProject\]\[google.cloud.discoveryengine.v1.ProjectService.ProvisionProject\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProvisionProjectRequest {
    /// Required. Full resource name of a
    /// \[Project\]\[google.cloud.discoveryengine.v1.Project\], such as
    /// `projects/{project_id_or_number}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Set to `true` to specify that caller has read and would like to
    /// give consent to the [Terms for data
    /// use](<https://cloud.google.com/retail/data-use-terms>).
    #[prost(bool, tag = "2")]
    pub accept_data_use_terms: bool,
    /// Required. The version of the [Terms for data
    /// use](<https://cloud.google.com/retail/data-use-terms>) that caller has read
    /// and would like to give consent to.
    ///
    /// Acceptable version is `2022-11-23`, and this may change over time.
    #[prost(string, tag = "3")]
    pub data_use_terms_version: ::prost::alloc::string::String,
}
/// Metadata associated with a project provision operation.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProvisionProjectMetadata {}
/// Generated client implementations.
pub mod project_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for operations on the
    /// \[Project\]\[google.cloud.discoveryengine.v1.Project\].
    #[derive(Debug, Clone)]
    pub struct ProjectServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProjectServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProjectServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProjectServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProjectServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Provisions the project resource. During the
        /// process, related systems will get prepared and initialized.
        ///
        /// Caller must read the [Terms for data
        /// use](https://cloud.google.com/retail/data-use-terms), and optionally
        /// specify in request to provide consent to that service terms.
        pub async fn provision_project(
            &mut self,
            request: impl tonic::IntoRequest<super::ProvisionProjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ProjectService/ProvisionProject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ProjectService",
                        "ProvisionProject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Record message for
/// \[RankService.Rank\]\[google.cloud.discoveryengine.v1.RankService.Rank\] method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankingRecord {
    /// The unique ID to represent the record.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// The title of the record. Empty by default.
    /// At least one of
    /// \[title\]\[google.cloud.discoveryengine.v1.RankingRecord.title\] or
    /// \[content\]\[google.cloud.discoveryengine.v1.RankingRecord.content\] should be
    /// set otherwise an INVALID_ARGUMENT error is thrown.
    #[prost(string, tag = "2")]
    pub title: ::prost::alloc::string::String,
    /// The content of the record. Empty by default.
    /// At least one of
    /// \[title\]\[google.cloud.discoveryengine.v1.RankingRecord.title\] or
    /// \[content\]\[google.cloud.discoveryengine.v1.RankingRecord.content\] should be
    /// set otherwise an INVALID_ARGUMENT error is thrown.
    #[prost(string, tag = "3")]
    pub content: ::prost::alloc::string::String,
    /// The score of this record based on the given query and selected model.
    /// The score will be rounded to 2 decimal places. If the score is close to 0,
    /// it will be rounded to 0.0001 to avoid returning unset.
    #[prost(float, tag = "4")]
    pub score: f32,
}
/// Request message for
/// \[RankService.Rank\]\[google.cloud.discoveryengine.v1.RankService.Rank\] method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankRequest {
    /// Required. The resource name of the rank service config, such as
    /// `projects/{project_num}/locations/{location}/rankingConfigs/default_ranking_config`.
    #[prost(string, tag = "1")]
    pub ranking_config: ::prost::alloc::string::String,
    /// The identifier of the model to use. It is one of:
    ///
    /// * `semantic-ranker-512@latest`: Semantic ranking model with maximum input
    ///   token size 512.
    ///
    /// It is set to `semantic-ranker-512@latest` by default if unspecified.
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    /// The number of results to return. If this is unset or no bigger than zero,
    /// returns all results.
    #[prost(int32, tag = "3")]
    pub top_n: i32,
    /// The query to use.
    #[prost(string, tag = "4")]
    pub query: ::prost::alloc::string::String,
    /// Required. A list of records to rank. At most 200 records to rank.
    #[prost(message, repeated, tag = "5")]
    pub records: ::prost::alloc::vec::Vec<RankingRecord>,
    /// If true, the response will contain only record ID and score. By default, it
    /// is false, the response will contain record details.
    #[prost(bool, tag = "6")]
    pub ignore_record_details_in_response: bool,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Google Cloud
    /// Document](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "7")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Response message for
/// \[RankService.Rank\]\[google.cloud.discoveryengine.v1.RankService.Rank\] method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RankResponse {
    /// A list of records sorted by descending score.
    #[prost(message, repeated, tag = "5")]
    pub records: ::prost::alloc::vec::Vec<RankingRecord>,
}
/// Generated client implementations.
pub mod rank_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for ranking text records.
    #[derive(Debug, Clone)]
    pub struct RankServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RankServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RankServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RankServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RankServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Ranks a list of text records based on the given input query.
        pub async fn rank(
            &mut self,
            request: impl tonic::IntoRequest<super::RankRequest>,
        ) -> std::result::Result<tonic::Response<super::RankResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.RankService/Rank",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.RankService",
                        "Rank",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for Recommend method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendRequest {
    /// Required. Full resource name of a
    /// \[ServingConfig\]\[google.cloud.discoveryengine.v1.ServingConfig\]:
    /// `projects/*/locations/global/collections/*/engines/*/servingConfigs/*`, or
    /// `projects/*/locations/global/collections/*/dataStores/*/servingConfigs/*`
    ///
    /// One default serving config is created along with your recommendation engine
    /// creation. The engine ID is used as the ID of the default serving
    /// config. For example, for Engine
    /// `projects/*/locations/global/collections/*/engines/my-engine`, you can use
    /// `projects/*/locations/global/collections/*/engines/my-engine/servingConfigs/my-engine`
    /// for your
    /// \[RecommendationService.Recommend\]\[google.cloud.discoveryengine.v1.RecommendationService.Recommend\]
    /// requests.
    #[prost(string, tag = "1")]
    pub serving_config: ::prost::alloc::string::String,
    /// Required. Context about the user, what they are looking at and what action
    /// they took to trigger the Recommend request. Note that this user event
    /// detail won't be ingested to userEvent logs. Thus, a separate userEvent
    /// write request is required for event logging.
    ///
    /// Don't set
    /// \[UserEvent.user_pseudo_id\]\[google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id\]
    /// or
    /// \[UserEvent.user_info.user_id\]\[google.cloud.discoveryengine.v1.UserInfo.user_id\]
    /// to the same fixed ID for different users. If you are trying to receive
    /// non-personalized recommendations (not recommended; this can negatively
    /// impact model performance), instead set
    /// \[UserEvent.user_pseudo_id\]\[google.cloud.discoveryengine.v1.UserEvent.user_pseudo_id\]
    /// to a random unique ID and leave
    /// \[UserEvent.user_info.user_id\]\[google.cloud.discoveryengine.v1.UserInfo.user_id\]
    /// unset.
    #[prost(message, optional, tag = "2")]
    pub user_event: ::core::option::Option<UserEvent>,
    /// Maximum number of results to return. Set this property
    /// to the number of recommendation results needed. If zero, the service
    /// chooses a reasonable default. The maximum allowed value is 100. Values
    /// above 100 are set to 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Filter for restricting recommendation results with a length limit of 5,000
    /// characters. Currently, only filter expressions on the `filter_tags`
    /// attribute is supported.
    ///
    /// Examples:
    ///
    /// * `(filter_tags: ANY("Red", "Blue") OR filter_tags: ANY("Hot", "Cold"))`
    /// * `(filter_tags: ANY("Red", "Blue")) AND NOT (filter_tags: ANY("Green"))`
    ///
    /// If `attributeFilteringSyntax` is set to true under the `params` field, then
    /// attribute-based expressions are expected instead of the above described
    /// tag-based syntax. Examples:
    ///
    /// * (language: ANY("en", "es")) AND NOT (categories: ANY("Movie"))
    /// * (available: true) AND
    ///   (language: ANY("en", "es")) OR (categories: ANY("Movie"))
    ///
    /// If your filter blocks all results, the API returns generic
    /// (unfiltered) popular Documents. If you only want results strictly matching
    /// the filters, set `strictFiltering` to `true` in
    /// \[RecommendRequest.params\]\[google.cloud.discoveryengine.v1.RecommendRequest.params\]
    /// to receive empty results instead.
    ///
    /// Note that the API never returns
    /// \[Document\]\[google.cloud.discoveryengine.v1.Document\]s with `storageStatus`
    /// as `EXPIRED` or `DELETED` regardless of filter choices.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Use validate only mode for this recommendation query. If set to `true`, a
    /// fake model is used that returns arbitrary Document IDs.
    /// Note that the validate only mode should only be used for testing the API,
    /// or if the model is not ready.
    #[prost(bool, tag = "5")]
    pub validate_only: bool,
    /// Additional domain specific parameters for the recommendations.
    ///
    /// Allowed values:
    ///
    /// * `returnDocument`: Boolean. If set to `true`, the associated Document
    ///   object is returned in
    ///   \[RecommendResponse.RecommendationResult.document\]\[google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult.document\].
    /// * `returnScore`: Boolean. If set to true, the recommendation score
    ///   corresponding to each returned Document is set in
    ///   \[RecommendResponse.RecommendationResult.metadata\]\[google.cloud.discoveryengine.v1.RecommendResponse.RecommendationResult.metadata\].
    ///   The given score indicates the probability of a Document conversion given
    ///   the user's context and history.
    /// * `strictFiltering`: Boolean. True by default. If set to `false`, the
    ///   service
    ///   returns generic (unfiltered) popular Documents instead of empty if
    ///   your filter blocks all recommendation results.
    /// * `diversityLevel`: String. Default empty. If set to be non-empty, then
    ///   it needs to be one of:
    ///   * `no-diversity`
    ///   * `low-diversity`
    ///   * `medium-diversity`
    ///   * `high-diversity`
    ///   * `auto-diversity`
    ///     This gives request-level control and adjusts recommendation results
    ///     based on Document category.
    /// * `attributeFilteringSyntax`: Boolean. False by default. If set to true,
    ///   the `filter` field is interpreted according to the new,
    ///   attribute-based syntax.
    #[prost(map = "string, message", tag = "6")]
    pub params: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost_types::Value,
    >,
    /// The user labels applied to a resource must meet the following requirements:
    ///
    /// * Each resource can have multiple labels, up to a maximum of 64.
    /// * Each label must be a key-value pair.
    /// * Keys have a minimum length of 1 character and a maximum length of 63
    ///   characters and cannot be empty. Values can be empty and have a maximum
    ///   length of 63 characters.
    /// * Keys and values can contain only lowercase letters, numeric characters,
    ///   underscores, and dashes. All characters must use UTF-8 encoding, and
    ///   international characters are allowed.
    /// * The key portion of a label must be unique. However, you can use the same
    ///   key with multiple resources.
    /// * Keys must start with a lowercase letter or international character.
    ///
    /// See [Requirements for
    /// labels](<https://cloud.google.com/resource-manager/docs/creating-managing-labels#requirements>)
    /// for more details.
    #[prost(map = "string, string", tag = "8")]
    pub user_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Response message for Recommend method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecommendResponse {
    /// A list of recommended Documents. The order represents the ranking (from the
    /// most relevant Document to the least).
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<recommend_response::RecommendationResult>,
    /// A unique attribution token. This should be included in the
    /// \[UserEvent\]\[google.cloud.discoveryengine.v1.UserEvent\] logs resulting from
    /// this recommendation, which enables accurate attribution of recommendation
    /// model performance.
    #[prost(string, tag = "2")]
    pub attribution_token: ::prost::alloc::string::String,
    /// IDs of documents in the request that were missing from the default Branch
    /// associated with the requested ServingConfig.
    #[prost(string, repeated, tag = "3")]
    pub missing_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// True if
    /// \[RecommendRequest.validate_only\]\[google.cloud.discoveryengine.v1.RecommendRequest.validate_only\]
    /// was set.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
}
/// Nested message and enum types in `RecommendResponse`.
pub mod recommend_response {
    /// RecommendationResult represents a generic recommendation result with
    /// associated metadata.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RecommendationResult {
        /// Resource ID of the recommended Document.
        #[prost(string, tag = "1")]
        pub id: ::prost::alloc::string::String,
        /// Set if `returnDocument` is set to true in
        /// \[RecommendRequest.params\]\[google.cloud.discoveryengine.v1.RecommendRequest.params\].
        #[prost(message, optional, tag = "2")]
        pub document: ::core::option::Option<super::Document>,
        /// Additional Document metadata or annotations.
        ///
        /// Possible values:
        ///
        /// * `score`: Recommendation score in double value. Is set if
        ///   `returnScore` is set to true in
        ///   \[RecommendRequest.params\]\[google.cloud.discoveryengine.v1.RecommendRequest.params\].
        #[prost(map = "string, message", tag = "3")]
        pub metadata: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost_types::Value,
        >,
    }
}
/// Generated client implementations.
pub mod recommendation_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for making recommendations.
    #[derive(Debug, Clone)]
    pub struct RecommendationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RecommendationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RecommendationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RecommendationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RecommendationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Makes a recommendation, which requires a contextual user event.
        pub async fn recommend(
            &mut self,
            request: impl tonic::IntoRequest<super::RecommendRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RecommendResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.RecommendationService/Recommend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.RecommendationService",
                        "Recommend",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for
/// \[SchemaService.GetSchema\]\[google.cloud.discoveryengine.v1.SchemaService.GetSchema\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSchemaRequest {
    /// Required. The full resource name of the schema, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[SchemaService.ListSchemas\]\[google.cloud.discoveryengine.v1.SchemaService.ListSchemas\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSchemasRequest {
    /// Required. The parent data store resource name, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s to
    /// return. The service may return fewer than this value.
    ///
    /// If unspecified, at most 100
    /// \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s are returned.
    ///
    /// The maximum value is 1000; values above 1000 are set to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous
    /// \[SchemaService.ListSchemas\]\[google.cloud.discoveryengine.v1.SchemaService.ListSchemas\]
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// \[SchemaService.ListSchemas\]\[google.cloud.discoveryengine.v1.SchemaService.ListSchemas\]
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[SchemaService.ListSchemas\]\[google.cloud.discoveryengine.v1.SchemaService.ListSchemas\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemasResponse {
    /// The \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s.
    #[prost(message, repeated, tag = "1")]
    pub schemas: ::prost::alloc::vec::Vec<Schema>,
    /// A token that can be sent as
    /// \[ListSchemasRequest.page_token\]\[google.cloud.discoveryengine.v1.ListSchemasRequest.page_token\]
    /// to retrieve the next page. If this field is omitted, there are no
    /// subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[SchemaService.CreateSchema\]\[google.cloud.discoveryengine.v1.SchemaService.CreateSchema\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSchemaRequest {
    /// Required. The parent data store resource name, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] to create.
    #[prost(message, optional, tag = "2")]
    pub schema: ::core::option::Option<Schema>,
    /// Required. The ID to use for the
    /// \[Schema\]\[google.cloud.discoveryengine.v1.Schema\], which becomes the final
    /// component of the
    /// \[Schema.name\]\[google.cloud.discoveryengine.v1.Schema.name\].
    ///
    /// This field should conform to
    /// [RFC-1034](<https://tools.ietf.org/html/rfc1034>) standard with a length
    /// limit of 63 characters.
    #[prost(string, tag = "3")]
    pub schema_id: ::prost::alloc::string::String,
}
/// Request message for
/// \[SchemaService.UpdateSchema\]\[google.cloud.discoveryengine.v1.SchemaService.UpdateSchema\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSchemaRequest {
    /// Required. The \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] to update.
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<Schema>,
    /// If set to true, and the \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] is
    /// not found, a new \[Schema\]\[google.cloud.discoveryengine.v1.Schema\] is
    /// created. In this situation, `update_mask` is ignored.
    #[prost(bool, tag = "3")]
    pub allow_missing: bool,
}
/// Request message for
/// \[SchemaService.DeleteSchema\]\[google.cloud.discoveryengine.v1.SchemaService.DeleteSchema\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSchemaRequest {
    /// Required. The full resource name of the schema, in the format of
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/schemas/{schema}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata for Create Schema LRO.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSchemaMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Metadata for UpdateSchema LRO.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateSchemaMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Metadata for DeleteSchema LRO.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSchemaMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod schema_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s.
    #[derive(Debug, Clone)]
    pub struct SchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SchemaServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn get_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/GetSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "GetSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of \[Schema\]\[google.cloud.discoveryengine.v1.Schema\]s.
        pub async fn list_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/ListSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "ListSchemas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn create_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/CreateSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "CreateSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn update_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/UpdateSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "UpdateSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Schema\]\[google.cloud.discoveryengine.v1.Schema\].
        pub async fn delete_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SchemaService/DeleteSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SchemaService",
                        "DeleteSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for
/// \[SearchTuningService.ListCustomModels\]\[google.cloud.discoveryengine.v1.SearchTuningService.ListCustomModels\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCustomModelsRequest {
    /// Required. The resource name of the parent Data Store, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    /// This field is used to identify the data store where to fetch the models
    /// from.
    #[prost(string, tag = "1")]
    pub data_store: ::prost::alloc::string::String,
}
/// Response message for
/// \[SearchTuningService.ListCustomModels\]\[google.cloud.discoveryengine.v1.SearchTuningService.ListCustomModels\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomModelsResponse {
    /// List of custom tuning models.
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<CustomTuningModel>,
}
/// Request message for
/// \[SearchTuningService.TrainCustomModel\]\[google.cloud.discoveryengine.v1.SearchTuningService.TrainCustomModel\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TrainCustomModelRequest {
    /// Required. The resource name of the Data Store, such as
    /// `projects/*/locations/global/collections/default_collection/dataStores/default_data_store`.
    /// This field is used to identify the data store where to train the models.
    #[prost(string, tag = "1")]
    pub data_store: ::prost::alloc::string::String,
    /// Model to be trained. Supported values are:
    ///
    /// * **search-tuning**: Fine tuning the search system based on data provided.
    #[prost(string, tag = "3")]
    pub model_type: ::prost::alloc::string::String,
    /// The desired location of errors incurred during the data ingestion and
    /// training.
    #[prost(message, optional, tag = "4")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    /// If not provided, a UUID will be generated.
    #[prost(string, tag = "5")]
    pub model_id: ::prost::alloc::string::String,
    /// Model training input.
    #[prost(oneof = "train_custom_model_request::TrainingInput", tags = "2")]
    pub training_input: ::core::option::Option<
        train_custom_model_request::TrainingInput,
    >,
}
/// Nested message and enum types in `TrainCustomModelRequest`.
pub mod train_custom_model_request {
    /// Cloud Storage training data input.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GcsTrainingInput {
        /// The Cloud Storage corpus data which could be associated in train data.
        /// The data path format is `gs://<bucket_to_data>/<jsonl_file_name>`.
        /// A newline delimited jsonl/ndjson file.
        ///
        /// For search-tuning model, each line should have the \_id, title
        /// and text. Example:
        /// `{"_id": "doc1", title: "relevant doc", "text": "relevant text"}`
        #[prost(string, tag = "1")]
        pub corpus_data_path: ::prost::alloc::string::String,
        /// The gcs query data which could be associated in train data.
        /// The data path format is `gs://<bucket_to_data>/<jsonl_file_name>`.
        /// A newline delimited jsonl/ndjson file.
        ///
        /// For search-tuning model, each line should have the \_id
        /// and text. Example: {"\_id": "query1",  "text": "example query"}
        #[prost(string, tag = "2")]
        pub query_data_path: ::prost::alloc::string::String,
        /// Cloud Storage training data path whose format should be
        /// `gs://<bucket_to_data>/<tsv_file_name>`. The file should be in tsv
        /// format. Each line should have the doc_id and query_id and score (number).
        ///
        /// For search-tuning model, it should have the query-id corpus-id
        /// score as tsv file header. The score should be a number in `[0, inf+)`.
        /// The larger the number is, the more relevant the pair is. Example:
        ///
        /// * `query-id\tcorpus-id\tscore`
        /// * `query1\tdoc1\t1`
        #[prost(string, tag = "3")]
        pub train_data_path: ::prost::alloc::string::String,
        /// Cloud Storage test data. Same format as train_data_path. If not provided,
        /// a random 80/20 train/test split will be performed on train_data_path.
        #[prost(string, tag = "4")]
        pub test_data_path: ::prost::alloc::string::String,
    }
    /// Model training input.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum TrainingInput {
        /// Cloud Storage training input.
        #[prost(message, tag = "2")]
        GcsTrainingInput(GcsTrainingInput),
    }
}
/// Response of the
/// \[TrainCustomModelRequest\]\[google.cloud.discoveryengine.v1.TrainCustomModelRequest\].
/// This message is returned by the google.longrunning.Operations.response field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TrainCustomModelResponse {
    /// A sample of errors encountered while processing the data.
    #[prost(message, repeated, tag = "1")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
    /// Echoes the destination for the complete errors in the request if set.
    #[prost(message, optional, tag = "2")]
    pub error_config: ::core::option::Option<ImportErrorConfig>,
    /// The trained model status. Possible values are:
    ///
    /// * **bad-data**: The training data quality is bad.
    /// * **no-improvement**: Tuning didn't improve performance. Won't deploy.
    /// * **in-progress**: Model training job creation is in progress.
    /// * **training**: Model is actively training.
    /// * **evaluating**: The model is evaluating trained metrics.
    /// * **indexing**: The model trained metrics are indexing.
    /// * **ready**: The model is ready for serving.
    #[prost(string, tag = "3")]
    pub model_status: ::prost::alloc::string::String,
    /// The metrics of the trained model.
    #[prost(map = "string, double", tag = "4")]
    pub metrics: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
    /// Fully qualified name of the CustomTuningModel.
    #[prost(string, tag = "5")]
    pub model_name: ::prost::alloc::string::String,
}
/// Metadata related to the progress of the TrainCustomModel operation. This is
/// returned by the google.longrunning.Operation.metadata field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TrainCustomModelMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod search_tuning_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for search tuning.
    #[derive(Debug, Clone)]
    pub struct SearchTuningServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SearchTuningServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SearchTuningServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SearchTuningServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SearchTuningServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Trains a custom model.
        pub async fn train_custom_model(
            &mut self,
            request: impl tonic::IntoRequest<super::TrainCustomModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SearchTuningService/TrainCustomModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SearchTuningService",
                        "TrainCustomModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of all the custom models.
        pub async fn list_custom_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomModelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SearchTuningService/ListCustomModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SearchTuningService",
                        "ListCustomModels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Configures metadata that is used to generate serving time results (e.g.
/// search results or recommendation predictions).
/// The ServingConfig is passed in the search and predict request and generates
/// results.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServingConfig {
    /// Immutable. Fully qualified name
    /// `projects/{project}/locations/{location}/collections/{collection_id}/engines/{engine_id}/servingConfigs/{serving_config_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The human readable serving config display name. Used in Discovery
    /// UI.
    ///
    /// This field must be a UTF-8 encoded string with a length limit of 128
    /// characters. Otherwise, an INVALID_ARGUMENT error is returned.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. Immutable. Specifies the solution type that a serving config can
    /// be associated with.
    #[prost(enumeration = "SolutionType", tag = "3")]
    pub solution_type: i32,
    /// The id of the model to use at serving time.
    /// Currently only RecommendationModels are supported.
    /// Can be changed but only to a compatible model (e.g.
    /// others-you-may-like CTR to others-you-may-like CVR).
    ///
    /// Required when \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\]
    /// is
    /// \[SOLUTION_TYPE_RECOMMENDATION\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION\].
    #[prost(string, tag = "4")]
    pub model_id: ::prost::alloc::string::String,
    /// How much diversity to use in recommendation model results e.g.
    /// `medium-diversity` or `high-diversity`. Currently supported values:
    ///
    /// * `no-diversity`
    /// * `low-diversity`
    /// * `medium-diversity`
    /// * `high-diversity`
    /// * `auto-diversity`
    ///
    /// If not specified, we choose default based on recommendation model
    /// type. Default value: `no-diversity`.
    ///
    /// Can only be set if
    /// \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    /// \[SOLUTION_TYPE_RECOMMENDATION\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION\].
    #[prost(string, tag = "5")]
    pub diversity_level: ::prost::alloc::string::String,
    /// The ranking expression controls the customized ranking on retrieval
    /// documents. To leverage this, document embedding is required. The ranking
    /// expression setting in ServingConfig applies to all search requests served
    /// by the serving config. However, if `SearchRequest.ranking_expression` is
    /// specified, it overrides the ServingConfig ranking expression.
    ///
    /// The ranking expression is a single function or multiple functions that are
    /// joined by "+".
    ///
    /// * ranking_expression = function, { " + ", function };
    ///
    /// Supported functions:
    ///
    /// * double * relevance_score
    /// * double * dotProduct(embedding_field_path)
    ///
    /// Function variables:
    ///
    /// * `relevance_score`: pre-defined keywords, used for measure relevance
    ///   between query and document.
    /// * `embedding_field_path`: the document embedding field
    ///   used with query embedding vector.
    /// * `dotProduct`: embedding function between embedding_field_path and query
    ///   embedding vector.
    ///
    /// Example ranking expression:
    ///
    /// ```text
    /// If document has an embedding field doc_embedding, the ranking expression
    /// could be `0.5 * relevance_score + 0.3 * dotProduct(doc_embedding)`.
    /// ```
    #[prost(string, tag = "21")]
    pub ranking_expression: ::prost::alloc::string::String,
    /// Output only. ServingConfig created timestamp.
    #[prost(message, optional, tag = "8")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. ServingConfig updated timestamp.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Filter controls to use in serving path.
    /// All triggered filter controls will be applied.
    /// Filter controls must be in the same data store as the serving config.
    /// Maximum of 20 filter controls.
    #[prost(string, repeated, tag = "11")]
    pub filter_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Boost controls to use in serving path.
    /// All triggered boost controls will be applied.
    /// Boost controls must be in the same data store as the serving config.
    /// Maximum of 20 boost controls.
    #[prost(string, repeated, tag = "12")]
    pub boost_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// IDs of the redirect controls. Only the first triggered redirect
    /// action is applied, even if multiple apply. Maximum number of
    /// specifications is 100.
    ///
    /// Can only be set if
    /// \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    #[prost(string, repeated, tag = "14")]
    pub redirect_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Condition synonyms specifications. If multiple synonyms conditions
    /// match, all matching synonyms controls in the list will execute.
    /// Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    #[prost(string, repeated, tag = "15")]
    pub synonyms_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Condition oneway synonyms specifications. If multiple oneway synonyms
    /// conditions match, all matching oneway synonyms controls in the list
    /// will execute. Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    #[prost(string, repeated, tag = "16")]
    pub oneway_synonyms_control_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Condition do not associate specifications. If multiple do not
    /// associate conditions match, all matching do not associate controls in
    /// the list will execute.
    /// Order does not matter.
    /// Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    #[prost(string, repeated, tag = "17")]
    pub dissociate_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Condition replacement specifications.
    /// Applied according to the order in the list.
    /// A previously replaced term can not be re-replaced.
    /// Maximum number of specifications is 100.
    ///
    /// Can only be set if
    /// \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    /// \[SOLUTION_TYPE_SEARCH\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_SEARCH\].
    #[prost(string, repeated, tag = "18")]
    pub replacement_control_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Condition ignore specifications. If multiple ignore
    /// conditions match, all matching ignore controls in the list will
    /// execute.
    /// Order does not matter.
    /// Maximum number of specifications is 100.
    #[prost(string, repeated, tag = "19")]
    pub ignore_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Condition promote specifications.
    ///
    /// Maximum number of specifications is 100.
    #[prost(string, repeated, tag = "26")]
    pub promote_control_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Industry vertical specific config.
    #[prost(oneof = "serving_config::VerticalConfig", tags = "7, 10")]
    pub vertical_config: ::core::option::Option<serving_config::VerticalConfig>,
}
/// Nested message and enum types in `ServingConfig`.
pub mod serving_config {
    /// Specifies the configurations needed for Media Discovery. Currently we
    /// support:
    ///
    /// * `demote_content_watched`: Threshold for watched content demotion.
    ///   Customers can specify if using watched content demotion or use viewed
    ///   detail page. Using the content watched demotion, customers need to specify
    ///   the watched minutes or percentage exceeds the threshold, the content will
    ///   be demoted in the recommendation result.
    /// * `promote_fresh_content`: cutoff days for fresh content promotion.
    ///   Customers can specify if using content freshness promotion. If the content
    ///   was published within the cutoff days, the content will be promoted in the
    ///   recommendation result.
    ///   Can only be set if
    ///   \[SolutionType\]\[google.cloud.discoveryengine.v1.SolutionType\] is
    ///   \[SOLUTION_TYPE_RECOMMENDATION\]\[google.cloud.discoveryengine.v1.SolutionType.SOLUTION_TYPE_RECOMMENDATION\].
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MediaConfig {
        /// Specifies the event type used for demoting recommendation result.
        /// Currently supported values:
        ///
        /// * `view-item`: Item viewed.
        /// * `media-play`: Start/resume watching a video, playing a song, etc.
        /// * `media-complete`: Finished or stopped midway through a video, song,
        ///   etc.
        ///
        /// If unset, watch history demotion will not be applied. Content freshness
        /// demotion will still be applied.
        #[prost(string, tag = "1")]
        pub demotion_event_type: ::prost::alloc::string::String,
        /// Optional. Specifies the number of days to look back for demoting watched
        /// content. If set to zero or unset, defaults to the maximum of 365 days.
        #[prost(int32, tag = "37")]
        pub demote_content_watched_past_days: i32,
        /// Specifies the content freshness used for recommendation result.
        /// Contents will be demoted if contents were published for more than content
        /// freshness cutoff days.
        #[prost(int32, tag = "4")]
        pub content_freshness_cutoff_days: i32,
        /// Specify the threshold for demoting watched content, the threshold can be
        /// either percentage or minutes value.
        /// This must be set for `media-complete` event type.
        #[prost(oneof = "media_config::DemoteContentWatched", tags = "2, 5")]
        pub demote_content_watched: ::core::option::Option<
            media_config::DemoteContentWatched,
        >,
    }
    /// Nested message and enum types in `MediaConfig`.
    pub mod media_config {
        /// Specify the threshold for demoting watched content, the threshold can be
        /// either percentage or minutes value.
        /// This must be set for `media-complete` event type.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum DemoteContentWatched {
            /// Specifies the content watched percentage threshold for demotion.
            /// Threshold value must be between \[0, 1.0\] inclusive.
            #[prost(float, tag = "2")]
            ContentWatchedPercentageThreshold(f32),
            /// Specifies the content watched minutes threshold for demotion.
            #[prost(float, tag = "5")]
            ContentWatchedSecondsThreshold(f32),
        }
    }
    /// Specifies the configurations needed for Generic Discovery.Currently we
    /// support:
    ///
    /// * `content_search_spec`: configuration for generic content search.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GenericConfig {
        /// Specifies the expected behavior of content search.
        /// Only valid for content-search enabled data store.
        #[prost(message, optional, tag = "1")]
        pub content_search_spec: ::core::option::Option<
            super::search_request::ContentSearchSpec,
        >,
    }
    /// Industry vertical specific config.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VerticalConfig {
        /// The MediaConfig of the serving configuration.
        #[prost(message, tag = "7")]
        MediaConfig(MediaConfig),
        /// The GenericConfig of the serving configuration.
        #[prost(message, tag = "10")]
        GenericConfig(GenericConfig),
    }
}
/// Request for UpdateServingConfig method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateServingConfigRequest {
    /// Required. The ServingConfig to update.
    #[prost(message, optional, tag = "1")]
    pub serving_config: ::core::option::Option<ServingConfig>,
    /// Indicates which fields in the provided
    /// \[ServingConfig\]\[google.cloud.discoveryengine.v1.ServingConfig\] to update.
    /// The following are NOT supported:
    ///
    /// * \[ServingConfig.name\]\[google.cloud.discoveryengine.v1.ServingConfig.name\]
    ///
    /// If not set, all supported fields are updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod serving_config_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for operations related to
    /// \[ServingConfig\]\[google.cloud.discoveryengine.v1.ServingConfig\].
    #[derive(Debug, Clone)]
    pub struct ServingConfigServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ServingConfigServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ServingConfigServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ServingConfigServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ServingConfigServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Updates a ServingConfig.
        ///
        /// Returns a NOT_FOUND error if the ServingConfig does not exist.
        pub async fn update_serving_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateServingConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::ServingConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.ServingConfigService/UpdateServingConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.ServingConfigService",
                        "UpdateServingConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod session_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing Sessions and Session-related resources.
    #[derive(Debug, Clone)]
    pub struct SessionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SessionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SessionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SessionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SessionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a Session.
        ///
        /// If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to create already
        /// exists, an ALREADY_EXISTS error is returned.
        pub async fn create_session(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SessionService/CreateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SessionService",
                        "CreateSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Session.
        ///
        /// If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to delete does
        /// not exist, a NOT_FOUND error is returned.
        pub async fn delete_session(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSessionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SessionService/DeleteSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SessionService",
                        "DeleteSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Session.
        ///
        /// \[Session\]\[google.cloud.discoveryengine.v1.Session\] action type cannot be
        /// changed. If the \[Session\]\[google.cloud.discoveryengine.v1.Session\] to
        /// update does not exist, a NOT_FOUND error is returned.
        pub async fn update_session(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SessionService/UpdateSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SessionService",
                        "UpdateSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Session.
        pub async fn get_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::Session>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SessionService/GetSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SessionService",
                        "GetSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all Sessions by their parent
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn list_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SessionService/ListSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SessionService",
                        "ListSessions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// SiteSearchEngine captures DataStore level site search persisting
/// configurations. It is a singleton value per data store.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SiteSearchEngine {
    /// The fully qualified resource name of the site search engine.
    /// Format: `projects/*/locations/*/dataStores/*/siteSearchEngine`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A target site for the SiteSearchEngine.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetSite {
    /// Output only. The fully qualified resource name of the target site.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`
    /// The `target_site_id` is system-generated.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Input only. The user provided URI pattern from which the
    /// `generated_uri_pattern` is generated.
    #[prost(string, tag = "2")]
    pub provided_uri_pattern: ::prost::alloc::string::String,
    /// The type of the target site, e.g., whether the site is to be included or
    /// excluded.
    #[prost(enumeration = "target_site::Type", tag = "3")]
    pub r#type: i32,
    /// Immutable. If set to false, a uri_pattern is generated to include all pages
    /// whose address contains the provided_uri_pattern. If set to true, an
    /// uri_pattern is generated to try to be an exact match of the
    /// provided_uri_pattern or just the specific page if the provided_uri_pattern
    /// is a specific one. provided_uri_pattern is always normalized to
    /// generate the URI pattern to be used by the search engine.
    #[prost(bool, tag = "6")]
    pub exact_match: bool,
    /// Output only. This is system-generated based on the provided_uri_pattern.
    #[prost(string, tag = "4")]
    pub generated_uri_pattern: ::prost::alloc::string::String,
    /// Output only. Root domain of the provided_uri_pattern.
    #[prost(string, tag = "10")]
    pub root_domain_uri: ::prost::alloc::string::String,
    /// Output only. Site ownership and validity verification status.
    #[prost(message, optional, tag = "7")]
    pub site_verification_info: ::core::option::Option<SiteVerificationInfo>,
    /// Output only. Indexing status.
    #[prost(enumeration = "target_site::IndexingStatus", tag = "8")]
    pub indexing_status: i32,
    /// Output only. The target site's last updated time.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Failure reason.
    #[prost(message, optional, tag = "9")]
    pub failure_reason: ::core::option::Option<target_site::FailureReason>,
}
/// Nested message and enum types in `TargetSite`.
pub mod target_site {
    /// Site search indexing failure reasons.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FailureReason {
        /// Failure reason.
        #[prost(oneof = "failure_reason::Failure", tags = "1")]
        pub failure: ::core::option::Option<failure_reason::Failure>,
    }
    /// Nested message and enum types in `FailureReason`.
    pub mod failure_reason {
        /// Failed due to insufficient quota.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct QuotaFailure {
            /// This number is an estimation on how much total quota this project needs
            /// to successfully complete indexing.
            #[prost(int64, tag = "1")]
            pub total_required_quota: i64,
        }
        /// Failure reason.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Failure {
            /// Failed due to insufficient quota.
            #[prost(message, tag = "1")]
            QuotaFailure(QuotaFailure),
        }
    }
    /// Possible target site types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// This value is unused. In this case, server behavior defaults to
        /// \[Type.INCLUDE\]\[google.cloud.discoveryengine.v1.TargetSite.Type.INCLUDE\].
        Unspecified = 0,
        /// Include the target site.
        Include = 1,
        /// Exclude the target site.
        Exclude = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Include => "INCLUDE",
                Self::Exclude => "EXCLUDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUDE" => Some(Self::Include),
                "EXCLUDE" => Some(Self::Exclude),
                _ => None,
            }
        }
    }
    /// Target site indexing status enumeration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IndexingStatus {
        /// Defaults to SUCCEEDED.
        Unspecified = 0,
        /// The target site is in the update queue and will be picked up by indexing
        /// pipeline.
        Pending = 1,
        /// The target site fails to be indexed.
        Failed = 2,
        /// The target site has been indexed.
        Succeeded = 3,
        /// The previously indexed target site has been marked to be deleted. This is
        /// a transitioning state which will resulted in either:
        ///
        /// 1. target site deleted if unindexing is successful;
        /// 1. state reverts to SUCCEEDED if the unindexing fails.
        Deleting = 4,
        /// The target site change is pending but cancellable.
        Cancellable = 5,
        /// The target site change is cancelled.
        Cancelled = 6,
    }
    impl IndexingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "INDEXING_STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
                Self::Deleting => "DELETING",
                Self::Cancellable => "CANCELLABLE",
                Self::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INDEXING_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                "DELETING" => Some(Self::Deleting),
                "CANCELLABLE" => Some(Self::Cancellable),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// Verification information for target sites in advanced site search.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SiteVerificationInfo {
    /// Site verification state indicating the ownership and validity.
    #[prost(enumeration = "site_verification_info::SiteVerificationState", tag = "1")]
    pub site_verification_state: i32,
    /// Latest site verification time.
    #[prost(message, optional, tag = "2")]
    pub verify_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `SiteVerificationInfo`.
pub mod site_verification_info {
    /// Site verification state.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SiteVerificationState {
        /// Defaults to VERIFIED.
        Unspecified = 0,
        /// Site ownership verified.
        Verified = 1,
        /// Site ownership pending verification or verification failed.
        Unverified = 2,
        /// Site exempt from verification, e.g., a public website that opens to all.
        Exempted = 3,
    }
    impl SiteVerificationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SITE_VERIFICATION_STATE_UNSPECIFIED",
                Self::Verified => "VERIFIED",
                Self::Unverified => "UNVERIFIED",
                Self::Exempted => "EXEMPTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SITE_VERIFICATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "VERIFIED" => Some(Self::Verified),
                "UNVERIFIED" => Some(Self::Unverified),
                "EXEMPTED" => Some(Self::Exempted),
                _ => None,
            }
        }
    }
}
/// A sitemap for the SiteSearchEngine.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Sitemap {
    /// Output only. The fully qualified resource name of the sitemap.
    /// `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine/sitemaps/*`
    /// The `sitemap_id` suffix is system-generated.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The sitemap's creation time.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Supported feed sources.
    #[prost(oneof = "sitemap::Feed", tags = "2")]
    pub feed: ::core::option::Option<sitemap::Feed>,
}
/// Nested message and enum types in `Sitemap`.
pub mod sitemap {
    /// Supported feed sources.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Feed {
        /// Public URI for the sitemap, e.g. `www.example.com/sitemap.xml`.
        #[prost(string, tag = "2")]
        Uri(::prost::alloc::string::String),
    }
}
/// Request message for
/// \[SiteSearchEngineService.GetSiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.GetSiteSearchEngine\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSiteSearchEngineRequest {
    /// Required. Resource name of
    /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\], such
    /// as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    ///
    /// If the caller does not have permission to access the \[SiteSearchEngine\],
    /// regardless of whether or not it exists, a PERMISSION_DENIED error is
    /// returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[SiteSearchEngineService.CreateTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateTargetSite\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTargetSiteRequest {
    /// Required. Parent resource name of
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\] to
    /// create.
    #[prost(message, optional, tag = "2")]
    pub target_site: ::core::option::Option<TargetSite>,
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.CreateTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateTargetSite\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTargetSiteMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[SiteSearchEngineService.BatchCreateTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSitesRequest {
    /// Required. The parent resource shared by all TargetSites being created.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    /// The parent field in the CreateBookRequest messages must either be empty or
    /// match this field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request message specifying the resources to create.
    /// A maximum of 20 TargetSites can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateTargetSiteRequest>,
}
/// Request message for
/// \[SiteSearchEngineService.GetTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.GetTargetSite\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTargetSiteRequest {
    /// Required. Full resource name of
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
    ///
    /// If the caller does not have permission to access the
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\]
    /// does not exist, a NOT_FOUND error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[SiteSearchEngineService.UpdateTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.UpdateTargetSite\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateTargetSiteRequest {
    /// Required. The target site to update.
    /// If the caller does not have permission to update the
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\] to update
    /// does not exist, a NOT_FOUND error is returned.
    #[prost(message, optional, tag = "1")]
    pub target_site: ::core::option::Option<TargetSite>,
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.UpdateTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.UpdateTargetSite\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateTargetSiteMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[SiteSearchEngineService.DeleteTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteTargetSite\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteTargetSiteRequest {
    /// Required. Full resource name of
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/targetSites/{target_site}`.
    ///
    /// If the caller does not have permission to access the
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\], regardless of
    /// whether or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\]
    /// does not exist, a NOT_FOUND error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.DeleteTargetSite\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteTargetSite\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteTargetSiteMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[SiteSearchEngineService.ListTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.ListTargetSites\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTargetSitesRequest {
    /// Required. The parent site search engine resource name, such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    ///
    /// If the caller does not have permission to list
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\]s under this site
    /// search engine, regardless of whether or not this branch exists, a
    /// PERMISSION_DENIED error is returned.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested. If
    /// unspecified, server will pick an appropriate default. The maximum value is
    /// 1000; values above 1000 will be coerced to 1000.
    ///
    /// If this field is negative, an INVALID_ARGUMENT error is returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `ListTargetSites` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTargetSites`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[SiteSearchEngineService.ListTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.ListTargetSites\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetSitesResponse {
    /// List of TargetSites.
    #[prost(message, repeated, tag = "1")]
    pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The total number of items matching the request.
    /// This will always be populated in the response.
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.BatchCreateTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchCreateTargetSiteMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Response message for
/// \[SiteSearchEngineService.BatchCreateTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchCreateTargetSites\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTargetSitesResponse {
    /// TargetSites created.
    #[prost(message, repeated, tag = "1")]
    pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
}
/// Request message for
/// \[SiteSearchEngineService.CreateSitemap\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateSitemap\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSitemapRequest {
    /// Required. Parent resource name of the
    /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\], such
    /// as `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\] to create.
    #[prost(message, optional, tag = "2")]
    pub sitemap: ::core::option::Option<Sitemap>,
}
/// Request message for
/// \[SiteSearchEngineService.DeleteSitemap\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteSitemap\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSitemapRequest {
    /// Required. Full resource name of
    /// \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\], such as
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine/sitemaps/{sitemap}`.
    ///
    /// If the caller does not have permission to access the
    /// \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\], regardless of whether
    /// or not it exists, a PERMISSION_DENIED error is returned.
    ///
    /// If the requested \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\] does
    /// not exist, a NOT_FOUND error is returned.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[SiteSearchEngineService.FetchSitemaps\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchSitemaps\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FetchSitemapsRequest {
    /// Required. Parent resource name of the
    /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\], such
    /// as `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If specified, fetches the matching
    /// \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s. If not specified,
    /// fetches all \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s in the
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
    #[prost(message, optional, tag = "2")]
    pub matcher: ::core::option::Option<fetch_sitemaps_request::Matcher>,
}
/// Nested message and enum types in `FetchSitemapsRequest`.
pub mod fetch_sitemaps_request {
    /// Matcher for the \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s by
    /// their uris.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UrisMatcher {
        /// The \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\] uris.
        #[prost(string, repeated, tag = "1")]
        pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Matcher for the \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s.
    /// Currently only supports uris matcher.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Matcher {
        /// Matcher for the \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s.
        #[prost(oneof = "matcher::Matcher", tags = "1")]
        pub matcher: ::core::option::Option<matcher::Matcher>,
    }
    /// Nested message and enum types in `Matcher`.
    pub mod matcher {
        /// Matcher for the \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Matcher {
            /// Matcher by sitemap URIs.
            #[prost(message, tag = "1")]
            UrisMatcher(super::UrisMatcher),
        }
    }
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.CreateSitemap\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.CreateSitemap\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSitemapMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.DeleteSitemap\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DeleteSitemap\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSitemapMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Response message for
/// \[SiteSearchEngineService.FetchSitemaps\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchSitemaps\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchSitemapsResponse {
    /// List of \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s fetched.
    #[prost(message, repeated, tag = "1")]
    pub sitemaps_metadata: ::prost::alloc::vec::Vec<
        fetch_sitemaps_response::SitemapMetadata,
    >,
}
/// Nested message and enum types in `FetchSitemapsResponse`.
pub mod fetch_sitemaps_response {
    /// Contains a \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\] and its
    /// metadata.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SitemapMetadata {
        /// The \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\].
        #[prost(message, optional, tag = "1")]
        pub sitemap: ::core::option::Option<super::Sitemap>,
    }
}
/// Request message for
/// \[SiteSearchEngineService.EnableAdvancedSiteSearch\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnableAdvancedSiteSearchRequest {
    /// Required. Full resource name of the
    /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\], such
    /// as
    /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
}
/// Response message for
/// \[SiteSearchEngineService.EnableAdvancedSiteSearch\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch\]
/// method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnableAdvancedSiteSearchResponse {}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.EnableAdvancedSiteSearch\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.EnableAdvancedSiteSearch\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnableAdvancedSiteSearchMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[SiteSearchEngineService.DisableAdvancedSiteSearch\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisableAdvancedSiteSearchRequest {
    /// Required. Full resource name of the
    /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\], such
    /// as
    /// `projects/{project}/locations/{location}/dataStores/{data_store_id}/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
}
/// Response message for
/// \[SiteSearchEngineService.DisableAdvancedSiteSearch\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch\]
/// method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisableAdvancedSiteSearchResponse {}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.DisableAdvancedSiteSearch\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.DisableAdvancedSiteSearch\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisableAdvancedSiteSearchMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[SiteSearchEngineService.RecrawlUris\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecrawlUrisRequest {
    /// Required. Full resource name of the
    /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\], such
    /// as `projects/*/locations/*/collections/*/dataStores/*/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
    /// Required. List of URIs to crawl. At most 10K URIs are supported, otherwise
    /// an INVALID_ARGUMENT error is thrown. Each URI should match at least one
    /// \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\] in
    /// `site_search_engine`.
    #[prost(string, repeated, tag = "2")]
    pub uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Credential id to use for crawling.
    #[prost(string, tag = "5")]
    pub site_credential: ::prost::alloc::string::String,
}
/// Response message for
/// \[SiteSearchEngineService.RecrawlUris\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecrawlUrisResponse {
    /// Details for a sample of up to 10 `failed_uris`.
    #[prost(message, repeated, tag = "1")]
    pub failure_samples: ::prost::alloc::vec::Vec<recrawl_uris_response::FailureInfo>,
    /// URIs that were not crawled before the LRO terminated.
    #[prost(string, repeated, tag = "2")]
    pub failed_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RecrawlUrisResponse`.
pub mod recrawl_uris_response {
    /// Details about why a particular URI failed to be crawled. Each FailureInfo
    /// contains one FailureReason per CorpusType.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FailureInfo {
        /// URI that failed to be crawled.
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
        /// List of failure reasons by corpus type (e.g. desktop, mobile).
        #[prost(message, repeated, tag = "2")]
        pub failure_reasons: ::prost::alloc::vec::Vec<failure_info::FailureReason>,
    }
    /// Nested message and enum types in `FailureInfo`.
    pub mod failure_info {
        /// Details about why crawling failed for a particular CorpusType, e.g.,
        /// DESKTOP and MOBILE crawling may fail for different reasons.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct FailureReason {
            /// DESKTOP, MOBILE, or CORPUS_TYPE_UNSPECIFIED.
            #[prost(enumeration = "failure_reason::CorpusType", tag = "1")]
            pub corpus_type: i32,
            /// Reason why the URI was not crawled.
            #[prost(string, tag = "2")]
            pub error_message: ::prost::alloc::string::String,
        }
        /// Nested message and enum types in `FailureReason`.
        pub mod failure_reason {
            /// CorpusType for the failed crawling operation.
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum CorpusType {
                /// Default value.
                Unspecified = 0,
                /// Denotes a crawling attempt for the desktop version of a page.
                Desktop = 1,
                /// Denotes a crawling attempt for the mobile version of a page.
                Mobile = 2,
            }
            impl CorpusType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "CORPUS_TYPE_UNSPECIFIED",
                        Self::Desktop => "DESKTOP",
                        Self::Mobile => "MOBILE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "CORPUS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                        "DESKTOP" => Some(Self::Desktop),
                        "MOBILE" => Some(Self::Mobile),
                        _ => None,
                    }
                }
            }
        }
    }
}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.RecrawlUris\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.RecrawlUris\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RecrawlUrisMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Unique URIs in the request that have invalid format. Sample limited to
    /// 1000.
    #[prost(string, repeated, tag = "3")]
    pub invalid_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Total number of unique URIs in the request that have invalid format.
    #[prost(int32, tag = "8")]
    pub invalid_uris_count: i32,
    /// URIs that have no index meta tag. Sample limited to 1000.
    #[prost(string, repeated, tag = "11")]
    pub noindex_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Total number of URIs that have no index meta tag.
    #[prost(int32, tag = "12")]
    pub noindex_uris_count: i32,
    /// Unique URIs in the request that don't match any TargetSite in the
    /// DataStore, only match TargetSites that haven't been fully indexed, or match
    /// a TargetSite with type EXCLUDE. Sample limited to 1000.
    #[prost(string, repeated, tag = "9")]
    pub uris_not_matching_target_sites: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Total number of URIs that don't match any TargetSites.
    #[prost(int32, tag = "10")]
    pub uris_not_matching_target_sites_count: i32,
    /// Total number of unique URIs in the request that are not in invalid_uris.
    #[prost(int32, tag = "4")]
    pub valid_uris_count: i32,
    /// Total number of URIs that have been crawled so far.
    #[prost(int32, tag = "5")]
    pub success_count: i32,
    /// Total number of URIs that have yet to be crawled.
    #[prost(int32, tag = "6")]
    pub pending_count: i32,
    /// Total number of URIs that were rejected due to insufficient indexing
    /// resources.
    #[prost(int32, tag = "7")]
    pub quota_exceeded_count: i32,
}
/// Request message for
/// \[SiteSearchEngineService.BatchVerifyTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchVerifyTargetSitesRequest {
    /// Required. The parent resource shared by all TargetSites being verified.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Response message for
/// \[SiteSearchEngineService.BatchVerifyTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites\]
/// method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchVerifyTargetSitesResponse {}
/// Metadata related to the progress of the
/// \[SiteSearchEngineService.BatchVerifyTargetSites\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.BatchVerifyTargetSites\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchVerifyTargetSitesMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request message for
/// \[SiteSearchEngineService.FetchDomainVerificationStatus\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchDomainVerificationStatus\]
/// method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FetchDomainVerificationStatusRequest {
    /// Required. The site search engine resource under which we fetch all the
    /// domain verification status.
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/siteSearchEngine`.
    #[prost(string, tag = "1")]
    pub site_search_engine: ::prost::alloc::string::String,
    /// Requested page size. Server may return fewer items than requested. If
    /// unspecified, server will pick an appropriate default. The maximum value is
    /// 1000; values above 1000 will be coerced to 1000.
    ///
    /// If this field is negative, an INVALID_ARGUMENT error is returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A page token, received from a previous `FetchDomainVerificationStatus`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `FetchDomainVerificationStatus` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[SiteSearchEngineService.FetchDomainVerificationStatus\]\[google.cloud.discoveryengine.v1.SiteSearchEngineService.FetchDomainVerificationStatus\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchDomainVerificationStatusResponse {
    /// List of TargetSites containing the site verification status.
    #[prost(message, repeated, tag = "1")]
    pub target_sites: ::prost::alloc::vec::Vec<TargetSite>,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// The total number of items matching the request.
    /// This will always be populated in the response.
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod site_search_engine_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing site search related resources.
    #[derive(Debug, Clone)]
    pub struct SiteSearchEngineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SiteSearchEngineServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SiteSearchEngineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SiteSearchEngineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SiteSearchEngineServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Gets the
        /// \[SiteSearchEngine\]\[google.cloud.discoveryengine.v1.SiteSearchEngine\].
        pub async fn get_site_search_engine(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSiteSearchEngineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SiteSearchEngine>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/GetSiteSearchEngine",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "GetSiteSearchEngine",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn create_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTargetSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/CreateTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "CreateTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\] in a
        /// batch.
        pub async fn batch_create_target_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateTargetSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/BatchCreateTargetSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "BatchCreateTargetSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn get_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetSite>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/GetTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "GetTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn update_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTargetSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/UpdateTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "UpdateTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\].
        pub async fn delete_target_site(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetSiteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/DeleteTargetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "DeleteTargetSite",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of \[TargetSite\]\[google.cloud.discoveryengine.v1.TargetSite\]s.
        pub async fn list_target_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTargetSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/ListTargetSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "ListTargetSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\].
        pub async fn create_sitemap(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSitemapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/CreateSitemap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "CreateSitemap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\].
        pub async fn delete_sitemap(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSitemapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/DeleteSitemap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "DeleteSitemap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetch \[Sitemap\]\[google.cloud.discoveryengine.v1.Sitemap\]s in a
        /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\].
        pub async fn fetch_sitemaps(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchSitemapsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchSitemapsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/FetchSitemaps",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "FetchSitemaps",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Upgrade from basic site search to advanced site search.
        pub async fn enable_advanced_site_search(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableAdvancedSiteSearchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/EnableAdvancedSiteSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "EnableAdvancedSiteSearch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Downgrade from advanced site search to basic site search.
        pub async fn disable_advanced_site_search(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableAdvancedSiteSearchRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/DisableAdvancedSiteSearch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "DisableAdvancedSiteSearch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Request on-demand recrawl for a list of URIs.
        pub async fn recrawl_uris(
            &mut self,
            request: impl tonic::IntoRequest<super::RecrawlUrisRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/RecrawlUris",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "RecrawlUris",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Verify target sites' ownership and validity.
        /// This API sends all the target sites under site search engine for
        /// verification.
        pub async fn batch_verify_target_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchVerifyTargetSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/BatchVerifyTargetSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "BatchVerifyTargetSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns list of target sites with its domain verification status.
        /// This method can only be called under data store with BASIC_SITE_SEARCH
        /// state at the moment.
        pub async fn fetch_domain_verification_status(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchDomainVerificationStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchDomainVerificationStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.SiteSearchEngineService/FetchDomainVerificationStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.SiteSearchEngineService",
                        "FetchDomainVerificationStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for WriteUserEvent method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteUserEventRequest {
    /// Required. The parent resource name.
    /// If the write user event action is applied in
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] level, the format
    /// is:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    /// If the write user event action is applied in
    /// \[Location\]\[google.cloud.location.Location\] level, for example, the event
    /// with \[Document\]\[google.cloud.discoveryengine.v1.Document\] across multiple
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], the format is:
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. User event to write.
    #[prost(message, optional, tag = "2")]
    pub user_event: ::core::option::Option<UserEvent>,
    /// If set to true, the user event is written asynchronously after
    /// validation, and the API responds without waiting for the write.
    #[prost(bool, tag = "3")]
    pub write_async: bool,
}
/// Request message for CollectUserEvent method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CollectUserEventRequest {
    /// Required. The parent resource name.
    /// If the collect user event action is applied in
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\] level, the format
    /// is:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}`.
    /// If the collect user event action is applied in
    /// \[Location\]\[google.cloud.location.Location\] level, for example, the event
    /// with \[Document\]\[google.cloud.discoveryengine.v1.Document\] across multiple
    /// \[DataStore\]\[google.cloud.discoveryengine.v1.DataStore\], the format is:
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. URL encoded UserEvent proto with a length limit of 2,000,000
    /// characters.
    #[prost(string, tag = "2")]
    pub user_event: ::prost::alloc::string::String,
    /// The URL including cgi-parameters but excluding the hash fragment with a
    /// length limit of 5,000 characters. This is often more useful than the
    /// referer URL, because many browsers only send the domain for third-party
    /// requests.
    #[prost(string, optional, tag = "3")]
    pub uri: ::core::option::Option<::prost::alloc::string::String>,
    /// The event timestamp in milliseconds. This prevents browser caching of
    /// otherwise identical get requests. The name is abbreviated to reduce the
    /// payload bytes.
    #[prost(int64, optional, tag = "4")]
    pub ets: ::core::option::Option<i64>,
}
/// Generated client implementations.
pub mod user_event_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for ingesting end user actions on a website to Discovery Engine API.
    #[derive(Debug, Clone)]
    pub struct UserEventServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserEventServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserEventServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserEventServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserEventServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Writes a single user event.
        pub async fn write_user_event(
            &mut self,
            request: impl tonic::IntoRequest<super::WriteUserEventRequest>,
        ) -> std::result::Result<tonic::Response<super::UserEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/WriteUserEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "WriteUserEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Writes a single user event from the browser. This uses a GET request to
        /// due to browser restriction of POST-ing to a third-party domain.
        ///
        /// This method is used only by the Discovery Engine API JavaScript pixel and
        /// Google Tag Manager. Users should not call this method directly.
        pub async fn collect_user_event(
            &mut self,
            request: impl tonic::IntoRequest<super::CollectUserEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/CollectUserEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "CollectUserEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes permanently all user events specified by the filter provided.
        /// Depending on the number of events specified by the filter, this operation
        /// could take hours or days to complete. To test a filter, use the list
        /// command first.
        pub async fn purge_user_events(
            &mut self,
            request: impl tonic::IntoRequest<super::PurgeUserEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/PurgeUserEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "PurgeUserEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk import of user events. Request processing might be
        /// synchronous. Events that already exist are skipped.
        /// Use this method for backfilling historical user events.
        ///
        /// Operation.response is of type ImportResponse. Note that it is
        /// possible for a subset of the items to be successfully inserted.
        /// Operation.metadata is of type ImportMetadata.
        pub async fn import_user_events(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportUserEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserEventService/ImportUserEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserEventService",
                        "ImportUserEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// User License information assigned by the admin.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserLicense {
    /// Required. Immutable. The user principal of the User, could be email address
    /// or other prinical identifier. This field is immutable. Admin assign
    /// licenses based on the user principal.
    #[prost(string, tag = "1")]
    pub user_principal: ::prost::alloc::string::String,
    /// Optional. The user profile.
    /// We user user full name(First name + Last name) as user profile.
    #[prost(string, tag = "3")]
    pub user_profile: ::prost::alloc::string::String,
    /// Output only. License assignment state of the user.
    /// If the user is assigned with a license config, the user loggin will be
    /// assigned with the license;
    /// If the user's license assignment state is unassigned or unspecified, no
    /// license config will be associated to the user;
    #[prost(enumeration = "user_license::LicenseAssignmentState", tag = "4")]
    pub license_assignment_state: i32,
    /// Optional. The full resource name of the Subscription(LicenseConfig)
    /// assigned to the user.
    #[prost(string, tag = "5")]
    pub license_config: ::prost::alloc::string::String,
    /// Output only. User created timestamp.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. User update timestamp.
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. User last logged in time.
    /// If the user has not logged in yet, this field will be empty.
    #[prost(message, optional, tag = "8")]
    pub last_login_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `UserLicense`.
pub mod user_license {
    /// License assignment state enumeration.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LicenseAssignmentState {
        /// Default value.
        Unspecified = 0,
        /// License assigned to the user.
        Assigned = 1,
        /// No license assigned to the user.
        /// Deprecated, translated to NO_LICENSE.
        Unassigned = 2,
        /// No license assigned to the user.
        NoLicense = 3,
        /// User attempted to login but no license assigned to the user.
        /// This state is only used for no user first time login attempt but cannot
        /// get license assigned.
        /// Users already logged in but cannot get license assigned will be assigned
        /// NO_LICENSE state(License could be unassigned by admin).
        NoLicenseAttemptedLogin = 4,
    }
    impl LicenseAssignmentState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LICENSE_ASSIGNMENT_STATE_UNSPECIFIED",
                Self::Assigned => "ASSIGNED",
                Self::Unassigned => "UNASSIGNED",
                Self::NoLicense => "NO_LICENSE",
                Self::NoLicenseAttemptedLogin => "NO_LICENSE_ATTEMPTED_LOGIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LICENSE_ASSIGNMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ASSIGNED" => Some(Self::Assigned),
                "UNASSIGNED" => Some(Self::Unassigned),
                "NO_LICENSE" => Some(Self::NoLicense),
                "NO_LICENSE_ATTEMPTED_LOGIN" => Some(Self::NoLicenseAttemptedLogin),
                _ => None,
            }
        }
    }
}
/// Request message for
/// \[UserLicenseService.ListUserLicenses\]\[google.cloud.discoveryengine.v1.UserLicenseService.ListUserLicenses\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListUserLicensesRequest {
    /// Required. The parent \[UserStore\]\[\] resource name, format:
    /// `projects/{project}/locations/{location}/userStores/{user_store_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, defaults to 10. The maximum value is 50; values
    /// above 50 will be coerced to 50.
    ///
    /// If this field is negative, an INVALID_ARGUMENT error is returned.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListUserLicenses` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListUserLicenses`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter for the list request.
    ///
    /// Supported fields:
    ///
    /// * `license_assignment_state`
    ///
    /// Examples:
    ///
    /// * `license_assignment_state = ASSIGNED` to list assigned user licenses.
    /// * `license_assignment_state = NO_LICENSE` to list not licensed users.
    /// * `license_assignment_state = NO_LICENSE_ATTEMPTED_LOGIN` to list users
    ///   who attempted login but no license assigned.
    /// * `license_assignment_state != NO_LICENSE_ATTEMPTED_LOGIN` to filter
    ///   out users who attempted login but no license assigned.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Response message for
/// \[UserLicenseService.ListUserLicenses\]\[google.cloud.discoveryengine.v1.UserLicenseService.ListUserLicenses\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUserLicensesResponse {
    /// All the customer's
    /// \[UserLicense\]\[google.cloud.discoveryengine.v1.UserLicense\]s.
    #[prost(message, repeated, tag = "1")]
    pub user_licenses: ::prost::alloc::vec::Vec<UserLicense>,
    /// A token, which can be sent as `page_token` to retrieve the next page. If
    /// this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for
/// \[UserLicenseService.BatchUpdateUserLicenses\]\[google.cloud.discoveryengine.v1.UserLicenseService.BatchUpdateUserLicenses\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateUserLicensesRequest {
    /// Required. The parent \[UserStore\]\[\] resource name, format:
    /// `projects/{project}/locations/{location}/userStores/{user_store_id}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If true, if user licenses removed associated license config, the
    /// user license will be deleted. By default which is false, the user license
    /// will be updated to unassigned state.
    #[prost(bool, tag = "4")]
    pub delete_unassigned_user_licenses: bool,
    /// Required. The source of the input.
    #[prost(oneof = "batch_update_user_licenses_request::Source", tags = "2")]
    pub source: ::core::option::Option<batch_update_user_licenses_request::Source>,
}
/// Nested message and enum types in `BatchUpdateUserLicensesRequest`.
pub mod batch_update_user_licenses_request {
    /// The inline source for the input config for BatchUpdateUserLicenses
    /// method.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InlineSource {
        /// Required. A list of user licenses to update. Each user license
        /// must have a valid
        /// \[UserLicense.user_principal\]\[google.cloud.discoveryengine.v1.UserLicense.user_principal\].
        #[prost(message, repeated, tag = "1")]
        pub user_licenses: ::prost::alloc::vec::Vec<super::UserLicense>,
        /// Optional. The list of fields to update.
        #[prost(message, optional, tag = "2")]
        pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    }
    /// Required. The source of the input.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// The inline source for the input content for document embeddings.
        #[prost(message, tag = "2")]
        InlineSource(InlineSource),
    }
}
/// Metadata related to the progress of the
/// \[UserLicenseService.BatchUpdateUserLicenses\]\[google.cloud.discoveryengine.v1.UserLicenseService.BatchUpdateUserLicenses\]
/// operation. This will be returned by the google.longrunning.Operation.metadata
/// field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchUpdateUserLicensesMetadata {
    /// Operation create time.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Operation last update time. If the operation is done, this is also the
    /// finish time.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Count of user licenses successfully updated.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Count of user licenses that failed to be updated.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
/// Response message for
/// \[UserLicenseService.BatchUpdateUserLicenses\]\[google.cloud.discoveryengine.v1.UserLicenseService.BatchUpdateUserLicenses\]
/// method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateUserLicensesResponse {
    /// UserLicenses successfully updated.
    #[prost(message, repeated, tag = "1")]
    pub user_licenses: ::prost::alloc::vec::Vec<UserLicense>,
    /// A sample of errors encountered while processing the request.
    #[prost(message, repeated, tag = "2")]
    pub error_samples: ::prost::alloc::vec::Vec<super::super::super::rpc::Status>,
}
/// Generated client implementations.
pub mod user_license_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing User Licenses.
    #[derive(Debug, Clone)]
    pub struct UserLicenseServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserLicenseServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserLicenseServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserLicenseServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserLicenseServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the User Licenses.
        pub async fn list_user_licenses(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUserLicensesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUserLicensesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserLicenseService/ListUserLicenses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserLicenseService",
                        "ListUserLicenses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the User License.
        /// This method is used for batch assign/unassign licenses to users.
        pub async fn batch_update_user_licenses(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateUserLicensesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.discoveryengine.v1.UserLicenseService/BatchUpdateUserLicenses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.discoveryengine.v1.UserLicenseService",
                        "BatchUpdateUserLicenses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
