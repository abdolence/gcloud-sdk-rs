// This file is @generated by prost-build.
/// Blueprints are OCI Images that contain all of the artifacts needed to
/// provision a unit. Metadata such as, type of the engine used to actuate the
/// blueprint (e.g. terraform, helm etc) and version will come from the image
/// manifest. If the hostname is omitted, it will be assumed to be the regional
/// path to Artifact Registry (eg. us-east1-docker.pkg.dev).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Blueprint {
    /// Optional. Immutable. URI to a blueprint used by the Unit (required unless
    /// unitKind or release is set).
    #[prost(string, tag = "1")]
    pub package: ::prost::alloc::string::String,
    /// Output only. Type of the engine used to actuate the blueprint. e.g.
    /// terraform, helm etc.
    #[prost(string, tag = "2")]
    pub engine: ::prost::alloc::string::String,
    /// Output only. Version metadata if present on the blueprint.
    #[prost(string, tag = "3")]
    pub version: ::prost::alloc::string::String,
}
/// UnitVariable describes a parameter for a Unit.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnitVariable {
    /// Required. Immutable. Name of the variable from actuation configs.
    #[prost(string, tag = "1")]
    pub variable: ::prost::alloc::string::String,
    /// Optional. Immutable. Name of a supported variable type. Supported types are
    /// string, int, bool.
    #[prost(enumeration = "unit_variable::Type", tag = "2")]
    pub r#type: i32,
    /// Optional. String encoded value for the variable.
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UnitVariable`.
pub mod unit_variable {
    /// Enumeration of variable types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Variable type is unspecified.
        Unspecified = 0,
        /// Variable type is string.
        String = 1,
        /// Variable type is int.
        Int = 2,
        /// Variable type is bool.
        Bool = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::String => "STRING",
                Self::Int => "INT",
                Self::Bool => "BOOL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "INT" => Some(Self::Int),
                "BOOL" => Some(Self::Bool),
                _ => None,
            }
        }
    }
}
/// UnitCondition describes the status of an Unit. UnitCondition is individual
/// components that contribute to an overall state.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnitCondition {
    /// Required. Status of the condition.
    #[prost(enumeration = "unit_condition::Status", tag = "1")]
    pub status: i32,
    /// Required. Type of the condition.
    #[prost(enumeration = "unit_condition::Type", tag = "2")]
    pub r#type: i32,
    /// Required. Last time the condition transited from one status to another.
    #[prost(message, optional, tag = "3")]
    pub last_transition_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. Human readable message indicating details about the last
    /// transition.
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    /// Required. Brief reason for the condition's last transition.
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UnitCondition`.
pub mod unit_condition {
    /// Enumeration of condition statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Condition status is unspecified.
        Unspecified = 0,
        /// Condition is unknown.
        Unknown = 1,
        /// Condition is true.
        True = 2,
        /// Condition is false.
        False = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Unknown => "STATUS_UNKNOWN",
                Self::True => "STATUS_TRUE",
                Self::False => "STATUS_FALSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_UNKNOWN" => Some(Self::Unknown),
                "STATUS_TRUE" => Some(Self::True),
                "STATUS_FALSE" => Some(Self::False),
                _ => None,
            }
        }
    }
    /// Enumeration of condition types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Condition type is unspecified.
        Unspecified = 0,
        /// Condition type is ready.
        Ready = 1,
        /// Condition type is updating.
        Updating = 2,
        /// Condition type is provisioned.
        Provisioned = 3,
        /// Condition type is operationError.
        /// True when the last unit operation fails with a non-ignorable error.
        OperationError = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Ready => "TYPE_READY",
                Self::Updating => "TYPE_UPDATING",
                Self::Provisioned => "TYPE_PROVISIONED",
                Self::OperationError => "TYPE_OPERATION_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_READY" => Some(Self::Ready),
                "TYPE_UPDATING" => Some(Self::Updating),
                "TYPE_PROVISIONED" => Some(Self::Provisioned),
                "TYPE_OPERATION_ERROR" => Some(Self::OperationError),
                _ => None,
            }
        }
    }
}
/// UnitOperationCondition describes the status of an Unit Operation.
/// UnitOperationCondition is individual components that contribute to an overall
/// state.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnitOperationCondition {
    /// Required. Status of the condition.
    #[prost(enumeration = "unit_operation_condition::Status", tag = "1")]
    pub status: i32,
    /// Required. Type of the condition.
    #[prost(enumeration = "unit_operation_condition::Type", tag = "2")]
    pub r#type: i32,
    /// Required. Last time the condition transited from one status to another.
    #[prost(message, optional, tag = "3")]
    pub last_transition_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. Human readable message indicating details about the last
    /// transition.
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    /// Required. Brief reason for the condition's last transition.
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UnitOperationCondition`.
pub mod unit_operation_condition {
    /// Enumeration of condition statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Condition status is unspecified.
        Unspecified = 0,
        /// Condition is unknown.
        Unknown = 1,
        /// Condition is true.
        True = 2,
        /// Condition is false.
        False = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Unknown => "STATUS_UNKNOWN",
                Self::True => "STATUS_TRUE",
                Self::False => "STATUS_FALSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_UNKNOWN" => Some(Self::Unknown),
                "STATUS_TRUE" => Some(Self::True),
                "STATUS_FALSE" => Some(Self::False),
                _ => None,
            }
        }
    }
    /// Enumeration of condition types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Condition type is unspecified.
        Unspecified = 0,
        /// Condition type is scheduled.
        Scheduled = 2,
        /// Condition type is running.
        Running = 3,
        /// Condition type is succeeded.
        Succeeded = 4,
        /// Condition type is cancelled.
        Cancelled = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Scheduled => "TYPE_SCHEDULED",
                Self::Running => "TYPE_RUNNING",
                Self::Succeeded => "TYPE_SUCCEEDED",
                Self::Cancelled => "TYPE_CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_SCHEDULED" => Some(Self::Scheduled),
                "TYPE_RUNNING" => Some(Self::Running),
                "TYPE_SUCCEEDED" => Some(Self::Succeeded),
                "TYPE_CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
/// Represents the aggregation of a set of population of like records by a
/// certain group. For example, a collection of unit counts can be aggregated and
/// grouped by their state.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Aggregate {
    /// Required. Group by which to aggregate.
    #[prost(string, tag = "1")]
    pub group: ::prost::alloc::string::String,
    /// Required. Number of records in the group.
    #[prost(int32, tag = "2")]
    pub count: i32,
}
/// UnitOperationErrorCategory describes the error category of the unit
/// operation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UnitOperationErrorCategory {
    /// Unit operation error category is unspecified
    Unspecified = 0,
    /// Unit operation error category is not applicable, or it is not an error
    NotApplicable = 1,
    /// Unit operation error category is fatal
    Fatal = 2,
    /// Unit operation error category is retriable
    Retriable = 3,
    /// Unit operation error category is ignorable
    Ignorable = 4,
    /// Unit operation error category is standard, counts towards Rollout error
    /// budget
    Standard = 5,
}
impl UnitOperationErrorCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNIT_OPERATION_ERROR_CATEGORY_UNSPECIFIED",
            Self::NotApplicable => "NOT_APPLICABLE",
            Self::Fatal => "FATAL",
            Self::Retriable => "RETRIABLE",
            Self::Ignorable => "IGNORABLE",
            Self::Standard => "STANDARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNIT_OPERATION_ERROR_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "NOT_APPLICABLE" => Some(Self::NotApplicable),
            "FATAL" => Some(Self::Fatal),
            "RETRIABLE" => Some(Self::Retriable),
            "IGNORABLE" => Some(Self::Ignorable),
            "STANDARD" => Some(Self::Standard),
            _ => None,
        }
    }
}
/// Location information that the service is available in.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Location {
    /// Optional. Name of location.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Saas is a representation of a SaaS service managed by the Producer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Saas {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/saas/{saas}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. List of locations that the service is available in. Rollout
    /// refers to the list to generate a rollout plan.
    #[prost(message, repeated, tag = "4")]
    pub locations: ::prost::alloc::vec::Vec<Location>,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Tenant represents the service producer side of an instance of the
/// service created based on a request from a consumer. In a typical scenario a
/// Tenant has a one-to-one mapping with a resource given out to a service
/// consumer.
///
/// Example:
///
/// ```text
/// tenant:
///   name: "projects/svc1/locations/loc/tenants/inst-068afff8"
///   consumer_resource: "projects/gshoe/locations/loc/shoes/black-shoe"
/// ```
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tenant {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/tenants/{tenant}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Immutable. A reference to the consumer resource this SaaS Tenant
    /// is representing.
    ///
    /// The relationship with a consumer resource can be used by SaaS Runtime for
    /// retrieving consumer-defined settings and policies such as maintenance
    /// policies (using Unified Maintenance Policy API).
    #[prost(string, tag = "2")]
    pub consumer_resource: ::prost::alloc::string::String,
    /// Required. Immutable. A reference to the Saas that defines the product
    /// (managed service) that the producer wants to manage with SaaS Runtime. Part
    /// of the SaaS Runtime common data model.
    #[prost(string, tag = "3")]
    pub saas: ::prost::alloc::string::String,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Definition of a Unit. Units belonging to the same UnitKind are managed
/// together; for example they follow the same release model (blueprints,
/// versions etc.) and are typically rolled out together.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnitKind {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/unitKinds/{unitKind}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A reference to the Release object to use as default for creating
    /// new units of this UnitKind (optional).
    ///
    /// If not specified, a new unit must explicitly reference which release to use
    /// for its creation.
    #[prost(string, tag = "2")]
    pub default_release: ::prost::alloc::string::String,
    /// Optional. Immutable. List of other unit kinds that this release will depend
    /// on. Dependencies will be automatically provisioned if not found.
    /// Maximum 10.
    #[prost(message, repeated, tag = "4")]
    pub dependencies: ::prost::alloc::vec::Vec<Dependency>,
    /// Optional. List of inputVariables for this release that will either be
    /// retrieved from a dependency’s outputVariables, or will be passed on to a
    /// dependency’s inputVariables. Maximum 100.
    #[prost(message, repeated, tag = "5")]
    pub input_variable_mappings: ::prost::alloc::vec::Vec<VariableMapping>,
    /// Optional. List of outputVariables for this unit kind will be passed to this
    /// unit's outputVariables. Maximum 100.
    #[prost(message, repeated, tag = "6")]
    pub output_variable_mappings: ::prost::alloc::vec::Vec<VariableMapping>,
    /// Required. Immutable. A reference to the Saas that defines the product
    /// (managed service) that the producer wants to manage with SaaS Runtime. Part
    /// of the SaaS Runtime common data model. Immutable once set.
    #[prost(string, tag = "8")]
    pub saas: ::prost::alloc::string::String,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A unit of deployment that has its lifecycle via a CRUD API using an actuation
/// engine under the hood (e.g. based on Terraform, Helm or a custom
/// implementation provided by a service producer). A building block of a SaaS
/// Tenant.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unit {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/units/{unit}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Reference to the UnitKind this Unit belongs to. Immutable once
    /// set.
    #[prost(string, tag = "2")]
    pub unit_kind: ::prost::alloc::string::String,
    /// Optional. Output only. The current Release object for this Unit.
    #[prost(string, tag = "13")]
    pub release: ::prost::alloc::string::String,
    /// Optional. Reference to the Saas Tenant resource this unit belongs to. This
    /// for example informs the maintenance policies to use for scheduling future
    /// updates on a unit. (optional and immutable once created)
    #[prost(string, tag = "4")]
    pub tenant: ::prost::alloc::string::String,
    /// Optional. Output only. List of concurrent UnitOperations that are operating
    /// on this Unit.
    #[prost(string, repeated, tag = "5")]
    pub ongoing_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Output only. List of pending (wait to be executed) UnitOperations
    /// for this unit.
    #[prost(string, repeated, tag = "6")]
    pub pending_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Output only. List of scheduled UnitOperations for this unit.
    #[prost(string, repeated, tag = "24")]
    pub scheduled_operations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Output only. List of Units that depend on this unit. Unit can
    /// only be deprovisioned if this list is empty. Maximum 1000.
    #[prost(message, repeated, tag = "7")]
    pub dependents: ::prost::alloc::vec::Vec<UnitDependency>,
    /// Optional. Output only. Set of dependencies for this unit. Maximum 10.
    #[prost(message, repeated, tag = "8")]
    pub dependencies: ::prost::alloc::vec::Vec<UnitDependency>,
    /// Optional. Output only. Indicates the current input variables deployed by
    /// the unit
    #[prost(message, repeated, tag = "9")]
    pub input_variables: ::prost::alloc::vec::Vec<UnitVariable>,
    /// Optional. Output only. Set of key/value pairs corresponding to output
    /// variables from execution of actuation templates. The variables are declared
    /// in actuation configs (e.g in helm chart or terraform) and the values are
    /// fetched and returned by the actuation engine upon completion of execution.
    #[prost(message, repeated, tag = "10")]
    pub output_variables: ::prost::alloc::vec::Vec<UnitVariable>,
    /// Optional. Captures requested directives for performing future maintenance
    /// on the unit. This includes a request for the unit to skip maintenance for a
    /// period of time and remain pinned to its current release as well as controls
    /// for postponing maintenance scheduled in future.
    #[prost(message, optional, tag = "14")]
    pub maintenance: ::core::option::Option<unit::MaintenanceSettings>,
    /// Optional. Output only. Current lifecycle state of the resource (e.g. if
    /// it's being created or ready to use).
    #[prost(enumeration = "unit::UnitState", tag = "16")]
    pub state: i32,
    /// Optional. Output only. A set of conditions which indicate the various
    /// conditions this resource can have.
    #[prost(message, repeated, tag = "20")]
    pub conditions: ::prost::alloc::vec::Vec<UnitCondition>,
    /// Optional. Immutable. Indicates whether the Unit life cycle is controlled
    /// by the user or by the system.
    /// Immutable once created.
    #[prost(enumeration = "unit::ManagementMode", tag = "22")]
    pub management_mode: i32,
    /// Optional. Output only. Indicates the system managed state of the unit.
    #[prost(enumeration = "unit::SystemManagedState", tag = "25")]
    pub system_managed_state: i32,
    /// Optional. Output only. If set, indicates the time when the system will
    /// start removing the unit.
    #[prost(message, optional, tag = "26")]
    pub system_cleanup_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Unit`.
pub mod unit {
    /// Captures requested directives for performing future maintenance on the
    /// unit. This includes a request for the unit to skip maintenance for a period
    /// of time and remain pinned to its current release as well as controls for
    /// postponing maintenance scheduled in future.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MaintenanceSettings {
        /// Optional. If present, it fixes the release on the unit until the given
        /// time; i.e. changes to the release field will be rejected. Rollouts should
        /// and will also respect this by not requesting an upgrade in the first
        /// place.
        #[prost(message, optional, tag = "1")]
        pub pinned_until_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// UnitState annotates what is the current state of the unit itself.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnitState {
        /// Unspecified state.
        Unspecified = 0,
        /// Unit is not provisioned.
        NotProvisioned = 1,
        /// Unit is being provisioned.
        Provisioning = 2,
        /// Unit is being updated. This is typically when a unit is being upgraded to
        /// a new release or some of the input variables on the Unit is being
        /// changed. Certain kinds of updates may cause the Unit to become unusable
        /// while the update is in progress.
        Updating = 3,
        /// Unit is being deleted.
        Deprovisioning = 4,
        /// Unit has been provisioned and is ready for use
        Ready = 5,
        /// Unit has error, when it is not ready and some error operation
        Error = 6,
    }
    impl UnitState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_STATE_UNSPECIFIED",
                Self::NotProvisioned => "UNIT_STATE_NOT_PROVISIONED",
                Self::Provisioning => "UNIT_STATE_PROVISIONING",
                Self::Updating => "UNIT_STATE_UPDATING",
                Self::Deprovisioning => "UNIT_STATE_DEPROVISIONING",
                Self::Ready => "UNIT_STATE_READY",
                Self::Error => "UNIT_STATE_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNIT_STATE_NOT_PROVISIONED" => Some(Self::NotProvisioned),
                "UNIT_STATE_PROVISIONING" => Some(Self::Provisioning),
                "UNIT_STATE_UPDATING" => Some(Self::Updating),
                "UNIT_STATE_DEPROVISIONING" => Some(Self::Deprovisioning),
                "UNIT_STATE_READY" => Some(Self::Ready),
                "UNIT_STATE_ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
    /// ManagementMode describes who is responsible for the management of the unit.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagementMode {
        Unspecified = 0,
        /// Unit's lifecycle is managed by the user.
        User = 1,
        /// The system will decide when to deprovision and delete the unit.
        /// User still can deprovision or delete the unit manually.
        System = 2,
    }
    impl ManagementMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "MANAGEMENT_MODE_UNSPECIFIED",
                Self::User => "MANAGEMENT_MODE_USER",
                Self::System => "MANAGEMENT_MODE_SYSTEM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MANAGEMENT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "MANAGEMENT_MODE_USER" => Some(Self::User),
                "MANAGEMENT_MODE_SYSTEM" => Some(Self::System),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SystemManagedState {
        Unspecified = 0,
        /// Unit has dependents attached.
        Active = 1,
        /// Unit has no dependencies attached, but attachment is allowed.
        Inactive = 2,
        /// Unit has no dependencies attached, and attachment is not allowed.
        Decommissioned = 3,
    }
    impl SystemManagedState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SYSTEM_MANAGED_STATE_UNSPECIFIED",
                Self::Active => "SYSTEM_MANAGED_STATE_ACTIVE",
                Self::Inactive => "SYSTEM_MANAGED_STATE_INACTIVE",
                Self::Decommissioned => "SYSTEM_MANAGED_STATE_DECOMMISSIONED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SYSTEM_MANAGED_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SYSTEM_MANAGED_STATE_ACTIVE" => Some(Self::Active),
                "SYSTEM_MANAGED_STATE_INACTIVE" => Some(Self::Inactive),
                "SYSTEM_MANAGED_STATE_DECOMMISSIONED" => Some(Self::Decommissioned),
                _ => None,
            }
        }
    }
}
/// Set of dependencies for this unit. Maximum 10.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnitDependency {
    /// Output only. Alias for the name of the dependency.
    #[prost(string, tag = "1")]
    pub alias: ::prost::alloc::string::String,
    /// Output only. A reference to the Unit object.
    #[prost(string, tag = "2")]
    pub unit: ::prost::alloc::string::String,
}
/// UnitOperation encapsulates the intent of changing/interacting with the
/// service component represented by the specific Unit. Multiple UnitOperations
/// can be created (requested) and scheduled in the future, however only one will
/// be allowed to execute at a time (that can change in the future for
/// non-mutating operations).
///
/// UnitOperations allow different actors interacting with the same
/// unit to focus only on the change they have requested.
///
/// This is a base object that contains the common fields in all unit operations.
/// Next: 19
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnitOperation {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/unitOperations/{unitOperation}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. The Unit a given UnitOperation will act upon.
    #[prost(string, tag = "2")]
    pub unit: ::prost::alloc::string::String,
    /// Optional. Reference to parent resource: UnitOperation. If an operation
    /// needs to create other operations as part of its workflow, each of the child
    /// operations should have this field set to the parent. This can be used for
    /// tracing. (Optional)
    #[prost(string, tag = "3")]
    pub parent_unit_operation: ::prost::alloc::string::String,
    /// Optional. Specifies which rollout created this Unit Operation. This cannot
    /// be modified and is used for filtering purposes only. If a dependent unit
    /// and unit operation are created as part of another unit operation, they will
    /// use the same rolloutId.
    #[prost(string, tag = "4")]
    pub rollout: ::prost::alloc::string::String,
    /// Optional. When true, attempt to cancel the operation. Cancellation may fail
    /// if the operation is already executing. (Optional)
    #[prost(bool, tag = "5")]
    pub cancel: bool,
    /// Optional. Output only. UnitOperationState describes the current state of
    /// the unit operation.
    #[prost(enumeration = "unit_operation::UnitOperationState", tag = "6")]
    pub state: i32,
    /// Optional. Output only. A set of conditions which indicate the various
    /// conditions this resource can have.
    #[prost(message, repeated, tag = "7")]
    pub conditions: ::prost::alloc::vec::Vec<UnitOperationCondition>,
    /// Optional. When to schedule this operation.
    #[prost(message, optional, tag = "12")]
    pub schedule: ::core::option::Option<Schedule>,
    /// Optional. Output only. The engine state for on-going
    /// deployment engine operation(s).
    /// This field is opaque for external usage.
    #[prost(string, tag = "14")]
    pub engine_state: ::prost::alloc::string::String,
    /// Optional. Output only. UnitOperationErrorCategory describe the error
    /// category.
    #[prost(enumeration = "UnitOperationErrorCategory", tag = "15")]
    pub error_category: i32,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "unit_operation::UnitOperationType", tags = "8, 9, 10")]
    pub unit_operation_type: ::core::option::Option<unit_operation::UnitOperationType>,
}
/// Nested message and enum types in `UnitOperation`.
pub mod unit_operation {
    /// UnitOperationState describes the current state of the unit operation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnitOperationState {
        Unknown = 0,
        /// Unit operation is accepted but not ready to run.
        Pending = 1,
        /// Unit operation is accepted and scheduled.
        Scheduled = 2,
        /// Unit operation is running.
        Running = 4,
        /// Unit operation has completed successfully.
        Succeeded = 5,
        /// Unit operation has failed.
        Failed = 6,
        /// Unit operation was cancelled.
        Cancelled = 7,
    }
    impl UnitOperationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UNIT_OPERATION_STATE_UNKNOWN",
                Self::Pending => "UNIT_OPERATION_STATE_PENDING",
                Self::Scheduled => "UNIT_OPERATION_STATE_SCHEDULED",
                Self::Running => "UNIT_OPERATION_STATE_RUNNING",
                Self::Succeeded => "UNIT_OPERATION_STATE_SUCCEEDED",
                Self::Failed => "UNIT_OPERATION_STATE_FAILED",
                Self::Cancelled => "UNIT_OPERATION_STATE_CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_OPERATION_STATE_UNKNOWN" => Some(Self::Unknown),
                "UNIT_OPERATION_STATE_PENDING" => Some(Self::Pending),
                "UNIT_OPERATION_STATE_SCHEDULED" => Some(Self::Scheduled),
                "UNIT_OPERATION_STATE_RUNNING" => Some(Self::Running),
                "UNIT_OPERATION_STATE_SUCCEEDED" => Some(Self::Succeeded),
                "UNIT_OPERATION_STATE_FAILED" => Some(Self::Failed),
                "UNIT_OPERATION_STATE_CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum UnitOperationType {
        #[prost(message, tag = "8")]
        Provision(super::Provision),
        #[prost(message, tag = "9")]
        Upgrade(super::Upgrade),
        #[prost(message, tag = "10")]
        Deprovision(super::Deprovision),
    }
}
/// Provision is the unit operation that provision the underlying resources
/// represented by a Unit. Can only execute if the Unit is not currently
/// provisioned.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Provision {
    /// Optional. Reference to the Release object to use for the Unit. (optional).
    #[prost(string, tag = "1")]
    pub release: ::prost::alloc::string::String,
    /// Optional. Set of input variables. Maximum 100. (optional)
    #[prost(message, repeated, tag = "3")]
    pub input_variables: ::prost::alloc::vec::Vec<UnitVariable>,
}
/// Deprovision is the unit operation that deprovision the underlying
/// resources represented by a Unit. Can only execute if the Unit is currently
/// provisioned.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Deprovision {}
/// Upgrade is the unit operation that upgrades a provisioned unit, which may
/// also include the underlying resources represented by a Unit. Can only execute
/// if the Unit is currently provisioned.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Upgrade {
    /// Optional. Reference to the Release object to use for the Unit. (optional).
    #[prost(string, tag = "1")]
    pub release: ::prost::alloc::string::String,
    /// Optional. Set of input variables. Maximum 100. (optional)
    #[prost(message, repeated, tag = "2")]
    pub input_variables: ::prost::alloc::vec::Vec<UnitVariable>,
}
/// A time specification to schedule the maintenance.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Schedule {
    /// Optional. Start of operation. If not set, will be set to the start of the
    /// next window. (optional)
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A new version to be propagated and deployed to units. This includes pointers
/// to packaged blueprints for actuation (e.g Helm or Terraform configuration
/// packages) via artifact registry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Release {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/releases/{release}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. Reference to the UnitKind this Release corresponds to
    /// (required and immutable once created).
    #[prost(string, tag = "2")]
    pub unit_kind: ::prost::alloc::string::String,
    /// Optional. Blueprints are OCI Images that contain all of the artifacts
    /// needed to provision a unit.
    #[prost(message, optional, tag = "3")]
    pub blueprint: ::core::option::Option<Blueprint>,
    /// Optional. Set of requirements to be fulfilled on the Unit when using this
    /// Release.
    #[prost(message, optional, tag = "4")]
    pub release_requirements: ::core::option::Option<release::ReleaseRequirements>,
    /// Optional. Output only. List of input variables declared on the blueprint
    /// and can be present with their values on the unit spec
    #[prost(message, repeated, tag = "5")]
    pub input_variables: ::prost::alloc::vec::Vec<UnitVariable>,
    /// Optional. Output only. List of output variables declared on the blueprint
    /// and can be present with their values on the unit status
    #[prost(message, repeated, tag = "6")]
    pub output_variables: ::prost::alloc::vec::Vec<UnitVariable>,
    /// Optional. Mapping of input variables to default values. Maximum 100
    #[prost(message, repeated, tag = "7")]
    pub input_variable_defaults: ::prost::alloc::vec::Vec<UnitVariable>,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Release`.
pub mod release {
    /// Set of requirements to be fulfilled on the Unit when using this Release.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ReleaseRequirements {
        /// Optional. A list of releases from which a unit can be upgraded to this
        /// one (optional). If left empty no constraints will be applied. When
        /// provided, unit upgrade requests to this release will check and enforce
        /// this constraint.
        #[prost(string, repeated, tag = "1")]
        pub upgradeable_from_releases: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
}
/// Mapping of input variables to their respective output variable for
/// depedenencies
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VariableMapping {
    /// Required. name of the variable
    #[prost(string, tag = "1")]
    pub variable: ::prost::alloc::string::String,
    #[prost(oneof = "variable_mapping::MappingType", tags = "2, 3")]
    pub mapping_type: ::core::option::Option<variable_mapping::MappingType>,
}
/// Nested message and enum types in `VariableMapping`.
pub mod variable_mapping {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum MappingType {
        /// Optional. Output variables which will get their values from dependencies
        #[prost(message, tag = "2")]
        From(super::FromMapping),
        /// Optional. Input variables whose values will be passed on to dependencies.
        #[prost(message, tag = "3")]
        To(super::ToMapping),
    }
}
/// Output variables whose values will be passed on to dependencies
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FromMapping {
    /// Required. Alias of the dependency that the outputVariable will pass its
    /// value to
    #[prost(string, tag = "1")]
    pub dependency: ::prost::alloc::string::String,
    /// Required. Name of the outputVariable on the dependency
    #[prost(string, tag = "2")]
    pub output_variable: ::prost::alloc::string::String,
}
/// Input variables whose values will be passed on to dependencies
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ToMapping {
    /// Required. Alias of the dependency that the inputVariable will pass its
    /// value to
    #[prost(string, tag = "1")]
    pub dependency: ::prost::alloc::string::String,
    /// Required. Name of the inputVariable on the dependency
    #[prost(string, tag = "2")]
    pub input_variable: ::prost::alloc::string::String,
    /// Optional. Tells SaaS Runtime if this mapping should be used during lookup
    /// or not
    #[prost(bool, tag = "3")]
    pub ignore_for_lookup: bool,
}
/// Dependency represent a single dependency with another unit kind by alias.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Dependency {
    /// Required. Immutable. The unit kind of the dependency.
    #[prost(string, tag = "1")]
    pub unit_kind: ::prost::alloc::string::String,
    /// Required. An alias for the dependency. Used for input variable mapping.
    #[prost(string, tag = "2")]
    pub alias: ::prost::alloc::string::String,
}
/// The request structure for the ListSaas method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSaasRequest {
    /// Required. The parent of the saas.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of saas to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListSaas method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSaasResponse {
    /// The resulting saas.
    #[prost(message, repeated, tag = "10509")]
    pub saas: ::prost::alloc::vec::Vec<Saas>,
    /// If present, the next page token can be provided to a subsequent
    /// ListSaas call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetSaas method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSaasRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateSaas method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSaasRequest {
    /// Required. The parent of the saas.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new saas.
    #[prost(string, tag = "10503")]
    pub saas_id: ::prost::alloc::string::String,
    /// Required. The desired state for the saas.
    #[prost(message, optional, tag = "10504")]
    pub saas: ::core::option::Option<Saas>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateSaas method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSaasRequest {
    /// Required. The desired state for the saas.
    #[prost(message, optional, tag = "10504")]
    pub saas: ::core::option::Option<Saas>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// Saas resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// Saas will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteSaas method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteSaasRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the saas. This is
    /// used with state-changing methods to prevent accidental overwrites when
    /// multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the saas. The Any wildcard (`*`) requires that the resource
    /// must already exists, and the Not Any wildcard (`!*`) requires that it must
    /// not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the ListTenants method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTenantsRequest {
    /// Required. The parent of the tenant.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of tenants to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListTenants method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTenantsResponse {
    /// The resulting tenants.
    #[prost(message, repeated, tag = "10509")]
    pub tenants: ::prost::alloc::vec::Vec<Tenant>,
    /// If present, the next page token can be provided to a subsequent
    /// ListTenants call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetTenant method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTenantRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateTenant method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateTenantRequest {
    /// Required. The parent of the tenant.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new tenant.
    #[prost(string, tag = "10503")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Required. The desired state for the tenant.
    #[prost(message, optional, tag = "10504")]
    pub tenant: ::core::option::Option<Tenant>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateTenant method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateTenantRequest {
    /// Required. The desired state for the tenant.
    #[prost(message, optional, tag = "10504")]
    pub tenant: ::core::option::Option<Tenant>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// Tenant resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// Tenant will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteTenant method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteTenantRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the tenant. This is
    /// used with state-changing methods to prevent accidental overwrites when
    /// multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the tenant. The Any wildcard (`*`) requires that the resource
    /// must already exists, and the Not Any wildcard (`!*`) requires that it must
    /// not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the ListUnitKinds method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListUnitKindsRequest {
    /// Required. The parent of the unit kind.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of unit kinds to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListUnitKinds method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUnitKindsResponse {
    /// The resulting unit kinds.
    #[prost(message, repeated, tag = "10509")]
    pub unit_kinds: ::prost::alloc::vec::Vec<UnitKind>,
    /// If present, the next page token can be provided to a subsequent
    /// ListUnitKinds call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetUnitKind method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetUnitKindRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateUnitKind method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUnitKindRequest {
    /// Required. The parent of the unit kind.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new unit kind.
    #[prost(string, tag = "10503")]
    pub unit_kind_id: ::prost::alloc::string::String,
    /// Required. The desired state for the unit kind.
    #[prost(message, optional, tag = "10504")]
    pub unit_kind: ::core::option::Option<UnitKind>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateUnitKind method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUnitKindRequest {
    /// Required. The desired state for the unit kind.
    #[prost(message, optional, tag = "10504")]
    pub unit_kind: ::core::option::Option<UnitKind>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// UnitKind resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// UnitKind will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteUnitKind method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteUnitKindRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the unit kind. This
    /// is used with state-changing methods to prevent accidental overwrites when
    /// multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the unit kind. The Any wildcard (`*`) requires that the
    /// resource must already exists, and the Not Any wildcard (`!*`) requires that
    /// it must not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the ListUnits method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListUnitsRequest {
    /// Required. The parent of the unit.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of units to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListUnits method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUnitsResponse {
    /// The resulting units.
    #[prost(message, repeated, tag = "10509")]
    pub units: ::prost::alloc::vec::Vec<Unit>,
    /// If present, the next page token can be provided to a subsequent
    /// ListUnits call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetUnit method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetUnitRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateUnit method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUnitRequest {
    /// Required. The parent of the unit.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new unit.
    #[prost(string, tag = "10503")]
    pub unit_id: ::prost::alloc::string::String,
    /// Required. The desired state for the unit.
    #[prost(message, optional, tag = "10504")]
    pub unit: ::core::option::Option<Unit>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateUnit method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUnitRequest {
    /// Required. The desired state for the unit.
    #[prost(message, optional, tag = "10504")]
    pub unit: ::core::option::Option<Unit>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// Unit resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// Unit will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteUnit method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteUnitRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the unit. This is
    /// used with state-changing methods to prevent accidental overwrites when
    /// multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the unit. The Any wildcard (`*`) requires that the resource
    /// must already exists, and the Not Any wildcard (`!*`) requires that it must
    /// not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the ListUnitOperations method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListUnitOperationsRequest {
    /// Required. The parent of the unit operation.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of unit operations to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListUnitOperations method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUnitOperationsResponse {
    /// The resulting unit operations.
    #[prost(message, repeated, tag = "10509")]
    pub unit_operations: ::prost::alloc::vec::Vec<UnitOperation>,
    /// If present, the next page token can be provided to a subsequent
    /// ListUnitOperations call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetUnitOperation method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetUnitOperationRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateUnitOperation method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateUnitOperationRequest {
    /// Required. The parent of the unit operation.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new unit operation.
    #[prost(string, tag = "10503")]
    pub unit_operation_id: ::prost::alloc::string::String,
    /// Required. The desired state for the unit operation.
    #[prost(message, optional, tag = "10504")]
    pub unit_operation: ::core::option::Option<UnitOperation>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateUnitOperation method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUnitOperationRequest {
    /// Required. The desired state for the unit operation.
    #[prost(message, optional, tag = "10504")]
    pub unit_operation: ::core::option::Option<UnitOperation>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// UnitOperation resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// UnitOperation will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteUnitOperation method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteUnitOperationRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the unit operation.
    /// This is used with state-changing methods to prevent accidental overwrites
    /// when multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the unit operation. The Any wildcard (`*`) requires that the
    /// resource must already exists, and the Not Any wildcard (`!*`) requires that
    /// it must not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the ListReleases method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListReleasesRequest {
    /// Required. The parent of the release.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of releases to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListReleases method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReleasesResponse {
    /// The resulting releases.
    #[prost(message, repeated, tag = "10509")]
    pub releases: ::prost::alloc::vec::Vec<Release>,
    /// If present, the next page token can be provided to a subsequent
    /// ListReleases call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetRelease method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetReleaseRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateRelease method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReleaseRequest {
    /// Required. The parent of the release.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new release.
    #[prost(string, tag = "10503")]
    pub release_id: ::prost::alloc::string::String,
    /// Required. The desired state for the release.
    #[prost(message, optional, tag = "10504")]
    pub release: ::core::option::Option<Release>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateRelease method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReleaseRequest {
    /// Required. The desired state for the release.
    #[prost(message, optional, tag = "10504")]
    pub release: ::core::option::Option<Release>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// Release resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// Release will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteRelease method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteReleaseRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the release. This is
    /// used with state-changing methods to prevent accidental overwrites when
    /// multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the release. The Any wildcard (`*`) requires that the resource
    /// must already exists, and the Not Any wildcard (`!*`) requires that it must
    /// not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod saas_deployments_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages the deployment of SaaS services.
    #[derive(Debug, Clone)]
    pub struct SaasDeploymentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SaasDeploymentsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SaasDeploymentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SaasDeploymentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SaasDeploymentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieve a collection of saas.
        pub async fn list_saas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSaasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSaasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/ListSaas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "ListSaas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single saas.
        pub async fn get_saas(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSaasRequest>,
        ) -> std::result::Result<tonic::Response<super::Saas>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/GetSaas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "GetSaas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new saas.
        pub async fn create_saas(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSaasRequest>,
        ) -> std::result::Result<tonic::Response<super::Saas>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/CreateSaas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "CreateSaas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single saas.
        pub async fn update_saas(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSaasRequest>,
        ) -> std::result::Result<tonic::Response<super::Saas>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/UpdateSaas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "UpdateSaas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single saas.
        pub async fn delete_saas(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSaasRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/DeleteSaas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "DeleteSaas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a collection of tenants.
        pub async fn list_tenants(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTenantsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTenantsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/ListTenants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "ListTenants",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single tenant.
        pub async fn get_tenant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTenantRequest>,
        ) -> std::result::Result<tonic::Response<super::Tenant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/GetTenant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "GetTenant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new tenant.
        pub async fn create_tenant(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTenantRequest>,
        ) -> std::result::Result<tonic::Response<super::Tenant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/CreateTenant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "CreateTenant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single tenant.
        pub async fn update_tenant(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTenantRequest>,
        ) -> std::result::Result<tonic::Response<super::Tenant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/UpdateTenant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "UpdateTenant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single tenant.
        pub async fn delete_tenant(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTenantRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/DeleteTenant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "DeleteTenant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a collection of unit kinds.
        pub async fn list_unit_kinds(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUnitKindsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUnitKindsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/ListUnitKinds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "ListUnitKinds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single unit kind.
        pub async fn get_unit_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUnitKindRequest>,
        ) -> std::result::Result<tonic::Response<super::UnitKind>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/GetUnitKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "GetUnitKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new unit kind.
        pub async fn create_unit_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUnitKindRequest>,
        ) -> std::result::Result<tonic::Response<super::UnitKind>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/CreateUnitKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "CreateUnitKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single unit kind.
        pub async fn update_unit_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUnitKindRequest>,
        ) -> std::result::Result<tonic::Response<super::UnitKind>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/UpdateUnitKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "UpdateUnitKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single unit kind.
        pub async fn delete_unit_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUnitKindRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/DeleteUnitKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "DeleteUnitKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a collection of units.
        pub async fn list_units(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/ListUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "ListUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single unit.
        pub async fn get_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::Unit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/GetUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "GetUnit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new unit.
        pub async fn create_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::Unit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/CreateUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "CreateUnit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single unit.
        pub async fn update_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::Unit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/UpdateUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "UpdateUnit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single unit.
        pub async fn delete_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUnitRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/DeleteUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "DeleteUnit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a collection of unit operations.
        pub async fn list_unit_operations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUnitOperationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUnitOperationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/ListUnitOperations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "ListUnitOperations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single unit operation.
        pub async fn get_unit_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUnitOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::UnitOperation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/GetUnitOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "GetUnitOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new unit operation.
        pub async fn create_unit_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateUnitOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::UnitOperation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/CreateUnitOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "CreateUnitOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single unit operation.
        pub async fn update_unit_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUnitOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::UnitOperation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/UpdateUnitOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "UpdateUnitOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single unit operation.
        pub async fn delete_unit_operation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUnitOperationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/DeleteUnitOperation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "DeleteUnitOperation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a collection of releases.
        pub async fn list_releases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReleasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReleasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/ListReleases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "ListReleases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single release.
        pub async fn get_release(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReleaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Release>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/GetRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "GetRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new release.
        pub async fn create_release(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReleaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Release>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/CreateRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "CreateRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single release.
        pub async fn update_release(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReleaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Release>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/UpdateRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "UpdateRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single release.
        pub async fn delete_release(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReleaseRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments/DeleteRelease",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasDeployments",
                        "DeleteRelease",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a single rollout execution and its results
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rollout {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/rollout/{rollout_id}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Immutable. Name of the Release that gets rolled out to target
    /// Units. Required if no other type of release is specified.
    #[prost(string, tag = "3")]
    pub release: ::prost::alloc::string::String,
    /// Optional. Output only. The time when the rollout started executing. Will be
    /// empty if the rollout hasn't started yet.
    #[prost(message, optional, tag = "7")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Output only. The time when the rollout finished execution
    /// (regardless of  success, failure, or cancellation). Will be empty if the
    /// rollout hasn't finished yet. Once set, the rollout is in terminal state and
    /// all the results are final.
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Current state of the rollout.
    #[prost(enumeration = "rollout::RolloutState", tag = "10")]
    pub state: i32,
    /// Output only. Human readable message indicating details about the last state
    /// transition.
    #[prost(string, tag = "11")]
    pub state_message: ::prost::alloc::string::String,
    /// Optional. Output only. The time when the rollout transitioned into its
    /// current state.
    #[prost(message, optional, tag = "12")]
    pub state_transition_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Output only. The root rollout that this rollout is stemming from.
    /// The resource name (full URI of the resource) following the standard naming
    /// scheme:
    ///
    /// "projects/{project}/locations/{location}/rollouts/{rollout_id}"
    #[prost(string, tag = "16")]
    pub root_rollout: ::prost::alloc::string::String,
    /// Optional. Output only. The direct parent rollout that this rollout is
    /// stemming from. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/rollouts/{rollout_id}"
    #[prost(string, tag = "17")]
    pub parent_rollout: ::prost::alloc::string::String,
    /// Optional. The strategy used for executing this Rollout.
    /// This strategy will override whatever strategy is specified in the
    /// RolloutType. If not specified on creation, the
    /// strategy from RolloutType will be used.
    ///
    /// There are two supported values strategies which are used to control
    ///
    /// * "Google.Cloud.Simple.AllAtOnce"
    /// * "Google.Cloud.Simple.OneLocationAtATime"
    ///
    /// A rollout with one of these simple strategies will rollout across
    /// all locations defined in the targeted UnitKind's Saas Locations.
    #[prost(string, tag = "19")]
    pub rollout_orchestration_strategy: ::prost::alloc::string::String,
    /// Optional. CEL(<https://github.com/google/cel-spec>) formatted filter string
    /// against Unit. The filter will be applied to determine the eligible unit
    /// population. This filter can only reduce, but not expand the scope of the
    /// rollout. If not provided, the unit_filter from the RolloutType will be
    /// used.
    #[prost(string, tag = "21")]
    pub unit_filter: ::prost::alloc::string::String,
    /// Optional. Immutable. Name of the RolloutKind this rollout is stemming from
    /// and adhering to.
    #[prost(string, tag = "22")]
    pub rollout_kind: ::prost::alloc::string::String,
    /// Optional. Output only. Details about the progress of the rollout.
    #[prost(message, optional, tag = "24")]
    pub stats: ::core::option::Option<RolloutStats>,
    /// Optional. Requested change to the execution of this rollout.
    /// Default RolloutControl.action is ROLLOUT_ACTION_RUN meaning
    /// the rollout will be executed to completion while progressing through
    /// all natural Rollout States (such as RUNNING -> SUCCEEDED or RUNNING ->
    /// FAILED). Requests can only be made when the Rollout is in a non-terminal
    /// state.
    #[prost(message, optional, tag = "25")]
    pub control: ::core::option::Option<RolloutControl>,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Rollout`.
pub mod rollout {
    /// The current state of the rollout.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RolloutState {
        /// Unspecified state.
        Unspecified = 0,
        /// Rollout is in progress.
        Running = 1,
        /// Rollout has been paused.
        Paused = 2,
        /// Rollout completed successfully.
        Succeeded = 3,
        /// Rollout has failed.
        Failed = 4,
        /// Rollout has been canceled.
        Cancelled = 5,
        /// Rollout is waiting for some condition to be met before starting.
        Waiting = 6,
        /// Rollout is being canceled.
        Cancelling = 7,
        /// Rollout is being resumed.
        Resuming = 8,
        /// Rollout is being paused.
        Pausing = 9,
    }
    impl RolloutState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ROLLOUT_STATE_UNSPECIFIED",
                Self::Running => "ROLLOUT_STATE_RUNNING",
                Self::Paused => "ROLLOUT_STATE_PAUSED",
                Self::Succeeded => "ROLLOUT_STATE_SUCCEEDED",
                Self::Failed => "ROLLOUT_STATE_FAILED",
                Self::Cancelled => "ROLLOUT_STATE_CANCELLED",
                Self::Waiting => "ROLLOUT_STATE_WAITING",
                Self::Cancelling => "ROLLOUT_STATE_CANCELLING",
                Self::Resuming => "ROLLOUT_STATE_RESUMING",
                Self::Pausing => "ROLLOUT_STATE_PAUSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLLOUT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ROLLOUT_STATE_RUNNING" => Some(Self::Running),
                "ROLLOUT_STATE_PAUSED" => Some(Self::Paused),
                "ROLLOUT_STATE_SUCCEEDED" => Some(Self::Succeeded),
                "ROLLOUT_STATE_FAILED" => Some(Self::Failed),
                "ROLLOUT_STATE_CANCELLED" => Some(Self::Cancelled),
                "ROLLOUT_STATE_WAITING" => Some(Self::Waiting),
                "ROLLOUT_STATE_CANCELLING" => Some(Self::Cancelling),
                "ROLLOUT_STATE_RESUMING" => Some(Self::Resuming),
                "ROLLOUT_STATE_PAUSING" => Some(Self::Pausing),
                _ => None,
            }
        }
    }
}
/// An object that describes various settings of Rollout execution. Includes
/// built-in policies across GCP and GDC, and customizable policies.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutKind {
    /// Identifier. The resource name (full URI of the resource) following the
    /// standard naming scheme:
    ///
    /// "projects/{project}/locations/{location}/rolloutKinds/{rollout_kind_id}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. UnitKind that this rollout kind corresponds to.
    /// Rollouts stemming from this rollout kind will target the units of this unit
    /// kind. In other words, this defines the population of target units to be
    /// upgraded by rollouts.
    #[prost(string, tag = "2")]
    pub unit_kind: ::prost::alloc::string::String,
    /// Optional. The strategy used for executing a Rollout. This is a required
    /// field.
    ///
    /// There are two supported values strategies which are used to control
    ///
    /// * "Google.Cloud.Simple.AllAtOnce"
    /// * "Google.Cloud.Simple.OneLocationAtATime"
    ///
    /// A rollout with one of these simple strategies will rollout across
    /// all locations defined in the associated UnitKind's Saas Locations.
    #[prost(string, tag = "3")]
    pub rollout_orchestration_strategy: ::prost::alloc::string::String,
    /// Optional. CEL(<https://github.com/google/cel-spec>) formatted filter string
    /// against Unit. The filter will be applied to determine the eligible unit
    /// population. This filter can only reduce, but not expand the scope of the
    /// rollout.
    #[prost(string, tag = "5")]
    pub unit_filter: ::prost::alloc::string::String,
    /// Optional. The config for updating the unit kind. By default, the unit kind
    /// will be updated on the rollout start.
    #[prost(enumeration = "rollout_kind::UpdateUnitKindStrategy", tag = "6")]
    pub update_unit_kind_strategy: i32,
    /// Optional. The configuration for error budget. If the number of failed units
    /// exceeds max(allowed_count, allowed_ratio * total_units), the rollout will
    /// be paused. If not set, all units will be attempted to be updated regardless
    /// of the number of failures encountered.
    #[prost(message, optional, tag = "7")]
    pub error_budget: ::core::option::Option<ErrorBudget>,
    /// Optional. The labels on the resource, which can be used for categorization.
    /// similar to Kubernetes resource labels.
    #[prost(map = "string, string", tag = "10401")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Annotations is an unstructured key-value map stored with a
    /// resource that may be set by external tools to store and retrieve arbitrary
    /// metadata. They are not queryable and should be preserved when modifying
    /// objects.
    ///
    /// More info: <https://kubernetes.io/docs/user-guide/annotations>
    #[prost(map = "string, string", tag = "10402")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The unique identifier of the resource. UID is unique in the
    /// time and space for this resource within the scope of the service. It is
    /// typically generated by the server on successful creation of a resource
    /// and must not be changed. UID is used to uniquely identify resources
    /// with resource name reuses. This should be a UUID4.
    #[prost(string, tag = "10201")]
    pub uid: ::prost::alloc::string::String,
    /// Output only. An opaque value that uniquely identifies a version or
    /// generation of a resource. It can be used to confirm that the client
    /// and server agree on the ordering of a resource being written.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The timestamp when the resource was created.
    #[prost(message, optional, tag = "10303")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the resource was last updated. Any
    /// change to the resource made by users must refresh this value.
    /// Changes to a resource made by the service should refresh this value.
    #[prost(message, optional, tag = "10304")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `RolloutKind`.
pub mod rollout_kind {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UpdateUnitKindStrategy {
        /// Strategy unspecified.
        Unspecified = 0,
        /// Update the unit kind strategy on the rollout start.
        OnStart = 1,
        /// Never update the unit kind.
        Never = 2,
    }
    impl UpdateUnitKindStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UPDATE_UNIT_KIND_STRATEGY_UNSPECIFIED",
                Self::OnStart => "UPDATE_UNIT_KIND_STRATEGY_ON_START",
                Self::Never => "UPDATE_UNIT_KIND_STRATEGY_NEVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UPDATE_UNIT_KIND_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "UPDATE_UNIT_KIND_STRATEGY_ON_START" => Some(Self::OnStart),
                "UPDATE_UNIT_KIND_STRATEGY_NEVER" => Some(Self::Never),
                _ => None,
            }
        }
    }
}
/// The configuration for error budget. If the number of failed units exceeds
/// max(allowed_count, allowed_ratio * total_units), the rollout will be paused.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ErrorBudget {
    /// Optional. The maximum number of failed units allowed in a location without
    /// pausing the rollout.
    #[prost(int32, tag = "1")]
    pub allowed_count: i32,
    /// Optional. The maximum percentage of units allowed to fail (0, 100\] within a
    /// location without pausing the rollout.
    #[prost(int32, tag = "2")]
    pub allowed_percentage: i32,
}
/// RolloutStats contains information about the progress of a rollout.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RolloutStats {
    /// Output only. A breakdown of the progress of operations triggered by the
    /// rollout. Provides a count of Operations by their state. This can be used to
    /// determine the number of units which have been updated, or are scheduled to
    /// be updated.
    ///
    /// There will be at most one entry per group.
    /// Possible values for operation groups are:
    ///
    /// * "SCHEDULED"
    /// * "PENDING"
    /// * "RUNNING"
    /// * "SUCCEEDED"
    /// * "FAILED"
    /// * "CANCELLED"
    #[prost(message, repeated, tag = "2")]
    pub operations_by_state: ::prost::alloc::vec::Vec<Aggregate>,
}
/// RolloutControl provides a way to request a change to the execution of a
/// Rollout by pausing or canceling it.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RolloutControl {
    /// Required. Action to be performed on the Rollout.
    /// The default behavior is to run the rollout until it naturally reaches a
    /// terminal state.
    #[prost(enumeration = "RolloutAction", tag = "1")]
    pub action: i32,
    /// Setting for the action. The setting must match the action
    /// e.g.: action=RUN may only set run_params or omit all parameters.
    /// It is an error to set a setting that is not applicable to the action.
    #[prost(oneof = "rollout_control::ActionParams", tags = "2")]
    pub action_params: ::core::option::Option<rollout_control::ActionParams>,
}
/// Nested message and enum types in `RolloutControl`.
pub mod rollout_control {
    /// Parameters for the RUN action controlling the behavior of the rollout
    /// when it is resumed from a PAUSED state.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RunRolloutActionParams {
        /// Required. If true, the rollout will retry failed operations when resumed.
        /// This is applicable only the current state of the Rollout is PAUSED and
        /// the requested action is RUN.
        #[prost(bool, tag = "1")]
        pub retry_failed_operations: bool,
    }
    /// Setting for the action. The setting must match the action
    /// e.g.: action=RUN may only set run_params or omit all parameters.
    /// It is an error to set a setting that is not applicable to the action.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ActionParams {
        /// Optional. Parameters for the RUN action. It is an error to specify this
        /// if the RolloutAction is not set to RUN. By default, the rollout will
        /// retry failed operations when resumed.
        #[prost(message, tag = "2")]
        RunParams(RunRolloutActionParams),
    }
}
/// RolloutAction indicates the action to be performed on the Rollout.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RolloutAction {
    /// Unspecified action, will be treated as RUN by default.
    Unspecified = 0,
    /// Run the Rollout until it naturally reaches a terminal state.
    /// A rollout requested to run will progress through all natural Rollout
    /// States (such as RUNNING -> SUCCEEDED or RUNNING -> FAILED).
    /// If retriable errors are encountered during the rollout, the rollout
    /// will paused by default and can be resumed by re-requesting this RUN
    /// action.
    Run = 1,
    /// Pause the Rollout until it is resumed (i.e. RUN is requested).
    Pause = 2,
    /// Cancel the Rollout permanently.
    Cancel = 3,
}
impl RolloutAction {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ROLLOUT_ACTION_UNSPECIFIED",
            Self::Run => "ROLLOUT_ACTION_RUN",
            Self::Pause => "ROLLOUT_ACTION_PAUSE",
            Self::Cancel => "ROLLOUT_ACTION_CANCEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLLOUT_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
            "ROLLOUT_ACTION_RUN" => Some(Self::Run),
            "ROLLOUT_ACTION_PAUSE" => Some(Self::Pause),
            "ROLLOUT_ACTION_CANCEL" => Some(Self::Cancel),
            _ => None,
        }
    }
}
/// The request structure for the ListRollouts method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRolloutsRequest {
    /// Required. The parent of the rollout.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of rollouts to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListRollouts method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolloutsResponse {
    /// The resulting rollouts.
    #[prost(message, repeated, tag = "10509")]
    pub rollouts: ::prost::alloc::vec::Vec<Rollout>,
    /// If present, the next page token can be provided to a subsequent
    /// ListRollouts call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetRollout method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRolloutRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateRollout method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRolloutRequest {
    /// Required. The parent of the rollout.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new rollout.
    #[prost(string, tag = "10503")]
    pub rollout_id: ::prost::alloc::string::String,
    /// Required. The desired state for the rollout.
    #[prost(message, optional, tag = "10504")]
    pub rollout: ::core::option::Option<Rollout>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateRollout method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRolloutRequest {
    /// Required. The desired state for the rollout.
    #[prost(message, optional, tag = "10504")]
    pub rollout: ::core::option::Option<Rollout>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// Rollout resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// Rollout will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteRollout method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteRolloutRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the rollout. This is
    /// used with state-changing methods to prevent accidental overwrites when
    /// multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the rollout. The Any wildcard (`*`) requires that the resource
    /// must already exists, and the Not Any wildcard (`!*`) requires that it must
    /// not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the ListRolloutKinds method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRolloutKindsRequest {
    /// Required. The parent of the rollout kind.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of rollout kinds to send per page.
    #[prost(int32, tag = "10505")]
    pub page_size: i32,
    /// The page token: If the next_page_token from a previous response
    /// is provided, this request will send the subsequent page.
    #[prost(string, tag = "10506")]
    pub page_token: ::prost::alloc::string::String,
    /// Filter the list as specified in <https://google.aip.dev/160.>
    #[prost(string, tag = "10507")]
    pub filter: ::prost::alloc::string::String,
    /// Order results as specified in <https://google.aip.dev/132.>
    #[prost(string, tag = "10508")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response structure for the ListRolloutKinds method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolloutKindsResponse {
    /// The resulting rollout kinds.
    #[prost(message, repeated, tag = "10509")]
    pub rollout_kinds: ::prost::alloc::vec::Vec<RolloutKind>,
    /// If present, the next page token can be provided to a subsequent
    /// ListRolloutKinds call to list the next page.
    /// If empty, there are no more pages.
    #[prost(string, tag = "10510")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "10511")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request structure for the GetRolloutKind method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRolloutKindRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
}
/// The request structure for the CreateRolloutKind method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRolloutKindRequest {
    /// Required. The parent of the rollout kind.
    #[prost(string, tag = "10006")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The ID value for the new rollout kind.
    #[prost(string, tag = "10503")]
    pub rollout_kind_id: ::prost::alloc::string::String,
    /// Required. The desired state for the rollout kind.
    #[prost(message, optional, tag = "10504")]
    pub rollout_kind: ::core::option::Option<RolloutKind>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// The request structure for the UpdateRolloutKind method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRolloutKindRequest {
    /// Required. The desired state for the rollout kind.
    #[prost(message, optional, tag = "10504")]
    pub rollout_kind: ::core::option::Option<RolloutKind>,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
    /// Field mask is used to specify the fields to be overwritten in the
    /// RolloutKind resource by the update.
    ///
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask.
    ///
    /// If the user does not provide a mask then all fields in the
    /// RolloutKind will be overwritten.
    #[prost(message, optional, tag = "10512")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request structure for the DeleteRolloutKind method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteRolloutKindRequest {
    /// Required. The resource name of the resource within a service.
    #[prost(string, tag = "10001")]
    pub name: ::prost::alloc::string::String,
    /// The etag known to the client for the expected state of the rollout kind.
    /// This is used with state-changing methods to prevent accidental overwrites
    /// when multiple user agents might be acting in parallel on the same resource.
    ///
    /// An etag wildcard provide optimistic concurrency based on the expected
    /// existence of the rollout kind. The Any wildcard (`*`) requires that the
    /// resource must already exists, and the Not Any wildcard (`!*`) requires that
    /// it must not.
    #[prost(string, tag = "10202")]
    pub etag: ::prost::alloc::string::String,
    /// If "validate_only" is set to true, the service will try to validate
    /// that this request would succeed, but will not actually make changes.
    #[prost(bool, tag = "10501")]
    pub validate_only: bool,
    /// An optional request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "10502")]
    pub request_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod saas_rollouts_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages the rollout of SaaS services.
    #[derive(Debug, Clone)]
    pub struct SaasRolloutsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SaasRolloutsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SaasRolloutsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SaasRolloutsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SaasRolloutsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieve a collection of rollouts.
        pub async fn list_rollouts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRolloutsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRolloutsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/ListRollouts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "ListRollouts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single rollout.
        pub async fn get_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRolloutRequest>,
        ) -> std::result::Result<tonic::Response<super::Rollout>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/GetRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "GetRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new rollout.
        pub async fn create_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRolloutRequest>,
        ) -> std::result::Result<tonic::Response<super::Rollout>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/CreateRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "CreateRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single rollout.
        pub async fn update_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRolloutRequest>,
        ) -> std::result::Result<tonic::Response<super::Rollout>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/UpdateRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "UpdateRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single rollout.
        pub async fn delete_rollout(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRolloutRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/DeleteRollout",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "DeleteRollout",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a collection of rollout kinds.
        pub async fn list_rollout_kinds(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRolloutKindsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRolloutKindsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/ListRolloutKinds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "ListRolloutKinds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single rollout kind.
        pub async fn get_rollout_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRolloutKindRequest>,
        ) -> std::result::Result<tonic::Response<super::RolloutKind>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/GetRolloutKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "GetRolloutKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new rollout kind.
        pub async fn create_rollout_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRolloutKindRequest>,
        ) -> std::result::Result<tonic::Response<super::RolloutKind>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/CreateRolloutKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "CreateRolloutKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a single rollout kind.
        pub async fn update_rollout_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRolloutKindRequest>,
        ) -> std::result::Result<tonic::Response<super::RolloutKind>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/UpdateRolloutKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "UpdateRolloutKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a single rollout kind.
        pub async fn delete_rollout_kind(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRolloutKindRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts/DeleteRolloutKind",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.saasplatform.saasservicemgmt.v1beta1.SaasRollouts",
                        "DeleteRolloutKind",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
