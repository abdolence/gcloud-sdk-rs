// This file is @generated by prost-build.
/// The Storage Batch Operations Job description.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Job {
    /// Identifier. The resource name of the Job. job_id is unique
    /// within the project, that is either set by the customer or
    /// defined by the service. Format:
    /// projects/{project}/locations/global/jobs/{job_id} .
    /// For example: "projects/123456/locations/global/jobs/job01".
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A description provided by the user for the job. Its max length is
    /// 1024 bytes when Unicode-encoded.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Logging configuration.
    #[prost(message, optional, tag = "9")]
    pub logging_config: ::core::option::Option<LoggingConfig>,
    /// Output only. The time that the job was created.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time that the job was scheduled.
    #[prost(message, optional, tag = "11")]
    pub schedule_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time that the job was completed.
    #[prost(message, optional, tag = "12")]
    pub complete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Information about the progress of the job.
    #[prost(message, optional, tag = "13")]
    pub counters: ::core::option::Option<Counters>,
    /// Output only. Summarizes errors encountered with sample error log entries.
    #[prost(message, repeated, tag = "14")]
    pub error_summaries: ::prost::alloc::vec::Vec<ErrorSummary>,
    /// Output only. State of the job.
    #[prost(enumeration = "job::State", tag = "15")]
    pub state: i32,
    /// Specifies objects to be transformed.
    #[prost(oneof = "job::Source", tags = "19")]
    pub source: ::core::option::Option<job::Source>,
    /// Operation to be performed on the objects.
    #[prost(oneof = "job::Transformation", tags = "5, 6, 8, 20")]
    pub transformation: ::core::option::Option<job::Transformation>,
}
/// Nested message and enum types in `Job`.
pub mod job {
    /// Describes state of a job.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// In progress.
        Running = 1,
        /// Completed successfully.
        Succeeded = 2,
        /// Cancelled by the user.
        Canceled = 3,
        /// Terminated due to an unrecoverable failure.
        Failed = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Running => "RUNNING",
                Self::Succeeded => "SUCCEEDED",
                Self::Canceled => "CANCELED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "RUNNING" => Some(Self::Running),
                "SUCCEEDED" => Some(Self::Succeeded),
                "CANCELED" => Some(Self::Canceled),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
    /// Specifies objects to be transformed.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Specifies a list of buckets and their objects to be transformed.
        #[prost(message, tag = "19")]
        BucketList(super::BucketList),
    }
    /// Operation to be performed on the objects.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Transformation {
        /// Changes object hold status.
        #[prost(message, tag = "5")]
        PutObjectHold(super::PutObjectHold),
        /// Delete objects.
        #[prost(message, tag = "6")]
        DeleteObject(super::DeleteObject),
        /// Updates object metadata. Allows updating fixed-key and custom metadata
        /// and fixed-key metadata i.e. Cache-Control, Content-Disposition,
        /// Content-Encoding, Content-Language, Content-Type, Custom-Time.
        #[prost(message, tag = "8")]
        PutMetadata(super::PutMetadata),
        /// Rewrite the object and updates metadata like KMS key.
        #[prost(message, tag = "20")]
        RewriteObject(super::RewriteObject),
    }
}
/// Describes list of buckets and their objects to be transformed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BucketList {
    /// Required. List of buckets and their objects to be transformed. Currently,
    /// only one bucket configuration is supported. If multiple buckets are
    /// specified, an error will be returned.
    #[prost(message, repeated, tag = "1")]
    pub buckets: ::prost::alloc::vec::Vec<bucket_list::Bucket>,
}
/// Nested message and enum types in `BucketList`.
pub mod bucket_list {
    /// Describes configuration of a single bucket and its objects to be
    /// transformed.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Bucket {
        /// Required. Bucket name for the objects to be transformed.
        #[prost(string, tag = "1")]
        pub bucket: ::prost::alloc::string::String,
        /// Specifies objects to be transformed.
        #[prost(oneof = "bucket::ObjectConfiguration", tags = "2, 3")]
        pub object_configuration: ::core::option::Option<bucket::ObjectConfiguration>,
    }
    /// Nested message and enum types in `Bucket`.
    pub mod bucket {
        /// Specifies objects to be transformed.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum ObjectConfiguration {
            /// Specifies objects matching a prefix set.
            #[prost(message, tag = "2")]
            PrefixList(super::super::PrefixList),
            /// Specifies objects in a manifest file.
            #[prost(message, tag = "3")]
            Manifest(super::super::Manifest),
        }
    }
}
/// Describes list of objects to be transformed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
    /// Required. `manifest_location` must contain the manifest source file that is
    /// a CSV file in a Google Cloud Storage bucket. Each row in the file must
    /// include the object details i.e. BucketId and Name. Generation may
    /// optionally be specified. When it is not specified the live object is acted
    /// upon.
    ///   `manifest_location` should either be
    /// 1) An absolute path to the object in the format of
    /// gs://bucket_name/path/file_name.csv.
    /// 2) An absolute path with a single wildcard character in the file name, for
    /// example gs://bucket_name/path/file_name*.csv.
    /// If manifest location is specified with a wildcard, objects in all manifest
    /// files matching the pattern will be acted upon.
    #[prost(string, tag = "2")]
    pub manifest_location: ::prost::alloc::string::String,
}
/// Describes prefixes of objects to be transformed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrefixList {
    /// Optional. Include prefixes of the objects to be transformed.
    /// * Supports full object name
    /// * Supports prefix of the object name
    /// * Wildcards are not supported
    /// * Supports empty string for all objects in a bucket.
    #[prost(string, repeated, tag = "2")]
    pub included_object_prefixes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Describes options to update object hold.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PutObjectHold {
    /// Required. Updates object temporary holds state. When object temporary hold
    /// is set, object cannot be deleted or replaced.
    #[prost(enumeration = "put_object_hold::HoldStatus", tag = "1")]
    pub temporary_hold: i32,
    /// Required. Updates object event based holds state. When object event based
    /// hold is set, object cannot be deleted or replaced. Resets object's time in
    /// the bucket for the purposes of the retention period.
    #[prost(enumeration = "put_object_hold::HoldStatus", tag = "2")]
    pub event_based_hold: i32,
}
/// Nested message and enum types in `PutObjectHold`.
pub mod put_object_hold {
    /// Describes the status of the hold.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HoldStatus {
        /// Default value, Object hold status will not be changed.
        Unspecified = 0,
        /// Places the hold.
        Set = 1,
        /// Releases the hold.
        Unset = 2,
    }
    impl HoldStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HOLD_STATUS_UNSPECIFIED",
                Self::Set => "SET",
                Self::Unset => "UNSET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HOLD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "SET" => Some(Self::Set),
                "UNSET" => Some(Self::Unset),
                _ => None,
            }
        }
    }
}
/// Describes options to delete an object.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteObject {
    /// Required. Controls deletion behavior when versioning is enabled for the
    /// object's bucket. If true both live and noncurrent objects will be
    /// permanently deleted. Otherwise live objects in versioned buckets will
    /// become noncurrent and objects that were already noncurrent will be skipped.
    /// This setting doesn't have any impact on the Soft Delete feature. All
    /// objects deleted by this service can be be restored for the duration of the
    /// Soft Delete retention duration if enabled. If enabled and the manifest
    /// doesn't specify an object's generation, a GetObjectMetadata call (a Class B
    /// operation) will be made to determine the live object generation.
    #[prost(bool, tag = "1")]
    pub permanent_object_deletion_enabled: bool,
}
/// Describes options for object rewrite.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RewriteObject {
    /// Required. Resource name of the Cloud KMS key that will be used to encrypt
    /// the object. The Cloud KMS key must be located in same location as the
    /// object. Refer to
    /// <https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys#add-object-key>
    /// for additional documentation. Format:
    /// projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}
    /// For example:
    /// "projects/123456/locations/us-central1/keyRings/my-keyring/cryptoKeys/my-key".
    /// The object will be rewritten and set with the specified KMS key.
    #[prost(string, optional, tag = "1")]
    pub kms_key: ::core::option::Option<::prost::alloc::string::String>,
}
/// Describes options for object metadata update.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PutMetadata {
    /// Optional. Updates objects Content-Disposition fixed metadata. Unset values
    /// will be ignored. Set empty values to clear the metadata. Refer
    /// <https://cloud.google.com/storage/docs/metadata#content-disposition> for
    /// additional documentation.
    #[prost(string, optional, tag = "1")]
    pub content_disposition: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Updates objects Content-Encoding fixed metadata. Unset values
    /// will be ignored. Set empty values to clear the metadata. Refer to
    /// documentation in
    /// <https://cloud.google.com/storage/docs/metadata#content-encoding.>
    #[prost(string, optional, tag = "2")]
    pub content_encoding: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Updates objects Content-Language fixed metadata. Refer to ISO
    /// 639-1 language codes for typical values of this metadata. Max length 100
    /// characters. Unset values will be ignored. Set empty values to clear the
    /// metadata. Refer to documentation in
    /// <https://cloud.google.com/storage/docs/metadata#content-language.>
    #[prost(string, optional, tag = "3")]
    pub content_language: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Updates objects Content-Type fixed metadata. Unset values will be
    /// ignored.
    ///   Set empty values to clear the metadata. Refer to documentation in
    ///   <https://cloud.google.com/storage/docs/metadata#content-type>
    #[prost(string, optional, tag = "4")]
    pub content_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Updates objects Cache-Control fixed metadata. Unset values will
    /// be
    ///   ignored. Set empty values to clear the metadata.
    ///   Additionally, the value for Custom-Time cannot decrease. Refer to
    ///   documentation in
    /// <https://cloud.google.com/storage/docs/metadata#caching_data.>
    #[prost(string, optional, tag = "5")]
    pub cache_control: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Updates objects Custom-Time fixed metadata. Unset values will be
    /// ignored. Set empty values to clear the metadata. Refer to documentation in
    /// <https://cloud.google.com/storage/docs/metadata#custom-time.>
    #[prost(string, optional, tag = "6")]
    pub custom_time: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Updates objects custom metadata. Adds or sets individual custom
    /// metadata key value pairs on objects. Keys that are set with empty custom
    /// metadata values will have its value cleared. Existing custom metadata not
    /// specified with this flag is not changed. Refer to documentation in
    /// <https://cloud.google.com/storage/docs/metadata#custom-metadata>
    #[prost(map = "string, string", tag = "7")]
    pub custom_metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// A summary of errors by error code, plus a count and sample error log
/// entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorSummary {
    /// Required. The canonical error code.
    #[prost(enumeration = "super::super::super::rpc::Code", tag = "1")]
    pub error_code: i32,
    /// Required. Number of errors encountered per `error_code`.
    #[prost(int64, tag = "2")]
    pub error_count: i64,
    /// Required. Sample error logs.
    #[prost(message, repeated, tag = "3")]
    pub error_log_entries: ::prost::alloc::vec::Vec<ErrorLogEntry>,
}
/// An entry describing an error that has occurred.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLogEntry {
    /// Required. Output only. Object URL. e.g. gs://my_bucket/object.txt
    #[prost(string, tag = "1")]
    pub object_uri: ::prost::alloc::string::String,
    /// Optional. Output only. At most 5 error log entries are recorded for a given
    /// error code for a job.
    #[prost(string, repeated, tag = "3")]
    pub error_details: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Describes details about the progress of the job.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Counters {
    /// Output only. Number of objects listed.
    #[prost(int64, tag = "1")]
    pub total_object_count: i64,
    /// Output only. Number of objects completed.
    #[prost(int64, tag = "2")]
    pub succeeded_object_count: i64,
    /// Output only. Number of objects failed.
    #[prost(int64, tag = "3")]
    pub failed_object_count: i64,
}
/// Specifies the Cloud Logging behavior.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggingConfig {
    /// Required. Specifies the actions to be logged.
    #[prost(
        enumeration = "logging_config::LoggableAction",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub log_actions: ::prost::alloc::vec::Vec<i32>,
    /// Required. States in which Action are logged.If empty, no logs are
    /// generated.
    #[prost(
        enumeration = "logging_config::LoggableActionState",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub log_action_states: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `LoggingConfig`.
pub mod logging_config {
    /// Loggable actions types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoggableAction {
        /// Illegal value, to avoid allowing a default.
        Unspecified = 0,
        /// The corresponding transform action in this job.
        Transform = 6,
    }
    impl LoggableAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOGGABLE_ACTION_UNSPECIFIED",
                Self::Transform => "TRANSFORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOGGABLE_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "TRANSFORM" => Some(Self::Transform),
                _ => None,
            }
        }
    }
    /// Loggable action states filter.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoggableActionState {
        /// Illegal value, to avoid allowing a default.
        Unspecified = 0,
        /// `LoggableAction` completed successfully. `SUCCEEDED` actions are
        /// logged as [INFO][google.logging.type.LogSeverity.INFO].
        Succeeded = 1,
        /// `LoggableAction` terminated in an error state. `FAILED` actions
        /// are logged as [ERROR][google.logging.type.LogSeverity.ERROR].
        Failed = 2,
    }
    impl LoggableActionState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOGGABLE_ACTION_STATE_UNSPECIFIED",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOGGABLE_ACTION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Message for request to list Jobs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsRequest {
    /// Required. Format: projects/{project_id}/locations/global.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Filters results as defined by <https://google.aip.dev/160.>
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The list page size. default page size is 100.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. The list page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Field to sort by. Supported fields are name, create_time.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Jobs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListJobsResponse {
    /// A list of storage batch jobs.
    #[prost(message, repeated, tag = "1")]
    pub jobs: ::prost::alloc::vec::Vec<Job>,
    /// A token identifying a page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Job
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetJobRequest {
    /// Required. `name` of the job to retrieve.
    /// Format: projects/{project_id}/locations/global/jobs/{job_id} .
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Job
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateJobRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The optional `job_id` for this Job . If not
    /// specified, an id is generated. `job_id` should be no more than 128
    /// characters and must include only characters available in DNS names, as
    /// defined by RFC-1123.
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub job: ::core::option::Option<Job>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID in case you need to retry your request. Requests with same
    /// `request_id` will ignored for at least 60 minutes since the first request.
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for Job to Cancel
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelJobRequest {
    /// Required. The `name` of the job to cancel.
    /// Format: projects/{project_id}/locations/global/jobs/{job_id}.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID in case you need to retry your request. Requests with same
    /// `request_id` will ignored for at least 60 minutes since the first request.
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Job
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteJobRequest {
    /// Required. The `name` of the job to delete.
    /// Format: projects/{project_id}/locations/global/jobs/{job_id} .
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID in case you need to retry your request. Requests with same
    /// `request_id` will ignored for at least 60 minutes since the first request.
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for response to cancel Job.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CancelJobResponse {}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The unique operation resource name.
    /// Format: projects/{project}/locations/global/operations/{operation}.
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "3")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    #[prost(bool, tag = "7")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "8")]
    pub api_version: ::prost::alloc::string::String,
    /// Output only. The Job associated with the operation.
    #[prost(message, optional, tag = "10")]
    pub job: ::core::option::Option<Job>,
}
/// Generated client implementations.
pub mod storage_batch_operations_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Storage Batch Operations offers a managed experience to perform batch
    /// operations on millions of Cloud Storage objects in a serverless fashion. With
    /// this service, you can automate and simplify large scale API operations
    /// performed on Cloud Storage objects.
    #[derive(Debug, Clone)]
    pub struct StorageBatchOperationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl StorageBatchOperationsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> StorageBatchOperationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StorageBatchOperationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            StorageBatchOperationsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Jobs in a given project.
        pub async fn list_jobs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListJobsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListJobsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.storagebatchoperations.v1.StorageBatchOperations/ListJobs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.storagebatchoperations.v1.StorageBatchOperations",
                        "ListJobs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a batch job.
        pub async fn get_job(
            &mut self,
            request: impl tonic::IntoRequest<super::GetJobRequest>,
        ) -> std::result::Result<tonic::Response<super::Job>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.storagebatchoperations.v1.StorageBatchOperations/GetJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.storagebatchoperations.v1.StorageBatchOperations",
                        "GetJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a batch job.
        pub async fn create_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.storagebatchoperations.v1.StorageBatchOperations/CreateJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.storagebatchoperations.v1.StorageBatchOperations",
                        "CreateJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a batch job.
        pub async fn delete_job(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteJobRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.storagebatchoperations.v1.StorageBatchOperations/DeleteJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.storagebatchoperations.v1.StorageBatchOperations",
                        "DeleteJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a batch job.
        pub async fn cancel_job(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelJobRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CancelJobResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.storagebatchoperations.v1.StorageBatchOperations/CancelJob",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.storagebatchoperations.v1.StorageBatchOperations",
                        "CancelJob",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
