// This file is @generated by prost-build.
/// Wrapper message for
/// \[AdBreakState\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdBreakStateEnum {}
/// Nested message and enum types in `AdBreakStateEnum`.
pub mod ad_break_state_enum {
    /// Represents the state of an ad break
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdBreakState {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The ad break's decisioning has finished. You can delete, but not update
        /// the ad break.
        Decisioned = 1,
        /// The ad break has started serving to users. You cannot delete or update
        /// the ad break.
        Complete = 2,
        /// The ad break is scheduled and decisioning will start later. You can
        /// delete or update the ad break.
        Scheduled = 3,
    }
    impl AdBreakState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AD_BREAK_STATE_UNSPECIFIED",
                Self::Decisioned => "DECISIONED",
                Self::Complete => "COMPLETE",
                Self::Scheduled => "SCHEDULED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AD_BREAK_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "DECISIONED" => Some(Self::Decisioned),
                "COMPLETE" => Some(Self::Complete),
                "SCHEDULED" => Some(Self::Scheduled),
                _ => None,
            }
        }
    }
}
/// The `AdBreak` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdBreak {
    /// Identifier. The resource name of the `AdBreak`.
    /// This field uses the `LiveStreamEvent` resource's asset key in the
    /// URI, even if the ad break was created, updated, or queried using the custom
    /// asset key.
    ///
    /// Format:
    /// `networks/{network_code}/liveStreamEventsByAssetKey/{asset_key}/adBreaks/{ad_break_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Immutable. `AdBreak` ID.
    /// Must consist only of lowercase letters, digits, and hyphens. Ad break IDs
    /// have a maximum length of 63 characters.
    /// If not set, an ad break ID is generated as a UUID string.
    #[prost(string, optional, tag = "2")]
    pub ad_break_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Immutable. The asset key of the `LiveStreamEvent` that the ad
    /// break belongs to. Either an asset key or a custom asset key must be
    /// provided for creation.
    #[prost(string, optional, tag = "3")]
    pub asset_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Immutable. The custom asset key of the `LiveStreamEvent` that the
    /// ad break belongs to. Either an asset key or a custom asset key must be
    /// provided for creation.
    #[prost(string, optional, tag = "4")]
    pub custom_asset_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The expected start time of the ad break.
    /// When set, the scheduled ad break will be decisioned shortly before the
    /// expected start time.
    /// If this field is not set, ad decisioning begins immediately.
    /// An ad break can be created up to six hours before the expected start time.
    #[prost(message, optional, tag = "5")]
    pub expected_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The duration of the `AdBreak`.
    /// An expected duration in seconds with up to nine fractional digits, ending
    /// with `s`, for example, `3.5s`. This value will be updated to match the
    /// actual duration from the manifest or pod request after the ad break's state
    /// is
    /// \[`COMPLETE`\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState.COMPLETE\].
    #[prost(message, optional, tag = "6")]
    pub duration: ::core::option::Option<::prost_types::Duration>,
    /// Output only. The state of the `AdBreak`.
    #[prost(enumeration = "ad_break_state_enum::AdBreakState", optional, tag = "7")]
    pub break_state: ::core::option::Option<i32>,
    /// Output only. The sequence id of the `AdBreak`.
    /// The unique sequence number of the created ad break. This value is only set
    /// after the `AdBreak` starts decisioning indicated by the ad break state's
    /// being
    /// \[`DECISIONED`\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState.DECISIONED\]
    /// .
    #[prost(int64, optional, tag = "8")]
    pub break_sequence: ::core::option::Option<i64>,
    /// Optional. The pod template name of the `AdBreak`.
    /// This field is the required unique name across all pod templates in the
    /// network, not the display name.
    #[prost(string, optional, tag = "9")]
    pub pod_template_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The key-value pairs to be included on the ad requests for this
    /// `AdBreak`. Key-value pairs to include on ad requests for this break for
    /// custom criteria targeting in Google Ad Manager, separated by `=` and joined
    /// by
    /// `&`.
    ///
    /// Format:"key1=value&key2=value"
    #[prost(string, optional, tag = "10")]
    pub custom_params: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The Base64-encoded SCTE-35 command associated with the `AdBreak`.
    /// This field can include the `splice_insert()` or `time_signal()` command.
    ///
    /// **Examples**
    ///
    /// * `time_signal()`
    ///   ```text,
    ///   /DA0AAAAAAAA///wBQb+cr0AUAAeAhxDVUVJSAAAjn/PAAGlmbAICAAAAAAsoKGKNAIAmsnRfg==
    ///   ```
    ///
    /// * `splice_insert()`
    ///   ```text,
    ///   /DAvAAAAAAAA///wFAVIAACPf+/+c2nALv4AUsz1AAAAAAAKAAhDVUVJAAABNWLbowo=
    ///   ```
    #[prost(string, optional, tag = "11")]
    pub scte_35_cue_out: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetAdBreak` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAdBreakRequest {
    /// Required. The resource name of the AdBreak using the asset key or custom
    /// asset key.
    ///
    /// Format:
    /// `networks/{network_code}/liveStreamEventsByAssetKey/{asset_key}/adBreaks/{ad_break_id}`
    /// `networks/{network_code}/liveStreamEventsByCustomAssetKey/{custom_asset_key}/adBreaks/{ad_break_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListAdBreaks` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAdBreaksRequest {
    /// Required. The parent, which owns this collection of AdBreaks.
    ///
    /// Formats:
    /// `networks/{network_code}/liveStreamEventsByAssetKey/{asset_key}`
    /// `networks/{network_code}/liveStreamEventsByCustomAssetKey/{custom_asset_key}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `AdBreaks` to return. The service might
    /// return fewer than this value. If unspecified, at most 10 ad breaks are
    /// returned. The maximum value is `100`. Values above `100` are coerced to
    /// `100`.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAdBreaks` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAdBreaks` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListAdBreaksRequest` containing matching `AdBreak`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdBreaksResponse {
    /// The `AdBreak` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub ad_breaks: ::prost::alloc::vec::Vec<AdBreak>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages. This field expires
    /// after five minutes.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `AdBreak` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateAdBreak` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateAdBreakRequest {
    /// Required. The parent resource where this `AdBreak` will be created
    /// identified by an asset key or custom asset key.
    ///
    /// Formats:
    /// `networks/{network_code}/liveStreamEventsByAssetKey/{asset_key}`
    /// `networks/{network_code}/liveStreamEventsByCustomAssetKey/{custom_asset_key}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `AdBreak` to create.
    #[prost(message, optional, tag = "2")]
    pub ad_break: ::core::option::Option<AdBreak>,
}
/// Request object for `UpdateAdBreak` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateAdBreakRequest {
    /// Required. The `AdBreak` to update.
    ///
    /// The `AdBreak`'s `name` is used to identify the `AdBreak` to update.
    #[prost(message, optional, tag = "1")]
    pub ad_break: ::core::option::Option<AdBreak>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `DeleteAdBreak` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAdBreakRequest {
    /// Required. The name of the ad break to delete.
    ///
    /// Format:
    /// `networks/{network_code}/liveStreamEventsByAssetKey/{asset_key}/adBreaks/{ad_break}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod ad_break_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `AdBreak` objects.
    #[derive(Debug, Clone)]
    pub struct AdBreakServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdBreakServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdBreakServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdBreakServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdBreakServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve an `AdBreak` object.
        ///
        /// Query an ad break by its resource name or custom asset key. Check the
        /// resource's `breakState` field to determine its state.
        pub async fn get_ad_break(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdBreakRequest>,
        ) -> std::result::Result<tonic::Response<super::AdBreak>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdBreakService/GetAdBreak",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdBreakService",
                        "GetAdBreak",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `AdBreak` objects.
        ///
        /// By default, when no `orderBy` query parameter is specified, ad breaks are
        /// ordered reverse chronologically. However, ad breaks with a 'breakState' of
        /// 'SCHEDULED' or 'DECISIONED' are prioritized and appear first.
        pub async fn list_ad_breaks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAdBreaksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAdBreaksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdBreakService/ListAdBreaks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdBreakService",
                        "ListAdBreaks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create an `AdBreak` object.
        ///
        /// Informs DAI of an upcoming ad break for a live stream event, with an
        /// optional expected start time. DAI will begin decisioning ads for the break
        /// shortly before the expected start time, if provided. Each live stream
        /// event can only have one incomplete ad break at any given time. The next ad
        /// break can be scheduled after the previous ad break has started serving,
        /// indicated by its state being
        /// \[`COMPLETE`\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState.COMPLETE\],
        /// or it has been deleted.
        ///
        /// This method cannot be used if the `LiveStreamEvent` has
        /// [prefetching ad breaks
        /// enabled](https://developers.google.com/ad-manager/api/reference/latest/LiveStreamEventService.LiveStreamEvent#prefetchenabled)
        /// or the event is not active. If a `LiveStreamEvent` is deactivated after
        /// creating an ad break and before the ad break is complete, the ad break
        /// is discarded.
        ///
        /// An ad break's state is complete when the following occurs:
        ///
        /// * Full service DAI: after a matching ad break shows in the
        ///  `LiveStreamEvent` manifest only when the ad break has started decisioning.
        /// * Pod Serving: after the ad break is requested using the ad break ID or
        ///  break sequence.
        pub async fn create_ad_break(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAdBreakRequest>,
        ) -> std::result::Result<tonic::Response<super::AdBreak>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdBreakService/CreateAdBreak",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdBreakService",
                        "CreateAdBreak",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update an `AdBreak` object.
        ///
        /// Modify an ad break when its state is
        /// \[`SCHEDULED`\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState.SCHEDULED\].
        pub async fn update_ad_break(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAdBreakRequest>,
        ) -> std::result::Result<tonic::Response<super::AdBreak>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdBreakService/UpdateAdBreak",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdBreakService",
                        "UpdateAdBreak",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to delete an `AdBreak` object.
        ///
        /// Deletes and cancels an incomplete ad break, mitigating the need to wait
        /// for the current break to serve before recreating an ad break. You can
        /// delete an ad break that has not started serving or seen in manifests,
        /// indicated by its state being
        /// \[`SCHEDULED`\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState.SCHEDULED\]
        /// or
        /// \[`DECISIONED`\]\[google.ads.admanager.v1.AdBreakStateEnum.AdBreakState.DECISIONED\].
        pub async fn delete_ad_break(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAdBreakRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdBreakService/DeleteAdBreak",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdBreakService",
                        "DeleteAdBreak",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[AdReviewCenterAdStatus\]\[google.ads.admanager.v1.AdReviewCenterAdStatusEnum.AdReviewCenterAdStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdReviewCenterAdStatusEnum {}
/// Nested message and enum types in `AdReviewCenterAdStatusEnum`.
pub mod ad_review_center_ad_status_enum {
    /// Specifies the status of an AdReviewCenterAd.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdReviewCenterAdStatus {
        /// Not specified value
        Unspecified = 0,
        /// This ad has been explicitly allowed to serve.
        Allowed = 1,
        /// This ad has been explicitly blocked from serving.
        Blocked = 2,
        /// This ad is allowed to serve by default and has not been reviewed.
        Unreviewed = 3,
    }
    impl AdReviewCenterAdStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AD_REVIEW_CENTER_AD_STATUS_UNSPECIFIED",
                Self::Allowed => "ALLOWED",
                Self::Blocked => "BLOCKED",
                Self::Unreviewed => "UNREVIEWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AD_REVIEW_CENTER_AD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ALLOWED" => Some(Self::Allowed),
                "BLOCKED" => Some(Self::Blocked),
                "UNREVIEWED" => Some(Self::Unreviewed),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[ExchangeSyndicationProduct\]\[google.ads.admanager.v1.ExchangeSyndicationProductEnum.ExchangeSyndicationProduct\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExchangeSyndicationProductEnum {}
/// Nested message and enum types in `ExchangeSyndicationProductEnum`.
pub mod exchange_syndication_product_enum {
    /// Ad Exchange syndication product.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExchangeSyndicationProduct {
        /// No value specified
        Unspecified = 0,
        /// Property serves in-browser.
        Display = 1,
        /// Property serves on mobile applications (includes JS and SDK).
        MobileApp = 2,
        /// Property serves video (includes audio).
        VideoAndAudio = 3,
        /// Property serves for games.
        Games = 4,
    }
    impl ExchangeSyndicationProduct {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXCHANGE_SYNDICATION_PRODUCT_UNSPECIFIED",
                Self::Display => "DISPLAY",
                Self::MobileApp => "MOBILE_APP",
                Self::VideoAndAudio => "VIDEO_AND_AUDIO",
                Self::Games => "GAMES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXCHANGE_SYNDICATION_PRODUCT_UNSPECIFIED" => Some(Self::Unspecified),
                "DISPLAY" => Some(Self::Display),
                "MOBILE_APP" => Some(Self::MobileApp),
                "VIDEO_AND_AUDIO" => Some(Self::VideoAndAudio),
                "GAMES" => Some(Self::Games),
                _ => None,
            }
        }
    }
}
/// Represents an ad that can be acted on or viewed in the Ad Review Center.
/// \[AdReviewCenterAd\]\[google.ads.admanager.v1.AdReviewCenterAd\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdReviewCenterAd {
    /// Identifier. The resource name of the AdReviewCenterAd.
    /// Format:
    /// `networks/{network_code}/webProperties/{web_property_code}/adReviewCenterAds/{ad_review_center_ad_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `AdReviewCenterAd` ID.
    #[prost(string, tag = "2")]
    pub ad_review_center_ad_id: ::prost::alloc::string::String,
    /// Output only. Specifies the ExchangeSyndicationProduct for this
    /// AdReviewCenterAd.
    #[prost(
        enumeration = "exchange_syndication_product_enum::ExchangeSyndicationProduct",
        tag = "3"
    )]
    pub product_type: i32,
    /// The status of the AdReviewCenterAd.
    #[prost(
        enumeration = "ad_review_center_ad_status_enum::AdReviewCenterAdStatus",
        tag = "4"
    )]
    pub status: i32,
    /// Output only. The preview URL that can be embedded or accessed directly
    /// which will present the rendered contents of the ad. (This URL expires 72
    /// hours after being retrieved.).
    #[prost(string, optional, tag = "5")]
    pub preview_url: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `SearchAdReviewCenterAds` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchAdReviewCenterAdsRequest {
    /// Required. The parent, which owns this collection of AdReviewCenterAds.
    /// Format: networks/{network_code}/webProperties/{web_property_code}
    ///
    /// Since a network can only have a single web property of each
    /// `ExchangeSyndicationProduct`, you can use the
    /// `ExchangeSyndicationProduct` as an alias for the web property code:
    ///
    /// `networks/{network_code}/webProperties/display`
    ///
    /// `networks/{network_code}/webProperties/videoAndAudio`
    ///
    /// `networks/{network_code}/webProperties/mobileApp`
    ///
    /// `networks/{network_code}/webProperties/games`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of AdReviewCenterAds to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// AdReviewCenterAds will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The page token to fetch the next page of AdReviewCenterAds. This
    /// is the value returned from a previous Search request, or empty.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Only return ads with the given status.
    #[prost(
        enumeration = "ad_review_center_ad_status_enum::AdReviewCenterAdStatus",
        tag = "4"
    )]
    pub status: i32,
    /// Optional. Only return ads with the given AdReviewCenterAd IDs. If provided,
    /// no other filter can be set (other than page size and page token).
    #[prost(string, repeated, tag = "5")]
    pub ad_review_center_ad_id: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. If provided, only return ads that served within the given date
    /// range (inclusive). The  date range must be within the last 30 days. If not
    /// provided, the date range will be the last 30 days.
    #[prost(message, optional, tag = "6")]
    pub date_time_range: ::core::option::Option<super::super::super::r#type::Interval>,
    /// Optional. If provided, restrict the search to AdReviewCenterAds associated
    /// with the text (including any text on the ad or in the destination URL). If
    /// more than one value is provided, the search will combine them in a logical
    /// AND. For example, \['car', 'blue'\] will match ads that contain both "car"
    /// and "blue", but not an ad that only contains "car".
    #[prost(string, repeated, tag = "7")]
    pub search_text: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. If provided, restrict the search to creatives belonging to one of
    /// the given Adx buyer account IDs. Only applicable to RTB creatives. Adx
    /// buyer account IDs can be found via the ProgrammaticBuyerService.
    #[prost(int64, repeated, packed = "false", tag = "8")]
    pub buyer_account_id: ::prost::alloc::vec::Vec<i64>,
}
/// Response object for `SearchAdReviewCenterAds` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAdReviewCenterAdsResponse {
    /// The AdReviewCenterAds that match the search request.
    #[prost(message, repeated, tag = "1")]
    pub ad_review_center_ads: ::prost::alloc::vec::Vec<AdReviewCenterAd>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request object for `BatchAllowAdReviewCenterAds` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchAllowAdReviewCenterAdsRequest {
    /// Required. The parent, which owns this collection of AdReviewCenterAds.
    /// Format: networks/{network_code}/webProperties/{web_property_code}
    ///
    /// Since a network can only have a single web property of each
    /// `ExchangeSyndicationProduct`, you can use the
    /// `ExchangeSyndicationProduct` as an alias for the web property code:
    ///
    /// `networks/{network_code}/webProperties/display`
    ///
    /// `networks/{network_code}/webProperties/videoAndAudio`
    ///
    /// `networks/{network_code}/webProperties/mobileApp`
    ///
    /// `networks/{network_code}/webProperties/games`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `AdReviewCenterAd`s to allow.
    /// Format:
    /// `networks/{network_code}/webProperties/{web_property_code}/adReviewCenterAds/{ad_review_center_ad_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchAllowAdReviewCenterAds` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchAllowAdReviewCenterAdsResponse {}
/// Request object for `BatchBlockAdReviewCenterAds` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchBlockAdReviewCenterAdsRequest {
    /// Required. The parent, which owns this collection of AdReviewCenterAds.
    /// Format: networks/{network_code}/webProperties/{web_property_code}
    ///
    /// Since a network can only have a single web property of each
    /// `ExchangeSyndicationProduct`, you can use the
    /// `ExchangeSyndicationProduct` as an alias for the web property code:
    ///
    /// `networks/{network_code}/webProperties/display`
    ///
    /// `networks/{network_code}/webProperties/videoAndAudio`
    ///
    /// `networks/{network_code}/webProperties/mobileApp`
    ///
    /// `networks/{network_code}/webProperties/games`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `AdReviewCenterAd`s to block.
    /// Format:
    /// `networks/{network_code}/webProperties/{web_property_code}/adReviewCenterAds/{ad_review_center_ad_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchBlockAdReviewCenterAds` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchBlockAdReviewCenterAdsResponse {}
/// Metadata object for `BatchAllowAdReviewCenterAds` and
/// `BatchBlockAdReviewCenterAds` methods.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchAdReviewCenterAdsOperationMetadata {
    /// The status of each failed request, keyed by the index of the corresponding
    /// request in the batch request.
    #[prost(map = "int32, message", tag = "1")]
    pub failed_requests: ::std::collections::HashMap<
        i32,
        super::super::super::rpc::Status,
    >,
}
/// Generated client implementations.
pub mod ad_review_center_ad_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling AdReviewCenterAd objects.
    #[derive(Debug, Clone)]
    pub struct AdReviewCenterAdServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdReviewCenterAdServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdReviewCenterAdServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdReviewCenterAdServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdReviewCenterAdServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to search for AdReviewCenterAds.
        pub async fn search_ad_review_center_ads(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAdReviewCenterAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAdReviewCenterAdsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdReviewCenterAdService/SearchAdReviewCenterAds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdReviewCenterAdService",
                        "SearchAdReviewCenterAds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch allow AdReviewCenterAds.
        /// This method supports partial success. Some operations may succeed while
        /// others fail. Callers should check the failedRequests field in the response
        /// to determine which operations failed.
        pub async fn batch_allow_ad_review_center_ads(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchAllowAdReviewCenterAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdReviewCenterAdService/BatchAllowAdReviewCenterAds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdReviewCenterAdService",
                        "BatchAllowAdReviewCenterAds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch block AdReviewCenterAds.
        /// This method supports partial success. Some operations may succeed while
        /// others fail. Callers should check the failedRequests field in the response
        /// to determine which operations failed.
        pub async fn batch_block_ad_review_center_ads(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchBlockAdReviewCenterAdsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdReviewCenterAdService/BatchBlockAdReviewCenterAds",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdReviewCenterAdService",
                        "BatchBlockAdReviewCenterAds",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[AdUnitStatus\]\[google.ads.admanager.v1.AdUnitStatusEnum.AdUnitStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdUnitStatusEnum {}
/// Nested message and enum types in `AdUnitStatusEnum`.
pub mod ad_unit_status_enum {
    /// The status of an AdUnit.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdUnitStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The ad unit is active, available for targeting, and serving.
        Active = 1,
        /// The ad unit will be visible in the UI, but ignored by serving.
        Inactive = 2,
        /// The ad unit will be hidden in the UI and ignored by serving.
        Archived = 3,
    }
    impl AdUnitStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AD_UNIT_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::Archived => "ARCHIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AD_UNIT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ARCHIVED" => Some(Self::Archived),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[SmartSizeMode\]\[google.ads.admanager.v1.SmartSizeModeEnum.SmartSizeMode\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SmartSizeModeEnum {}
/// Nested message and enum types in `SmartSizeModeEnum`.
pub mod smart_size_mode_enum {
    /// The smart size mode for this ad unit. This attribute is optional and
    /// defaults to SmartSizeMode.NONE for fixed sizes.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartSizeMode {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Fixed size mode (default).
        None = 1,
        /// The height is fixed for the request, the width is a range.
        SmartBanner = 2,
        /// Height and width are ranges.
        DynamicSize = 3,
    }
    impl SmartSizeMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SMART_SIZE_MODE_UNSPECIFIED",
                Self::None => "NONE",
                Self::SmartBanner => "SMART_BANNER",
                Self::DynamicSize => "DYNAMIC_SIZE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SMART_SIZE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "SMART_BANNER" => Some(Self::SmartBanner),
                "DYNAMIC_SIZE" => Some(Self::DynamicSize),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[TargetWindow\]\[google.ads.admanager.v1.TargetWindowEnum.TargetWindow\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetWindowEnum {}
/// Nested message and enum types in `TargetWindowEnum`.
pub mod target_window_enum {
    /// Corresponds to an HTML link's target attribute.
    /// See <http://www.w3.org/TR/html401/present/frames.html#adef-target>
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetWindow {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Specifies that the link should open in the full body of the page.
        Top = 1,
        /// Specifies that the link should open in a new window.
        Blank = 2,
    }
    impl TargetWindow {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TARGET_WINDOW_UNSPECIFIED",
                Self::Top => "TOP",
                Self::Blank => "BLANK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_WINDOW_UNSPECIFIED" => Some(Self::Unspecified),
                "TOP" => Some(Self::Top),
                "BLANK" => Some(Self::Blank),
                _ => None,
            }
        }
    }
}
/// Represents a Label that can be applied to an entity.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AppliedLabel {
    /// Required. The label to be applied.
    /// Format: "networks/{network_code}/labels/{label_id}"
    #[prost(string, tag = "1")]
    pub label: ::prost::alloc::string::String,
    /// Specifies whether or not to negate the effects of the label.
    #[prost(bool, tag = "2")]
    pub negated: bool,
}
/// Wrapper message for
/// \[EnvironmentType\]\[google.ads.admanager.v1.EnvironmentTypeEnum.EnvironmentType\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EnvironmentTypeEnum {}
/// Nested message and enum types in `EnvironmentTypeEnum`.
pub mod environment_type_enum {
    /// The different environments in which an ad can be shown.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnvironmentType {
        /// No value specified
        Unspecified = 0,
        /// A regular web browser.
        Browser = 1,
        /// Video players.
        VideoPlayer = 2,
    }
    impl EnvironmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ENVIRONMENT_TYPE_UNSPECIFIED",
                Self::Browser => "BROWSER",
                Self::VideoPlayer => "VIDEO_PLAYER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENVIRONMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BROWSER" => Some(Self::Browser),
                "VIDEO_PLAYER" => Some(Self::VideoPlayer),
                _ => None,
            }
        }
    }
}
/// Wrapper message for TimeUnit.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeUnitEnum {}
/// Nested message and enum types in `TimeUnitEnum`.
pub mod time_unit_enum {
    /// Unit of time for the frequency cap.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeUnit {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Minute
        Minute = 1,
        /// Hour
        Hour = 2,
        /// Day
        Day = 3,
        /// Week
        Week = 4,
        /// Month
        Month = 5,
        /// Lifetime
        Lifetime = 6,
        /// Per pod of ads in a video stream. Only valid for entities in a
        /// VIDEO_PLAYER environment.
        Pod = 7,
        /// Per video stream. Only valid for entities in a VIDEO_PLAYER environment.
        Stream = 8,
    }
    impl TimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_UNIT_UNSPECIFIED",
                Self::Minute => "MINUTE",
                Self::Hour => "HOUR",
                Self::Day => "DAY",
                Self::Week => "WEEK",
                Self::Month => "MONTH",
                Self::Lifetime => "LIFETIME",
                Self::Pod => "POD",
                Self::Stream => "STREAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "MINUTE" => Some(Self::Minute),
                "HOUR" => Some(Self::Hour),
                "DAY" => Some(Self::Day),
                "WEEK" => Some(Self::Week),
                "MONTH" => Some(Self::Month),
                "LIFETIME" => Some(Self::Lifetime),
                "POD" => Some(Self::Pod),
                "STREAM" => Some(Self::Stream),
                _ => None,
            }
        }
    }
}
/// Represents a Frequency Cap that can be applied to an entity.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrequencyCap {
    /// The maximum number of impressions for this frequency cap.
    #[prost(int64, optional, tag = "1")]
    pub max_impressions: ::core::option::Option<i64>,
    /// The number of time units over which the frequency cap is effective.
    #[prost(int64, optional, tag = "2")]
    pub time_amount: ::core::option::Option<i64>,
    /// The units of time of this frequency cap.
    #[prost(enumeration = "time_unit_enum::TimeUnit", optional, tag = "3")]
    pub time_unit: ::core::option::Option<i32>,
}
/// Wrapper message for
/// \[SizeType\]\[google.ads.admanager.v1.SizeTypeEnum.SizeType\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SizeTypeEnum {}
/// Nested message and enum types in `SizeTypeEnum`.
pub mod size_type_enum {
    /// The different Size types for an ad.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SizeType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Dimension based size, an actual height and width in pixels.
        Pixel = 1,
        /// Size is expressed as a ratio. For example, 4:1 could be
        /// met by a 100 x 25 sized image.
        AspectRatio = 2,
        /// Out-of-page (Interstitial) size that is not related to the slot it is
        /// served. This must be used with 1x1 size.
        Interstitial = 3,
        /// Size is ignored. This must be used with 1x1
        /// size.
        Ignored = 4,
        /// Native size, which is a function of the how the client renders the
        /// creative. This must be used with 1x1 size.
        Native = 5,
        /// Fluid size. Automatically sizes the ad by filling the width of the
        /// enclosing column and adjusting the height as appropriate. This must be
        /// used with 1x1 size.
        Fluid = 6,
        /// Audio size. Used with audio ads. This must be used with 1x1 size.
        Audio = 7,
    }
    impl SizeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SIZE_TYPE_UNSPECIFIED",
                Self::Pixel => "PIXEL",
                Self::AspectRatio => "ASPECT_RATIO",
                Self::Interstitial => "INTERSTITIAL",
                Self::Ignored => "IGNORED",
                Self::Native => "NATIVE",
                Self::Fluid => "FLUID",
                Self::Audio => "AUDIO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SIZE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PIXEL" => Some(Self::Pixel),
                "ASPECT_RATIO" => Some(Self::AspectRatio),
                "INTERSTITIAL" => Some(Self::Interstitial),
                "IGNORED" => Some(Self::Ignored),
                "NATIVE" => Some(Self::Native),
                "FLUID" => Some(Self::Fluid),
                "AUDIO" => Some(Self::Audio),
                _ => None,
            }
        }
    }
}
/// Represents the dimensions of an AdUnit, LineItem, or Creative.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Size {
    /// Required. The width of the Creative,
    /// \[AdUnit\]\[google.ads.admanager.v1.AdUnit\], or LineItem.
    #[prost(int32, tag = "1")]
    pub width: i32,
    /// Required. The height of the Creative,
    /// \[AdUnit\]\[google.ads.admanager.v1.AdUnit\], or LineItem.
    #[prost(int32, tag = "2")]
    pub height: i32,
    /// Required. The SizeType of the Creative,
    /// \[AdUnit\]\[google.ads.admanager.v1.AdUnit\], or LineItem.
    #[prost(enumeration = "size_type_enum::SizeType", tag = "3")]
    pub size_type: i32,
}
/// The AdUnit resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdUnit {
    /// Identifier. The resource name of the AdUnit.
    /// Format: `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. AdUnit ID.
    #[prost(int64, tag = "15")]
    pub ad_unit_id: i64,
    /// Required. Immutable. The AdUnit's parent. Every ad unit has a parent except
    /// for the root ad unit, which is created by Google. Format:
    /// "networks/{network_code}/adUnits/{ad_unit_id}"
    #[prost(string, optional, tag = "10")]
    pub parent_ad_unit: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The path to this AdUnit in the ad unit hierarchy represented
    /// as a list from the root to this ad unit's parent. For root ad units, this
    /// list is empty.
    #[prost(message, repeated, tag = "11")]
    pub parent_path: ::prost::alloc::vec::Vec<AdUnitParent>,
    /// Required. The display name of the ad unit. Its maximum length is 255
    /// characters.
    #[prost(string, optional, tag = "9")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Immutable. A string used to uniquely identify the ad unit for the
    /// purposes of serving the ad. This attribute can be set during ad unit
    /// creation. If it is not provided, it will be assigned by Google based on the
    /// ad unit ID.
    #[prost(string, optional, tag = "2")]
    pub ad_unit_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of this ad unit.  It defaults to ACTIVE.
    #[prost(enumeration = "ad_unit_status_enum::AdUnitStatus", optional, tag = "13")]
    pub status: ::core::option::Option<i32>,
    /// Optional. The target window directly applied to this AdUnit.
    /// If this field is not set, this AdUnit uses the target window specified in
    /// effectiveTargetWindow.
    #[prost(enumeration = "target_window_enum::TargetWindow", optional, tag = "44")]
    pub applied_target_window: ::core::option::Option<i32>,
    /// Output only. Non-empty default. The target window of this AdUnit. This
    /// value is inherited from ancestor AdUnits and defaults to TOP if no AdUnit
    /// in the hierarchy specifies it.
    #[prost(enumeration = "target_window_enum::TargetWindow", optional, tag = "45")]
    pub effective_target_window: ::core::option::Option<i32>,
    /// Optional. The resource names of Teams directly applied to this AdUnit.
    /// Format: "networks/{network_code}/teams/{team_id}"
    #[prost(string, repeated, tag = "3")]
    pub applied_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The resource names of all Teams that this AdUnit is on as well
    /// as those inherited from parent AdUnits. Format:
    /// "networks/{network_code}/teams/{team_id}"
    #[prost(string, repeated, tag = "4")]
    pub teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A description of the ad unit. The maximum length is 65,535
    /// characters.
    #[prost(string, optional, tag = "5")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. If this field is set to true, then the AdUnit will not be
    /// implicitly targeted when its parent is. Traffickers must explicitly
    /// target such an AdUnit or else no line items will serve to it. This
    /// feature is only available for Ad Manager 360 accounts.
    #[prost(bool, optional, tag = "6")]
    pub explicitly_targeted: ::core::option::Option<bool>,
    /// Output only. This field is set to true if the ad unit has any children.
    #[prost(bool, optional, tag = "7")]
    pub has_children: ::core::option::Option<bool>,
    /// Output only. The time this AdUnit was last modified.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The sizes that can be served inside this ad unit.
    #[prost(message, repeated, tag = "14")]
    pub ad_unit_sizes: ::prost::alloc::vec::Vec<AdUnitSize>,
    /// Optional. Determines what set top box video on demand channel this ad unit
    /// corresponds to in an external set top box ad campaign system.
    #[deprecated]
    #[prost(string, optional, tag = "17")]
    pub external_set_top_box_channel_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Optional. The duration after which an Ad Unit will automatically refresh.
    /// This is only valid for ad units in mobile apps. If not set, the ad unit
    /// will not refresh.
    #[prost(message, optional, tag = "19")]
    pub refresh_delay: ::core::option::Option<::prost_types::Duration>,
    /// Optional. The set of labels applied directly to this ad unit.
    #[prost(message, repeated, tag = "21")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    /// Output only. Contains the set of labels applied directly to the ad unit as
    /// well as those inherited from the parent ad units. If a label has been
    /// negated, only the negated label is returned. This attribute is assigned by
    /// Google.
    #[prost(message, repeated, tag = "22")]
    pub effective_applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    /// Optional. The set of label frequency caps applied directly to this ad unit.
    /// There is a limit of 10 label frequency caps per ad unit.
    #[prost(message, repeated, tag = "23")]
    pub applied_label_frequency_caps: ::prost::alloc::vec::Vec<LabelFrequencyCap>,
    /// Output only. The label frequency caps applied directly to the ad unit as
    /// well as those inherited from parent ad units.
    #[prost(message, repeated, tag = "24")]
    pub effective_label_frequency_caps: ::prost::alloc::vec::Vec<LabelFrequencyCap>,
    /// Optional. Non-empty default. The smart size mode for this ad unit. This
    /// attribute defaults to SmartSizeMode.NONE for fixed sizes.
    #[prost(enumeration = "smart_size_mode_enum::SmartSizeMode", optional, tag = "25")]
    pub smart_size_mode: ::core::option::Option<i32>,
    /// Optional. The value of AdSense enabled directly applied to this ad unit. If
    /// not specified this ad unit will inherit the value of
    /// effectiveAdsenseEnabled from its ancestors.
    #[prost(bool, optional, tag = "26")]
    pub applied_adsense_enabled: ::core::option::Option<bool>,
    /// Output only. Specifies whether or not the AdUnit is enabled for serving ads
    /// from the AdSense content network. This attribute defaults to the ad unit's
    /// parent or ancestor's setting if one has been set. If no ancestor of the ad
    /// unit has set appliedAdsenseEnabled, the attribute is defaulted to true.
    #[prost(bool, optional, tag = "27")]
    pub effective_adsense_enabled: ::core::option::Option<bool>,
}
/// Represents the size, environment, and companions of an ad in an ad unit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdUnitSize {
    /// Required. The Size of the AdUnit.
    #[prost(message, optional, tag = "1")]
    pub size: ::core::option::Option<Size>,
    /// Required. The EnvironmentType of the AdUnit
    #[prost(enumeration = "environment_type_enum::EnvironmentType", optional, tag = "2")]
    pub environment_type: ::core::option::Option<i32>,
    /// The companions for this ad unit size. Companions are only valid if the
    /// environment is
    /// \[VIDEO_PLAYER\]\[google.ads.admanager.v1.EnvironmentTypeEnum.EnvironmentType\].
    #[prost(message, repeated, tag = "3")]
    pub companions: ::prost::alloc::vec::Vec<Size>,
}
/// The summary of a parent AdUnit.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdUnitParent {
    /// Output only. The parent of the current AdUnit
    /// Format: `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(string, optional, tag = "1")]
    pub parent_ad_unit: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The display name of the parent AdUnit.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. A string used to uniquely identify the ad unit for the
    /// purposes of serving the ad.
    #[prost(string, optional, tag = "3")]
    pub ad_unit_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Frequency cap using a label.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LabelFrequencyCap {
    /// Required. The label to used for frequency capping.
    /// Format: "networks/{network_code}/labels/{label_id}"
    #[prost(string, optional, tag = "1")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    /// The frequency cap.
    #[prost(message, optional, tag = "2")]
    pub frequency_cap: ::core::option::Option<FrequencyCap>,
}
/// Request object for GetAdUnit method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAdUnitRequest {
    /// Required. The resource name of the AdUnit.
    /// Format: `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for ListAdUnits method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAdUnitsRequest {
    /// Required. The parent, which owns this collection of AdUnits.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of AdUnits to return. The service may return
    /// fewer than this value. If unspecified, at most 50 ad units will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAdUnits` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAdUnits` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for ListAdUnitsRequest containing matching AdUnit resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdUnitsResponse {
    /// The AdUnit from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub ad_units: ::prost::alloc::vec::Vec<AdUnit>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of AdUnits.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateAdUnit` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAdUnitRequest {
    /// Required. The parent resource where this `AdUnit` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `AdUnit` to create.
    #[prost(message, optional, tag = "2")]
    pub ad_unit: ::core::option::Option<AdUnit>,
}
/// Request object for `UpdateAdUnit` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAdUnitRequest {
    /// Required. The `AdUnit` to update.
    ///
    /// The `AdUnit`'s name is used to identify the `AdUnit` to update. Format:
    /// `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(message, optional, tag = "1")]
    pub ad_unit: ::core::option::Option<AdUnit>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchCreateAdUnits` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateAdUnitsRequest {
    /// Required. The parent resource where `AdUnits` will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreateAdUnitRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `AdUnit` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateAdUnitRequest>,
}
/// Response object for `BatchCreateAdUnits` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateAdUnitsResponse {
    /// The `AdUnit` objects created.
    #[prost(message, repeated, tag = "1")]
    pub ad_units: ::prost::alloc::vec::Vec<AdUnit>,
}
/// Request object for `BatchUpdateAdUnits` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateAdUnitsRequest {
    /// Required. The parent resource where `AdUnits` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdateAdUnitRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `AdUnit` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateAdUnitRequest>,
}
/// Response object for `BatchUpdateAdUnits` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateAdUnitsResponse {
    /// The `AdUnit` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub ad_units: ::prost::alloc::vec::Vec<AdUnit>,
}
/// Request object for ListAdUnitSizes method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAdUnitSizesRequest {
    /// Required. The parent, which owns this collection of AdUnitSizes.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of AdUnitSizes to return. The service may
    /// return fewer than this value. If unspecified, at most 50 ad unit sizes will
    /// be returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAdUnitSizes` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAdUnitSizes` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for ListAdUnitSizesRequest containing matching AdUnitSizes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdUnitSizesResponse {
    /// The AdUnitSizes from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub ad_unit_sizes: ::prost::alloc::vec::Vec<AdUnitSize>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of AdUnitSizes.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `BatchActivateAdUnits` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateAdUnitsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `AdUnit`s to activate.
    /// Format: `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchActivateAdUnits` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateAdUnitsResponse {}
/// Request object for `BatchDeactivateAdUnits` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateAdUnitsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `AdUnit`s to deactivate.
    /// Format: `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchDeactivateAdUnits` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateAdUnitsResponse {}
/// Request object for `BatchArchiveAdUnits` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchArchiveAdUnitsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `AdUnit`s to archive.
    /// Format: `networks/{network_code}/adUnits/{ad_unit_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchArchiveAdUnits` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchArchiveAdUnitsResponse {}
/// Generated client implementations.
pub mod ad_unit_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling AdUnit objects.
    #[derive(Debug, Clone)]
    pub struct AdUnitServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdUnitServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdUnitServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdUnitServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdUnitServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve an AdUnit object.
        pub async fn get_ad_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::AdUnit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/GetAdUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.AdUnitService", "GetAdUnit"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of AdUnit objects.
        pub async fn list_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/ListAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "ListAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of AdUnitSize objects.
        pub async fn list_ad_unit_sizes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAdUnitSizesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAdUnitSizesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/ListAdUnitSizes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "ListAdUnitSizes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create an `AdUnit` object.
        pub async fn create_ad_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAdUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::AdUnit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/CreateAdUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "CreateAdUnit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update an `AdUnit` object.
        pub async fn update_ad_unit(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAdUnitRequest>,
        ) -> std::result::Result<tonic::Response<super::AdUnit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/UpdateAdUnit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "UpdateAdUnit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `AdUnit` objects.
        pub async fn batch_create_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/BatchCreateAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "BatchCreateAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `AdUnit` objects.
        pub async fn batch_update_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/BatchUpdateAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "BatchUpdateAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch activate `AdUnit` objects.
        pub async fn batch_activate_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchActivateAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchActivateAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/BatchActivateAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "BatchActivateAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deactivates a list of `AdUnit` objects.
        pub async fn batch_deactivate_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeactivateAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchDeactivateAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/BatchDeactivateAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "BatchDeactivateAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Archives a list of `AdUnit` objects.
        pub async fn batch_archive_ad_units(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchArchiveAdUnitsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchArchiveAdUnitsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AdUnitService/BatchArchiveAdUnits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AdUnitService",
                        "BatchArchiveAdUnits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// / AdManagerError contains all the information required for processing a
/// / particular error thrown by the AdManager API.
/// /
/// / At least one AdManagerError should be included in all error messages sent
/// to / the client.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdManagerError {
    /// The unique identifying string for this error.
    #[prost(string, tag = "1")]
    pub error_code: ::prost::alloc::string::String,
    /// A publisher appropriate explanation of this error.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// The field path that triggered this error.
    #[prost(string, tag = "3")]
    pub field_path: ::prost::alloc::string::String,
    /// The value that triggered this error.
    #[prost(string, tag = "4")]
    pub trigger: ::prost::alloc::string::String,
    /// The stack trace that accompanies this error.
    #[prost(string, tag = "5")]
    pub stack_trace: ::prost::alloc::string::String,
    /// A list of messages that carry any additional error details.
    #[prost(message, repeated, tag = "6")]
    pub details: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
/// An application that has been added to or "claimed" by the network to be used
/// for targeting purposes. These mobile apps can come from various app stores.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Application {
    /// Identifier. The resource name of the `Application`.
    /// Format: `networks/{network_code}/applications/{application_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The display name of the application. This attribute is required
    /// and has a maximum length of 80 characters.
    #[prost(string, optional, tag = "4")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetApplication` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetApplicationRequest {
    /// Required. The resource name of the Application.
    /// Format: `networks/{network_code}/applications/{application_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListApplications` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListApplicationsRequest {
    /// Required. The parent, which owns this collection of Applications.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Applications` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Applications`
    /// will be returned. The maximum value is 1000; values greater than 1000 will
    /// be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListApplications` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListApplications` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListApplicationsRequest` containing matching
/// `Application` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListApplicationsResponse {
    /// The `Application` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub applications: ::prost::alloc::vec::Vec<Application>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Application` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod application_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Application` objects.
    #[derive(Debug, Clone)]
    pub struct ApplicationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ApplicationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ApplicationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ApplicationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ApplicationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Application` object.
        pub async fn get_application(
            &mut self,
            request: impl tonic::IntoRequest<super::GetApplicationRequest>,
        ) -> std::result::Result<tonic::Response<super::Application>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ApplicationService/GetApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ApplicationService",
                        "GetApplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Application` objects.
        pub async fn list_applications(
            &mut self,
            request: impl tonic::IntoRequest<super::ListApplicationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListApplicationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ApplicationService/ListApplications",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ApplicationService",
                        "ListApplications",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The `AudienceSegment` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AudienceSegment {
    /// Identifier. The resource name of the `AudienceSegment`.
    /// Format: `networks/{network_code}/audienceSegments/{audience_segment_id}`
    /// The `audience_segment_id` may have up to 1 of the following suffixes:
    ///
    /// * `~direct` for directly licensed third-party segments
    /// * `~global` for globally licensed third-party segments
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Display name of the `AudienceSegment`. The attribute has a
    /// maximum length of 255 characters.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetAudienceSegment` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAudienceSegmentRequest {
    /// Required. The resource name of the AudienceSegment.
    /// Format: `networks/{network_code}/audienceSegments/{audience_segment_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListAudienceSegments` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAudienceSegmentsRequest {
    /// Required. The parent publisher network associated with these audience
    /// segments. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `AudienceSegments` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `AudienceSegments` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAudienceSegments`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListAudienceSegments`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListAudienceSegmentsRequest` containing matching
/// `AudienceSegment` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudienceSegmentsResponse {
    /// The `AudienceSegment` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub audience_segments: ::prost::alloc::vec::Vec<AudienceSegment>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `AudienceSegment` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod audience_segment_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `AudienceSegment` objects.
    #[derive(Debug, Clone)]
    pub struct AudienceSegmentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AudienceSegmentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AudienceSegmentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AudienceSegmentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AudienceSegmentServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve an `AudienceSegment` object.
        pub async fn get_audience_segment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAudienceSegmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AudienceSegment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AudienceSegmentService/GetAudienceSegment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AudienceSegmentService",
                        "GetAudienceSegment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `AudienceSegment` objects.
        pub async fn list_audience_segments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAudienceSegmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAudienceSegmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.AudienceSegmentService/ListAudienceSegments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.AudienceSegmentService",
                        "ListAudienceSegments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a group of bandwidths that are logically organized by some well
/// known generic name such as 'Cable' or 'DSL'.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BandwidthGroup {
    /// Identifier. The resource name of the `BandwidthGroup`.
    /// Format: `networks/{network_code}/bandwidthGroups/{bandwidth_group_id}`
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The localized name of the bandwidth group.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetBandwidthGroup` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBandwidthGroupRequest {
    /// Required. The resource name of the BandwidthGroup.
    /// Format: `networks/{network_code}/bandwidthGroups/{bandwidth_group_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListBandwidthGroups` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBandwidthGroupsRequest {
    /// Required. The parent, which owns this collection of BandwidthGroups.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `BandwidthGroups` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `BandwidthGroups` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListBandwidthGroups`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListBandwidthGroups`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListBandwidthGroupsRequest` containing matching
/// `BandwidthGroup` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBandwidthGroupsResponse {
    /// The `BandwidthGroup` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub bandwidth_groups: ::prost::alloc::vec::Vec<BandwidthGroup>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `BandwidthGroup` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod bandwidth_group_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `BandwidthGroup` objects.
    #[derive(Debug, Clone)]
    pub struct BandwidthGroupServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BandwidthGroupServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BandwidthGroupServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BandwidthGroupServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BandwidthGroupServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `BandwidthGroup` object.
        pub async fn get_bandwidth_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBandwidthGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::BandwidthGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.BandwidthGroupService/GetBandwidthGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.BandwidthGroupService",
                        "GetBandwidthGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `BandwidthGroup` objects.
        pub async fn list_bandwidth_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBandwidthGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBandwidthGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.BandwidthGroupService/ListBandwidthGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.BandwidthGroupService",
                        "ListBandwidthGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents the language of a browser.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BrowserLanguage {
    /// Identifier. The resource name of the `BrowserLanguage`.
    /// Format: `networks/{network_code}/browserLanguages/{browser_language_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The name of the browser language, localized.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetBrowserLanguage` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBrowserLanguageRequest {
    /// Required. The resource name of the BrowserLanguage.
    /// Format: `networks/{network_code}/browserLanguages/{browser_language_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListBrowserLanguages` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBrowserLanguagesRequest {
    /// Required. The parent, which owns this collection of BrowserLanguages.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `BrowserLanguages` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `BrowserLanguages` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListBrowserLanguages`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListBrowserLanguages`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListBrowserLanguagesRequest` containing matching
/// `BrowserLanguage` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBrowserLanguagesResponse {
    /// The `BrowserLanguage` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub browser_languages: ::prost::alloc::vec::Vec<BrowserLanguage>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `BrowserLanguage` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod browser_language_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `BrowserLanguage` objects.
    #[derive(Debug, Clone)]
    pub struct BrowserLanguageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BrowserLanguageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BrowserLanguageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BrowserLanguageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BrowserLanguageServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `BrowserLanguage` object.
        pub async fn get_browser_language(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBrowserLanguageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BrowserLanguage>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.BrowserLanguageService/GetBrowserLanguage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.BrowserLanguageService",
                        "GetBrowserLanguage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `BrowserLanguage` objects.
        pub async fn list_browser_languages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBrowserLanguagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBrowserLanguagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.BrowserLanguageService/ListBrowserLanguages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.BrowserLanguageService",
                        "ListBrowserLanguages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a browser, including its version.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Browser {
    /// Identifier. The resource name of the `Browser`.
    /// Format: `networks/{network_code}/browsers/{browser}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The display name of the browser, including version info.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The major version of the browser.
    #[prost(string, optional, tag = "4")]
    pub major_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The minor version of the browser.
    #[prost(string, optional, tag = "5")]
    pub minor_version: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetBrowser` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBrowserRequest {
    /// Required. The resource name of the Browser.
    /// Format: `networks/{network_code}/browsers/{browser_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListBrowsers` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListBrowsersRequest {
    /// Required. The parent, which owns this collection of Browsers.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Browsers` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Browsers` will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListBrowsers` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListBrowsers` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListBrowsersRequest` containing matching `Browser`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBrowsersResponse {
    /// The `Browser` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub browsers: ::prost::alloc::vec::Vec<Browser>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Browser` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod browser_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Browser` objects.
    #[derive(Debug, Clone)]
    pub struct BrowserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl BrowserServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> BrowserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BrowserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            BrowserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Browser` object.
        pub async fn get_browser(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBrowserRequest>,
        ) -> std::result::Result<tonic::Response<super::Browser>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.BrowserService/GetBrowser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.BrowserService",
                        "GetBrowser",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Browser` objects.
        pub async fn list_browsers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBrowsersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBrowsersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.BrowserService/ListBrowsers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.BrowserService",
                        "ListBrowsers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[CmsMetadataKeyStatus\]\[google.ads.admanager.v1.CmsMetadataKeyStatusEnum.CmsMetadataKeyStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CmsMetadataKeyStatusEnum {}
/// Nested message and enum types in `CmsMetadataKeyStatusEnum`.
pub mod cms_metadata_key_status_enum {
    /// Status for CmsMetadataKey objects.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CmsMetadataKeyStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The key is active.
        Active = 1,
        /// The key is not active.
        Inactive = 2,
    }
    impl CmsMetadataKeyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CMS_METADATA_KEY_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CMS_METADATA_KEY_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Key associated with a piece of content from a publisher's CMS.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CmsMetadataKey {
    /// Identifier. The resource name of the `CmsMetadataKey`.
    /// Format: `networks/{network_code}/cmsMetadataKeys/{cms_metadata_key_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The key of a key-value pair.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The status of this CMS metadata key.
    #[prost(
        enumeration = "cms_metadata_key_status_enum::CmsMetadataKeyStatus",
        tag = "4"
    )]
    pub status: i32,
}
/// Request object for `GetCmsMetadataKey` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCmsMetadataKeyRequest {
    /// Required. The resource name of the CmsMetadataKey.
    /// Format: `networks/{network_code}/cmsMetadataKeys/{cms_metadata_key_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCmsMetadataKeys` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCmsMetadataKeysRequest {
    /// Required. The parent, which owns this collection of CmsMetadataKeys.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `CmsMetadataKeys` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `CmsMetadataKeys` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCmsMetadataKeys`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCmsMetadataKeys`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCmsMetadataKeysRequest` containing matching
/// `CmsMetadataKey` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCmsMetadataKeysResponse {
    /// The `CmsMetadataKey` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub cms_metadata_keys: ::prost::alloc::vec::Vec<CmsMetadataKey>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `CmsMetadataKey` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod cms_metadata_key_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CmsMetadataKey` objects.
    #[derive(Debug, Clone)]
    pub struct CmsMetadataKeyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CmsMetadataKeyServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CmsMetadataKeyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CmsMetadataKeyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CmsMetadataKeyServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CmsMetadataKey` object.
        pub async fn get_cms_metadata_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCmsMetadataKeyRequest>,
        ) -> std::result::Result<tonic::Response<super::CmsMetadataKey>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CmsMetadataKeyService/GetCmsMetadataKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CmsMetadataKeyService",
                        "GetCmsMetadataKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CmsMetadataKey` objects.
        pub async fn list_cms_metadata_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCmsMetadataKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCmsMetadataKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CmsMetadataKeyService/ListCmsMetadataKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CmsMetadataKeyService",
                        "ListCmsMetadataKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[CmsMetadataValueStatus\]\[google.ads.admanager.v1.CmsMetadataValueStatusEnum.CmsMetadataValueStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CmsMetadataValueStatusEnum {}
/// Nested message and enum types in `CmsMetadataValueStatusEnum`.
pub mod cms_metadata_value_status_enum {
    /// Status for CmsMetadataValue objects.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CmsMetadataValueStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The value is active.
        Active = 1,
        /// The value is archived.
        Archived = 2,
        /// The value is not active.
        Inactive = 3,
    }
    impl CmsMetadataValueStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CMS_METADATA_VALUE_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Archived => "ARCHIVED",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CMS_METADATA_VALUE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "ARCHIVED" => Some(Self::Archived),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Key value pair associated with a piece of content from a publisher's CMS.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CmsMetadataValue {
    /// Identifier. The resource name of the `CmsMetadataValue`.
    /// Format:
    /// `networks/{network_code}/cmsMetadataValues/{cms_metadata_value_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The value of this key-value pair.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. Immutable. The resource name of the CmsMetadataKey.
    /// Format: "networks/{network_code}/cmsMetadataKey/{cms_metadata_key_id}"
    #[prost(string, tag = "5")]
    pub key: ::prost::alloc::string::String,
    /// Output only. The status of this CMS metadata value.
    #[prost(
        enumeration = "cms_metadata_value_status_enum::CmsMetadataValueStatus",
        tag = "6"
    )]
    pub status: i32,
}
/// Request object for `GetCmsMetadataValue` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCmsMetadataValueRequest {
    /// Required. The resource name of the CmsMetadataValue.
    /// Format: `networks/{network_code}/cmsMetadataValues/{cms_metadata_value_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCmsMetadataValues` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCmsMetadataValuesRequest {
    /// Required. The parent, which owns this collection of CmsMetadataValues.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `CmsMetadataValues` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `CmsMetadataValues` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCmsMetadataValues`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCmsMetadataValues`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCmsMetadataValuesRequest` containing matching
/// `CmsMetadataValue` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCmsMetadataValuesResponse {
    /// The `CmsMetadataValue` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub cms_metadata_values: ::prost::alloc::vec::Vec<CmsMetadataValue>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `CmsMetadataValue` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod cms_metadata_value_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CmsMetadataValue` objects.
    #[derive(Debug, Clone)]
    pub struct CmsMetadataValueServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CmsMetadataValueServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CmsMetadataValueServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CmsMetadataValueServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CmsMetadataValueServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CmsMetadataValue` object.
        pub async fn get_cms_metadata_value(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCmsMetadataValueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CmsMetadataValue>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CmsMetadataValueService/GetCmsMetadataValue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CmsMetadataValueService",
                        "GetCmsMetadataValue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CmsMetadataValue` objects.
        pub async fn list_cms_metadata_values(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCmsMetadataValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCmsMetadataValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CmsMetadataValueService/ListCmsMetadataValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CmsMetadataValueService",
                        "ListCmsMetadataValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[CompanyType\]\[google.ads.admanager.v1.CompanyTypeEnum.CompanyType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompanyTypeEnum {}
/// Nested message and enum types in `CompanyTypeEnum`.
pub mod company_type_enum {
    /// The type of a company.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompanyType {
        /// No value specified
        Unspecified = 0,
        /// A business entity that purchases ad inventory.
        Advertiser = 1,
        /// A company representing the publisher's own advertiser for house ads.
        HouseAdvertiser = 2,
        /// An organization that manages ad accounts and offers services, such as ad
        /// creation, placement, and management to advertisers.
        Agency = 3,
        /// A company representing the publisher's own agency.
        HouseAgency = 4,
        /// A company representing multiple advertisers and agencies.
        AdNetwork = 5,
    }
    impl CompanyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPANY_TYPE_UNSPECIFIED",
                Self::Advertiser => "ADVERTISER",
                Self::HouseAdvertiser => "HOUSE_ADVERTISER",
                Self::Agency => "AGENCY",
                Self::HouseAgency => "HOUSE_AGENCY",
                Self::AdNetwork => "AD_NETWORK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPANY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ADVERTISER" => Some(Self::Advertiser),
                "HOUSE_ADVERTISER" => Some(Self::HouseAdvertiser),
                "AGENCY" => Some(Self::Agency),
                "HOUSE_AGENCY" => Some(Self::HouseAgency),
                "AD_NETWORK" => Some(Self::AdNetwork),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CompanyCreditStatus\]\[google.ads.admanager.v1.CompanyCreditStatusEnum.CompanyCreditStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompanyCreditStatusEnum {}
/// Nested message and enum types in `CompanyCreditStatusEnum`.
pub mod company_credit_status_enum {
    /// The credit status of a company.
    ///
    /// Credit statuses specify the credit-worthiness of a company and affect the
    /// ad serving of campaigns belonging to the company.
    ///
    /// In basic settings, only the
    /// \[ACTIVE\]\[google.ads.admanager.v1.CompanyCreditStatusEnum.CompanyCreditStatus.ACTIVE\]
    /// and
    /// \[INACTIVE\]\[google.ads.admanager.v1.CompanyCreditStatusEnum.CompanyCreditStatus.INACTIVE\]
    /// credit statuses are applicable. In advance settings, all credit statuses
    /// are applicable.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompanyCreditStatus {
        /// No value specified
        Unspecified = 0,
        /// The company's credit status is active.
        ///
        /// Line items belonging to the company can serve.
        ///
        /// This credit status is the default for basic settings and is available in
        /// both basic and advance settings.
        Active = 1,
        /// The company's credit status is inactive.
        ///
        /// Line items belonging to the company cannot be activated. However, line
        /// items that were activated before the credit status changed will remain
        /// active. New orders or line items belonging to the company cannot be
        /// created.
        ///
        /// Companies with this credit status will be hidden by default in company
        /// search results.
        ///
        /// This credit status is available in both basic and advance settings.
        Inactive = 2,
        /// The company's credit status is on hold.
        ///
        /// Line items belonging to the company cannot be activated. However, line
        /// items that were activated before the credit status changed will remain
        /// active. New orders or line items belonging to the company can be
        /// created.
        ///
        /// This credit status is the default in advance settings and is only
        /// available in advance settings.
        OnHold = 3,
        /// The company's credit status is stopped.
        ///
        /// Line items belonging to the company cannot be activated. However, line
        /// items that were activated before the credit status changed will remain
        /// active. New orders or line items belonging to the company cannot be
        /// created.
        ///
        /// This credit status is only available in advance settings.
        Stop = 4,
        /// The company's credit status is blocked.
        ///
        /// All active line items belonging to the company will stop serving with
        /// immediate effect. Line items belonging to the company cannot be
        /// activated, and new orders or line items belonging to the company cannot
        /// be created.
        ///
        /// This credit status is only available in advance settings.
        Blocked = 5,
    }
    impl CompanyCreditStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMPANY_CREDIT_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::OnHold => "ON_HOLD",
                Self::Stop => "STOP",
                Self::Blocked => "BLOCKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPANY_CREDIT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ON_HOLD" => Some(Self::OnHold),
                "STOP" => Some(Self::Stop),
                "BLOCKED" => Some(Self::Blocked),
                _ => None,
            }
        }
    }
}
/// The `Company` resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Company {
    /// Identifier. The resource name of the `Company`.
    /// Format: `networks/{network_code}/companies/{company_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `Company` ID.
    #[prost(int64, optional, tag = "2")]
    pub company_id: ::core::option::Option<i64>,
    /// Required. The display name of the `Company`.
    ///
    /// This value has a maximum length of 127 characters.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The type of the `Company`.
    #[prost(enumeration = "company_type_enum::CompanyType", optional, tag = "4")]
    pub r#type: ::core::option::Option<i32>,
    /// Optional. The address for the `Company`.
    ///
    /// This value has a maximum length of 1024 characters.
    #[prost(string, optional, tag = "5")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The email for the `Company`.
    ///
    /// This value has a maximum length of 128 characters.
    #[prost(string, optional, tag = "6")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The fax number for the `Company`.
    ///
    /// This value has a maximum length of 63 characters.
    #[prost(string, optional, tag = "7")]
    pub fax: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The phone number for the `Company`.
    ///
    /// This value has a maximum length of 63 characters.
    #[prost(string, optional, tag = "8")]
    pub phone: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The external ID for the `Company`.
    ///
    /// This value has a maximum length of 255 characters.
    #[prost(string, optional, tag = "9")]
    pub external_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Comments about the `Company`.
    ///
    /// This value has a maximum length of 1024 characters.
    #[prost(string, optional, tag = "10")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The credit status of the `Company`.
    ///
    /// This attribute defaults to `ACTIVE` if basic settings are enabled and
    /// `ON_HOLD` if advance settings are enabled.
    #[prost(
        enumeration = "company_credit_status_enum::CompanyCreditStatus",
        optional,
        tag = "11"
    )]
    pub credit_status: ::core::option::Option<i32>,
    /// Optional. The labels that are directly applied to the `Company`.
    #[prost(message, repeated, tag = "12")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    /// Optional. The resource names of primary Contact of the `Company`.
    /// Format: "networks/{network_code}/contacts/{contact_id}"
    #[prost(string, optional, tag = "13")]
    pub primary_contact: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The resource names of Teams that are directly associated with the
    /// `Company`. Format: "networks/{network_code}/teams/{team_id}"
    #[prost(string, repeated, tag = "14")]
    pub applied_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The ID of the Google-recognized canonicalized form of the
    /// `Company`.
    #[prost(int64, optional, tag = "16")]
    pub third_party_company_id: ::core::option::Option<i64>,
    /// Output only. The time the `Company` was last modified.
    #[prost(message, optional, tag = "15")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request object for `GetCompany` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCompanyRequest {
    /// Required. The resource name of the Company.
    /// Format: `networks/{network_code}/companies/{company_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCompanies` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCompaniesRequest {
    /// Required. The parent, which owns this collection of Companies.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Companies` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Companies` will
    /// be returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCompanies` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCompanies` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCompaniesRequest` containing matching `Company`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCompaniesResponse {
    /// The `Company` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub companies: ::prost::alloc::vec::Vec<Company>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Company` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod company_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Company` objects.
    #[derive(Debug, Clone)]
    pub struct CompanyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CompanyServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CompanyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CompanyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CompanyServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Company` object.
        pub async fn get_company(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCompanyRequest>,
        ) -> std::result::Result<tonic::Response<super::Company>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CompanyService/GetCompany",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CompanyService",
                        "GetCompany",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Company` objects.
        pub async fn list_companies(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCompaniesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCompaniesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CompanyService/ListCompanies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CompanyService",
                        "ListCompanies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[ContactStatus\]\[google.ads.admanager.v1.ContactStatusEnum.ContactStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContactStatusEnum {}
/// Nested message and enum types in `ContactStatusEnum`.
pub mod contact_status_enum {
    /// Describes the contact statuses.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContactStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The contact was invited to see their orders, but the invitation was
        /// cancelled.
        InviteCanceled = 1,
        /// The contact has been invited to see their orders, but the invitation has
        /// already expired.
        InviteExpired = 2,
        /// The contact has been invited to see their orders, but has not yet
        /// accepted the invitation.
        InvitePending = 3,
        /// The contact has not been invited to see their orders.
        Uninvited = 4,
        /// The contact has access to login and view their orders.
        UserActive = 5,
        /// The contact accepted an invitation to see their orders, but their access
        /// was later revoked.
        UserDisabled = 6,
    }
    impl ContactStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONTACT_STATUS_UNSPECIFIED",
                Self::InviteCanceled => "INVITE_CANCELED",
                Self::InviteExpired => "INVITE_EXPIRED",
                Self::InvitePending => "INVITE_PENDING",
                Self::Uninvited => "UNINVITED",
                Self::UserActive => "USER_ACTIVE",
                Self::UserDisabled => "USER_DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTACT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "INVITE_CANCELED" => Some(Self::InviteCanceled),
                "INVITE_EXPIRED" => Some(Self::InviteExpired),
                "INVITE_PENDING" => Some(Self::InvitePending),
                "UNINVITED" => Some(Self::Uninvited),
                "USER_ACTIVE" => Some(Self::UserActive),
                "USER_DISABLED" => Some(Self::UserDisabled),
                _ => None,
            }
        }
    }
}
/// A contact represents a person who is affiliated with a single company. A
/// contact can have a variety of contact information associated to it, and can
/// be invited to view their company's orders, line items, creatives, and
/// reports.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Contact {
    /// Identifier. The resource name of the `Contact`.
    /// Format: `networks/{network_code}/contacts/{contact_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the contact. This attribute has a maximum length of
    /// 127 characters.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Immutable. The resource name of the Company.
    /// Format: "networks/{network_code}/companies/{company_id}"
    #[prost(string, optional, tag = "5")]
    pub company: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of the contact. This attribute is assigned by
    /// Google.
    #[prost(enumeration = "contact_status_enum::ContactStatus", optional, tag = "6")]
    pub status: ::core::option::Option<i32>,
    /// Optional. The address of the contact. This attribute has a maximum length
    /// of 1024 characters.
    #[prost(string, optional, tag = "7")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The cell phone number where the contact can be reached.
    #[prost(string, optional, tag = "8")]
    pub cell_phone: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A free-form text comment for the contact. This attribute has a
    /// maximum length of 1024 characters.
    #[prost(string, optional, tag = "9")]
    pub comment: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The e-mail address where the contact can be reached. This
    /// attribute has a maximum length of 128 characters.
    #[prost(string, optional, tag = "10")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The fax number where the contact can be reached. This attribute
    /// has a maximum length of 1024 characters.
    #[prost(string, optional, tag = "11")]
    pub fax: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The job title of the contact. This attribute has a maximum length
    /// of 1024 characters.
    #[prost(string, optional, tag = "12")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The work phone number where the contact can be reached. This
    /// attribute has a maximum length of 1024 characters.
    #[prost(string, optional, tag = "13")]
    pub work_phone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetContact` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetContactRequest {
    /// Required. The resource name of the Contact.
    /// Format: `networks/{network_code}/contacts/{contact_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListContacts` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListContactsRequest {
    /// Required. The parent, which owns this collection of Contacts.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Contacts` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Contacts` will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListContacts` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListContacts` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListContactsRequest` containing matching `Contact`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContactsResponse {
    /// The `Contact` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Contact` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateContact` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateContactRequest {
    /// Required. The parent resource where this `Contact` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Contact` to create.
    #[prost(message, optional, tag = "2")]
    pub contact: ::core::option::Option<Contact>,
}
/// Request object for `BatchCreateContacts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateContactsRequest {
    /// Required. The parent resource where `Contacts` will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreateContactRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Contact` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateContactRequest>,
}
/// Response object for `BatchCreateContacts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateContactsResponse {
    /// The `Contact` objects created.
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
/// Request object for `UpdateContact` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateContactRequest {
    /// Required. The `Contact` to update.
    ///
    /// The `Contact`'s `name` is used to identify the `Contact` to update.
    #[prost(message, optional, tag = "1")]
    pub contact: ::core::option::Option<Contact>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchUpdateContacts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateContactsRequest {
    /// Required. The parent resource where `Contacts` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdateContactRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Contact` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateContactRequest>,
}
/// Response object for `BatchUpdateContacts` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateContactsResponse {
    /// The `Contact` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub contacts: ::prost::alloc::vec::Vec<Contact>,
}
/// Generated client implementations.
pub mod contact_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Contact` objects.
    #[derive(Debug, Clone)]
    pub struct ContactServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContactServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContactServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContactServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContactServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Contact` object.
        pub async fn get_contact(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContactRequest>,
        ) -> std::result::Result<tonic::Response<super::Contact>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/GetContact",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "GetContact",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Contact` objects.
        pub async fn list_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContactsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/ListContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "ListContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `Contact` object.
        pub async fn create_contact(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateContactRequest>,
        ) -> std::result::Result<tonic::Response<super::Contact>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/CreateContact",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "CreateContact",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `Contact` objects.
        pub async fn batch_create_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateContactsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/BatchCreateContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "BatchCreateContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `Contact` object.
        pub async fn update_contact(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateContactRequest>,
        ) -> std::result::Result<tonic::Response<super::Contact>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/UpdateContact",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "UpdateContact",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `Contact` objects.
        pub async fn batch_update_contacts(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateContactsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateContactsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContactService/BatchUpdateContacts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContactService",
                        "BatchUpdateContacts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A \[ContentBundle\]\[google.ads.admanager.v1.ContentBundle\] is a grouping of
/// individual \[Content\]\[google.ads.admanager.v1.Content\]. A
/// \[ContentBundle\]\[google.ads.admanager.v1.ContentBundle\] is defined as
/// including the \[Content\]\[google.ads.admanager.v1.Content\] that match certain
/// filter rules along with the option to explicitly include or exclude certain
/// Content IDs.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContentBundle {
    /// Identifier. The resource name of the
    /// \[ContentBundle\]\[google.ads.admanager.v1.ContentBundle\]. Format:
    /// `networks/{network_code}/contentBundles/{content_bundle_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the
    /// \[ContentBundle\]\[google.ads.admanager.v1.ContentBundle\]. This attribute is
    /// required and has a maximum length of 255 characters.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
}
/// Request object for `GetContentBundle` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetContentBundleRequest {
    /// Required. The resource name of the ContentBundle.
    /// Format: `networks/{network_code}/contentBundles/{content_bundle_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListContentBundles` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListContentBundlesRequest {
    /// Required. The parent, which owns this collection of ContentBundles.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `ContentBundles` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `ContentBundles`
    /// will be returned. The maximum value is 1000; values greater than 1000 will
    /// be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListContentBundles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListContentBundles` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListContentBundlesRequest` containing matching
/// `ContentBundle` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentBundlesResponse {
    /// The `ContentBundle` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub content_bundles: ::prost::alloc::vec::Vec<ContentBundle>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `ContentBundle` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod content_bundle_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `ContentBundle` objects.
    #[derive(Debug, Clone)]
    pub struct ContentBundleServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContentBundleServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContentBundleServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContentBundleServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContentBundleServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `ContentBundle` object.
        pub async fn get_content_bundle(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContentBundleRequest>,
        ) -> std::result::Result<tonic::Response<super::ContentBundle>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContentBundleService/GetContentBundle",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContentBundleService",
                        "GetContentBundle",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `ContentBundle` objects.
        pub async fn list_content_bundles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContentBundlesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContentBundlesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContentBundleService/ListContentBundles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContentBundleService",
                        "ListContentBundles",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A content label.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContentLabel {
    /// Identifier. The resource name of the `ContentLabel`.
    /// Format: `networks/{network_code}/contentLabels/{content_label_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The display name of the `ContentLabel`.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// Request object for `GetContentLabel` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetContentLabelRequest {
    /// Required. The resource name of the ContentLabel.
    /// Format: `networks/{network_code}/contentLabels/{content_label_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListContentLabels` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListContentLabelsRequest {
    /// Required. The parent, which owns this collection of ContentLabels.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `ContentLabels` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `ContentLabels`
    /// will be returned. The maximum value is 1000; values greater than 1000 will
    /// be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListContentLabels` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListContentLabels` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListContentLabelsRequest` containing matching
/// `ContentLabel` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentLabelsResponse {
    /// The `ContentLabel` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub content_labels: ::prost::alloc::vec::Vec<ContentLabel>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `ContentLabel` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod content_label_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `ContentLabel` objects.
    #[derive(Debug, Clone)]
    pub struct ContentLabelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContentLabelServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContentLabelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContentLabelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContentLabelServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `ContentLabel` object.
        pub async fn get_content_label(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContentLabelRequest>,
        ) -> std::result::Result<tonic::Response<super::ContentLabel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContentLabelService/GetContentLabel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContentLabelService",
                        "GetContentLabel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `ContentLabel` objects.
        pub async fn list_content_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContentLabelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContentLabelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContentLabelService/ListContentLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContentLabelService",
                        "ListContentLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A piece of content from a Publisher's CMS.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Content {
    /// Identifier. The resource name of the `Content`.
    /// Format: `networks/{network_code}/content/{content_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The name of the `Content`.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetContent` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetContentRequest {
    /// Required. The resource name of the Content.
    /// Format: `networks/{network_code}/content/{content_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListContent` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListContentRequest {
    /// Required. The parent, which owns this collection of Content.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Content` to return. The service may return
    /// fewer than this value. If unspecified, at most 50 `Content` will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListContent` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListContent` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListContentRequest` containing matching `Content`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContentResponse {
    /// The `Content` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub content: ::prost::alloc::vec::Vec<Content>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Content` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod content_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Content` objects.
    #[derive(Debug, Clone)]
    pub struct ContentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Content` object.
        pub async fn get_content(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContentRequest>,
        ) -> std::result::Result<tonic::Response<super::Content>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContentService/GetContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContentService",
                        "GetContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Content` objects.
        pub async fn list_content(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListContentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ContentService/ListContent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ContentService",
                        "ListContent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[CreativeTemplateType\]\[google.ads.admanager.v1.CreativeTemplateTypeEnum.CreativeTemplateType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreativeTemplateTypeEnum {}
/// Nested message and enum types in `CreativeTemplateTypeEnum`.
pub mod creative_template_type_enum {
    /// Describes type of the creative template.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreativeTemplateType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Creative templates that are included in Ad Manager by default.
        Standard = 1,
        /// Creative templates created by an administrator or other user in the
        /// network.
        Custom = 2,
    }
    impl CreativeTemplateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CREATIVE_TEMPLATE_TYPE_UNSPECIFIED",
                Self::Standard => "STANDARD",
                Self::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATIVE_TEMPLATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CreativeTemplateStatus\]\[google.ads.admanager.v1.CreativeTemplateStatusEnum.CreativeTemplateStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreativeTemplateStatusEnum {}
/// Nested message and enum types in `CreativeTemplateStatusEnum`.
pub mod creative_template_status_enum {
    /// Describes status of the creative template
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreativeTemplateStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The CreativeTemplate is active
        Active = 1,
        /// The CreativeTemplate is deleted. Creatives created from this
        /// CreativeTemplate can no longer serve.
        Deleted = 2,
        /// The CreativeTemplate is inactive. Users cannot create new creatives
        /// from this template, but existing ones can be edited and continue to serve
        Inactive = 3,
    }
    impl CreativeTemplateStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CREATIVE_TEMPLATE_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Deleted => "DELETED",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATIVE_TEMPLATE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "DELETED" => Some(Self::Deleted),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CreativeTemplateVariableUrlType\]\[google.ads.admanager.v1.CreativeTemplateVariableUrlTypeEnum.CreativeTemplateVariableUrlType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreativeTemplateVariableUrlTypeEnum {}
/// Nested message and enum types in `CreativeTemplateVariableUrlTypeEnum`.
pub mod creative_template_variable_url_type_enum {
    /// Types of URLs that a UrlCreativeTemplateVariable can represent.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreativeTemplateVariableUrlType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Click tracking URL.
        ClickTracker = 1,
        /// Deep-link URL.
        Deeplink = 2,
        /// Impression tracking URL.
        ImpressionTracker = 3,
        /// Standard HTTP URL.
        StandardHttp = 4,
    }
    impl CreativeTemplateVariableUrlType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CREATIVE_TEMPLATE_VARIABLE_URL_TYPE_UNSPECIFIED",
                Self::ClickTracker => "CLICK_TRACKER",
                Self::Deeplink => "DEEPLINK",
                Self::ImpressionTracker => "IMPRESSION_TRACKER",
                Self::StandardHttp => "STANDARD_HTTP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATIVE_TEMPLATE_VARIABLE_URL_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "CLICK_TRACKER" => Some(Self::ClickTracker),
                "DEEPLINK" => Some(Self::Deeplink),
                "IMPRESSION_TRACKER" => Some(Self::ImpressionTracker),
                "STANDARD_HTTP" => Some(Self::StandardHttp),
                _ => None,
            }
        }
    }
}
/// A template that can be used to create a \[TemplateCreative\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreativeTemplate {
    /// Identifier. The resource name of the creative template.
    /// Format: `networks/{network_code}/creativeTemplates/{creative_template_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The display name of the creative template. This has a maximum
    /// length of 255 characters.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The description of the creative template.
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The code snippet of the creative template, with placeholders for
    /// the associated variables.
    #[prost(string, optional, tag = "4")]
    pub snippet: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of the creative template. This attribute is
    /// assigned by Google.
    #[prost(
        enumeration = "creative_template_status_enum::CreativeTemplateStatus",
        optional,
        tag = "6"
    )]
    pub status: ::core::option::Option<i32>,
    /// Optional. The type of the creative template. Users can only create or
    /// update `CreativeTemplateType.CUSTOM` templates.
    #[prost(
        enumeration = "creative_template_type_enum::CreativeTemplateType",
        optional,
        tag = "7"
    )]
    pub r#type: ::core::option::Option<i32>,
    /// Optional. `True` if this creative template produces out-of-page creatives.
    /// Creative templates with this setting enabled must include the viewed
    /// impression macro.
    #[prost(bool, optional, tag = "8")]
    pub interstitial: ::core::option::Option<bool>,
    /// Optional. `True` if this creative template produces native-eligible
    /// creatives.
    #[prost(bool, optional, tag = "9")]
    pub native_eligible: ::core::option::Option<bool>,
    /// Optional. `True` if this creative template produces native video-eligible
    /// creatives.
    #[prost(bool, optional, tag = "10")]
    pub native_video_eligible: ::core::option::Option<bool>,
    /// Optional. Whether the Creative produced is compatible for SafeFrame
    /// rendering. This attribute defaults to `True`.
    #[prost(bool, optional, tag = "12")]
    pub safe_frame_compatible: ::core::option::Option<bool>,
    /// Required. The list of creative template variables.
    #[prost(message, repeated, tag = "14")]
    pub variables: ::prost::alloc::vec::Vec<CreativeTemplateVariable>,
}
/// Represents a variable defined in a creative template.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreativeTemplateVariable {
    /// Required. Label that is displayed to users when creating from the creative
    /// template. This has a maximum length of 127 characters.
    #[prost(string, optional, tag = "1")]
    pub label: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Unique name used to identify the variable. This attribute is
    /// assigned by Google when a creative template variable is created.
    #[prost(string, optional, tag = "2")]
    pub unique_display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. A descriptive help text that is displayed to users along with the
    /// label. This attribute has a maximum length of 255 characters.
    #[prost(string, optional, tag = "3")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. `True` if this variable is required to be filled in by users when
    /// creating a creative from the creative template.
    #[prost(bool, optional, tag = "4")]
    pub required: ::core::option::Option<bool>,
    /// The specific type of variable represented by this
    /// \[CreativeTemplateVariable\]\[google.ads.admanager.v1.CreativeTemplateVariable\].
    /// Exactly one must be set.
    #[prost(oneof = "creative_template_variable::SubType", tags = "5, 7, 8, 9, 10")]
    pub sub_type: ::core::option::Option<creative_template_variable::SubType>,
}
/// Nested message and enum types in `CreativeTemplateVariable`.
pub mod creative_template_variable {
    /// Represents a file asset variable defined in a creative template.
    ///
    /// Use \[AssetCreativeTemplateVariableValue\]\[\] to specify the value for this
    /// variable when creating a \[TemplateCreative\]\[\] from a
    /// \[CreativeTemplate\]\[google.ads.admanager.v1.CreativeTemplate\].
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct AssetCreativeTemplateVariable {
        /// Optional. The set of allowed MIME types. If unspecified, all MIME types
        /// are allowed.
        #[prost(
            enumeration = "asset_creative_template_variable::MimeType",
            repeated,
            packed = "false",
            tag = "1"
        )]
        pub mime_types: ::prost::alloc::vec::Vec<i32>,
    }
    /// Nested message and enum types in `AssetCreativeTemplateVariable`.
    pub mod asset_creative_template_variable {
        /// Different MIME types that the asset variable supports.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MimeType {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The `image/jpeg` MIME type.
            Jpg = 1,
            /// The `image/png` MIME type.
            Png = 2,
            /// The `image/gif` MIME type.
            Gif = 3,
        }
        impl MimeType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "MIME_TYPE_UNSPECIFIED",
                    Self::Jpg => "JPG",
                    Self::Png => "PNG",
                    Self::Gif => "GIF",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MIME_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "JPG" => Some(Self::Jpg),
                    "PNG" => Some(Self::Png),
                    "GIF" => Some(Self::Gif),
                    _ => None,
                }
            }
        }
    }
    /// Represents a list variable defined in a creative template. This is similar
    /// to
    /// \[StringCreativeTemplateVariable\]\[google.ads.admanager.v1.CreativeTemplateVariable.StringCreativeTemplateVariable\],
    /// except that there are possible choices to choose from.
    ///
    /// Use \[StringCreativeTemplateVariableValue\]\[\] to specify the value
    /// for this variable when creating a \[TemplateCreative\]\[\] from a
    /// \[CreativeTemplate\]\[google.ads.admanager.v1.CreativeTemplate\].
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ListStringCreativeTemplateVariable {
        /// Optional. Default value to be filled in when creating creatives from the
        /// creative template.
        #[prost(string, optional, tag = "1")]
        pub default_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Sample value that is used when previewing the template in the
        /// UI.
        #[prost(string, optional, tag = "2")]
        pub sample_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. The selectable values that the user can choose from.
        #[prost(message, repeated, tag = "3")]
        pub choices: ::prost::alloc::vec::Vec<
            list_string_creative_template_variable::VariableChoice,
        >,
        /// Optional. `True` if a user can specify an 'other' value. For example, if
        /// a variable called backgroundColor is defined as a list with values: red,
        /// green, blue, this boolean can be set to allow a user to enter a value not
        /// on the list such as purple.
        #[prost(bool, optional, tag = "4")]
        pub allow_other_choice: ::core::option::Option<bool>,
    }
    /// Nested message and enum types in `ListStringCreativeTemplateVariable`.
    pub mod list_string_creative_template_variable {
        /// Stores variable choices selectable by users.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct VariableChoice {
            /// Required. A label is displayed to users when creating a
            /// \[TemplateCreative\]\[\]. This attribute is intended to be more descriptive
            /// than value. This attribute has a maximum length of 255 characters.
            #[prost(string, optional, tag = "1")]
            pub label: ::core::option::Option<::prost::alloc::string::String>,
            /// Required. When creating a \[TemplateCreative\]\[\], the value in
            /// \[StringCreativeTemplateVariableValue\]\[\] should match this value, if you
            /// intend to select this value. This attribute has a maximum length of 255
            /// characters.
            #[prost(string, optional, tag = "2")]
            pub value: ::core::option::Option<::prost::alloc::string::String>,
        }
    }
    /// Represents a long variable defined in a creative template.
    ///
    /// Use \[LongCreativeTemplateVariableValue\]\[\] to specify the value
    /// for this variable when creating \[TemplateCreative\]\[\] from a
    /// \[CreativeTemplate\]\[google.ads.admanager.v1.CreativeTemplate\].
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LongCreativeTemplateVariable {
        /// Optional. Default value to be filled in when creating creatives from the
        /// creative template.
        #[prost(int64, optional, tag = "1")]
        pub default_value: ::core::option::Option<i64>,
        /// Optional. Sample value that is used when previewing the template in the
        /// UI.
        #[prost(int64, optional, tag = "2")]
        pub sample_value: ::core::option::Option<i64>,
    }
    /// Represents a string variable defined in a creative template.
    ///
    /// Use \[StringCreativeTemplateVariableValue\]\[\] to specify the value
    /// for this variable when creating \[TemplateCreative\]\[\] from a
    /// \[CreativeTemplate\]\[google.ads.admanager.v1.CreativeTemplate\].
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StringCreativeTemplateVariable {
        /// Optional. Default value to be filled in when creating creatives from the
        /// creative template.
        #[prost(string, optional, tag = "1")]
        pub default_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Sample value that is used when previewing the template in the
        /// UI.
        #[prost(string, optional, tag = "2")]
        pub sample_value: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Represents a url variable defined in a creative template.
    ///
    /// Use \[UrlCreativeTemplateVariableValue\]\[\] to specify the value for this
    /// variable when creating a \[TemplateCreative\]\[\] from a
    /// \[CreativeTemplate\]\[google.ads.admanager.v1.CreativeTemplate\].
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct UrlCreativeTemplateVariable {
        /// Optional. Default value to be filled in when creating creatives from the
        /// creative template.
        #[prost(string, optional, tag = "1")]
        pub default_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. Sample value that is used when previewing the template in the
        /// UI.
        #[prost(string, optional, tag = "2")]
        pub sample_value: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. The type of URL that this variable represents. Different types
        /// of URLs may be handled differently at rendering time.
        #[prost(
            enumeration = "super::creative_template_variable_url_type_enum::CreativeTemplateVariableUrlType",
            optional,
            tag = "4"
        )]
        pub url_type: ::core::option::Option<i32>,
    }
    /// The specific type of variable represented by this
    /// \[CreativeTemplateVariable\]\[google.ads.admanager.v1.CreativeTemplateVariable\].
    /// Exactly one must be set.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SubType {
        /// Optional. Represents a file asset variable defined in a creative
        /// template.
        #[prost(message, tag = "5")]
        AssetVariable(AssetCreativeTemplateVariable),
        /// Optional. Represents a list variable defined in a creative template.
        #[prost(message, tag = "7")]
        ListStringVariable(ListStringCreativeTemplateVariable),
        /// Optional. Represents a long variable defined in a creative template.
        #[prost(message, tag = "8")]
        LongVariable(LongCreativeTemplateVariable),
        /// Optional. Represents a string variable defined in a creative template.
        #[prost(message, tag = "9")]
        StringVariable(StringCreativeTemplateVariable),
        /// Optional. Represents a url variable defined in a creative template.
        #[prost(message, tag = "10")]
        UrlVariable(UrlCreativeTemplateVariable),
    }
}
/// Request object for `GetCreativeTemplate` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCreativeTemplateRequest {
    /// Required. The resource name of the CreativeTemplate.
    /// Format: `networks/{network_code}/creativeTemplates/{creative_template_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCreativeTemplates` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCreativeTemplatesRequest {
    /// Required. The parent, which owns this collection of CreativeTemplates.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `CreativeTemplates` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `CreativeTemplates` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCreativeTemplates`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCreativeTemplates`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCreativeTemplatesRequest` containing matching
/// `CreativeTemplate` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCreativeTemplatesResponse {
    /// The `CreativeTemplate` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub creative_templates: ::prost::alloc::vec::Vec<CreativeTemplate>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `CreativeTemplate` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod creative_template_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CreativeTemplate` objects.
    #[derive(Debug, Clone)]
    pub struct CreativeTemplateServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CreativeTemplateServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CreativeTemplateServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CreativeTemplateServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CreativeTemplateServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CreativeTemplate` object.
        pub async fn get_creative_template(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCreativeTemplateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreativeTemplate>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CreativeTemplateService/GetCreativeTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CreativeTemplateService",
                        "GetCreativeTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CreativeTemplate` objects.
        pub async fn list_creative_templates(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCreativeTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCreativeTemplatesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CreativeTemplateService/ListCreativeTemplates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CreativeTemplateService",
                        "ListCreativeTemplates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[CustomFieldDataType\]\[google.ads.admanager.v1.CustomFieldDataTypeEnum.CustomFieldDataType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomFieldDataTypeEnum {}
/// Nested message and enum types in `CustomFieldDataTypeEnum`.
pub mod custom_field_data_type_enum {
    /// The data type for a CustomField.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldDataType {
        /// No value specified
        Unspecified = 0,
        /// A string field
        ///
        /// The max length is 255 characters.
        String = 1,
        /// A number field.
        Number = 2,
        /// A "Yes" or "No" toggle field.
        Toggle = 3,
        /// A drop-down field.
        DropDown = 4,
    }
    impl CustomFieldDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_FIELD_DATA_TYPE_UNSPECIFIED",
                Self::String => "STRING",
                Self::Number => "NUMBER",
                Self::Toggle => "TOGGLE",
                Self::DropDown => "DROP_DOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_DATA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "NUMBER" => Some(Self::Number),
                "TOGGLE" => Some(Self::Toggle),
                "DROP_DOWN" => Some(Self::DropDown),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CustomFieldEntityType\]\[google.ads.admanager.v1.CustomFieldEntityTypeEnum.CustomFieldEntityType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomFieldEntityTypeEnum {}
/// Nested message and enum types in `CustomFieldEntityTypeEnum`.
pub mod custom_field_entity_type_enum {
    /// The types of entities that a CustomField can be applied to.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldEntityType {
        /// No value specified
        Unspecified = 0,
        /// The CustomField is applied to LineItems.
        LineItem = 1,
        /// The CustomField is applied to Orders.
        Order = 2,
        /// The CustomField is applied to Creatives.
        Creative = 3,
        /// The CustomField is applied to Proposals.
        Proposal = 4,
        /// The CustomField is applied to ProposalLineItems.
        ProposalLineItem = 5,
    }
    impl CustomFieldEntityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_FIELD_ENTITY_TYPE_UNSPECIFIED",
                Self::LineItem => "LINE_ITEM",
                Self::Order => "ORDER",
                Self::Creative => "CREATIVE",
                Self::Proposal => "PROPOSAL",
                Self::ProposalLineItem => "PROPOSAL_LINE_ITEM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_ENTITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LINE_ITEM" => Some(Self::LineItem),
                "ORDER" => Some(Self::Order),
                "CREATIVE" => Some(Self::Creative),
                "PROPOSAL" => Some(Self::Proposal),
                "PROPOSAL_LINE_ITEM" => Some(Self::ProposalLineItem),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CustomFieldStatus\]\[google.ads.admanager.v1.CustomFieldStatusEnum.CustomFieldStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomFieldStatusEnum {}
/// Nested message and enum types in `CustomFieldStatusEnum`.
pub mod custom_field_status_enum {
    /// The status of the CustomField.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldStatus {
        /// No value specified
        Unspecified = 0,
        /// The CustomField is active.
        Active = 1,
        /// The CustomField is inactive.
        Inactive = 2,
    }
    impl CustomFieldStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_FIELD_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CustomFieldVisibility\]\[google.ads.admanager.v1.CustomFieldVisibilityEnum.CustomFieldVisibility\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomFieldVisibilityEnum {}
/// Nested message and enum types in `CustomFieldVisibilityEnum`.
pub mod custom_field_visibility_enum {
    /// The visibility level of a CustomField.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomFieldVisibility {
        /// No value specified
        Unspecified = 0,
        /// The CustomField is not visible in the UI and only visible through the
        /// API.
        Hidden = 1,
        /// The CustomField is visible in the UI and only editable through the API.
        ReadOnly = 2,
        /// The CustomField is visible and editable in both the API and UI.
        Editable = 3,
    }
    impl CustomFieldVisibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_FIELD_VISIBILITY_UNSPECIFIED",
                Self::Hidden => "HIDDEN",
                Self::ReadOnly => "READ_ONLY",
                Self::Editable => "EDITABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_FIELD_VISIBILITY_UNSPECIFIED" => Some(Self::Unspecified),
                "HIDDEN" => Some(Self::Hidden),
                "READ_ONLY" => Some(Self::ReadOnly),
                "EDITABLE" => Some(Self::Editable),
                _ => None,
            }
        }
    }
}
/// An additional, user-created field on an entity.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomField {
    /// Identifier. The resource name of the `CustomField`.
    /// Format: `networks/{network_code}/customFields/{custom_field}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Unique ID of the CustomField. This attribute is assigned by
    /// Google.
    #[prost(int64, optional, tag = "2")]
    pub custom_field_id: ::core::option::Option<i64>,
    /// Required. Name of the CustomField. The max length is 127 characters.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A description of the custom field. The maximum length is 511
    /// characters.
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of the `CustomField`.
    #[prost(
        enumeration = "custom_field_status_enum::CustomFieldStatus",
        optional,
        tag = "5"
    )]
    pub status: ::core::option::Option<i32>,
    /// Required. The type of entity the `CustomField` can be applied to.
    #[prost(
        enumeration = "custom_field_entity_type_enum::CustomFieldEntityType",
        optional,
        tag = "7"
    )]
    pub entity_type: ::core::option::Option<i32>,
    /// Required. The data type of the `CustomField`.
    #[prost(
        enumeration = "custom_field_data_type_enum::CustomFieldDataType",
        optional,
        tag = "8"
    )]
    pub data_type: ::core::option::Option<i32>,
    /// Required. The visibility of the `CustomField`.
    #[prost(
        enumeration = "custom_field_visibility_enum::CustomFieldVisibility",
        optional,
        tag = "9"
    )]
    pub visibility: ::core::option::Option<i32>,
    /// Optional. The drop-down options for the `CustomField`.
    ///
    /// Only applicable for `CustomField` with the drop-down data type.
    #[prost(message, repeated, tag = "10")]
    pub options: ::prost::alloc::vec::Vec<CustomFieldOption>,
}
/// An option for a drop-down `CustomField`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomFieldOption {
    /// Optional. Non-empty default. `CustomFieldOption` ID.
    #[prost(int64, tag = "1")]
    pub custom_field_option_id: i64,
    /// Required. The display name of the `CustomFieldOption`.
    ///
    /// This value has a maximum length of 127 characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// Request object for `GetCustomField` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCustomFieldRequest {
    /// Required. The resource name of the CustomField.
    /// Format: `networks/{network_code}/customFields/{custom_field_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCustomFields` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCustomFieldsRequest {
    /// Required. The parent, which owns this collection of CustomFields.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `CustomFields` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `CustomFields`
    /// will be returned. The maximum value is 1000; values greater than 1000 will
    /// be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCustomFields` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCustomFields` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCustomFieldsRequest` containing matching
/// `CustomField` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomFieldsResponse {
    /// The `CustomField` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub custom_fields: ::prost::alloc::vec::Vec<CustomField>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `CustomField` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateCustomField` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomFieldRequest {
    /// Required. The parent resource where this `CustomField` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `CustomField` to create.
    #[prost(message, optional, tag = "2")]
    pub custom_field: ::core::option::Option<CustomField>,
}
/// Request object for `BatchCreateCustomFields` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateCustomFieldsRequest {
    /// Required. The parent resource where `CustomFields` will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreateCustomFieldRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `CustomField` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateCustomFieldRequest>,
}
/// Response object for `BatchCreateCustomFields` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateCustomFieldsResponse {
    /// The `CustomField` objects created.
    #[prost(message, repeated, tag = "1")]
    pub custom_fields: ::prost::alloc::vec::Vec<CustomField>,
}
/// Request object for `UpdateCustomField` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomFieldRequest {
    /// Required. The `CustomField` to update.
    ///
    /// The `CustomField`'s `name` is used to identify the `CustomField` to update.
    #[prost(message, optional, tag = "1")]
    pub custom_field: ::core::option::Option<CustomField>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchUpdateCustomFields` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateCustomFieldsRequest {
    /// Required. The parent resource where `CustomFields` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdateCustomFieldRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `CustomField` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateCustomFieldRequest>,
}
/// Response object for `BatchUpdateCustomFields` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateCustomFieldsResponse {
    /// The `CustomField` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub custom_fields: ::prost::alloc::vec::Vec<CustomField>,
}
/// Request message for `BatchActivateCustomFields` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateCustomFieldsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `CustomField` objects to activate.
    /// Format: `networks/{network_code}/customFields/{custom_field_id}`
    #[prost(string, repeated, tag = "3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchActivateCustomFields` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateCustomFieldsResponse {}
/// Request message for `BatchDeactivateCustomFields` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateCustomFieldsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `CustomField` objects to deactivate.
    /// Format: `networks/{network_code}/customFields/{custom_field_id}`
    #[prost(string, repeated, tag = "3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchDeactivateCustomFields` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateCustomFieldsResponse {}
/// Generated client implementations.
pub mod custom_field_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CustomField` objects.
    #[derive(Debug, Clone)]
    pub struct CustomFieldServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomFieldServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomFieldServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CustomFieldServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CustomFieldServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CustomField` object.
        pub async fn get_custom_field(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomFieldRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomField>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/GetCustomField",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "GetCustomField",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CustomField` objects.
        pub async fn list_custom_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/ListCustomFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "ListCustomFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `CustomField` object.
        pub async fn create_custom_field(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomFieldRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomField>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/CreateCustomField",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "CreateCustomField",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `CustomField` objects.
        pub async fn batch_create_custom_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateCustomFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateCustomFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/BatchCreateCustomFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "BatchCreateCustomFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `CustomField` object.
        pub async fn update_custom_field(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomFieldRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomField>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/UpdateCustomField",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "UpdateCustomField",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `CustomField` objects.
        pub async fn batch_update_custom_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateCustomFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateCustomFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/BatchUpdateCustomFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "BatchUpdateCustomFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Activates a list of `CustomField` objects.
        pub async fn batch_activate_custom_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchActivateCustomFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchActivateCustomFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/BatchActivateCustomFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "BatchActivateCustomFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deactivates a list of `CustomField` objects.
        pub async fn batch_deactivate_custom_fields(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeactivateCustomFieldsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchDeactivateCustomFieldsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomFieldService/BatchDeactivateCustomFields",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomFieldService",
                        "BatchDeactivateCustomFields",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A value for a CustomField on a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomFieldValue {
    /// Required. The custom field for which this is a value.
    /// Format: "networks/{network_code}/customFields/{custom_field_id}"
    #[prost(string, tag = "1")]
    pub custom_field: ::prost::alloc::string::String,
    /// Required. A typed value representation of the value.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<custom_field_value::Value>,
}
/// Nested message and enum types in `CustomFieldValue`.
pub mod custom_field_value {
    /// Represent custom field value type.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Value {
        /// The value of this field.
        #[prost(oneof = "value::Value", tags = "1, 2, 3, 4")]
        pub value: ::core::option::Option<value::Value>,
    }
    /// Nested message and enum types in `Value`.
    pub mod value {
        /// The value of this field.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Value {
            /// The custom_field_option_id, if the CustomFieldDataType is DROPDOWN.
            #[prost(int64, tag = "1")]
            DropdownValue(i64),
            /// The value, if the CustomFieldDataType is STRING.
            #[prost(string, tag = "2")]
            StringValue(::prost::alloc::string::String),
            /// The value, if the CustomFieldDataType is NUMBER.
            #[prost(double, tag = "3")]
            NumberValue(f64),
            /// The value, if the CustomFieldDataType is TOGGLE.
            #[prost(bool, tag = "4")]
            ToggleValue(bool),
        }
    }
}
/// Wrapper message for
/// \[CustomTargetingKeyStatus\]\[google.ads.admanager.v1.CustomTargetingKeyStatusEnum.CustomTargetingKeyStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingKeyStatusEnum {}
/// Nested message and enum types in `CustomTargetingKeyStatusEnum`.
pub mod custom_targeting_key_status_enum {
    /// Status of the custom targeting key.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingKeyStatus {
        /// Not specified value.
        Unspecified = 0,
        /// Custom targeting key is active.
        Active = 1,
        /// Custom targeting key is inactive.
        Inactive = 2,
    }
    impl CustomTargetingKeyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_TARGETING_KEY_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_KEY_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CustomTargetingKeyType\]\[google.ads.admanager.v1.CustomTargetingKeyTypeEnum.CustomTargetingKeyType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingKeyTypeEnum {}
/// Nested message and enum types in `CustomTargetingKeyTypeEnum`.
pub mod custom_targeting_key_type_enum {
    /// Type of the custom targeting key.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingKeyType {
        /// Not specified value.
        Unspecified = 0,
        /// Key with a fixed set of values.
        Predefined = 1,
        /// Key without a fixed set of values
        Freeform = 2,
    }
    impl CustomTargetingKeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_TARGETING_KEY_TYPE_UNSPECIFIED",
                Self::Predefined => "PREDEFINED",
                Self::Freeform => "FREEFORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_KEY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PREDEFINED" => Some(Self::Predefined),
                "FREEFORM" => Some(Self::Freeform),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CustomTargetingKeyReportableType\]\[google.ads.admanager.v1.CustomTargetingKeyReportableTypeEnum.CustomTargetingKeyReportableType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingKeyReportableTypeEnum {}
/// Nested message and enum types in `CustomTargetingKeyReportableTypeEnum`.
pub mod custom_targeting_key_reportable_type_enum {
    /// Reportable type of the custom targeting key.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingKeyReportableType {
        /// Not specified value.
        Unspecified = 0,
        /// Not available for reporting in the Ad Manager query tool.
        Off = 1,
        /// Available for reporting in the Ad Manager query tool.
        On = 2,
        /// Custom dimension available for reporting in the AdManager query tool.
        CustomDimension = 3,
    }
    impl CustomTargetingKeyReportableType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_TARGETING_KEY_REPORTABLE_TYPE_UNSPECIFIED",
                Self::Off => "OFF",
                Self::On => "ON",
                Self::CustomDimension => "CUSTOM_DIMENSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_KEY_REPORTABLE_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "OFF" => Some(Self::Off),
                "ON" => Some(Self::On),
                "CUSTOM_DIMENSION" => Some(Self::CustomDimension),
                _ => None,
            }
        }
    }
}
/// The `CustomTargetingKey` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingKey {
    /// Identifier. The resource name of the `CustomTargetingKey`.
    /// Format:
    /// `networks/{network_code}/customTargetingKeys/{custom_targeting_key_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `CustomTargetingKey` ID.
    #[prost(int64, optional, tag = "2")]
    pub custom_targeting_key_id: ::core::option::Option<i64>,
    /// Immutable. Name of the key. Keys can contain up to 10 characters each. You
    /// can use alphanumeric characters and symbols other than the following:
    /// ", ', =, !, +, #, \*, ~, ;, ^, (, ), \<, >, \[, \], the white space character.
    #[prost(string, optional, tag = "3")]
    pub ad_tag_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Descriptive name for the `CustomTargetingKey`.
    #[prost(string, optional, tag = "4")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Indicates whether users will select from predefined values or
    /// create new targeting values, while specifying targeting criteria for a line
    /// item.
    #[prost(
        enumeration = "custom_targeting_key_type_enum::CustomTargetingKeyType",
        optional,
        tag = "5"
    )]
    pub r#type: ::core::option::Option<i32>,
    /// Output only. Status of the `CustomTargetingKey`.
    #[prost(
        enumeration = "custom_targeting_key_status_enum::CustomTargetingKeyStatus",
        optional,
        tag = "6"
    )]
    pub status: ::core::option::Option<i32>,
    /// Required. Reportable state of the `CustomTargetingKey`.
    #[prost(
        enumeration = "custom_targeting_key_reportable_type_enum::CustomTargetingKeyReportableType",
        optional,
        tag = "7"
    )]
    pub reportable_type: ::core::option::Option<i32>,
}
/// Request object for `GetCustomTargetingKey` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCustomTargetingKeyRequest {
    /// Required. The resource name of the CustomTargetingKey.
    /// Format:
    /// `networks/{network_code}/customTargetingKeys/{custom_targeting_key_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCustomTargetingKeys` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCustomTargetingKeysRequest {
    /// Required. The parent, which owns this collection of CustomTargetingKeys.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `CustomTargetingKeys` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `CustomTargetingKeys` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListCustomTargetingKeys`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCustomTargetingKeys`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCustomTargetingKeysRequest` containing matching
/// `CustomTargetingKey` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetingKeysResponse {
    /// The `CustomTargetingKey` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_keys: ::prost::alloc::vec::Vec<CustomTargetingKey>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `CustomTargetingKey` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateCustomTargetingKey` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateCustomTargetingKeyRequest {
    /// Required. The parent resource where this `CustomTargetingKey` will be
    /// created. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `CustomTargetingKey` to create.
    #[prost(message, optional, tag = "2")]
    pub custom_targeting_key: ::core::option::Option<CustomTargetingKey>,
}
/// Request object for `BatchCreateCustomTargetingKeys` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateCustomTargetingKeysRequest {
    /// Required. The parent resource where `CustomTargetingKeys` will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreateCustomTargetingKeyRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `CustomTargetingKey` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateCustomTargetingKeyRequest>,
}
/// Response object for `BatchCreateCustomTargetingKeys` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateCustomTargetingKeysResponse {
    /// The `CustomTargetingKey` objects created.
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_keys: ::prost::alloc::vec::Vec<CustomTargetingKey>,
}
/// Request object for `UpdateCustomTargetingKey` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateCustomTargetingKeyRequest {
    /// Required. The `CustomTargetingKey` to update.
    ///
    /// The `CustomTargetingKey`'s `name` is used to identify the
    /// `CustomTargetingKey` to update.
    #[prost(message, optional, tag = "1")]
    pub custom_targeting_key: ::core::option::Option<CustomTargetingKey>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchUpdateCustomTargetingKeys` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateCustomTargetingKeysRequest {
    /// Required. The parent resource where `CustomTargetingKeys` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdateCustomTargetingKeyRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `CustomTargetingKey` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateCustomTargetingKeyRequest>,
}
/// Response object for `BatchUpdateCustomTargetingKeys` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateCustomTargetingKeysResponse {
    /// The `CustomTargetingKey` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_keys: ::prost::alloc::vec::Vec<CustomTargetingKey>,
}
/// Request object for `BatchActivateCustomTargetingKeys` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateCustomTargetingKeysRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `CustomTargetingKey`s to activate.
    /// Format:
    /// `networks/{network_code}/customTargetingKeys/{custom_targeting_key_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchActivateCustomTargetingKeys` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateCustomTargetingKeysResponse {}
/// Request message for `BatchDeactivateCustomTargetingKeys` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateCustomTargetingKeysRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `CustomTargetingKey`s to deactivate.
    /// Format:
    /// `networks/{network_code}/customTargetingKeys/{custom_targeting_key_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchDeactivateCustomTargetingKeys` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateCustomTargetingKeysResponse {}
/// Generated client implementations.
pub mod custom_targeting_key_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CustomTargetingKey` objects.
    #[derive(Debug, Clone)]
    pub struct CustomTargetingKeyServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomTargetingKeyServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomTargetingKeyServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CustomTargetingKeyServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CustomTargetingKeyServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CustomTargetingKey` object.
        pub async fn get_custom_targeting_key(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomTargetingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetingKey>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/GetCustomTargetingKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "GetCustomTargetingKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CustomTargetingKey` objects.
        pub async fn list_custom_targeting_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomTargetingKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomTargetingKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/ListCustomTargetingKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "ListCustomTargetingKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `CustomTargetingKey` object.
        pub async fn create_custom_targeting_key(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomTargetingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetingKey>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/CreateCustomTargetingKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "CreateCustomTargetingKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `CustomTargetingKey` objects.
        pub async fn batch_create_custom_targeting_keys(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchCreateCustomTargetingKeysRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateCustomTargetingKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/BatchCreateCustomTargetingKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "BatchCreateCustomTargetingKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `CustomTargetingKey` object.
        pub async fn update_custom_targeting_key(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomTargetingKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetingKey>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/UpdateCustomTargetingKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "UpdateCustomTargetingKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `CustomTargetingKey` objects.
        pub async fn batch_update_custom_targeting_keys(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchUpdateCustomTargetingKeysRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateCustomTargetingKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/BatchUpdateCustomTargetingKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "BatchUpdateCustomTargetingKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch activate `CustomTargetingKey` objects.
        pub async fn batch_activate_custom_targeting_keys(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchActivateCustomTargetingKeysRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchActivateCustomTargetingKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/BatchActivateCustomTargetingKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "BatchActivateCustomTargetingKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deactivates a list of `CustomTargetingKey` objects.
        pub async fn batch_deactivate_custom_targeting_keys(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchDeactivateCustomTargetingKeysRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchDeactivateCustomTargetingKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingKeyService/BatchDeactivateCustomTargetingKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingKeyService",
                        "BatchDeactivateCustomTargetingKeys",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[CustomTargetingValueStatus\]\[google.ads.admanager.v1.CustomTargetingValueStatusEnum.CustomTargetingValueStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingValueStatusEnum {}
/// Nested message and enum types in `CustomTargetingValueStatusEnum`.
pub mod custom_targeting_value_status_enum {
    /// Status of the custom targeting value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingValueStatus {
        /// Not specified value.
        Unspecified = 0,
        /// Custom targeting value is active.
        Active = 1,
        /// Custom targeting value is inactive.
        Inactive = 2,
    }
    impl CustomTargetingValueStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_TARGETING_VALUE_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_VALUE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[CustomTargetingValueMatchType\]\[google.ads.admanager.v1.CustomTargetingValueMatchTypeEnum.CustomTargetingValueMatchType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingValueMatchTypeEnum {}
/// Nested message and enum types in `CustomTargetingValueMatchTypeEnum`.
pub mod custom_targeting_value_match_type_enum {
    /// Match type of the custom targeting value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomTargetingValueMatchType {
        /// Not specified value.
        Unspecified = 0,
        /// Used for exact matching. For example, the targeting value car=honda will
        /// only match to the ad request car=honda.
        Exact = 1,
        /// Used for lenient matching when at least one of the words in the ad
        /// request matches the targeted value. The targeting value car=honda will
        /// match to ad requests containing the word honda. So ad requests car=honda
        /// or car=honda civic or car=buy honda or car=how much does a honda cost
        /// will all have the line item delivered.
        /// This match type can not be used within an audience segment rule.
        Broad = 2,
        /// Used for 'starts with' matching when the first few characters in the ad
        /// request match all of the characters in the targeted value. The targeting
        /// value car=honda will match to ad requests car=honda or car=hondas for
        /// sale but not to car=I want a honda.
        Prefix = 3,
        /// This is a combination of MatchType#BROAD and MatchType#PREFIX matching.
        /// The targeting value car=honda will match to ad requests that contain
        /// words that start with the characters in the targeted value, for example
        /// with car=civic hondas.
        /// This match type can not be used within an audience segment rule.
        BroadPrefix = 4,
        /// Used for 'ends with' matching when the last characters in the ad request
        /// match all of the characters in the targeted value. The targeting value
        /// car=honda will match with ad requests car=honda or car=I want a honda but
        /// not to car=hondas for sale.
        /// This match type can not be used within line item targeting.
        Suffix = 5,
        /// Used for 'within' matching when the string in the ad request contains the
        /// string in the targeted value. The targeting value car=honda will match
        /// with ad requests car=honda, car=I want a honda, and also with car=hondas
        /// for sale, but not with car=misspelled hond a. This match type can not be
        /// used within line item targeting.
        Contains = 6,
    }
    impl CustomTargetingValueMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CUSTOM_TARGETING_VALUE_MATCH_TYPE_UNSPECIFIED",
                Self::Exact => "EXACT",
                Self::Broad => "BROAD",
                Self::Prefix => "PREFIX",
                Self::BroadPrefix => "BROAD_PREFIX",
                Self::Suffix => "SUFFIX",
                Self::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CUSTOM_TARGETING_VALUE_MATCH_TYPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "EXACT" => Some(Self::Exact),
                "BROAD" => Some(Self::Broad),
                "PREFIX" => Some(Self::Prefix),
                "BROAD_PREFIX" => Some(Self::BroadPrefix),
                "SUFFIX" => Some(Self::Suffix),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
/// The `CustomTargetingValue` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingValue {
    /// Identifier. The resource name of the `CustomTargetingValue`.
    /// Format:
    /// `networks/{network_code}/customTargetingValues/{custom_targeting_value_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Immutable. The resource name of the `CustomTargetingKey`.
    /// Format:
    /// `networks/{network_code}/customTargetingKeys/{custom_targeting_key_id}`
    #[prost(string, optional, tag = "8")]
    pub custom_targeting_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Immutable. Name of the `CustomTargetingValue`. Values can contain up to 40
    /// characters each. You can use alphanumeric characters and symbols other than
    /// the following: ", ', =, !, +, #, \*, ~, ;, ^, (, ), \<, >, \[, \]. Values are
    /// not data-specific; all values are treated as strings. For example, instead
    /// of using "age>=18 AND \<=34", try "18-34"
    #[prost(string, optional, tag = "4")]
    pub ad_tag_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Descriptive name for the `CustomTargetingValue`.
    #[prost(string, optional, tag = "5")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. Immutable. The way in which the CustomTargetingValue.name strings
    /// will be matched.
    #[prost(
        enumeration = "custom_targeting_value_match_type_enum::CustomTargetingValueMatchType",
        optional,
        tag = "6"
    )]
    pub match_type: ::core::option::Option<i32>,
    /// Output only. Status of the `CustomTargetingValue`.
    #[prost(
        enumeration = "custom_targeting_value_status_enum::CustomTargetingValueStatus",
        optional,
        tag = "7"
    )]
    pub status: ::core::option::Option<i32>,
}
/// Request object for `GetCustomTargetingValue` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCustomTargetingValueRequest {
    /// Required. The resource name of the CustomTargetingValue.
    /// Format:
    /// `networks/{network_code}/customTargetingValues/{custom_targeting_value_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListCustomTargetingValues` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCustomTargetingValuesRequest {
    /// Required. The parent, which owns this collection of CustomTargetingValues.
    /// Format:
    /// `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `CustomTargetingValues` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `CustomTargetingValues` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListCustomTargetingValues` call. Provide this to retrieve the subsequent
    /// page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListCustomTargetingValues` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListCustomTargetingValuesRequest` containing matching
/// `CustomTargetingValue` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomTargetingValuesResponse {
    /// The `CustomTargetingValue` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_values: ::prost::alloc::vec::Vec<CustomTargetingValue>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `CustomTargetingValue` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod custom_targeting_value_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `CustomTargetingValue` objects.
    #[derive(Debug, Clone)]
    pub struct CustomTargetingValueServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CustomTargetingValueServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CustomTargetingValueServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CustomTargetingValueServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CustomTargetingValueServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `CustomTargetingValue` object.
        pub async fn get_custom_targeting_value(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomTargetingValueRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomTargetingValue>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingValueService/GetCustomTargetingValue",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingValueService",
                        "GetCustomTargetingValue",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `CustomTargetingValue` objects.
        pub async fn list_custom_targeting_values(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomTargetingValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomTargetingValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.CustomTargetingValueService/ListCustomTargetingValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.CustomTargetingValueService",
                        "ListCustomTargetingValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[DealBuyerPermissionType\]\[google.ads.admanager.v1.DealBuyerPermissionTypeEnum.DealBuyerPermissionType\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DealBuyerPermissionTypeEnum {}
/// Nested message and enum types in `DealBuyerPermissionTypeEnum`.
pub mod deal_buyer_permission_type_enum {
    /// Defines how a deal would transact among all buyers under the same bidder.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DealBuyerPermissionType {
        /// No value specified.
        Unspecified = 0,
        /// The deal only transacts with the buyer specified.
        NegotiatorOnly = 1,
        /// The deal transacts with all buyers under the same bidder.
        Bidder = 2,
    }
    impl DealBuyerPermissionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DEAL_BUYER_PERMISSION_TYPE_UNSPECIFIED",
                Self::NegotiatorOnly => "NEGOTIATOR_ONLY",
                Self::Bidder => "BIDDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEAL_BUYER_PERMISSION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEGOTIATOR_ONLY" => Some(Self::NegotiatorOnly),
                "BIDDER" => Some(Self::Bidder),
                _ => None,
            }
        }
    }
}
/// Represents a device capability.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceCapability {
    /// Identifier. The resource name of the `DeviceCapability`.
    /// Format: `networks/{network_code}/deviceCapabilities/{device_capability_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The localized name of the device capability.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetDeviceCapability` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDeviceCapabilityRequest {
    /// Required. The resource name of the DeviceCapability.
    /// Format: `networks/{network_code}/deviceCapabilities/{device_capability_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListDeviceCapabilities` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDeviceCapabilitiesRequest {
    /// Required. The parent, which owns this collection of DeviceCapabilities.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `DeviceCapabilities` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `DeviceCapabilities` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDeviceCapabilities`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDeviceCapabilities`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListDeviceCapabilitiesRequest` containing matching
/// `DeviceCapability` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeviceCapabilitiesResponse {
    /// The `DeviceCapability` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub device_capabilities: ::prost::alloc::vec::Vec<DeviceCapability>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `DeviceCapability` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod device_capability_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `DeviceCapability` objects.
    #[derive(Debug, Clone)]
    pub struct DeviceCapabilityServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeviceCapabilityServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeviceCapabilityServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeviceCapabilityServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeviceCapabilityServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `DeviceCapability` object.
        pub async fn get_device_capability(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeviceCapabilityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeviceCapability>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.DeviceCapabilityService/GetDeviceCapability",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.DeviceCapabilityService",
                        "GetDeviceCapability",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `DeviceCapability` objects.
        pub async fn list_device_capabilities(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeviceCapabilitiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeviceCapabilitiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.DeviceCapabilityService/ListDeviceCapabilities",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.DeviceCapabilityService",
                        "ListDeviceCapabilities",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents the category of a device. For example, "smartphone" or "desktop".
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceCategory {
    /// Identifier. The resource name of the `DeviceCategory`.
    /// Format: `networks/{network_code}/deviceCategories/{device_category}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The display name of the device category.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetDeviceCategory` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDeviceCategoryRequest {
    /// Required. The resource name of the DeviceCategory.
    /// Format: `networks/{network_code}/deviceCategories/{device_category_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListDeviceCategories` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDeviceCategoriesRequest {
    /// Required. The parent, which owns this collection of DeviceCategories.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `DeviceCategories` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `DeviceCategories` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDeviceCategories`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDeviceCategories`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListDeviceCategoriesRequest` containing matching
/// `DeviceCategory` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeviceCategoriesResponse {
    /// The `DeviceCategory` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub device_categories: ::prost::alloc::vec::Vec<DeviceCategory>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `DeviceCategory` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod device_category_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `DeviceCategory` objects.
    #[derive(Debug, Clone)]
    pub struct DeviceCategoryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeviceCategoryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeviceCategoryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeviceCategoryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeviceCategoryServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `DeviceCategory` object.
        pub async fn get_device_category(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeviceCategoryRequest>,
        ) -> std::result::Result<tonic::Response<super::DeviceCategory>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.DeviceCategoryService/GetDeviceCategory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.DeviceCategoryService",
                        "GetDeviceCategory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `DeviceCategory` objects.
        pub async fn list_device_categories(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeviceCategoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeviceCategoriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.DeviceCategoryService/ListDeviceCategories",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.DeviceCategoryService",
                        "ListDeviceCategories",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a device manufacturer.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceManufacturer {
    /// Identifier. The resource name of the `DeviceManufacturer`.
    /// Format:
    /// `networks/{network_code}/deviceManufacturers/{device_manufacturer}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The localized name of the device manufacturer.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetDeviceManufacturer` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDeviceManufacturerRequest {
    /// Required. The resource name of the DeviceManufacturer.
    /// Format:
    /// `networks/{network_code}/deviceManufacturers/{device_manufacturer_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListDeviceManufacturers` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListDeviceManufacturersRequest {
    /// Required. The parent, which owns this collection of DeviceManufacturers.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `DeviceManufacturers` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `DeviceManufacturers` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDeviceManufacturers`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDeviceManufacturers`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListDeviceManufacturersRequest` containing matching
/// `DeviceManufacturer` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDeviceManufacturersResponse {
    /// The `DeviceManufacturer` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub device_manufacturers: ::prost::alloc::vec::Vec<DeviceManufacturer>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `DeviceManufacturer` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod device_manufacturer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `DeviceManufacturer` objects.
    #[derive(Debug, Clone)]
    pub struct DeviceManufacturerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeviceManufacturerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeviceManufacturerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeviceManufacturerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeviceManufacturerServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `DeviceManufacturer` object.
        pub async fn get_device_manufacturer(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDeviceManufacturerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeviceManufacturer>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.DeviceManufacturerService/GetDeviceManufacturer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.DeviceManufacturerService",
                        "GetDeviceManufacturer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `DeviceManufacturer` objects.
        pub async fn list_device_manufacturers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDeviceManufacturersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDeviceManufacturersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.DeviceManufacturerService/ListDeviceManufacturers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.DeviceManufacturerService",
                        "ListDeviceManufacturers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The `EntitySignalsMapping` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EntitySignalsMapping {
    /// Identifier. The resource name of the `EntitySignalsMapping`.
    /// Format:
    /// `networks/{network_code}/entitySignalsMappings/{entity_signals_mapping_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `EntitySignalsMapping` ID.
    #[prost(int64, optional, tag = "2")]
    pub entity_signals_mapping_id: ::core::option::Option<i64>,
    /// Optional. The IDs of the categories that are associated with the
    /// referencing entity.
    #[prost(int64, repeated, packed = "false", tag = "6")]
    pub taxonomy_category_ids: ::prost::alloc::vec::Vec<i64>,
    /// The entity that the mapping belongs to.
    #[prost(oneof = "entity_signals_mapping::Entity", tags = "3, 4, 5")]
    pub entity: ::core::option::Option<entity_signals_mapping::Entity>,
}
/// Nested message and enum types in `EntitySignalsMapping`.
pub mod entity_signals_mapping {
    /// The entity that the mapping belongs to.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Entity {
        /// ID of an AudienceSegment that this mapping belongs to.
        #[prost(int64, tag = "3")]
        AudienceSegmentId(i64),
        /// ID of a ContentBundle that this mapping belongs to.
        #[prost(int64, tag = "4")]
        ContentBundleId(i64),
        /// ID of a CustomValue that this mapping belongs to.
        #[prost(int64, tag = "5")]
        CustomTargetingValueId(i64),
    }
}
/// Request object for `GetEntitySignalsMapping` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetEntitySignalsMappingRequest {
    /// Required. The resource name of the EntitySignalsMapping.
    /// Format:
    /// `networks/{network_code}/entitySignalsMappings/{entity_signals_mapping_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListEntitySignalsMappings` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListEntitySignalsMappingsRequest {
    /// Required. The parent, which owns this collection of EntitySignalsMappings.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `EntitySignalsMappings` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `EntitySignalsMappings` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListEntitySignalsMappings` call. Provide this to retrieve the subsequent
    /// page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListEntitySignalsMappings` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Request object for 'CreateEntitySignalsMapping' method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateEntitySignalsMappingRequest {
    /// Required. The parent resource where this EntitySignalsMapping will be
    /// created. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The EntitySignalsMapping object to create.
    #[prost(message, optional, tag = "2")]
    pub entity_signals_mapping: ::core::option::Option<EntitySignalsMapping>,
}
/// Request object for 'UpdateEntitySignalsMapping' method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateEntitySignalsMappingRequest {
    /// Required. The `EntitySignalsMapping` to update.
    ///
    /// The EntitySignalsMapping's name is used to identify the
    /// EntitySignalsMapping to update.
    /// Format:
    /// `networks/{network_code}/entitySignalsMappings/{entity_signals_mapping}`
    #[prost(message, optional, tag = "1")]
    pub entity_signals_mapping: ::core::option::Option<EntitySignalsMapping>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Response object for `ListEntitySignalsMappingsRequest` containing matching
/// `EntitySignalsMapping` resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEntitySignalsMappingsResponse {
    /// The `EntitySignalsMapping` from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub entity_signals_mappings: ::prost::alloc::vec::Vec<EntitySignalsMapping>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `EntitySignalsMappings`.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `BatchCreateEntitySignalsMappings` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateEntitySignalsMappingsRequest {
    /// Required. The parent resource where `EntitySignalsMappings` will be
    /// created. Format: `networks/{network_code}` The parent field in the
    /// CreateEntitySignalsMappingRequest must match this field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `EntitySignalsMapping` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateEntitySignalsMappingRequest>,
}
/// Response object for `BatchCreateEntitySignalsMappings` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateEntitySignalsMappingsResponse {
    /// The `EntitySignalsMapping` objects created.
    #[prost(message, repeated, tag = "1")]
    pub entity_signals_mappings: ::prost::alloc::vec::Vec<EntitySignalsMapping>,
}
/// Request object for `BatchUpdateEntitySignalsMappings` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateEntitySignalsMappingsRequest {
    /// Required. The parent resource where `EntitySignalsMappings` will be
    /// updated. Format: `networks/{network_code}` The parent field in the
    /// UpdateEntitySignalsMappingRequest must match this field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `EntitySignalsMapping` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateEntitySignalsMappingRequest>,
}
/// Response object for `BatchUpdateEntitySignalsMappings` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateEntitySignalsMappingsResponse {
    /// The `EntitySignalsMapping` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub entity_signals_mappings: ::prost::alloc::vec::Vec<EntitySignalsMapping>,
}
/// Generated client implementations.
pub mod entity_signals_mapping_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `EntitySignalsMapping` objects.
    #[derive(Debug, Clone)]
    pub struct EntitySignalsMappingServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl EntitySignalsMappingServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> EntitySignalsMappingServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> EntitySignalsMappingServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            EntitySignalsMappingServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `EntitySignalsMapping` object.
        pub async fn get_entity_signals_mapping(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntitySignalsMappingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EntitySignalsMapping>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.EntitySignalsMappingService/GetEntitySignalsMapping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.EntitySignalsMappingService",
                        "GetEntitySignalsMapping",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `EntitySignalsMapping` objects.
        pub async fn list_entity_signals_mappings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEntitySignalsMappingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEntitySignalsMappingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.EntitySignalsMappingService/ListEntitySignalsMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.EntitySignalsMappingService",
                        "ListEntitySignalsMappings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create an `EntitySignalsMapping` object.
        pub async fn create_entity_signals_mapping(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEntitySignalsMappingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EntitySignalsMapping>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.EntitySignalsMappingService/CreateEntitySignalsMapping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.EntitySignalsMappingService",
                        "CreateEntitySignalsMapping",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update an `EntitySignalsMapping` object.
        pub async fn update_entity_signals_mapping(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEntitySignalsMappingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EntitySignalsMapping>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.EntitySignalsMappingService/UpdateEntitySignalsMapping",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.EntitySignalsMappingService",
                        "UpdateEntitySignalsMapping",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `EntitySignalsMapping` objects.
        pub async fn batch_create_entity_signals_mappings(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchCreateEntitySignalsMappingsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateEntitySignalsMappingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.EntitySignalsMappingService/BatchCreateEntitySignalsMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.EntitySignalsMappingService",
                        "BatchCreateEntitySignalsMappings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `EntitySignalsMapping` objects.
        pub async fn batch_update_entity_signals_mappings(
            &mut self,
            request: impl tonic::IntoRequest<
                super::BatchUpdateEntitySignalsMappingsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateEntitySignalsMappingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.EntitySignalsMappingService/BatchUpdateEntitySignalsMappings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.EntitySignalsMappingService",
                        "BatchUpdateEntitySignalsMappings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a location in the world, for targeting.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GeoTarget {
    /// Identifier. The resource name of the `GeoTarget`.
    /// Format: `networks/{network_code}/geoTargets/{geo_target_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The display name of the GeoTarget.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The name of the direct parent that defines the canonical name
    /// of the geo target. For example, if the current geo target is "San
    /// Francisco", its canonical name would be "San Francisco, California, United
    /// States" thus the canonical_parent would be the name of California and the
    /// canonical_parent of California would be the name of United states Format:
    /// `networks/{network_code}/geoTargets/{geo_target}`
    #[prost(string, optional, tag = "3")]
    pub canonical_parent: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. All parents of the geo target ordered by ascending size.
    #[prost(string, repeated, tag = "4")]
    pub parent_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The Unicode CLDR region code of the geo target.
    #[prost(string, optional, tag = "5")]
    pub region_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The location type (unlocalized) for this geographical entity.
    #[prost(string, optional, tag = "6")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether the geo target is targetable.
    #[prost(bool, optional, tag = "7")]
    pub targetable: ::core::option::Option<bool>,
}
/// Request object for `GetGeoTarget` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetGeoTargetRequest {
    /// Required. The resource name of the GeoTarget.
    /// Format: `networks/{network_code}/geoTargets/{geo_target_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListGeoTargets` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListGeoTargetsRequest {
    /// Required. The parent, which owns this collection of GeoTargets.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `GeoTargets` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `GeoTargets` will
    /// be returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListGeoTargets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListGeoTargets` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListGeoTargetsRequest` containing matching `GeoTarget`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGeoTargetsResponse {
    /// The `GeoTarget` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub geo_targets: ::prost::alloc::vec::Vec<GeoTarget>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `GeoTarget` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod geo_target_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `GeoTarget` objects.
    #[derive(Debug, Clone)]
    pub struct GeoTargetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl GeoTargetServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> GeoTargetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GeoTargetServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            GeoTargetServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `GeoTarget` object.
        pub async fn get_geo_target(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGeoTargetRequest>,
        ) -> std::result::Result<tonic::Response<super::GeoTarget>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.GeoTargetService/GetGeoTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.GeoTargetService",
                        "GetGeoTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `GeoTarget` objects.
        pub async fn list_geo_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGeoTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGeoTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.GeoTargetService/ListGeoTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.GeoTargetService",
                        "ListGeoTargets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[GoalType\]\[google.ads.admanager.v1.GoalTypeEnum.GoalType\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GoalTypeEnum {}
/// Nested message and enum types in `GoalTypeEnum`.
pub mod goal_type_enum {
    /// Specifies the type of the goal for a LineItem.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoalType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// No goal is specified for the number of ads delivered.
        /// The line item \[type\]\[google.ads.admanager.v1.LineItem.line_item_type\]
        /// must be one of:
        ///
        /// * \[LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]
        /// * \[LineItemTypeEnum.LineItemType.AD_EXCHANGE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.AD_EXCHANGE\]
        /// * \[LineItemTypeEnum.LineItemType.CLICK_TRACKING\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.CLICK_TRACKING\]
        None = 1,
        /// There is a goal on the number of ads delivered for this line item during
        /// its entire lifetime.
        /// The line item \[type\]\[google.ads.admanager.v1.LineItem.line_item_type\]
        /// must be one of:
        ///
        /// * \[LineItemTypeEnum.LineItemType.STANDARD\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.STANDARD\]
        /// * \[LineItemTypeEnum.LineItemType.BULK\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.BULK\]
        /// * \[LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]
        /// * \[LineItemTypeEnum.LineItemType.ADSENSE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.ADSENSE\]
        /// * \[LineItemTypeEnum.LineItemType.AD_EXCHANGE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.AD_EXCHANGE\]
        /// * \[LineItemTypeEnum.LineItemType.ADMOB\]\[\]
        /// * \[LineItemTypeEnum.LineItemType.CLICK_TRACKING\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.CLICK_TRACKING\]
        Lifetime = 2,
        /// There is a daily goal on the number of ads delivered for this line item.
        /// The line item \[type\]\[google.ads.admanager.v1.LineItem.line_item_type\]
        /// must be one of:
        ///
        /// * \[LineItemTypeEnum.LineItemType.SPONSORSHIP\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.SPONSORSHIP\]
        /// * \[LineItemTypeEnum.LineItemType.NETWORK\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.NETWORK\]
        /// * \[LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]
        /// * \[LineItemTypeEnum.LineItemType.HOUSE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.HOUSE\]
        /// * \[LineItemTypeEnum.LineItemType.ADSENSE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.ADSENSE\]
        /// * \[LineItemTypeEnum.LineItemType.AD_EXCHANGE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.AD_EXCHANGE\]
        /// * \[LineItemTypeEnum.LineItemType.ADMOB\]\[\]
        /// * \[LineItemTypeEnum.LineItemType.BUMPER\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.BUMPER\]
        Daily = 3,
    }
    impl GoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "GOAL_TYPE_UNSPECIFIED",
                Self::None => "NONE",
                Self::Lifetime => "LIFETIME",
                Self::Daily => "DAILY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GOAL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "LIFETIME" => Some(Self::Lifetime),
                "DAILY" => Some(Self::Daily),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[UnitType\]\[google.ads.admanager.v1.UnitTypeEnum.UnitType\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnitTypeEnum {}
/// Nested message and enum types in `UnitTypeEnum`.
pub mod unit_type_enum {
    /// Indicates the type of unit used for defining a reservation. The
    /// \[LineItem.cost_type\]\[\] can differ from the UnitType - an
    /// ad can have an impression goal, but be billed by its click. Usually
    /// CostType and UnitType will refer to the same unit.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnitType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The number of impressions served by creatives associated with the line
        /// item.
        Impressions = 1,
        /// The number of clicks reported by creatives associated with the line item.
        /// The line item \[type\]\[google.ads.admanager.v1.LineItem.line_item_type\]
        /// must be one of:
        ///
        /// * \[LineItemTypeEnum.LineItemType.STANDARD\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.STANDARD\]
        /// * \[LineItemTypeEnum.LineItemType.BULK\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.BULK\]
        /// * \[LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]
        Clicks = 2,
        /// The number of click-through Cost-Per-Action (CPA) conversions from
        /// creatives associated with the line item. This is only supported as
        /// secondary goal and the \[LineItem.cost_type\]\[\] must be
        /// \[CostTypeEnum.CostType.CPA\]\[\].
        ClickThroughCpaConversions = 3,
        /// The number of view-through Cost-Per-Action (CPA) conversions from
        /// creatives associated with the line item. This is only supported as
        /// secondary goal and the \[LineItem.cost_type\]\[\] must be
        /// \[CostTypeEnum.CostType.CPA}.
        ViewThroughCpaConversions = 4,
        /// The number of total Cost-Per-Action (CPA) conversions from creatives
        /// associated with the line item. This is only supported as secondary goal
        /// and the \[LineItem.cost_type} must be \[CostTypeEnum.CostType.CPA}.
        TotalCpaConversions = 5,
        /// The number of viewable impressions reported by creatives associated with
        /// the line item. The
        /// \[LineItem.line_item_type\]\[google.ads.admanager.v1.LineItem.line_item_type\]
        /// must be
        /// \[LineItemTypeEnum.LineItemType.STANDARD\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.STANDARD\].
        ViewableImpressions = 6,
        /// The number of in-target impressions reported by third party measurements.
        /// The
        /// \[LineItem.line_item_type\]\[google.ads.admanager.v1.LineItem.line_item_type\]
        /// must be
        /// \[LineItemTypeEnum.LineItemType.STANDARD\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.STANDARD\].
        InTargetImpressions = 7,
    }
    impl UnitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNIT_TYPE_UNSPECIFIED",
                Self::Impressions => "IMPRESSIONS",
                Self::Clicks => "CLICKS",
                Self::ClickThroughCpaConversions => "CLICK_THROUGH_CPA_CONVERSIONS",
                Self::ViewThroughCpaConversions => "VIEW_THROUGH_CPA_CONVERSIONS",
                Self::TotalCpaConversions => "TOTAL_CPA_CONVERSIONS",
                Self::ViewableImpressions => "VIEWABLE_IMPRESSIONS",
                Self::InTargetImpressions => "IN_TARGET_IMPRESSIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IMPRESSIONS" => Some(Self::Impressions),
                "CLICKS" => Some(Self::Clicks),
                "CLICK_THROUGH_CPA_CONVERSIONS" => Some(Self::ClickThroughCpaConversions),
                "VIEW_THROUGH_CPA_CONVERSIONS" => Some(Self::ViewThroughCpaConversions),
                "TOTAL_CPA_CONVERSIONS" => Some(Self::TotalCpaConversions),
                "VIEWABLE_IMPRESSIONS" => Some(Self::ViewableImpressions),
                "IN_TARGET_IMPRESSIONS" => Some(Self::InTargetImpressions),
                _ => None,
            }
        }
    }
}
/// Defines the criteria a \[LineItem\]\[google.ads.admanager.v1.LineItem\] needs to
/// satisfy to meet its delivery goal.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Goal {
    /// The type of the goal for the LineItem. It defines the period over which the
    /// goal should be reached.
    #[prost(enumeration = "goal_type_enum::GoalType", optional, tag = "1")]
    pub goal_type: ::core::option::Option<i32>,
    /// The type of the goal unit for the LineItem.
    #[prost(enumeration = "unit_type_enum::UnitType", optional, tag = "2")]
    pub unit_type: ::core::option::Option<i32>,
    /// If this is a primary goal, it represents the number or percentage of
    /// impressions or clicks that will be reserved. If the line item is of type
    /// \[LineItemTypeEnum.LineItemType.SPONSORSHIP\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.SPONSORSHIP\],
    /// it represents the percentage of available impressions reserved. If the line
    /// item is of type
    /// \[LineItemTypeEnum.LineItemType.BULK\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.BULK\]
    /// or
    /// \[LineItemTypeEnum.LineItemType.PRICE_PRIORITY\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.PRICE_PRIORITY\],
    /// it represents the number of remaining impressions reserved. If the line
    /// item is of type
    /// \[LineItemTypeEnum.LineItemType.NETWORK\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.NETWORK\]
    /// or
    /// \[LineItemTypeEnum.LineItemType.HOUSE\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType.HOUSE\],
    /// it represents the percentage of remaining impressions reserved. <p>If this
    /// is an impression cap goal, it represents the number of impressions or
    /// conversions that the line item will stop serving at if reached. For valid
    /// line item types, see \[LineItem.impressions_cap\]\[\].
    #[prost(int64, optional, tag = "3")]
    pub units: ::core::option::Option<i64>,
}
/// A Label is additional information that can be added to an entity.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Label {
    /// Identifier. The resource name of the `Label`.
    /// Format: `networks/{network_code}/labels/{label_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Wrapper message for
/// \[LineItemType\]\[google.ads.admanager.v1.LineItemTypeEnum.LineItemType\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LineItemTypeEnum {}
/// Nested message and enum types in `LineItemTypeEnum`.
pub mod line_item_type_enum {
    /// Indicates the priority of a LineItem, determined by the way in which
    /// impressions are reserved to be served for it.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LineItemType {
        /// Not specified value.
        Unspecified = 0,
        /// The type of LineItem for which a percentage of all the impressions that
        /// are being sold are reserved.
        Sponsorship = 12,
        /// The type of LineItem for which a fixed quantity of impressions or
        /// clicks are reserved.
        Standard = 13,
        /// The type of LineItem most commonly used to fill a site's unsold
        /// inventory if not contractually obligated to deliver a requested number
        /// of impressions. Uses daily percentage of unsold impressions or clicks.
        Network = 9,
        /// The type of LineItem for which a fixed quantity of impressions or
        /// clicks will be delivered at a priority lower than the STANDARD type.
        Bulk = 4,
        /// The type of LineItem most commonly used to fill a site's unsold
        /// inventory if not contractually obligated to deliver a requested number
        /// of impressions. Uses fixed quantity percentage of unsold impressions or
        /// clicks.
        PricePriority = 11,
        /// The type of LineItem typically used for ads that promote products and
        /// services chosen by the publisher.
        House = 7,
        /// The type of LineItem used for ads that track ads being served
        /// externally of Ad Manager.
        ClickTracking = 6,
        /// Targets the LineItem to specific inventory available to AdSense buyers.
        Adsense = 2,
        /// Targets the LineItem to specific inventory available to Authorized Buyers
        /// and the Open Auction.
        AdExchange = 3,
        /// Represents a non-monetizable video LineItem that targets one or more
        /// bumper positions, which are short house video messages used by
        /// publishers to separate content from ad breaks.
        Bumper = 5,
        /// The type of LineItem for which there are no impressions reserved, and
        /// will serve for a second price bid.
        PreferredDeal = 10,
        /// The type of LineItem used for configuring audience extension campaigns.
        AudienceExtension = 14,
    }
    impl LineItemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LINE_ITEM_TYPE_UNSPECIFIED",
                Self::Sponsorship => "SPONSORSHIP",
                Self::Standard => "STANDARD",
                Self::Network => "NETWORK",
                Self::Bulk => "BULK",
                Self::PricePriority => "PRICE_PRIORITY",
                Self::House => "HOUSE",
                Self::ClickTracking => "CLICK_TRACKING",
                Self::Adsense => "ADSENSE",
                Self::AdExchange => "AD_EXCHANGE",
                Self::Bumper => "BUMPER",
                Self::PreferredDeal => "PREFERRED_DEAL",
                Self::AudienceExtension => "AUDIENCE_EXTENSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LINE_ITEM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SPONSORSHIP" => Some(Self::Sponsorship),
                "STANDARD" => Some(Self::Standard),
                "NETWORK" => Some(Self::Network),
                "BULK" => Some(Self::Bulk),
                "PRICE_PRIORITY" => Some(Self::PricePriority),
                "HOUSE" => Some(Self::House),
                "CLICK_TRACKING" => Some(Self::ClickTracking),
                "ADSENSE" => Some(Self::Adsense),
                "AD_EXCHANGE" => Some(Self::AdExchange),
                "BUMPER" => Some(Self::Bumper),
                "PREFERRED_DEAL" => Some(Self::PreferredDeal),
                "AUDIENCE_EXTENSION" => Some(Self::AudienceExtension),
                _ => None,
            }
        }
    }
}
/// A LineItem contains information about how specific ad creatives are intended
/// to serve to your website or app along with pricing and other delivery
/// details.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LineItem {
    /// Identifier. The resource name of the `LineItem`.
    /// Format: `networks/{network_code}/lineItems/{line_item_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The ID of the Order to which the LineItem belongs. This
    /// attribute is required. Format: `networks/{network_code}/orders/{order}`
    #[prost(string, optional, tag = "2")]
    pub order: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The name of the line item. This attribute is required and has a
    /// maximum length of 255 characters.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The date and time on which the LineItem is enabled to begin
    /// serving. This attribute is required and must be in the future.
    #[prost(message, optional, tag = "6")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp when the LineItem will stop serving. This
    /// attribute is read-only and includes auto extension days.
    #[prost(message, optional, tag = "7")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. Indicates the line item type of a LineItem. This attribute is
    /// required. The line item type determines the default priority of the line
    /// item. More information can be found at
    /// <https://support.google.com/admanager/answer/177279.>
    #[prost(enumeration = "line_item_type_enum::LineItemType", optional, tag = "17")]
    pub line_item_type: ::core::option::Option<i32>,
    /// Required. The amount of money to spend per impression or click.
    #[prost(message, optional, tag = "20")]
    pub rate: ::core::option::Option<super::super::super::r#type::Money>,
    /// Output only. The amount of money allocated to the LineItem. This attribute
    /// is readonly and is populated by Google. The currency code is readonly.
    #[prost(message, optional, tag = "35")]
    pub budget: ::core::option::Option<super::super::super::r#type::Money>,
    /// Optional. The values of the custom fields associated with this line item.
    #[prost(message, repeated, tag = "59")]
    pub custom_field_values: ::prost::alloc::vec::Vec<CustomFieldValue>,
    /// Optional. The primary goal that this LineItem is associated with, which is
    /// used in its pacing and budgeting.
    #[prost(message, optional, tag = "76")]
    pub goal: ::core::option::Option<Goal>,
}
/// Request object for `GetLineItem` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetLineItemRequest {
    /// Required. The resource name of the LineItem.
    /// Format: `networks/{network_code}/lineItems/{line_item_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListLineItems` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListLineItemsRequest {
    /// Required. The parent, which owns this collection of LineItems.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `LineItems` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `LineItems` will
    /// be returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListLineItems` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListLineItems` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListLineItemsRequest` containing matching `LineItem`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLineItemsResponse {
    /// The `LineItem` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub line_items: ::prost::alloc::vec::Vec<LineItem>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `LineItem` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod line_item_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `LineItem` objects.
    #[derive(Debug, Clone)]
    pub struct LineItemServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl LineItemServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> LineItemServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LineItemServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            LineItemServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `LineItem` object.
        pub async fn get_line_item(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLineItemRequest>,
        ) -> std::result::Result<tonic::Response<super::LineItem>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.LineItemService/GetLineItem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.LineItemService",
                        "GetLineItem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `LineItem` objects.
        pub async fn list_line_items(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLineItemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLineItemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.LineItemService/ListLineItems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.LineItemService",
                        "ListLineItems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A `LiveStreamEvent` encapsulates all the information necessary to enable DAI
/// (Dynamic Ad Insertion) into a live video stream.
/// This includes information such as the start and expected end time of the
/// `LiveStreamEvent`, the URL of the actual content for Ad Manager to pull and
/// insert ads into, as well as the metadata necessary to generate ad requests
/// during the live stream.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LiveStreamEvent {
    /// Identifier. The resource name of the `LiveStreamEvent`.
    /// Format: `networks/{network_code}/liveStreamEvents/{live_stream_event_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents a mobile carrier.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MobileCarrier {
    /// Identifier. The resource name of the `MobileCarrier`.
    /// Format: `networks/{network_code}/mobileCarriers/{mobile_carrier}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The localized name of the mobile carrier.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The region code of the mobile carrier.
    #[prost(string, optional, tag = "4")]
    pub region_code: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetMobileCarrier` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMobileCarrierRequest {
    /// Required. The resource name of the MobileCarrier.
    /// Format: `networks/{network_code}/mobileCarriers/{mobile_carrier_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListMobileCarriers` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMobileCarriersRequest {
    /// Required. The parent, which owns this collection of MobileCarriers.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `MobileCarriers` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `MobileCarriers`
    /// will be returned. The maximum value is 1000; values greater than 1000 will
    /// be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListMobileCarriers` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMobileCarriers` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListMobileCarriersRequest` containing matching
/// `MobileCarrier` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMobileCarriersResponse {
    /// The `MobileCarrier` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub mobile_carriers: ::prost::alloc::vec::Vec<MobileCarrier>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `MobileCarrier` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod mobile_carrier_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `MobileCarrier` objects.
    #[derive(Debug, Clone)]
    pub struct MobileCarrierServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MobileCarrierServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MobileCarrierServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MobileCarrierServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MobileCarrierServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `MobileCarrier` object.
        pub async fn get_mobile_carrier(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMobileCarrierRequest>,
        ) -> std::result::Result<tonic::Response<super::MobileCarrier>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.MobileCarrierService/GetMobileCarrier",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.MobileCarrierService",
                        "GetMobileCarrier",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `MobileCarrier` objects.
        pub async fn list_mobile_carriers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMobileCarriersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMobileCarriersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.MobileCarrierService/ListMobileCarriers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.MobileCarrierService",
                        "ListMobileCarriers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a mobile device.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MobileDevice {
    /// Identifier. The resource name of the `MobileDevice`.
    /// Format: `networks/{network_code}/mobileDevices/{mobile_device}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The localized name of the mobile device.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The manufacturer associated with the mobile device.
    /// Format: `networks/{network_code}/deviceManufacturers/{device_manufacturer}`
    #[prost(string, optional, tag = "3")]
    pub manufacturer: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetMobileDevice` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMobileDeviceRequest {
    /// Required. The resource name of the MobileDevice.
    /// Format: `networks/{network_code}/mobileDevices/{mobile_device_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListMobileDevices` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMobileDevicesRequest {
    /// Required. The parent, which owns this collection of MobileDevices.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `MobileDevices` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `MobileDevices`
    /// will be returned. The maximum value is 1000; values greater than 1000 will
    /// be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListMobileDevices` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMobileDevices` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListMobileDevicesRequest` containing matching
/// `MobileDevice` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMobileDevicesResponse {
    /// The `MobileDevice` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub mobile_devices: ::prost::alloc::vec::Vec<MobileDevice>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `MobileDevice` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod mobile_device_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `MobileDevice` objects.
    #[derive(Debug, Clone)]
    pub struct MobileDeviceServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MobileDeviceServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MobileDeviceServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MobileDeviceServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MobileDeviceServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `MobileDevice` object.
        pub async fn get_mobile_device(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMobileDeviceRequest>,
        ) -> std::result::Result<tonic::Response<super::MobileDevice>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.MobileDeviceService/GetMobileDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.MobileDeviceService",
                        "GetMobileDevice",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `MobileDevice` objects.
        pub async fn list_mobile_devices(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMobileDevicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMobileDevicesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.MobileDeviceService/ListMobileDevices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.MobileDeviceService",
                        "ListMobileDevices",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a mobile device submodel.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MobileDeviceSubmodel {
    /// Identifier. The resource name of the `MobileDeviceSubmodel`.
    /// Format:
    /// `networks/{network_code}/mobileDeviceSubmodels/{mobile_device_submodel}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The display name of the mobile device submodel.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The mobile device associated with the submodel.
    /// Format: `networks/{network_code}/mobileDevices/{mobile_device}`
    #[prost(string, optional, tag = "3")]
    pub mobile_device: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetMobileDeviceSubmodel` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMobileDeviceSubmodelRequest {
    /// Required. The resource name of the MobileDeviceSubmodel.
    /// Format:
    /// `networks/{network_code}/mobileDeviceSubmodels/{mobile_device_submodel_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListMobileDeviceSubmodels` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMobileDeviceSubmodelsRequest {
    /// Required. The parent, which owns this collection of MobileDeviceSubmodels.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `MobileDeviceSubmodels` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `MobileDeviceSubmodels` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListMobileDeviceSubmodels` call. Provide this to retrieve the subsequent
    /// page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListMobileDeviceSubmodels` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListMobileDeviceSubmodelsRequest` containing matching
/// `MobileDeviceSubmodel` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMobileDeviceSubmodelsResponse {
    /// The `MobileDeviceSubmodel` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub mobile_device_submodels: ::prost::alloc::vec::Vec<MobileDeviceSubmodel>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `MobileDeviceSubmodel` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod mobile_device_submodel_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `MobileDeviceSubmodel` objects.
    #[derive(Debug, Clone)]
    pub struct MobileDeviceSubmodelServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MobileDeviceSubmodelServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MobileDeviceSubmodelServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MobileDeviceSubmodelServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MobileDeviceSubmodelServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `MobileDeviceSubmodel` object.
        pub async fn get_mobile_device_submodel(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMobileDeviceSubmodelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MobileDeviceSubmodel>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.MobileDeviceSubmodelService/GetMobileDeviceSubmodel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.MobileDeviceSubmodelService",
                        "GetMobileDeviceSubmodel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `MobileDeviceSubmodel` objects.
        pub async fn list_mobile_device_submodels(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMobileDeviceSubmodelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMobileDeviceSubmodelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.MobileDeviceSubmodelService/ListMobileDeviceSubmodels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.MobileDeviceSubmodelService",
                        "ListMobileDeviceSubmodels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The Network resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Network {
    /// Identifier. The resource name of the Network.
    /// Format: networks/{network_code}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name for Network.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Network Code.
    #[prost(string, optional, tag = "3")]
    pub network_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Property code.
    #[prost(string, optional, tag = "4")]
    pub property_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Time zone associated with the delivery of orders and
    /// reporting.
    #[prost(string, optional, tag = "5")]
    pub time_zone: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Primary currency code, in ISO-4217 format.
    #[prost(string, optional, tag = "6")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Currency codes that can be used as an alternative to the primary
    /// currency code for trafficking Line Items.
    #[prost(string, repeated, tag = "7")]
    pub secondary_currency_codes: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. Top most [Ad Unit](google.ads.admanager.v1.AdUnit) to which
    /// descendant Ad Units can be added.
    /// Format: networks/{network_code}/adUnits/{ad_unit}
    #[prost(string, optional, tag = "8")]
    pub effective_root_ad_unit: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether this is a test network.
    #[prost(bool, optional, tag = "10")]
    pub test_network: ::core::option::Option<bool>,
    /// Output only. Network ID.
    #[prost(int64, optional, tag = "11")]
    pub network_id: ::core::option::Option<i64>,
}
/// Request to get Network
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetNetworkRequest {
    /// Required. Resource name of Network.
    /// Format: networks/{network_code}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListNetworks` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListNetworksRequest {
    /// Optional. The maximum number of `Network`s to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Network`s will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListNetworks` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListNetworks` must match
    /// the call that provided the page token.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "5")]
    pub skip: i32,
}
/// Response object for `ListNetworks` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworksResponse {
    /// The `Network`s a user has access to.
    #[prost(message, repeated, tag = "1")]
    pub networks: ::prost::alloc::vec::Vec<Network>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Network`s.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod network_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Network` objects.
    #[derive(Debug, Clone)]
    pub struct NetworkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl NetworkServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> NetworkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            NetworkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a Network object.
        pub async fn get_network(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Network>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.NetworkService/GetNetwork",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.NetworkService",
                        "GetNetwork",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve all the networks the current user has access to.
        pub async fn list_networks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListNetworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.NetworkService/ListNetworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.NetworkService",
                        "ListNetworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a device's operating system.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperatingSystem {
    /// Identifier. The resource name of the `OperatingSystem`.
    /// Format: `networks/{network_code}/operatingSystems/{operating_system_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The name of the operating system.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetOperatingSystem` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOperatingSystemRequest {
    /// Required. The resource name of the OperatingSystem.
    /// Format: `networks/{network_code}/operatingSystems/{operating_system_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListOperatingSystems` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListOperatingSystemsRequest {
    /// Required. The parent, which owns this collection of OperatingSystems.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `OperatingSystems` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `OperatingSystems` will be returned. The maximum value is 1000; values
    /// greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListOperatingSystems`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListOperatingSystems`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListOperatingSystemsRequest` containing matching
/// `OperatingSystem` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperatingSystemsResponse {
    /// The `OperatingSystem` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub operating_systems: ::prost::alloc::vec::Vec<OperatingSystem>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `OperatingSystem` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod operating_system_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `OperatingSystem` objects.
    #[derive(Debug, Clone)]
    pub struct OperatingSystemServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OperatingSystemServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OperatingSystemServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OperatingSystemServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OperatingSystemServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `OperatingSystem` object.
        pub async fn get_operating_system(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOperatingSystemRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OperatingSystem>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OperatingSystemService/GetOperatingSystem",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.OperatingSystemService",
                        "GetOperatingSystem",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `OperatingSystem` objects.
        pub async fn list_operating_systems(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOperatingSystemsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOperatingSystemsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OperatingSystemService/ListOperatingSystems",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.OperatingSystemService",
                        "ListOperatingSystems",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a specific version of an operating system.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperatingSystemVersion {
    /// Identifier. The resource name of the `OperatingSystemVersion`.
    /// Format:
    /// `networks/{network_code}/operatingSystemVersions/{operating_system_version_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The major version of the operating system.
    #[prost(int32, optional, tag = "2")]
    pub major_version: ::core::option::Option<i32>,
    /// Output only. The minor version of the operating system.
    #[prost(int32, optional, tag = "3")]
    pub minor_version: ::core::option::Option<i32>,
    /// Output only. The micro version of the operating system.
    #[prost(int32, optional, tag = "4")]
    pub micro_version: ::core::option::Option<i32>,
}
/// Request object for `GetOperatingSystemVersion` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOperatingSystemVersionRequest {
    /// Required. The resource name of the OperatingSystemVersion.
    /// Format:
    /// `networks/{network_code}/operatingSystemVersions/{operating_system_version_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListOperatingSystemVersions` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListOperatingSystemVersionsRequest {
    /// Required. The parent, which owns this collection of
    /// OperatingSystemVersions. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `OperatingSystemVersions` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `OperatingSystemVersions` will be returned. The maximum value is 1000;
    /// values greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous
    /// `ListOperatingSystemVersions` call. Provide this to retrieve the subsequent
    /// page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListOperatingSystemVersions` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListOperatingSystemVersionsRequest` containing matching
/// `OperatingSystemVersion` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOperatingSystemVersionsResponse {
    /// The `OperatingSystemVersion` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub operating_system_versions: ::prost::alloc::vec::Vec<OperatingSystemVersion>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `OperatingSystemVersion` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod operating_system_version_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `OperatingSystemVersion` objects.
    #[derive(Debug, Clone)]
    pub struct OperatingSystemVersionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OperatingSystemVersionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OperatingSystemVersionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OperatingSystemVersionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OperatingSystemVersionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `OperatingSystemVersion` object.
        pub async fn get_operating_system_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOperatingSystemVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::OperatingSystemVersion>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OperatingSystemVersionService/GetOperatingSystemVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.OperatingSystemVersionService",
                        "GetOperatingSystemVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `OperatingSystemVersion` objects.
        pub async fn list_operating_system_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOperatingSystemVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOperatingSystemVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OperatingSystemVersionService/ListOperatingSystemVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.OperatingSystemVersionService",
                        "ListOperatingSystemVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[OrderStatus\]\[google.ads.admanager.v1.OrderStatusEnum.OrderStatus\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderStatusEnum {}
/// Nested message and enum types in `OrderStatusEnum`.
pub mod order_status_enum {
    /// The status of an Order.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OrderStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Indicates that the Order has just been created but no approval has been
        /// requested yet.
        Draft = 2,
        /// Indicates that a request for approval for the Order has been made.
        PendingApproval = 3,
        /// Indicates that the Order has been approved and is ready to serve.
        Approved = 4,
        /// Indicates that the Order has been disapproved and is not eligible to
        /// serve.
        Disapproved = 5,
        /// This is a legacy state. Paused status should be checked on LineItems
        /// within the order.
        Paused = 6,
        /// Indicates that the Order has been canceled and cannot serve.
        Canceled = 7,
        /// Indicates that the Order has been deleted.
        Deleted = 8,
    }
    impl OrderStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ORDER_STATUS_UNSPECIFIED",
                Self::Draft => "DRAFT",
                Self::PendingApproval => "PENDING_APPROVAL",
                Self::Approved => "APPROVED",
                Self::Disapproved => "DISAPPROVED",
                Self::Paused => "PAUSED",
                Self::Canceled => "CANCELED",
                Self::Deleted => "DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ORDER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "DRAFT" => Some(Self::Draft),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                "PAUSED" => Some(Self::Paused),
                "CANCELED" => Some(Self::Canceled),
                "DELETED" => Some(Self::Deleted),
                _ => None,
            }
        }
    }
}
/// The `Order` resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Order {
    /// Identifier. The resource name of the `Order`.
    /// Format: `networks/{network_code}/orders/{order_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Order ID.
    #[prost(int64, optional, tag = "4")]
    pub order_id: ::core::option::Option<i64>,
    /// Required. The display name of the Order.  This value has a maximum length
    /// of 255 characters.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Specifies whether or not the Order is a programmatic order.
    #[prost(bool, optional, tag = "3")]
    pub programmatic: ::core::option::Option<bool>,
    /// Required. The resource name of the User responsible for trafficking the
    /// Order. Format: "networks/{network_code}/users/{user_id}"
    #[prost(string, optional, tag = "23")]
    pub trafficker: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Unordered list. The resource names of Contacts from the
    /// advertiser of this Order. Format:
    /// "networks/{network_code}/contacts/{contact_id}"
    #[prost(string, repeated, tag = "5")]
    pub advertiser_contacts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. The resource name of the Company, which is of type
    /// Company.Type.ADVERTISER, to which this order belongs. Format:
    /// "networks/{network_code}/companies/{company_id}"
    #[prost(string, optional, tag = "6")]
    pub advertiser: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The resource names of Contacts from the advertising Agency of
    /// this Order. Format: "networks/{network_code}/contacts/{contact_id}"
    #[prost(string, repeated, tag = "7")]
    pub agency_contacts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The resource name of the Company, which is of type
    /// Company.Type.AGENCY, with which this order is associated. Format:
    /// "networks/{network_code}/companies/{company_id}"
    #[prost(string, optional, tag = "8")]
    pub agency: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The resource names of Teams directly applied to this Order.
    /// Format: "networks/{network_code}/teams/{team_id}"
    #[prost(string, repeated, tag = "9")]
    pub applied_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The resource names of Teams applied to this Order including
    /// inherited values. Format: "networks/{network_code}/teams/{team_id}"
    #[prost(string, repeated, tag = "28")]
    pub effective_teams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The resource name of the User who created the Order on behalf
    /// of the advertiser. Format: "networks/{network_code}/users/{user_id}"
    #[prost(string, optional, tag = "10")]
    pub creator: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The ISO 4217 3-letter currency code for the currency used by
    /// the Order. This value is the network's currency code.
    #[prost(string, optional, tag = "11")]
    pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The instant at which the Order and its associated Line items
    /// are eligible to begin serving. This attribute is derived from the Line item
    /// of the order that has the earliest `LineItem.start_time`.
    #[prost(message, optional, tag = "19")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The instant at which the Order and its associated Line items
    /// stop being served. This attribute is derived from the Line item of the
    /// order that has the latest `LineItem.end_time`.
    #[prost(message, optional, tag = "12")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Indicates whether or not this Order has an end time.
    #[prost(bool, optional, tag = "45")]
    pub unlimited_end_time: ::core::option::Option<bool>,
    /// Optional. An arbitrary ID to associate to the Order, which can be used as a
    /// key to an external system.
    #[prost(int32, optional, tag = "13")]
    pub external_order_id: ::core::option::Option<i32>,
    /// Output only. The archival status of the Order.
    #[prost(bool, optional, tag = "14")]
    pub archived: ::core::option::Option<bool>,
    /// Output only. The application which modified this order. This attribute is
    /// assigned by Google.
    #[prost(string, optional, tag = "15")]
    pub last_modified_by_app: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The instant this Order was last modified.
    #[prost(message, optional, tag = "16")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Provides any additional notes that may annotate the Order. This
    /// attribute has a maximum length of 65,535 characters.
    #[prost(string, optional, tag = "17")]
    pub notes: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The purchase order number for the Order. This value has a maximum
    /// length of 63 characters.
    #[prost(string, optional, tag = "18")]
    pub po_number: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of the Order.
    #[prost(enumeration = "order_status_enum::OrderStatus", optional, tag = "20")]
    pub status: ::core::option::Option<i32>,
    /// Optional. The resource name of the User responsible for the sales of the
    /// Order. Format: "networks/{network_code}/users/{user_id}"
    #[prost(string, optional, tag = "21")]
    pub salesperson: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Unordered list. The resource names of the secondary salespeople
    /// associated with the order. Format:
    /// "networks/{network_code}/users/{user_id}"
    #[prost(string, repeated, tag = "22")]
    pub secondary_salespeople: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Unordered list. The resource names of the secondary traffickers
    /// associated with the order. Format:
    /// "networks/{network_code}/users/{user_id}"
    #[prost(string, repeated, tag = "24")]
    pub secondary_traffickers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The set of labels applied directly to this order.
    #[prost(message, repeated, tag = "25")]
    pub applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    /// Output only. Contains the set of labels applied directly to the order as
    /// well as those inherited from the company that owns the order. If a label
    /// has been negated, only the negated label is returned. This field is
    /// assigned by Google.
    #[prost(message, repeated, tag = "26")]
    pub effective_applied_labels: ::prost::alloc::vec::Vec<AppliedLabel>,
    /// Optional. The set of custom field values to this order.
    #[prost(message, repeated, tag = "38")]
    pub custom_field_values: ::prost::alloc::vec::Vec<CustomFieldValue>,
}
/// Request object for `GetOrder` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetOrderRequest {
    /// Required. The resource name of the Order.
    /// Format: `networks/{network_code}/orders/{order_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListOrders` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListOrdersRequest {
    /// Required. The parent, which owns this collection of Orders.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Orders` to return. The service may return
    /// fewer than this value. If unspecified, at most 50 `Orders` will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListOrders` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListOrders` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListOrdersRequest` containing matching `Order`
/// resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListOrdersResponse {
    /// The `Order` from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub orders: ::prost::alloc::vec::Vec<Order>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Orders`.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod order_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Order` objects.
    #[derive(Debug, Clone)]
    pub struct OrderServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl OrderServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> OrderServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> OrderServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            OrderServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve an Order object.
        pub async fn get_order(
            &mut self,
            request: impl tonic::IntoRequest<super::GetOrderRequest>,
        ) -> std::result::Result<tonic::Response<super::Order>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OrderService/GetOrder",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.OrderService", "GetOrder"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Order` objects.
        ///
        /// Fields used for literal matching in filter string:
        ///
        /// * `order_id`
        /// * `display_name`
        /// * `external_order_id`
        pub async fn list_orders(
            &mut self,
            request: impl tonic::IntoRequest<super::ListOrdersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListOrdersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.OrderService/ListOrders",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.OrderService", "ListOrders"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[PlacementStatus\]\[google.ads.admanager.v1.PlacementStatusEnum.PlacementStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlacementStatusEnum {}
/// Nested message and enum types in `PlacementStatusEnum`.
pub mod placement_status_enum {
    /// Status of the placement.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlacementStatus {
        /// Not specified value.
        Unspecified = 0,
        /// Stats are collected, user-visible.
        Active = 1,
        /// No stats collected, not user-visible.
        Inactive = 2,
        /// No stats collected, user-visible.
        Archived = 3,
    }
    impl PlacementStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PLACEMENT_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
                Self::Archived => "ARCHIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PLACEMENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "ARCHIVED" => Some(Self::Archived),
                _ => None,
            }
        }
    }
}
/// The `Placement` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Placement {
    /// Identifier. The resource name of the `Placement`.
    /// Format: `networks/{network_code}/placements/{placement_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `Placement` ID.
    #[prost(int64, tag = "2")]
    pub placement_id: i64,
    /// Required. The display name of the placement. This attribute has a maximum
    /// length of 255 characters.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. A description of the Placement. This attribute has a maximum
    /// length of 65,535 characters.
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. A string used to uniquely identify the Placement for purposes
    /// of serving the ad. This attribute is assigned by Google.
    #[prost(string, optional, tag = "5")]
    pub placement_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of the Placement.
    #[prost(enumeration = "placement_status_enum::PlacementStatus", optional, tag = "6")]
    pub status: ::core::option::Option<i32>,
    /// Optional. The resource names of AdUnits that constitute the Placement.
    /// Format: "networks/{network_code}/adUnits/{ad_unit}"
    #[prost(string, repeated, tag = "7")]
    pub targeted_ad_units: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The instant this Placement was last modified.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request object for `GetPlacement` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPlacementRequest {
    /// Required. The resource name of the Placement.
    /// Format: `networks/{network_code}/placements/{placement_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListPlacements` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPlacementsRequest {
    /// Required. The parent, which owns this collection of Placements.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Placements` to return. The service may
    /// return fewer than this value. If unspecified, at most 50 `Placements` will
    /// be returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListPlacements` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListPlacements` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListPlacementsRequest` containing matching `Placement`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPlacementsResponse {
    /// The `Placement` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub placements: ::prost::alloc::vec::Vec<Placement>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Placement` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreatePlacement` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreatePlacementRequest {
    /// Required. The parent resource where this `Placement` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Placement` to create.
    #[prost(message, optional, tag = "2")]
    pub placement: ::core::option::Option<Placement>,
}
/// Request object for `BatchCreatePlacements` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreatePlacementsRequest {
    /// Required. The parent resource where the `Placement`s will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreatePlacementRequest messages match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Placement` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreatePlacementRequest>,
}
/// Response object for `BatchCreatePlacements` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreatePlacementsResponse {
    /// The `Placement` objects created.
    #[prost(message, repeated, tag = "1")]
    pub placements: ::prost::alloc::vec::Vec<Placement>,
}
/// Request object for `UpdatePlacement` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePlacementRequest {
    /// Required. The `Placement` to update.
    ///
    /// The `Placement`'s name is used to identify the `Placement` to
    /// update. Format:
    /// `networks/{network_code}/placements/{placement_id}`
    #[prost(message, optional, tag = "1")]
    pub placement: ::core::option::Option<Placement>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchUpdatePlacements` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdatePlacementsRequest {
    /// Required. The parent resource where `Placements` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdatePlacementsRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Placement` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdatePlacementRequest>,
}
/// Response object for `BatchUpdatePlacements` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdatePlacementsResponse {
    /// The `Placement` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub placements: ::prost::alloc::vec::Vec<Placement>,
}
/// Request message for `BatchActivatePlacements` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivatePlacementsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The names of the `Placement` objects to activate.
    /// Format: `networks/{network_code}/placements/{placement_id}`
    #[prost(string, repeated, tag = "3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchActivatePlacements` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivatePlacementsResponse {}
/// Request message for `BatchDeactivatePlacements` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivatePlacementsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The names of the `Placement` objects to deactivate.
    /// Format: `networks/{network_code}/placements/{placement_id}`
    #[prost(string, repeated, tag = "3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchDeactivatePlacements` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivatePlacementsResponse {}
/// Request message for `BatchArchivePlacements` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchArchivePlacementsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The names of the `Placement` objects to archive.
    /// Format: `networks/{network_code}/placements/{placement_id}`
    #[prost(string, repeated, tag = "3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchArchivePlacements` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchArchivePlacementsResponse {}
/// Generated client implementations.
pub mod placement_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Placement` objects.
    #[derive(Debug, Clone)]
    pub struct PlacementServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PlacementServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PlacementServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PlacementServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PlacementServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Placement` object.
        pub async fn get_placement(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPlacementRequest>,
        ) -> std::result::Result<tonic::Response<super::Placement>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/GetPlacement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "GetPlacement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Placement` objects.
        pub async fn list_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/ListPlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "ListPlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create an `Placement` object.
        pub async fn create_placement(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePlacementRequest>,
        ) -> std::result::Result<tonic::Response<super::Placement>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/CreatePlacement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "CreatePlacement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update an `Placement` object.
        pub async fn update_placement(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePlacementRequest>,
        ) -> std::result::Result<tonic::Response<super::Placement>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/UpdatePlacement",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "UpdatePlacement",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `Placement` objects.
        pub async fn batch_create_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreatePlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreatePlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/BatchCreatePlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "BatchCreatePlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `Placement` objects.
        pub async fn batch_update_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdatePlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdatePlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/BatchUpdatePlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "BatchUpdatePlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Activates a list of `Placement` objects.
        pub async fn batch_activate_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchActivatePlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchActivatePlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/BatchActivatePlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "BatchActivatePlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deactivates a list of `Placement` objects.
        pub async fn batch_deactivate_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeactivatePlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchDeactivatePlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/BatchDeactivatePlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "BatchDeactivatePlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Archives a list of `Placement` objects.
        pub async fn batch_archive_placements(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchArchivePlacementsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchArchivePlacementsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PlacementService/BatchArchivePlacements",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PlacementService",
                        "BatchArchivePlacements",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[PrivateMarketplaceDealStatus\]\[google.ads.admanager.v1.PrivateMarketplaceDealStatusEnum.PrivateMarketplaceDealStatus\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivateMarketplaceDealStatusEnum {}
/// Nested message and enum types in `PrivateMarketplaceDealStatusEnum`.
pub mod private_marketplace_deal_status_enum {
    /// Describes the status of a private marketplace deal.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PrivateMarketplaceDealStatus {
        /// No value specified.
        Unspecified = 0,
        /// The deal is pending.
        Pending = 1,
        /// The deal is active.
        Active = 2,
        /// The deal is canceled.
        Canceled = 3,
        /// The deal is paused by the seller.
        SellerPaused = 4,
        /// The deal is paused by the buyer.
        BuyerPaused = 5,
    }
    impl PrivateMarketplaceDealStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PRIVATE_MARKETPLACE_DEAL_STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Active => "ACTIVE",
                Self::Canceled => "CANCELED",
                Self::SellerPaused => "SELLER_PAUSED",
                Self::BuyerPaused => "BUYER_PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIVATE_MARKETPLACE_DEAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ACTIVE" => Some(Self::Active),
                "CANCELED" => Some(Self::Canceled),
                "SELLER_PAUSED" => Some(Self::SellerPaused),
                "BUYER_PAUSED" => Some(Self::BuyerPaused),
                _ => None,
            }
        }
    }
}
/// Wrapper message for \[RequestPlatform\].
///
/// Describes the platform from which a request is made and on which the ad is
/// rendered. In the event of multiple platforms, the platform that ultimately
/// renders the ad is the targeted platform. For example, a video player on a
/// website would have a request platform of `VIDEO_PLAYER`.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestPlatformEnum {}
/// Nested message and enum types in `RequestPlatformEnum`.
pub mod request_platform_enum {
    /// The different environments in which an ad can be shown.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestPlatform {
        /// No value specified
        Unspecified = 0,
        /// Represents a request made from a web browser (incl. desktop browsers,
        /// mobile browsers, webviews, etc.).
        Browser = 1,
        /// Represents a request made from a Mobile Application.
        MobileApp = 2,
        /// Represents a request made from a video player.
        VideoPlayer = 3,
    }
    impl RequestPlatform {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REQUEST_PLATFORM_UNSPECIFIED",
                Self::Browser => "BROWSER",
                Self::MobileApp => "MOBILE_APP",
                Self::VideoPlayer => "VIDEO_PLAYER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REQUEST_PLATFORM_UNSPECIFIED" => Some(Self::Unspecified),
                "BROWSER" => Some(Self::Browser),
                "MOBILE_APP" => Some(Self::MobileApp),
                "VIDEO_PLAYER" => Some(Self::VideoPlayer),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[TargetedVideoBumperType\]\[google.ads.admanager.v1.TargetedVideoBumperTypeEnum.TargetedVideoBumperType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetedVideoBumperTypeEnum {}
/// Nested message and enum types in `TargetedVideoBumperTypeEnum`.
pub mod targeted_video_bumper_type_enum {
    /// Represents the options for targetable bumper positions, surrounding an ad
    /// pod, within a video stream. This includes before and after the supported ad
    /// pod positions, `VideoPositionType.PREROLL`, `VideoPositionType.MIDROLL`,
    /// and `VideoPositionType.POSTROLL`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetedVideoBumperType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Represents the bumper position after the ad pod.
        After = 1,
        /// Represents the bumper position before the ad pod.
        Before = 2,
    }
    impl TargetedVideoBumperType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TARGETED_VIDEO_BUMPER_TYPE_UNSPECIFIED",
                Self::After => "AFTER",
                Self::Before => "BEFORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGETED_VIDEO_BUMPER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AFTER" => Some(Self::After),
                "BEFORE" => Some(Self::Before),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[VideoPosition\]\[google.ads.admanager.v1.VideoPositionEnum.VideoPosition\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VideoPositionEnum {}
/// Nested message and enum types in `VideoPositionEnum`.
pub mod video_position_enum {
    /// Represents a targetable position within a video.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VideoPosition {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Allow ad placement at any position within the video.
        All = 1,
        /// Target ad placement during the video.
        Midroll = 2,
        /// Target ad placement after the video ends.
        Postroll = 3,
        /// Target ad placement before the video starts.
        Preroll = 4,
    }
    impl VideoPosition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VIDEO_POSITION_UNSPECIFIED",
                Self::All => "ALL",
                Self::Midroll => "MIDROLL",
                Self::Postroll => "POSTROLL",
                Self::Preroll => "PREROLL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VIDEO_POSITION_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL" => Some(Self::All),
                "MIDROLL" => Some(Self::Midroll),
                "POSTROLL" => Some(Self::Postroll),
                "PREROLL" => Some(Self::Preroll),
                _ => None,
            }
        }
    }
}
/// Targeting expression.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Targeting {
    /// Optional. Used to target/exclude various geo targets.
    #[prost(message, optional, tag = "2")]
    pub geo_targeting: ::core::option::Option<GeoTargeting>,
    /// Optional. Used to target various technology targeting dimensions.
    #[prost(message, optional, tag = "3")]
    pub technology_targeting: ::core::option::Option<TechnologyTargeting>,
    /// Optional. Used to target/exclude various ad units and/or placements.
    #[prost(message, optional, tag = "5")]
    pub inventory_targeting: ::core::option::Option<InventoryTargeting>,
    /// Optional. Used to target specific request platforms.
    #[prost(message, optional, tag = "6")]
    pub request_platform_targeting: ::core::option::Option<RequestPlatformTargeting>,
    /// Optional. Used to target key/values, audience segments, and/or CMS
    /// metadata.
    #[prost(message, optional, tag = "7")]
    pub custom_targeting: ::core::option::Option<CustomTargeting>,
    /// Optional. Used to target user domains.
    #[prost(message, optional, tag = "10")]
    pub user_domain_targeting: ::core::option::Option<UserDomainTargeting>,
    /// Optional. Used to target video positions.
    #[prost(message, optional, tag = "12")]
    pub video_position_targeting: ::core::option::Option<VideoPositionTargeting>,
    /// Optional. Used to target data segments.
    #[prost(message, optional, tag = "13")]
    pub data_segment_targeting: ::core::option::Option<DataSegmentTargeting>,
    /// Optional. Used to target content.
    #[prost(message, optional, tag = "15")]
    pub content_targeting: ::core::option::Option<ContentTargeting>,
    /// Optional. Used to target mobile applications.
    #[prost(message, optional, tag = "18")]
    pub mobile_application_targeting: ::core::option::Option<MobileApplicationTargeting>,
}
/// Represents a list of targeted and excluded geos.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GeoTargeting {
    /// Optional. A list of geo resource names that should be targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_geos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of geo resource names that should be excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_geos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Various types of technology targeting expressed by child messages are
/// applied with logical AND.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TechnologyTargeting {
    /// Optional. Bandwidth targeting dimension.
    #[prost(message, optional, tag = "3")]
    pub bandwidth_targeting: ::core::option::Option<BandwidthTargeting>,
    /// Optional. Browser targeting dimension.
    #[prost(message, optional, tag = "4")]
    pub browser_targeting: ::core::option::Option<BrowserTargeting>,
    /// Optional. Browser language targeting dimension.
    #[prost(message, optional, tag = "5")]
    pub browser_language_targeting: ::core::option::Option<BrowserLanguageTargeting>,
    /// Optional. Device capability targeting dimension.
    #[prost(message, optional, tag = "6")]
    pub device_capability_targeting: ::core::option::Option<DeviceCapabilityTargeting>,
    /// Optional. Device category targeting dimension.
    #[prost(message, optional, tag = "1")]
    pub device_category_targeting: ::core::option::Option<DeviceCategoryTargeting>,
    /// Optional. Device manufacturer targeting dimension.
    #[prost(message, optional, tag = "7")]
    pub device_manufacturer_targeting: ::core::option::Option<
        DeviceManufacturerTargeting,
    >,
    /// Optional. Mobile carrier targeting dimension.
    #[prost(message, optional, tag = "8")]
    pub mobile_carrier_targeting: ::core::option::Option<MobileCarrierTargeting>,
    /// Optional. Operating system targeting dimension.
    #[prost(message, optional, tag = "2")]
    pub operating_system_targeting: ::core::option::Option<OperatingSystemTargeting>,
}
/// Bandwidth Targeting.
///
/// Reach users accessing the internet via various means of connection, such as
/// cable, DSL, or dial-up. Can be useful to target campaigns using
/// low-resolution creatives or text ads for users with low bandwidth.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BandwidthTargeting {
    /// Optional. A list of resource names of the bandwidth groups that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_bandwidth_groups: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of resource names of the bandwidth groups that should be
    /// excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_bandwidth_groups: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Browser Targeting.
///
/// Allows publishers to target/exclude a browser type (e.g. Chrome, Firefox,
/// Safari). For more information, see
/// <https://support.google.com/admanager/answer/2884033> (Targeting types >
/// Browser).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BrowserTargeting {
    /// Optional. A list of browser resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_browsers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of browser resource names that should be excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_browsers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Browser Language Targeting.
///
/// For ads targeting mobile apps and their associated WebViews, the language
/// used is based on the language specified by the user in their mobile device
/// settings. If a browser has more than one language assigned to it, each
/// language generates an impression.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BrowserLanguageTargeting {
    /// Optional. A list of browser language resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_browser_languages: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of browser language resource names that should be
    /// excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_browser_languages: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Represents a list of targeted and excluded device categories.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceCategoryTargeting {
    /// Optional. A list of device category resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of device category resource names that should be excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Device Capability Targeting.
///
/// Can be used to target/exclude users using mobile apps, ad requests resulting
/// from apps built on the MRAID standard, or users on devices that are able to
/// make phone calls versus devices that aren't able to make phone calls, such as
/// tablets.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceCapabilityTargeting {
    /// Optional. A list of device capability resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of device capability resource names that should be
    /// excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Device Manufacturer Targeting.
///
/// Can be used to target/exclude users on devices made by specific brands or
/// companies, such as Apple, Google, Samsung and others. For more information,
/// see <https://support.google.com/admanager/answer/2884033> ("Targeting types >
/// Device manufacturer").
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceManufacturerTargeting {
    /// Optional. A list of device manufacturer resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "7")]
    pub targeted_device_manufacturers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of device manufacturer resource names that should be
    /// excluded.
    #[prost(string, repeated, tag = "8")]
    pub excluded_device_manufacturers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of mobile device resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "9")]
    pub targeted_mobile_devices: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of mobile device resource names that should be excluded.
    #[prost(string, repeated, tag = "10")]
    pub excluded_mobile_devices: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of mobile device submodel resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "11")]
    pub targeted_mobile_device_submodels: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of mobile device submodel resource names that should be
    /// excluded.
    #[prost(string, repeated, tag = "12")]
    pub excluded_mobile_device_submodels: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Mobile Carrier Targeting.
///
/// Can be used to target/exclude a variety of mobile carriers, such as AT&T,
/// Verizon, or T-Mobile.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MobileCarrierTargeting {
    /// Optional. A list of mobile carrier resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "3")]
    pub targeted_mobile_carriers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of mobile carrier resource names that should be excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_mobile_carriers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Operating System Targeting
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperatingSystemTargeting {
    /// Optional. A list of operating system resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "5")]
    pub targeted_operating_systems: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of operating system resource names that should be
    /// excluded.
    #[prost(string, repeated, tag = "6")]
    pub excluded_operating_systems: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of operating system version resource names that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "7")]
    pub targeted_operating_system_versions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. A list of operating system version resource names that should be
    /// excluded.
    #[prost(string, repeated, tag = "8")]
    pub excluded_operating_system_versions: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Targeted ad units and AU placements are applied with
/// logical OR. Example:
///
/// (au:1 OR au:2 OR au_placement:5) AND (NOT (au:3))
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InventoryTargeting {
    /// Optional. A list of ad units that should be targeted/included.
    #[prost(message, repeated, tag = "1")]
    pub targeted_ad_units: ::prost::alloc::vec::Vec<AdUnitTargeting>,
    /// Optional. A list of ad units that should be excluded.
    ///
    /// Excluded AUs take precedence over targeted AUs. In fact an AU can be
    /// excluded only if one of its ancestors is targeted. Subsequently child
    /// AUs of an excluded AU can not be targeted (except via a placement).
    #[prost(message, repeated, tag = "2")]
    pub excluded_ad_units: ::prost::alloc::vec::Vec<AdUnitTargeting>,
    /// Optional. The resource names of the placements that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "5")]
    pub targeted_placements: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Specifies an ad unit and (optionally) its descendants.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AdUnitTargeting {
    /// Whether this ad unit's children should be targeted/excluded as well.
    #[prost(bool, optional, tag = "1")]
    pub include_descendants: ::core::option::Option<bool>,
    /// Optional. The resource name of this ad unit.
    #[prost(string, optional, tag = "3")]
    pub ad_unit: ::core::option::Option<::prost::alloc::string::String>,
}
/// Represents a list of targeted request platforms.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RequestPlatformTargeting {
    /// Optional. The list of request platforms that should be targeted.
    #[prost(
        enumeration = "request_platform_enum::RequestPlatform",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub request_platforms: ::prost::alloc::vec::Vec<i32>,
}
/// Represents the top level targeting expression for custom key/values,
/// audience segments, and/or CMS metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargeting {
    /// Optional. These clauses are all ORed together.
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_clauses: ::prost::alloc::vec::Vec<CustomTargetingClause>,
}
/// Represents a logical AND of individual custom targeting expressions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomTargetingClause {
    /// Optional. Leaf targeting expressions for custom key/values.
    #[prost(message, repeated, tag = "1")]
    pub custom_targeting_literals: ::prost::alloc::vec::Vec<CustomTargetingLiteral>,
    /// Optional. Leaf targeting expressions for audience segments.
    #[prost(message, repeated, tag = "2")]
    pub audience_segment_targetings: ::prost::alloc::vec::Vec<AudienceSegmentTargeting>,
    /// Optional. Leaf targeting expressions for cms metadata.
    #[prost(message, repeated, tag = "3")]
    pub cms_metadata_targetings: ::prost::alloc::vec::Vec<CmsMetadataTargeting>,
}
/// Represents targeting for custom key/values. The values are ORed together.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CustomTargetingLiteral {
    /// Whether this expression is negatively targeted, meaning it matches
    /// ad requests that exclude the below values.
    #[prost(bool, optional, tag = "1")]
    pub negative: ::core::option::Option<bool>,
    /// Optional. The resource name of the targeted CustomKey.
    #[prost(string, optional, tag = "4")]
    pub custom_targeting_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The resource names of the targeted CustomValues.
    #[prost(string, repeated, tag = "5")]
    pub custom_targeting_values: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Represents targeting for audience segments. The values are combined in a
/// logical `OR`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AudienceSegmentTargeting {
    /// Whether this expression is negatively targeted, meaning it matches
    /// ad requests that exclude the below values.
    #[prost(bool, optional, tag = "1")]
    pub negative: ::core::option::Option<bool>,
    /// Optional. The targeted audience segments.
    ///
    /// This is either the resource name of a first-party audience segment or an
    /// alias to the effective third-party audience segment. Third-party audience
    /// segment resource names containing `~direct` or `~global` will be normalized
    /// by the server. For example, `networks/1234/audienceSegments/4567~direct`
    /// will be normalized to `networks/1234/audienceSegments/4567`.
    #[prost(string, repeated, tag = "3")]
    pub audience_segments: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Represents targeting for CMS metadata. The values are ORed together.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CmsMetadataTargeting {
    /// Whether this expression is negatively targeted, meaning it matches
    /// ad requests that exclude the below values.
    #[prost(bool, optional, tag = "1")]
    pub negative: ::core::option::Option<bool>,
    /// Optional. The resource names of the targeted CMS metadata values.
    #[prost(string, repeated, tag = "3")]
    pub cms_metadata_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// User Domain Targeting
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UserDomainTargeting {
    /// Optional. A list of user domains that should be targeted/included.
    #[prost(string, repeated, tag = "1")]
    pub targeted_user_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. A list of user domains that should be excluded.
    #[prost(string, repeated, tag = "2")]
    pub excluded_user_domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Video Position Targeting
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VideoPositionTargeting {
    /// Optional. A list of video position targeting criterion (applied with a
    /// logical AND).
    #[prost(message, repeated, tag = "1")]
    pub video_positions: ::prost::alloc::vec::Vec<VideoPosition>,
}
/// Video Position Targeting Criterion
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VideoPosition {
    /// Optional. The index of the mid-roll to target. This field is ignored when
    /// targeting any video position (e.g. position_type) other than MIDROLL.
    #[prost(int64, optional, tag = "1")]
    pub midroll_index: ::core::option::Option<i64>,
    /// Optional. The index from the back of the pod of the mid-roll to target.
    /// This field is ignored when targeting any video position (e.g.
    /// position_type) other than MIDROLL or if targeting a specific midroll index
    /// (e.g. midroll_index != 0).
    #[prost(int64, optional, tag = "2")]
    pub reverse_midroll_index: ::core::option::Option<i64>,
    /// Optional. The video position within a pod to target. This field must be
    /// unset in order to target a specific video position (e.g. position_type),
    /// bumper type (e.g. bumper_type), or custom ad spot (e.g. custom_spot_id).
    #[prost(int64, optional, tag = "3")]
    pub pod_position: ::core::option::Option<i64>,
    /// Optional. The position within a video to target. A video ad can target a
    /// position (pre-roll, all mid-rolls, or post-roll) or a specific mid-roll
    /// index.
    #[prost(enumeration = "video_position_enum::VideoPosition", optional, tag = "5")]
    pub position_type: ::core::option::Option<i32>,
    /// Optional. The video bumper type to target. This field must be unset in
    /// order to target a specific video position (e.g. position_type), pod
    /// position (e.g. pod_position), or custom ad spot (e.g. custom_spot_id).
    #[prost(
        enumeration = "targeted_video_bumper_type_enum::TargetedVideoBumperType",
        optional,
        tag = "6"
    )]
    pub bumper_type: ::core::option::Option<i32>,
}
/// Data Segment Targeting
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DataSegmentTargeting {
    /// Output only. Whether any data segments are currently targeted.
    #[prost(bool, tag = "2")]
    pub has_data_segment_targeting: bool,
}
/// Content Targeting
///
/// Targeted/excluded content entities and bundles.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContentTargeting {
    /// Optional. The resource names of the
    /// \[Content\]\[google.ads.admanager.v1.Content\] that should be
    /// targeted/included.
    #[prost(string, repeated, tag = "5")]
    pub targeted_content: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The resource names of the
    /// \[Content\]\[google.ads.admanager.v1.Content\] that should be
    /// excluded.
    #[prost(string, repeated, tag = "6")]
    pub excluded_content: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The resource names of the
    /// \[ContentBundles\]\[google.ads.admanager.v1.ContentBundle\] that
    /// should be targeted/included.
    #[prost(string, repeated, tag = "7")]
    pub targeted_content_bundles: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. The resource names of the
    /// \[ContentBundles\]\[google.ads.admanager.v1.ContentBundle\] that
    /// should be excluded.
    #[prost(string, repeated, tag = "8")]
    pub excluded_content_bundles: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Mobile Application Targeting
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MobileApplicationTargeting {
    /// The mobile application targeting.
    #[prost(oneof = "mobile_application_targeting::Targeting", tags = "1")]
    pub targeting: ::core::option::Option<mobile_application_targeting::Targeting>,
}
/// Nested message and enum types in `MobileApplicationTargeting`.
pub mod mobile_application_targeting {
    /// The mobile application targeting.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Targeting {
        /// Optional. The targeted/excluded first-party mobile applications.
        #[prost(message, tag = "1")]
        FirstPartyTargeting(super::FirstPartyMobileApplicationTargeting),
    }
}
/// First-party mobile application targeting.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FirstPartyMobileApplicationTargeting {
    /// Optional. The resource names of the first-party applications that should be
    /// targeted.
    #[prost(string, repeated, tag = "3")]
    pub targeted_applications: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The resource names of the first-party applications that should be
    /// excluded.
    #[prost(string, repeated, tag = "4")]
    pub excluded_applications: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The `PrivateAuctionDeal` resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateAuctionDeal {
    /// Identifier. The resource name of the `PrivateAuctionDeal`.
    /// Format:
    /// `networks/{network_code}/privateAuctionDeals/{private_auction_deal_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `PrivateAuctionDeal` ID.
    #[prost(int64, optional, tag = "2")]
    pub private_auction_deal_id: ::core::option::Option<i64>,
    /// Immutable. The ID of the
    /// [PrivateAuction](google.ads.admanager.v1.PrivateAuction).
    #[prost(int64, optional, tag = "3")]
    pub private_auction_id: ::core::option::Option<i64>,
    /// Output only. The display name of the
    /// [PrivateAuction](google.ads.admanager.v1.PrivateAuction).
    #[prost(string, optional, tag = "20")]
    pub private_auction_display_name: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    /// Immutable. The account ID of the buyer of the `PrivateAuctionDeal`.
    #[prost(int64, optional, tag = "4")]
    pub buyer_account_id: ::core::option::Option<i64>,
    /// Output only. The external ID of the `PrivateAuctionDeal`.
    #[prost(int64, optional, tag = "5")]
    pub external_deal_id: ::core::option::Option<i64>,
    /// Optional. The targeting of the `PrivateAuctionDeal`.
    #[prost(message, optional, tag = "6")]
    pub targeting: ::core::option::Option<Targeting>,
    /// Optional. The end time of the `PrivateAuctionDeal`.
    #[prost(message, optional, tag = "8")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The floor price of the `PrivateAuctionDeal`.
    #[prost(message, optional, tag = "9")]
    pub floor_price: ::core::option::Option<super::super::super::r#type::Money>,
    /// Optional. The expected creative sizes of the `PrivateAuctionDeal`.
    #[prost(message, repeated, tag = "18")]
    pub creative_sizes: ::prost::alloc::vec::Vec<Size>,
    /// Output only. The status of the `PrivateAuctionDeal`.
    #[prost(
        enumeration = "private_marketplace_deal_status_enum::PrivateMarketplaceDealStatus",
        optional,
        tag = "10"
    )]
    pub status: ::core::option::Option<i32>,
    /// Optional. Whether the deal is enabled with priority over open auction.
    #[prost(bool, optional, tag = "11")]
    pub auction_priority_enabled: ::core::option::Option<bool>,
    /// Optional. Whether the deal has block override enabled.
    #[prost(bool, optional, tag = "12")]
    pub block_override_enabled: ::core::option::Option<bool>,
    /// Optional. The buyer permission model defining how the deal would transact
    /// among all buyers under the same bidder.
    #[prost(
        enumeration = "deal_buyer_permission_type_enum::DealBuyerPermissionType",
        optional,
        tag = "13"
    )]
    pub buyer_permission_type: ::core::option::Option<i32>,
    /// Optional. The buyer data required by the Marketplace API.
    #[prost(message, optional, tag = "14")]
    pub buyer_data: ::core::option::Option<private_auction_deal::BuyerData>,
    /// Output only. The instant at which the `PrivateAuctionDeal` was created.
    #[prost(message, optional, tag = "15")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The instant at which the `PrivateAuctionDeal` was last
    /// updated.
    #[prost(message, optional, tag = "16")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `PrivateAuctionDeal`.
pub mod private_auction_deal {
    /// Contains buyer data. This data is required by the Marketplace API.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct BuyerData {
        /// Optional. The email contacts of the buyer of the `PrivateAuctionDeal`.
        #[prost(string, repeated, tag = "1")]
        pub buyer_emails: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
/// Request object for `GetPrivateAuctionDeal` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPrivateAuctionDealRequest {
    /// Required. The resource name of the PrivateAuctionDeal.
    /// Format:
    /// `networks/{network_code}/privateAuctionDeals/{private_auction_deal_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListPrivateAuctionDeals` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPrivateAuctionDealsRequest {
    /// Required. The parent, which owns this collection of PrivateAuctionDeals.
    /// Format:
    /// `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `PrivateAuctionDeals` to return. The
    /// service may return fewer than this value. If unspecified, at most 50
    /// `PrivateAuctionDeals` will be returned. The maximum value is 1000;
    /// values greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListPrivateAuctionDeals`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateAuctionDeals` must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListPrivateAuctionDealsRequest` containing matching
/// `PrivateAuctionDeal` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateAuctionDealsResponse {
    /// The `PrivateAuctionDeal` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub private_auction_deals: ::prost::alloc::vec::Vec<PrivateAuctionDeal>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `PrivateAuctionDeal` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreatePrivateAuctionDeal` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePrivateAuctionDealRequest {
    /// Required. The parent resource where this `PrivateAuctionDeal` will be
    /// created. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `PrivateAuctionDeal` to create.
    #[prost(message, optional, tag = "2")]
    pub private_auction_deal: ::core::option::Option<PrivateAuctionDeal>,
}
/// Request object for `UpdatePrivateAuctionDeal` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePrivateAuctionDealRequest {
    /// Required. The `PrivateAuctionDeal` to update.
    ///
    /// The `PrivateAuctionDeal`'s `name` is used to identify the
    /// `PrivateAuctionDeal` to update.
    #[prost(message, optional, tag = "1")]
    pub private_auction_deal: ::core::option::Option<PrivateAuctionDeal>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod private_auction_deal_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `PrivateAuctionDeal` objects.
    #[derive(Debug, Clone)]
    pub struct PrivateAuctionDealServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PrivateAuctionDealServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PrivateAuctionDealServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PrivateAuctionDealServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PrivateAuctionDealServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `PrivateAuctionDeal` object.
        pub async fn get_private_auction_deal(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPrivateAuctionDealRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PrivateAuctionDeal>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionDealService/GetPrivateAuctionDeal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionDealService",
                        "GetPrivateAuctionDeal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `PrivateAuctionDeal` objects.
        pub async fn list_private_auction_deals(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPrivateAuctionDealsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPrivateAuctionDealsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionDealService/ListPrivateAuctionDeals",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionDealService",
                        "ListPrivateAuctionDeals",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `PrivateAuctionDeal` object.
        pub async fn create_private_auction_deal(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePrivateAuctionDealRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PrivateAuctionDeal>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionDealService/CreatePrivateAuctionDeal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionDealService",
                        "CreatePrivateAuctionDeal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `PrivateAuctionDeal` object.
        pub async fn update_private_auction_deal(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePrivateAuctionDealRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PrivateAuctionDeal>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionDealService/UpdatePrivateAuctionDeal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionDealService",
                        "UpdatePrivateAuctionDeal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The `PrivateAuction` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PrivateAuction {
    /// Identifier. The resource name of the `PrivateAuction`.
    /// Format:
    /// `networks/{network_code}/privateAuctions/{private_auction_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `PrivateAuction` ID.
    #[prost(int64, optional, tag = "2")]
    pub private_auction_id: ::core::option::Option<i64>,
    /// Required. Display name of the `PrivateAuction`. This attribute has a
    /// maximum length of 255 bytes.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. Description of the `PrivateAuction`. This attribute has a
    /// maximum length of 4096 bytes.
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The resource names of the seller contact users associated with
    /// this `PrivateAuction`. Format: `networks/{network_code}/users/{user_id}`
    #[prost(string, repeated, tag = "9")]
    pub seller_contact_users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Whether the `PrivateAuction` is archived.
    #[prost(bool, optional, tag = "6")]
    pub archived: ::core::option::Option<bool>,
    /// Output only. The instant at which the PrivateAuction was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The instant at which the PrivateAuction was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Request object for `GetPrivateAuction` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetPrivateAuctionRequest {
    /// Required. The resource name of the PrivateAuction.
    /// Format:
    /// `networks/{network_code}/privateAuctions/{private_auction_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListPrivateAuctions` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListPrivateAuctionsRequest {
    /// Required. The parent, which owns this collection of PrivateAuctions.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `PrivateAuctions` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `PrivateAuctions` will be returned. The maximum value is 1000;
    /// values greater than 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListPrivateAuctions`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListPrivateAuctions` must match the call that provided the
    /// page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListPrivateAuctionsRequest` containing
/// matching `PrivateAuction` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPrivateAuctionsResponse {
    /// The `PrivateAuction` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub private_auctions: ::prost::alloc::vec::Vec<PrivateAuction>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `PrivateAuction` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreatePrivateAuction` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreatePrivateAuctionRequest {
    /// Required. The parent resource where this `PrivateAuction` will be
    /// created. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `PrivateAuction` to create.
    #[prost(message, optional, tag = "2")]
    pub private_auction: ::core::option::Option<PrivateAuction>,
}
/// Request object for `UpdatePrivateAuction` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdatePrivateAuctionRequest {
    /// Required. The `PrivateAuction` to update.
    ///
    /// The `PrivateAuction`'s `name` is used to identify the
    /// `PrivateAuction` to update.
    #[prost(message, optional, tag = "1")]
    pub private_auction: ::core::option::Option<PrivateAuction>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Generated client implementations.
pub mod private_auction_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `PrivateAuction` objects.
    #[derive(Debug, Clone)]
    pub struct PrivateAuctionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl PrivateAuctionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> PrivateAuctionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PrivateAuctionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            PrivateAuctionServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `PrivateAuction` object.
        pub async fn get_private_auction(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPrivateAuctionRequest>,
        ) -> std::result::Result<tonic::Response<super::PrivateAuction>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionService/GetPrivateAuction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionService",
                        "GetPrivateAuction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `PrivateAuction` objects.
        pub async fn list_private_auctions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPrivateAuctionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPrivateAuctionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionService/ListPrivateAuctions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionService",
                        "ListPrivateAuctions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `PrivateAuction` object.
        pub async fn create_private_auction(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePrivateAuctionRequest>,
        ) -> std::result::Result<tonic::Response<super::PrivateAuction>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionService/CreatePrivateAuction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionService",
                        "CreatePrivateAuction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `PrivateAuction` object.
        pub async fn update_private_auction(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePrivateAuctionRequest>,
        ) -> std::result::Result<tonic::Response<super::PrivateAuction>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.PrivateAuctionService/UpdatePrivateAuction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.PrivateAuctionService",
                        "UpdatePrivateAuction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a programmatic buyer.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProgrammaticBuyer {
    /// Identifier. The resource name of the `ProgrammaticBuyer`.
    /// Format:
    /// `networks/{network_code}/programmaticBuyers/{buyer_account_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The buyer account ID of the buyer.
    #[prost(int64, optional, tag = "2")]
    pub buyer_account_id: ::core::option::Option<i64>,
    /// Output only. The display name of the buyer.
    #[prost(string, optional, tag = "5")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The ID of the programmatic buyer's sponsor. If the buyer has
    /// no sponsor, this field will be -1.
    #[prost(int64, optional, tag = "6")]
    pub parent_account_id: ::core::option::Option<i64>,
    /// Output only. ID of the Display & Video 360 client buyer partner ID (if
    /// Display & Video 360) or Authorized Buyers client buyer account ID.
    #[prost(string, optional, tag = "7")]
    pub partner_client_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether the buyer is an advertising agency.
    #[prost(bool, optional, tag = "9")]
    pub agency: ::core::option::Option<bool>,
    /// Output only. Whether the buyer is enabled for preferred deals.
    #[prost(bool, optional, tag = "12")]
    pub preferred_deals_enabled: ::core::option::Option<bool>,
    /// Output only. Whether the buyer is enabled for programmatic guaranteed
    /// deals.
    #[prost(bool, optional, tag = "13")]
    pub programmatic_guaranteed_enabled: ::core::option::Option<bool>,
}
/// Request object for `GetProgrammaticBuyer` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetProgrammaticBuyerRequest {
    /// Required. The resource name of the ProgrammaticBuyer.
    /// Format:
    /// `networks/{network_code}/programmaticBuyers/{buyer_account_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListProgrammaticBuyers` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListProgrammaticBuyersRequest {
    /// Required. The parent, which owns this collection of ProgrammaticBuyers.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `ProgrammaticBuyers` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `ProgrammaticBuyers` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListProgrammaticBuyers`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListProgrammaticBuyers`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListProgrammaticBuyersRequest` containing matching
/// `ProgrammaticBuyer` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProgrammaticBuyersResponse {
    /// The `ProgrammaticBuyer` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub programmatic_buyers: ::prost::alloc::vec::Vec<ProgrammaticBuyer>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `ProgrammaticBuyer` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod programmatic_buyer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `ProgrammaticBuyer` objects.
    #[derive(Debug, Clone)]
    pub struct ProgrammaticBuyerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ProgrammaticBuyerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ProgrammaticBuyerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProgrammaticBuyerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ProgrammaticBuyerServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `ProgrammaticBuyer` object.
        pub async fn get_programmatic_buyer(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProgrammaticBuyerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProgrammaticBuyer>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ProgrammaticBuyerService/GetProgrammaticBuyer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ProgrammaticBuyerService",
                        "GetProgrammaticBuyer",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `ProgrammaticBuyer` objects.
        pub async fn list_programmatic_buyers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProgrammaticBuyersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProgrammaticBuyersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ProgrammaticBuyerService/ListProgrammaticBuyers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ProgrammaticBuyerService",
                        "ListProgrammaticBuyers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a single value in a report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportValue {
    /// The value of the field, depends on the field's data format.
    #[prost(oneof = "report_value::Value", tags = "1, 2, 3, 4, 6, 7, 9, 8")]
    pub value: ::core::option::Option<report_value::Value>,
}
/// Nested message and enum types in `ReportValue`.
pub mod report_value {
    /// A list of integer values.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IntList {
        /// The values
        #[prost(int64, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<i64>,
    }
    /// A list of string values.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct StringList {
        /// The values
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// A list of double values.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DoubleList {
        /// The values
        #[prost(double, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<f64>,
    }
    /// The value of the field, depends on the field's data format.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// For integer values.
        #[prost(int64, tag = "1")]
        IntValue(i64),
        /// For double values.
        #[prost(double, tag = "2")]
        DoubleValue(f64),
        /// For string values.
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        /// For boolean values.
        #[prost(bool, tag = "4")]
        BoolValue(bool),
        /// For lists of integer values.
        #[prost(message, tag = "6")]
        IntListValue(IntList),
        /// For lists of string values.
        #[prost(message, tag = "7")]
        StringListValue(StringList),
        /// For lists of double values.
        #[prost(message, tag = "9")]
        DoubleListValue(DoubleList),
        /// For bytes values.
        #[prost(bytes, tag = "8")]
        BytesValue(::prost::alloc::vec::Vec<u8>),
    }
}
/// The definition of how a report should be run.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportDefinition {
    /// Required. The list of dimensions to report on. If empty, the report will
    /// have no dimensions, and any metrics will be totals.
    #[prost(
        enumeration = "report_definition::Dimension",
        repeated,
        packed = "false",
        tag = "1"
    )]
    pub dimensions: ::prost::alloc::vec::Vec<i32>,
    /// Required. The list of metrics to report on. If empty, the report will have
    /// no metrics.
    #[prost(
        enumeration = "report_definition::Metric",
        repeated,
        packed = "false",
        tag = "2"
    )]
    pub metrics: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The filters for this report.
    #[prost(message, repeated, tag = "3")]
    pub filters: ::prost::alloc::vec::Vec<report_definition::Filter>,
    /// Optional. Where to get the time zone for this report. Defaults to using the
    /// network time zone setting (PUBLISHER). If source is PROVIDED, the time_zone
    /// field in the report definition must also set a time zone.
    #[prost(enumeration = "report_definition::TimeZoneSource", tag = "20")]
    pub time_zone_source: i32,
    /// Optional. If time_zone_source is PROVIDED, this is the time zone to use for
    /// this report. Leave empty for any other time zone source. Time zone in IANA
    /// format. For example, "America/New_York".
    #[prost(string, tag = "4")]
    pub time_zone: ::prost::alloc::string::String,
    /// Optional. The ISO 4217 currency code for this report. Defaults to publisher
    /// currency code if not specified.
    #[prost(string, tag = "5")]
    pub currency_code: ::prost::alloc::string::String,
    /// Required. The primary date range of this report.
    #[prost(message, optional, tag = "6")]
    pub date_range: ::core::option::Option<report_definition::DateRange>,
    /// Optional. The comparison date range of this report. If unspecified, the
    /// report won't have any comparison metrics.
    #[prost(message, optional, tag = "9")]
    pub comparison_date_range: ::core::option::Option<report_definition::DateRange>,
    /// Optional. Custom Dimension keys that represent CUSTOM_DIMENSION\_\*
    /// dimensions. The index of this repeated field corresponds to the index on
    /// each dimension. For example, custom_dimension_key_ids\[0\] describes
    /// CUSTOM_DIMENSION_0_VALUE_ID and CUSTOM_DIMENSION_0_VALUE.
    #[prost(int64, repeated, packed = "false", tag = "7")]
    pub custom_dimension_key_ids: ::prost::alloc::vec::Vec<i64>,
    /// Optional. Custom field IDs that represent LINE_ITEM_CUSTOM_FIELD\_\*
    /// dimensions. The index of this repeated field corresponds to the index on
    /// each dimension. For example, line_item_custom_field_ids\[0\] describes
    /// LINE_ITEM_CUSTOM_FIELD_0_OPTION_ID and LINE_ITEM_CUSTOM_FIELD_0_VALUE.
    #[prost(int64, repeated, packed = "false", tag = "11")]
    pub line_item_custom_field_ids: ::prost::alloc::vec::Vec<i64>,
    /// Optional. Custom field IDs that represent ORDER_CUSTOM_FIELD\_\*
    /// dimensions. The index of this repeated field corresponds to the index on
    /// each dimension. For example, order_custom_field_ids\[0\] describes
    /// ORDER_CUSTOM_FIELD_0_OPTION_ID and ORDER_CUSTOM_FIELD_0_VALUE.
    #[prost(int64, repeated, packed = "false", tag = "12")]
    pub order_custom_field_ids: ::prost::alloc::vec::Vec<i64>,
    /// Optional. Custom field IDs that represent CREATIVE_CUSTOM_FIELD\_\*
    /// dimensions. The index of this repeated field corresponds to the index on
    /// each dimension. For example, creative_custom_field_ids\[0\] describes
    /// CREATIVE_CUSTOM_FIELD_0_OPTION_ID and CREATIVE_CUSTOM_FIELD_0_VALUE.
    #[prost(int64, repeated, packed = "false", tag = "13")]
    pub creative_custom_field_ids: ::prost::alloc::vec::Vec<i64>,
    /// Required. The type of this report.
    #[prost(enumeration = "report_definition::ReportType", tag = "8")]
    pub report_type: i32,
    /// Optional. Include a time period column to introduce comparison columns in
    /// the report for each generated period. For example, set to  "QUARTERS" here
    /// to have a column for each quarter present in the primary date range. If
    /// "PREVIOUS PERIOD" is specified in comparison_date_range, then each quarter
    /// column will also include comparison values for its relative previous
    /// quarter.
    #[prost(enumeration = "report_definition::TimePeriodColumn", tag = "10")]
    pub time_period_column: i32,
    /// Optional. List of flags for this report. Used to flag rows in a result set
    /// based on a set of defined filters.
    #[prost(message, repeated, tag = "14")]
    pub flags: ::prost::alloc::vec::Vec<report_definition::Flag>,
    /// Optional. Default sorts to apply to this report.
    #[prost(message, repeated, tag = "15")]
    pub sorts: ::prost::alloc::vec::Vec<report_definition::Sort>,
}
/// Nested message and enum types in `ReportDefinition`.
pub mod report_definition {
    /// A dimension or a metric in a report.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Field {
        /// Either a dimension or a metric.
        #[prost(oneof = "field::Field", tags = "1, 2")]
        pub field: ::core::option::Option<field::Field>,
    }
    /// Nested message and enum types in `Field`.
    pub mod field {
        /// Either a dimension or a metric.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Field {
            /// The dimension this field represents.
            #[prost(enumeration = "super::Dimension", tag = "1")]
            Dimension(i32),
            /// The metric this field represents.
            #[prost(enumeration = "super::Metric", tag = "2")]
            Metric(i32),
        }
    }
    /// A date range for a report.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct DateRange {
        /// Either a fixed or relative date range.
        #[prost(oneof = "date_range::DateRangeType", tags = "1, 2")]
        pub date_range_type: ::core::option::Option<date_range::DateRangeType>,
    }
    /// Nested message and enum types in `DateRange`.
    pub mod date_range {
        /// A date range between two fixed dates (inclusive of end date).
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct FixedDateRange {
            /// Required. The start date of this date range.
            #[prost(message, optional, tag = "1")]
            pub start_date: ::core::option::Option<
                super::super::super::super::super::r#type::Date,
            >,
            /// Required. The end date (inclusive) of this date range.
            #[prost(message, optional, tag = "2")]
            pub end_date: ::core::option::Option<
                super::super::super::super::super::r#type::Date,
            >,
        }
        /// Options for relative date ranges.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum RelativeDateRange {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// The date the report is run.
            Today = 1,
            /// The date a day before the date that the report is run.
            Yesterday = 2,
            /// The full week in which this report is run. Could include dates in
            /// the future.
            ThisWeek = 3,
            /// From the beginning of the calendar week (Monday to Sunday) in which the
            /// up to and including the day the report is run.
            ThisWeekToDate = 29,
            /// The full month in which this report is run. Could include dates in
            /// the future.
            ThisMonth = 4,
            /// From the beginning of the calendar month in which the report is run, to
            /// up to and including the day the report is run.
            ThisMonthToDate = 26,
            /// The full quarter in which this report is run. Could include dates
            /// in the future.
            ThisQuarter = 5,
            /// From the beginning of the calendar quarter in which the report is run,
            /// up to and including the day the report is run.
            ThisQuarterToDate = 27,
            /// The full year in which this report is run. Could include dates in
            /// the future.
            ThisYear = 6,
            /// From the beginning of the calendar year in which the report is run, to
            /// up to and including the day the report is run.
            ThisYearToDate = 28,
            /// The entire previous calendar week, Monday to Sunday (inclusive),
            /// preceding the calendar week the report is run.
            LastWeek = 7,
            /// The entire previous calendar week, Sunday to Saturday (inclusive),
            /// preceding the calendar week the report is run.
            LastWeekStartingSunday = 39,
            /// The entire previous calendar month preceding the calendar month the
            /// report is run.
            LastMonth = 8,
            /// The entire previous calendar quarter preceding the calendar quarter the
            /// report is run.
            LastQuarter = 9,
            /// The entire previous calendar year preceding the calendar year the
            /// report is run.
            LastYear = 10,
            /// The 7 days preceding the day the report is run.
            Last7Days = 11,
            /// The 30 days preceding the day the report is run.
            Last30Days = 12,
            /// The 60 days preceding the day the report is run.
            Last60Days = 13,
            /// The 90 days preceding the day the report is run.
            Last90Days = 14,
            /// The 93 days preceding the day the report is run.
            Last93Days = 38,
            /// The 180 days preceding the day the report is run.
            Last180Days = 15,
            /// The 360 days preceding the day the report is run.
            Last360Days = 16,
            /// The 365 days preceding the day the report is run.
            Last365Days = 17,
            /// The entire previous 3 calendar months preceding the calendar month the
            /// report is run.
            Last3Months = 18,
            /// The entire previous 6 calendar months preceding the calendar month the
            /// report is run.
            Last6Months = 19,
            /// The entire previous 6 calendar months preceding the calendar month the
            /// report is run.
            Last12Months = 20,
            /// From 3 years before the report is run, to the day before the report is
            /// run, inclusive.
            AllAvailable = 21,
            /// The date a day after the date that the report is run.
            Tomorrow = 30,
            /// The 90 days following the day the report is run.
            Next90Days = 31,
            /// The entire calendar month following the calendar month the report is
            /// run.
            NextMonth = 32,
            /// The entire 3 calendar months following the calendar month the report
            /// is run.
            Next3Months = 33,
            /// The entire 12 calendar months following the calendar month the report
            /// is run.
            Next12Months = 34,
            /// The entire calendar week, Monday to Sunday (inclusive), following the
            /// calendar week the report is run.
            NextWeek = 35,
            /// The entire calendar quarter following the calendar quarter the report
            /// is run.
            NextQuarter = 36,
            /// From the date a day after the date that the report is run, to the end
            /// of the calendar month following the calendar month the report is run.
            ToEndOfNextMonth = 37,
            /// Only valid when used in the comparison_date_range field. The complete
            /// period preceding the date period provided in date_range.
            ///
            /// In the case where date_range is a FixedDateRange of N days, this will
            /// be a period of N days where the end date is the date preceding the
            /// start date of the date_range.
            ///
            /// In the case where date_range is a RelativeDateRange, this will be a
            /// period of the same timeframe preceding the date_range. In the case
            /// where the date_range does not capture the full period because a report
            /// is run in the middle of that period, this will still be the full
            /// preceding period. For example, if date_range is THIS_WEEK, but the
            /// report is run on a Wednesday, THIS_WEEK will be Monday - Wednesday, but
            /// PREVIOUS_PERIOD will be Monday - Sunday.
            PreviousPeriod = 22,
            /// Only valid when used in the comparison_date_range field. The period
            /// starting 1 year prior to the date period provided in date_range.
            ///
            /// In the case where date_range is a FixedDateRange, this will be a date
            /// range starting 1 year prior to the date_range start date and ending 1
            /// year prior to the date_range end date.
            ///
            /// In the case where date_range is a RelativeDateRange, this will be a
            /// period of the same timeframe exactly 1 year prior to the date_range.
            /// In the case where the date_range does not capture the full period
            /// because a report is run in the middle of that period, this will still
            /// be the full period 1 year prior. For example, if date range is
            /// THIS_WEEK, but the report is run on a Wednesday, THIS_WEEK will be
            /// Monday - Wednesday, but SAME_PERIOD_PREVIOUS_YEAR will be Monday -
            /// Sunday.
            SamePeriodPreviousYear = 24,
        }
        impl RelativeDateRange {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "RELATIVE_DATE_RANGE_UNSPECIFIED",
                    Self::Today => "TODAY",
                    Self::Yesterday => "YESTERDAY",
                    Self::ThisWeek => "THIS_WEEK",
                    Self::ThisWeekToDate => "THIS_WEEK_TO_DATE",
                    Self::ThisMonth => "THIS_MONTH",
                    Self::ThisMonthToDate => "THIS_MONTH_TO_DATE",
                    Self::ThisQuarter => "THIS_QUARTER",
                    Self::ThisQuarterToDate => "THIS_QUARTER_TO_DATE",
                    Self::ThisYear => "THIS_YEAR",
                    Self::ThisYearToDate => "THIS_YEAR_TO_DATE",
                    Self::LastWeek => "LAST_WEEK",
                    Self::LastWeekStartingSunday => "LAST_WEEK_STARTING_SUNDAY",
                    Self::LastMonth => "LAST_MONTH",
                    Self::LastQuarter => "LAST_QUARTER",
                    Self::LastYear => "LAST_YEAR",
                    Self::Last7Days => "LAST_7_DAYS",
                    Self::Last30Days => "LAST_30_DAYS",
                    Self::Last60Days => "LAST_60_DAYS",
                    Self::Last90Days => "LAST_90_DAYS",
                    Self::Last93Days => "LAST_93_DAYS",
                    Self::Last180Days => "LAST_180_DAYS",
                    Self::Last360Days => "LAST_360_DAYS",
                    Self::Last365Days => "LAST_365_DAYS",
                    Self::Last3Months => "LAST_3_MONTHS",
                    Self::Last6Months => "LAST_6_MONTHS",
                    Self::Last12Months => "LAST_12_MONTHS",
                    Self::AllAvailable => "ALL_AVAILABLE",
                    Self::Tomorrow => "TOMORROW",
                    Self::Next90Days => "NEXT_90_DAYS",
                    Self::NextMonth => "NEXT_MONTH",
                    Self::Next3Months => "NEXT_3_MONTHS",
                    Self::Next12Months => "NEXT_12_MONTHS",
                    Self::NextWeek => "NEXT_WEEK",
                    Self::NextQuarter => "NEXT_QUARTER",
                    Self::ToEndOfNextMonth => "TO_END_OF_NEXT_MONTH",
                    Self::PreviousPeriod => "PREVIOUS_PERIOD",
                    Self::SamePeriodPreviousYear => "SAME_PERIOD_PREVIOUS_YEAR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "RELATIVE_DATE_RANGE_UNSPECIFIED" => Some(Self::Unspecified),
                    "TODAY" => Some(Self::Today),
                    "YESTERDAY" => Some(Self::Yesterday),
                    "THIS_WEEK" => Some(Self::ThisWeek),
                    "THIS_WEEK_TO_DATE" => Some(Self::ThisWeekToDate),
                    "THIS_MONTH" => Some(Self::ThisMonth),
                    "THIS_MONTH_TO_DATE" => Some(Self::ThisMonthToDate),
                    "THIS_QUARTER" => Some(Self::ThisQuarter),
                    "THIS_QUARTER_TO_DATE" => Some(Self::ThisQuarterToDate),
                    "THIS_YEAR" => Some(Self::ThisYear),
                    "THIS_YEAR_TO_DATE" => Some(Self::ThisYearToDate),
                    "LAST_WEEK" => Some(Self::LastWeek),
                    "LAST_WEEK_STARTING_SUNDAY" => Some(Self::LastWeekStartingSunday),
                    "LAST_MONTH" => Some(Self::LastMonth),
                    "LAST_QUARTER" => Some(Self::LastQuarter),
                    "LAST_YEAR" => Some(Self::LastYear),
                    "LAST_7_DAYS" => Some(Self::Last7Days),
                    "LAST_30_DAYS" => Some(Self::Last30Days),
                    "LAST_60_DAYS" => Some(Self::Last60Days),
                    "LAST_90_DAYS" => Some(Self::Last90Days),
                    "LAST_93_DAYS" => Some(Self::Last93Days),
                    "LAST_180_DAYS" => Some(Self::Last180Days),
                    "LAST_360_DAYS" => Some(Self::Last360Days),
                    "LAST_365_DAYS" => Some(Self::Last365Days),
                    "LAST_3_MONTHS" => Some(Self::Last3Months),
                    "LAST_6_MONTHS" => Some(Self::Last6Months),
                    "LAST_12_MONTHS" => Some(Self::Last12Months),
                    "ALL_AVAILABLE" => Some(Self::AllAvailable),
                    "TOMORROW" => Some(Self::Tomorrow),
                    "NEXT_90_DAYS" => Some(Self::Next90Days),
                    "NEXT_MONTH" => Some(Self::NextMonth),
                    "NEXT_3_MONTHS" => Some(Self::Next3Months),
                    "NEXT_12_MONTHS" => Some(Self::Next12Months),
                    "NEXT_WEEK" => Some(Self::NextWeek),
                    "NEXT_QUARTER" => Some(Self::NextQuarter),
                    "TO_END_OF_NEXT_MONTH" => Some(Self::ToEndOfNextMonth),
                    "PREVIOUS_PERIOD" => Some(Self::PreviousPeriod),
                    "SAME_PERIOD_PREVIOUS_YEAR" => Some(Self::SamePeriodPreviousYear),
                    _ => None,
                }
            }
        }
        /// Either a fixed or relative date range.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum DateRangeType {
            /// A fixed date range.
            #[prost(message, tag = "1")]
            Fixed(FixedDateRange),
            /// A relative date range.
            #[prost(enumeration = "RelativeDateRange", tag = "2")]
            Relative(i32),
        }
    }
    /// A filter over one or more fields.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Filter {
        /// The type determines how the underlying filters are combined.
        #[prost(oneof = "filter::Type", tags = "1, 2, 3, 4")]
        pub r#type: ::core::option::Option<filter::Type>,
    }
    /// Nested message and enum types in `Filter`.
    pub mod filter {
        /// A filter on a specific field.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FieldFilter {
            /// Required. The field to filter on.
            #[prost(message, optional, tag = "1")]
            pub field: ::core::option::Option<super::Field>,
            /// Required. The operation of this filter.
            #[prost(enumeration = "Operation", tag = "2")]
            pub operation: i32,
            /// Required. Values to filter to.
            #[prost(message, repeated, tag = "3")]
            pub values: ::prost::alloc::vec::Vec<super::super::ReportValue>,
            /// Optional. Use to filter on a specific slice of data.
            #[prost(message, optional, tag = "4")]
            pub slice: ::core::option::Option<super::Slice>,
            /// Optional. When using time period columns, use this to filter on a
            /// specific column.
            #[prost(int32, optional, tag = "5")]
            pub time_period_index: ::core::option::Option<i32>,
            /// Optional. Use to specify which metric value type to filter on. Defaults
            /// to PRIMARY.
            #[prost(enumeration = "super::MetricValueType", optional, tag = "6")]
            pub metric_value_type: ::core::option::Option<i32>,
        }
        /// A list of filters.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct FilterList {
            /// Required. A list of filters.
            #[prost(message, repeated, tag = "1")]
            pub filters: ::prost::alloc::vec::Vec<super::Filter>,
        }
        /// Supported filter operations.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operation {
            /// For scalar operands, checks if the operand is in the set of provided
            /// filter values.
            ///
            /// For list operands, checks if any element in the operand is in the set
            /// of provided filter values.
            ///
            /// Default value.
            In = 0,
            /// For scalar operands, checks that the operand is not in the set of
            /// provided filter values.
            ///
            /// For list operands, checks that none of the elements in the operand
            /// is in the set of provided filter values.
            NotIn = 1,
            /// For scalar string operands, checks if the operand contains any of the
            /// provided filter substrings.
            ///
            /// For string list operands, checks if any string in the operand contains
            /// any of the provided filter substrings.
            Contains = 2,
            /// For scalar string operands, checks that the operand contains none of
            /// the provided filter substrings.
            ///
            /// For string list operands, checks that none of the strings in the
            /// operand contain none of the provided filter substrings.
            NotContains = 3,
            /// Operand is less than the provided filter value.
            LessThan = 4,
            /// Operand is less than or equal to provided filter value.
            LessThanEquals = 5,
            /// Operand is greater than provided filter value.
            GreaterThan = 6,
            /// Operand is greater than or equal to provided filter value.
            GreaterThanEquals = 7,
            /// Operand is between provided filter values.
            Between = 8,
            /// Operand matches against a regular expression or set of regular
            /// expressions (one must match).
            Matches = 9,
            /// Operand negative matches against a regular expression or set of regular
            /// expressions (none must match).
            NotMatches = 10,
        }
        impl Operation {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::In => "IN",
                    Self::NotIn => "NOT_IN",
                    Self::Contains => "CONTAINS",
                    Self::NotContains => "NOT_CONTAINS",
                    Self::LessThan => "LESS_THAN",
                    Self::LessThanEquals => "LESS_THAN_EQUALS",
                    Self::GreaterThan => "GREATER_THAN",
                    Self::GreaterThanEquals => "GREATER_THAN_EQUALS",
                    Self::Between => "BETWEEN",
                    Self::Matches => "MATCHES",
                    Self::NotMatches => "NOT_MATCHES",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "IN" => Some(Self::In),
                    "NOT_IN" => Some(Self::NotIn),
                    "CONTAINS" => Some(Self::Contains),
                    "NOT_CONTAINS" => Some(Self::NotContains),
                    "LESS_THAN" => Some(Self::LessThan),
                    "LESS_THAN_EQUALS" => Some(Self::LessThanEquals),
                    "GREATER_THAN" => Some(Self::GreaterThan),
                    "GREATER_THAN_EQUALS" => Some(Self::GreaterThanEquals),
                    "BETWEEN" => Some(Self::Between),
                    "MATCHES" => Some(Self::Matches),
                    "NOT_MATCHES" => Some(Self::NotMatches),
                    _ => None,
                }
            }
        }
        /// The type determines how the underlying filters are combined.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Type {
            /// A filter on a single field.
            #[prost(message, tag = "1")]
            FieldFilter(FieldFilter),
            /// A filter whose result is negated.
            #[prost(message, tag = "2")]
            NotFilter(::prost::alloc::boxed::Box<super::Filter>),
            /// A list of filters whose results are AND-ed.
            #[prost(message, tag = "3")]
            AndFilter(FilterList),
            /// A list of filters whose results are OR-ed.
            #[prost(message, tag = "4")]
            OrFilter(FilterList),
        }
    }
    /// Represents a sorting in a report.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sort {
        /// Required. A field (dimension or metric) to sort by.
        #[prost(message, optional, tag = "1")]
        pub field: ::core::option::Option<Field>,
        /// Optional. The sort order. If true the sort will be descending.
        #[prost(bool, tag = "2")]
        pub descending: bool,
        /// Optional. Use to sort on a specific slice of data.
        #[prost(message, optional, tag = "3")]
        pub slice: ::core::option::Option<Slice>,
        /// Optional. When using time period columns, use this to sort on a specific
        /// column.
        #[prost(int32, optional, tag = "4")]
        pub time_period_index: ::core::option::Option<i32>,
        /// Optional. Use to specify which metric value type to sort on. Defaults to
        /// PRIMARY.
        #[prost(enumeration = "MetricValueType", optional, tag = "5")]
        pub metric_value_type: ::core::option::Option<i32>,
    }
    /// Use to specify a slice of data.
    ///
    /// For example, in a report, to focus on just data from the US, specify
    /// `COUNTRY_NAME` for dimension and value: `"United States"`.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Slice {
        /// Required. The dimension to slice on.
        #[prost(enumeration = "Dimension", tag = "1")]
        pub dimension: i32,
        /// Required. The value of the dimension.
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<super::ReportValue>,
    }
    /// A flag for a report. Flags are used show if certain thresholds are met.
    /// Result rows that match the filter will have the corresponding
    /// \[MetricValueGroup.flagValues\]\[MetricValueGroup\] index set to true.
    /// For more information about flags see:
    /// <https://support.google.com/admanager/answer/15079975>
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Flag {
        /// Required. Filters to apply for the flag.
        #[prost(message, repeated, tag = "1")]
        pub filters: ::prost::alloc::vec::Vec<Filter>,
        /// Optional. Name of the flag.
        /// The flag names RED, YELLOW, GREEN, BLUE, PURPLE, and GREY correspond to
        /// the colored flags that appear in the UI. The UI won't display flags
        /// with other names, but they are available for use by API clients.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
    /// Supported report types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReportType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Historical.
        Historical = 1,
        /// Reach.
        Reach = 5,
        /// Privacy and messaging.
        PrivacyAndMessaging = 6,
        /// Gross revenue.
        RevenueVerification = 7,
        /// Partner finance.
        PartnerFinance = 8,
        /// Ad speed.
        AdSpeed = 13,
    }
    impl ReportType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REPORT_TYPE_UNSPECIFIED",
                Self::Historical => "HISTORICAL",
                Self::Reach => "REACH",
                Self::PrivacyAndMessaging => "PRIVACY_AND_MESSAGING",
                Self::RevenueVerification => "REVENUE_VERIFICATION",
                Self::PartnerFinance => "PARTNER_FINANCE",
                Self::AdSpeed => "AD_SPEED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPORT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "HISTORICAL" => Some(Self::Historical),
                "REACH" => Some(Self::Reach),
                "PRIVACY_AND_MESSAGING" => Some(Self::PrivacyAndMessaging),
                "REVENUE_VERIFICATION" => Some(Self::RevenueVerification),
                "PARTNER_FINANCE" => Some(Self::PartnerFinance),
                "AD_SPEED" => Some(Self::AdSpeed),
                _ => None,
            }
        }
    }
    /// Reporting dimensions.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Dimension {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The measurement source of a video ad.
        ///
        /// Corresponds to "Active View measurement source value" in the Ad Manager
        /// UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        ActiveViewMeasurementSource = 575,
        /// Active View measurement source localized name.
        ///
        /// Corresponds to "Active View measurement source" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ActiveViewMeasurementSourceName = 576,
        /// Advertiser credit status ENUM
        ///
        /// Corresponds to "Advertiser credit status value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `ENUM`
        AdvertiserCreditStatus = 475,
        /// Advertiser credit status localized name
        ///
        /// Corresponds to "Advertiser credit status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdvertiserCreditStatusName = 476,
        /// The domain name of the advertiser.
        ///
        /// Corresponds to "Advertiser domain" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdvertiserDomainName = 242,
        /// The ID used in an external system for advertiser identification
        ///
        /// Corresponds to "Advertiser external ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        AdvertiserExternalId = 228,
        /// The ID of an advertiser company assigned to an order
        ///
        /// Corresponds to "Advertiser ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdvertiserId = 131,
        /// Labels applied to the advertiser
        /// can be used for either competitive exclusion or ad exclusion
        ///
        /// Corresponds to "Advertiser labels" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        AdvertiserLabels = 230,
        /// Label ids applied to the advertiser
        /// can be used for either competitive exclusion or ad exclusion
        ///
        /// Corresponds to "Advertiser label IDs" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        AdvertiserLabelIds = 229,
        /// The name of an advertiser company assigned to an order
        ///
        /// Corresponds to "Advertiser" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdvertiserName = 132,
        /// The name of the contact associated with an advertiser company
        ///
        /// Corresponds to "Advertiser primary contact" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        AdvertiserPrimaryContact = 227,
        /// Advertiser status ENUM
        ///
        /// Corresponds to "Advertiser status value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AdvertiserStatus = 471,
        /// Advertiser status localized name
        ///
        /// Corresponds to "Advertiser status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdvertiserStatusName = 472,
        /// Advertiser type ENUM
        ///
        /// Corresponds to "Advertiser type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `ENUM`
        AdvertiserType = 473,
        /// Advertiser type localized name
        ///
        /// Corresponds to "Advertiser type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdvertiserTypeName = 474,
        /// The category of an advertiser, such as Arts & Entertainment or Travel &
        /// Tourism.
        ///
        /// Corresponds to "Advertiser vertical" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdvertiserVertical = 580,
        /// Classification of different Ad Exchange products.
        ///
        /// Corresponds to "Ad Exchange product value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `ENUM`
        AdxProduct = 499,
        /// Localized name of the classification of different Ad Exchange
        /// products.
        ///
        /// Corresponds to "Ad Exchange product" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `STRING`
        AdxProductName = 500,
        /// Ad experiences type.
        ///
        /// Corresponds to "Ad experiences value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AdExperiencesType = 641,
        /// Localized name of the Ad experiences type.
        ///
        /// Corresponds to "Ad experiences" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdExperiencesTypeName = 642,
        /// Shows an ENUM value describing whether a given piece of publisher
        /// inventory was above (ATF) or below the fold (BTF) of a page.
        ///
        /// Corresponds to "Ad location value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AdLocation = 390,
        /// Shows a localized string describing whether a given piece of publisher
        /// inventory was above (ATF) or below the fold (BTF) of a page.
        ///
        /// Corresponds to "Ad location" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdLocationName = 391,
        /// Multi-size inventory in an ad request.
        ///
        /// Corresponds to "Ad request sizes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING_LIST`
        AdRequestSizes = 541,
        /// The domain of the ad technology provider associated with the bid.
        ///
        /// Corresponds to "Ad technology provider domain" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdTechnologyProviderDomain = 620,
        /// The ID of the ad technology provider associated with the bid.
        ///
        /// Corresponds to "Ad technology provider ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AdTechnologyProviderId = 621,
        /// The name of the ad technology provider associated with the bid.
        ///
        /// Corresponds to "Ad technology provider" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdTechnologyProviderName = 622,
        /// Segmentation of ad types.
        ///
        /// Corresponds to "Ad type value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AdType = 497,
        /// Localized name of the ad type.
        ///
        /// Corresponds to "Ad type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AdTypeName = 498,
        /// The code of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `STRING`
        AdUnitCode = 64,
        /// The code of the first level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 1" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel1 = 65,
        /// The code of the tenth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 10" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel10 = 74,
        /// The code of the eleventh level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 11" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel11 = 75,
        /// The code of the twelfth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 12" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel12 = 76,
        /// The code of the thirteenth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 13" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel13 = 77,
        /// The code of the fourteenth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 14" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel14 = 78,
        /// The code of the fifteenth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 15" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel15 = 79,
        /// The code of the sixteenth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 16" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel16 = 80,
        /// The code of the second level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 2" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel2 = 66,
        /// The code of the third level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 3" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel3 = 67,
        /// The code of the fourth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 4" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel4 = 68,
        /// The code of the fifth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 5" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel5 = 69,
        /// The code of the sixth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 6" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel6 = 70,
        /// The code of the seventh level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 7" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel7 = 71,
        /// The code of the eighth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 8" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel8 = 72,
        /// The code of the ninth level ad unit of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit code level 9" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitCodeLevel9 = 73,
        /// The ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitId = 25,
        /// The full hierarchy of ad unit IDs where the ad was requested, from
        /// root to leaf, excluding the root ad unit ID.
        ///
        /// Corresponds to "Ad unit ID (all levels)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        AdUnitIdAllLevel = 27,
        /// The first level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 1" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel1 = 30,
        /// The tenth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 10" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel10 = 48,
        /// The eleventh level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 11" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel11 = 50,
        /// The twelfth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 12" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel12 = 52,
        /// The thirteenth level ad unit ID of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit ID level 13" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel13 = 54,
        /// The fourteenth level ad unit ID of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit ID level 14" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel14 = 56,
        /// The fifteenth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 15" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel15 = 58,
        /// The sixteenth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 16" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel16 = 60,
        /// The second level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 2" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel2 = 32,
        /// The third level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 3" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel3 = 34,
        /// The fourth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 4" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel4 = 36,
        /// The fifth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 5" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel5 = 38,
        /// The sixth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 6" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel6 = 40,
        /// The seventh level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 7" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel7 = 42,
        /// The eighth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 8" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel8 = 44,
        /// The ninth level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID level 9" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdLevel9 = 46,
        /// The top-level ad unit ID of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit ID (top level)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        AdUnitIdTopLevel = 142,
        /// The name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `STRING`
        AdUnitName = 26,
        /// The full hierarchy of ad unit names where the ad was requested, from
        /// root to leaf, excluding the root ad unit name.
        ///
        /// Corresponds to "Ad unit (all levels)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `STRING_LIST`
        AdUnitNameAllLevel = 29,
        /// The first level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 1" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel1 = 31,
        /// The tenth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 10" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel10 = 49,
        /// The eleventh level ad unit name of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit level 11" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel11 = 51,
        /// The twelfth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 12" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel12 = 53,
        /// The thirteenth level ad unit name of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit level 13" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel13 = 55,
        /// The fourteenth level ad unit name of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit level 14" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel14 = 57,
        /// The fifteenth level ad unit name of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit level 15" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel15 = 59,
        /// The sixteenth level ad unit name of the ad unit where the ad was
        /// requested.
        ///
        /// Corresponds to "Ad unit level 16" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel16 = 61,
        /// The second level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 2" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel2 = 33,
        /// The third level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 3" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel3 = 35,
        /// The fourth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 4" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel4 = 37,
        /// The fifth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 5" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel5 = 39,
        /// The sixth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 6" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel6 = 41,
        /// The seventh level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 7" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel7 = 43,
        /// The eighth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 8" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel8 = 45,
        /// The ninth level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit level 9" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameLevel9 = 47,
        /// The top-level ad unit name of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit (top level)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitNameTopLevel = 143,
        /// The reward amount of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit reward amount" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `INTEGER`
        AdUnitRewardAmount = 63,
        /// The reward type of the ad unit where the ad was requested.
        ///
        /// Corresponds to "Ad unit reward type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`,
        /// `REACH`
        ///
        /// Data format: `STRING`
        AdUnitRewardType = 62,
        /// The status of the ad unit
        ///
        /// Corresponds to "Ad unit status value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `ENUM`
        AdUnitStatus = 206,
        /// The name of the status of the ad unit
        ///
        /// Corresponds to "Ad unit status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        AdUnitStatusName = 207,
        /// The ID of an agency at level 1 of agency hierarchy.
        ///
        /// Corresponds to "Agency ID (Level 1)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AgencyLevel1Id = 565,
        /// The name of an agency at level 1 of agency hierarchy.
        ///
        /// Corresponds to "Agency (Level 1)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AgencyLevel1Name = 566,
        /// The ID of an agency at level 2 of agency hierarchy.
        ///
        /// Corresponds to "Agency ID (Level 2)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AgencyLevel2Id = 567,
        /// The name of an agency at level 2 of agency hierarchy.
        ///
        /// Corresponds to "Agency (Level 2)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AgencyLevel2Name = 568,
        /// The ID of an agency at level 3 of agency hierarchy.
        ///
        /// Corresponds to "Agency ID (Level 3)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AgencyLevel3Id = 569,
        /// The name of an agency at level 3 of agency hierarchy.
        ///
        /// Corresponds to "Agency (Level 3)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AgencyLevel3Name = 570,
        /// User age bracket enum.
        ///
        /// Corresponds to "Age bracket value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AgeBracket = 508,
        /// Localized user age bracket returned from Google Analytics. For example,
        /// "18-24", "25-34", "35-44", "45-54", "55-64", "65+".
        ///
        /// Corresponds to "Age bracket" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AgeBracketName = 582,
        /// Property ID in Google Analytics
        ///
        /// Corresponds to "Analytics property ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AnalyticsPropertyId = 733,
        /// Property name in Google Analytics
        ///
        /// Corresponds to "Analytics property" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AnalyticsPropertyName = 767,
        /// Enum value for App Tracking Transparency consent status.
        ///
        /// Corresponds to "App Tracking Transparency consent status value" in the Ad
        /// Manager UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AppTrackingTransparencyConsentStatus = 442,
        /// Localized string value for App Tracking Transparency consent status.
        ///
        /// Corresponds to "App Tracking Transparency consent status" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AppTrackingTransparencyConsentStatusName = 443,
        /// The app version.
        ///
        /// Corresponds to "App version" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AppVersion = 392,
        /// The name of Auction Package deal
        ///
        /// Corresponds to "Auction package deal" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AuctionPackageDeal = 579,
        /// The ID of Auction Package deal
        ///
        /// Corresponds to "Auction package deal ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AuctionPackageDealId = 571,
        /// Name of billable audience segment.
        ///
        /// Corresponds to "Audience segment (billable)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AudienceSegmentBillable = 594,
        /// ID of the data provider for the audience segment.
        ///
        /// Corresponds to "Audience segment data provider ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AudienceSegmentDataProviderId = 613,
        /// Name of the data provider for the audience segment.
        ///
        /// Corresponds to "Audience segment data provider" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AudienceSegmentDataProviderName = 614,
        /// ID of billable audience segment.
        ///
        /// Corresponds to "Audience segment ID (billable)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AudienceSegmentIdBillable = 595,
        /// ID of targeted audience segment, including all first-party and
        /// third-party segments that matched the user on the winning line item.
        ///
        /// Corresponds to "Audience segment ID (targeted)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        AudienceSegmentIdTargeted = 584,
        /// Name of targeted audience segment, including all first-party and
        /// third-party segments that matched the user on the winning line item.
        ///
        /// Corresponds to "Audience segment (targeted)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AudienceSegmentTargeted = 585,
        /// Number of AdID identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) AdID size" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedAdIdUserSize = 605,
        /// Number of Amazon Fire identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) Amazon Fire size" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedAmazonFireUserSize = 606,
        /// Number of Android TV identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) Android TV size" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedAndroidTvUserSize = 607,
        /// Number of Apple TV identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) Apple TV size" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedAppleTvUserSize = 608,
        /// Number of IDFA identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) IDFA size" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedIdfaUserSize = 609,
        /// Number of mobile web identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) mobile web size" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedMobileWebUserSize = 610,
        /// Number of PlayStation identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) PlayStation size" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedPlaystationUserSize = 611,
        /// Number of PPID identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) PPID size" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedPpidUserSize = 612,
        /// Number of Roku identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) Roku size" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedRokuUserSize = 615,
        /// Number of Samsung TV identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) Samsung TV size" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedSamsungTvUserSize = 616,
        /// Number of identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) size" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedSize = 618,
        /// Status of the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) status value" in the Ad
        /// Manager UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AudienceSegmentTargetedStatus = 628,
        /// Name of the status of the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AudienceSegmentTargetedStatusName = 617,
        /// Number of Xbox identifiers in the audience segment.
        ///
        /// Corresponds to "Audience segment (targeted) Xbox size" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AudienceSegmentTargetedXboxUserSize = 619,
        /// Enum value of Auto refreshed traffic.
        ///
        /// Corresponds to "Auto refreshed traffic value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        AutoRefreshedTraffic = 421,
        /// Indicates if the traffic is from auto-refreshed ad requests.
        ///
        /// Corresponds to "Auto refreshed traffic" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        AutoRefreshedTrafficName = 422,
        /// The encrypted version of BIDDER_ID.
        ///
        /// Corresponds to "Bidder encrypted ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `STRING`
        BidderEncryptedId = 493,
        /// The name of the bidder.
        ///
        /// Corresponds to "Bidder" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `STRING`
        BidderName = 494,
        /// The cpm range within which a bid falls.
        ///
        /// Corresponds to "Bid Range" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BID_RANGE`
        BidRange = 679,
        /// The reason a bid was rejected.
        ///
        /// Corresponds to "Bid rejection reason value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        BidRejectionReason = 599,
        /// The localized name of the reason a bid was rejected.
        ///
        /// Corresponds to "Bid rejection reason" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        BidRejectionReasonName = 600,
        /// The amount of information about the Publisher's page sent to the buyer
        /// who purchased the impressions.
        ///
        /// Corresponds to "Branding type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        BrandingType = 383,
        /// The localized version of branding type, the amount of information about
        /// the Publisher's page sent to the buyer who purchased the impressions.
        ///
        /// Corresponds to "Branding type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        BrandingTypeName = 384,
        /// Browser category.
        ///
        /// Corresponds to "Browser category value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        BrowserCategory = 119,
        /// Browser category name.
        ///
        /// Corresponds to "Browser category" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        BrowserCategoryName = 120,
        /// The ID of the browser.
        ///
        /// Corresponds to "Browser ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        BrowserId = 235,
        /// The name of the browser.
        ///
        /// Corresponds to "Browser" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        BrowserName = 236,
        /// The ID of the buyer network.
        ///
        /// Corresponds to "Buyer network ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        BuyerNetworkId = 448,
        /// The name of the buyer network.
        ///
        /// Corresponds to "Buyer network" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        BuyerNetworkName = 449,
        /// The callout status category in the Ads traffic navigator report.
        ///
        /// Corresponds to "Callout status category value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `ENUM`
        CalloutStatusCategory = 588,
        /// The callout status category name in the Ads traffic navigator report.
        ///
        /// Corresponds to "Callout status category" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        CalloutStatusCategoryName = 589,
        /// Mobile carrier ID.
        ///
        /// Corresponds to "Carrier ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        CarrierId = 369,
        /// Name of the mobile carrier.
        ///
        /// Corresponds to "Carrier" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CarrierName = 368,
        /// Inventory segmentation by channel.
        ///
        /// Corresponds to "Channel" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        Channel = 501,
        /// Child Publisher Network Code
        ///
        /// Corresponds to "Child network code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ChildNetworkCode = 542,
        /// Child Publisher Network ID
        ///
        /// Corresponds to "Child network ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        ChildNetworkId = 544,
        /// Child Partner Network Name
        ///
        /// Corresponds to "Child network" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ChildPartnerName = 543,
        /// The criteria ID of the city in which the ad served.
        ///
        /// Corresponds to "City ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        CityId = 459,
        /// The name of the city in which the ad served.
        ///
        /// Corresponds to "City" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        CityName = 452,
        /// The ID of an advertiser, classified by Google, associated with a creative
        /// transacted
        ///
        /// Corresponds to "Advertiser ID (classified)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        ClassifiedAdvertiserId = 133,
        /// The name of an advertiser, classified by Google, associated with a
        /// creative transacted
        ///
        /// Corresponds to "Advertiser (classified)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        ClassifiedAdvertiserName = 134,
        /// ID of the brand, as classified by Google,
        ///
        /// Corresponds to "Brand ID (classified)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        ClassifiedBrandId = 243,
        /// Name of the brand, as classified by Google,
        ///
        /// Corresponds to "Brand (classified)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        ClassifiedBrandName = 244,
        /// ID of the video content bundle served.
        ///
        /// Corresponds to "Content bundle ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        ContentBundleId = 460,
        /// Name of the video content bundle served.
        ///
        /// Corresponds to "Content bundle" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContentBundleName = 461,
        /// ID of the video content metadata namespace served.
        ///
        /// Corresponds to "CMS metadata key ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        ContentCmsMetadataKvNamespaceId = 462,
        /// Name of the video content metadata namespace served.
        ///
        /// Corresponds to "CMS metadata key" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContentCmsMetadataKvNamespaceName = 463,
        /// The display name of the CMS content.
        ///
        /// Corresponds to "Content source name" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContentCmsName = 643,
        /// The CMS content ID of the video content.
        ///
        /// Corresponds to "ID of the video in the content source" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContentCmsVideoId = 644,
        /// ID of the video content served.
        ///
        /// Corresponds to "Content ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        ContentId = 246,
        /// Content mapping presence ENUM value
        ///
        /// Corresponds to "Content mapping presence value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        ContentMappingPresence = 731,
        /// Content mapping presence name
        ///
        /// Corresponds to "Content mapping presence" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContentMappingPresenceName = 732,
        /// Name of the video content served.
        ///
        /// Corresponds to "Content" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContentName = 247,
        /// The continent in which the ad served (derived from country).
        ///
        /// Corresponds to "Continent value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        Continent = 469,
        /// The name of the continent in which the ad served (derived from country).
        ///
        /// Corresponds to "Continent" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ContinentName = 470,
        /// The ISO code of the country in which the ad served.
        ///
        /// Corresponds to "Country code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        CountryCode = 466,
        /// The criteria ID of the country in which the ad served.
        ///
        /// Corresponds to "Country ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        CountryId = 11,
        /// The name of the country in which the ad served.
        ///
        /// Corresponds to "Country" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        CountryName = 12,
        /// Enum value of creative billing type
        ///
        /// Corresponds to "Creative billing type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        CreativeBillingType = 366,
        /// Localized string value of creative billing type
        ///
        /// Corresponds to "Creative billing type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeBillingTypeName = 367,
        /// Represents the click-through URL of a creative
        ///
        /// Corresponds to "Creative click through url" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeClickThroughUrl = 174,
        /// The ID of a creative
        ///
        /// Corresponds to "Creative ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        CreativeId = 138,
        /// Creative name
        ///
        /// Corresponds to "Creative" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        CreativeName = 139,
        /// Creative Policies filtering.
        ///
        /// Corresponds to "Creative policies filtering value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        CreativePoliciesFiltering = 711,
        /// Localized name of the Creative Policies filtering.
        ///
        /// Corresponds to "Creative policies filtering" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativePoliciesFilteringName = 712,
        /// Creative Protections filtering.
        ///
        /// Corresponds to "Creative protections filtering value" in the Ad Manager
        /// UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        CreativeProtectionsFiltering = 704,
        /// Localized name of the Creative Protections filtering.
        ///
        /// Corresponds to "Creative protections filtering" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeProtectionsFilteringName = 705,
        /// ENUM describing whether the creative is part of a creative set and if so,
        /// what its role in the creative set is.
        ///
        /// Corresponds to "Creative set role type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        CreativeSetRoleType = 686,
        /// Localized name describing whether the creative is part of a creative set
        /// and if so, what its role in the creative set is.
        ///
        /// Corresponds to "Creative set role type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeSetRoleTypeName = 687,
        /// Creative technology ENUM
        ///
        /// Corresponds to "Creative technology value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        CreativeTechnology = 148,
        /// Creative technology localized name
        ///
        /// Corresponds to "Creative technology" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeTechnologyName = 149,
        /// Third party vendor name of a creative
        ///
        /// Corresponds to "Creative third party vendor" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeThirdPartyVendor = 361,
        /// Enum value of creative type
        ///
        /// Corresponds to "Creative type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `ENUM`
        CreativeType = 344,
        /// Localized string name of creative type
        ///
        /// Corresponds to "Creative type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        CreativeTypeName = 345,
        /// Creative vendor ID.
        ///
        /// Corresponds to "Creative vendor ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        CreativeVendorId = 706,
        /// Name of the Creative vendor.
        ///
        /// Corresponds to "Creative vendor" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeVendorName = 707,
        /// The third party where Google Ad Manager was redirected for the creative,
        /// based on the domain.
        ///
        /// Corresponds to "Creative video redirect third party" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CreativeVideoRedirectThirdParty = 562,
        /// The ID of a Curation partner
        ///
        /// Corresponds to "Curation partner ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        CuratorId = 572,
        /// The name of a Curation partner
        ///
        /// Corresponds to "Curation partner" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CuratorName = 573,
        /// Custom event ID
        ///
        /// Corresponds to "Custom event id" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        CustomEventId = 737,
        /// Custom event name
        ///
        /// Corresponds to "Custom event" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CustomEventName = 735,
        /// Custom event type
        ///
        /// Corresponds to "Custom event type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        CustomEventType = 736,
        /// Localized name of the custom event type
        ///
        /// Corresponds to "Custom event type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CustomEventTypeName = 738,
        /// The ID of an ad spot. An ad spot can be added to an ad break template, as
        /// well as directly targeted by a video line item.
        ///
        /// Corresponds to "Custom spot ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        CustomSpotId = 423,
        /// The name of an ad spot. An ad spot can be added to an ad break
        /// template, as well as directly targeted by a video line item.
        ///
        /// Corresponds to "Custom spot" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        CustomSpotName = 424,
        /// Breaks down reporting data by date.
        ///
        /// Corresponds to "Date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`, `REVENUE_VERIFICATION`, `AD_SPEED`
        ///
        /// Data format: `DATE`
        Date = 3,
        /// Breaks down reporting data by day of the week. Monday is 1 and 7 is
        /// Sunday.
        ///
        /// Corresponds to "Day of week" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        DayOfWeek = 4,
        /// The ID of the buyer of a deal.
        ///
        /// Corresponds to "Deal buyer ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        DealBuyerId = 240,
        /// The name of the buyer of a deal.
        ///
        /// Corresponds to "Deal buyer" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DealBuyerName = 241,
        /// Deal ID
        ///
        /// Corresponds to "Deal ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DealId = 436,
        /// Deal name
        ///
        /// Corresponds to "Deal" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DealName = 437,
        /// The ID of the secure signals that were sent to the bidder who won the
        /// impression.
        ///
        /// Corresponds to "Secure signal ID (delivered)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        DeliveredSecureSignalId = 309,
        /// The name of the secure signals that were sent to the bidder who won the
        /// impression.
        ///
        /// Corresponds to "Secure signal name (delivered)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DeliveredSecureSignalName = 310,
        /// Demand channel.
        ///
        /// Corresponds to "Demand channel value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `REVENUE_VERIFICATION`, `AD_SPEED`
        ///
        /// Data format: `ENUM`
        DemandChannel = 9,
        /// Demand channel name.
        ///
        /// Corresponds to "Demand channel" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `REVENUE_VERIFICATION`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        DemandChannelName = 10,
        /// Demand source.
        ///
        /// Corresponds to "Demand source value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `ENUM`
        DemandSource = 592,
        /// Demand source name.
        ///
        /// Corresponds to "Demand source" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        DemandSourceName = 593,
        /// Demand subchannel.
        ///
        /// Corresponds to "Demand subchannel value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        DemandSubchannel = 22,
        /// Demand subchannel name.
        ///
        /// Corresponds to "Demand subchannel" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DemandSubchannelName = 23,
        /// The device on which an ad was served.
        ///
        /// Corresponds to "Device value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        Device = 226,
        /// The device category to which an ad is being targeted.
        ///
        /// Corresponds to "Device category value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `ENUM`
        DeviceCategory = 15,
        /// The name of the category of device (smartphone, feature phone, tablet, or
        /// desktop) to which an ad is being targeted.
        ///
        /// Corresponds to "Device category" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        DeviceCategoryName = 16,
        /// Device manufacturer ID
        ///
        /// Corresponds to "Device manufacturer ID" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        DeviceManufacturerId = 525,
        /// Device manufacturer name
        ///
        /// Corresponds to "Device manufacturer" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DeviceManufacturerName = 526,
        /// Device model ID
        ///
        /// Corresponds to "Device model ID" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        DeviceModelId = 527,
        /// Device model name
        ///
        /// Corresponds to "Device model" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DeviceModelName = 528,
        /// The localized name of the device on which an ad was served.
        ///
        /// Corresponds to "Device" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DeviceName = 225,
        /// The ID of DSP Seat
        ///
        /// Corresponds to "DSP seat ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DspSeatId = 564,
        /// Categorization of inventory sources based on AdX dynamic allocation
        /// backfill type.
        ///
        /// Corresponds to "Dynamic allocation value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        DynamicAllocationType = 502,
        /// Localized name of the dynamic allocation type.
        ///
        /// Corresponds to "Dynamic allocation" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        DynamicAllocationTypeName = 503,
        /// Status of Encrypted Signals for Publishers delivery.
        ///
        /// Corresponds to "Secure signal delivery value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        EspDelivery = 623,
        /// Localized name of the ESP delivery status.
        ///
        /// Corresponds to "Secure signal delivery" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        EspDeliveryName = 624,
        /// Whether Encrypted Signals for Publishers are present on the ad request.
        ///
        /// Corresponds to "Secure signal presence value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        EspPresence = 625,
        /// Localized name of the ESP presence status.
        ///
        /// Corresponds to "Secure signal presence" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        EspPresenceName = 626,
        /// Exchange bidding deal ID.
        ///
        /// Corresponds to "Exchange bidding deal id" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ExchangeBiddingDealId = 715,
        /// Exchange bidding deal type.
        ///
        /// Corresponds to "Exchange bidding deal type value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        ExchangeBiddingDealType = 714,
        /// Localized name of the exchange bidding deal type.
        ///
        /// Corresponds to "Exchange bidding deal type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ExchangeBiddingDealTypeName = 723,
        /// ID of the yield partner as classified by Google
        ///
        /// Corresponds to "Yield partner ID (classified)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        ExchangeThirdPartyCompanyId = 185,
        /// Name of the yield partner as classified by Google
        ///
        /// Corresponds to "Yield partner (classified)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ExchangeThirdPartyCompanyName = 186,
        /// The ID of the first look pricing rule.
        ///
        /// Corresponds to "First look pricing rule ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        FirstLookPricingRuleId = 248,
        /// The name of the first look pricing rule.
        ///
        /// Corresponds to "First look pricing rule" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        FirstLookPricingRuleName = 249,
        /// Whether a first-party user identifier was present on a given
        /// ad-request.
        ///
        /// Corresponds to "First-party ID status value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        FirstPartyIdStatus = 404,
        /// The localized name of whether a first-party user identifier was present
        /// on a given ad-request.
        ///
        /// Corresponds to "First-party ID status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        FirstPartyIdStatusName = 405,
        /// User gender enum value returned from Google Analytics.
        ///
        /// Corresponds to "Gender value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        Gender = 509,
        /// Localized user gender returned from Google Analytics. For example,
        /// "male", "female".
        ///
        /// Corresponds to "Gender" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        GenderName = 583,
        /// The ID of a Google Analytics stream. For example, web site or mobile app
        ///
        /// Corresponds to "Google Analytics stream ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        GoogleAnalyticsStreamId = 519,
        /// The name of a Google Analytics stream. For example,
        /// web site or mobile app.
        ///
        /// Corresponds to "Google Analytics stream" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        GoogleAnalyticsStreamName = 520,
        /// The ID of the header bidding trafficking yield partner.
        ///
        /// Corresponds to "Yield partner ID (header bidding trafficking)" in the Ad
        /// Manager UI (when showing API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `IDENTIFIER`
        HbtYieldPartnerId = 659,
        /// The name of the header bidding trafficking yield partner.
        ///
        /// Corresponds to "Yield partner (header bidding trafficking)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        HbtYieldPartnerName = 660,
        /// Header Bidder integration type.
        ///
        /// Corresponds to "Header bidder integration type value" in the Ad Manager
        /// UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        HeaderBidderIntegrationType = 718,
        /// Localized name of the Header Bidder integration type.
        ///
        /// Corresponds to "Header bidder integration type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        HeaderBidderIntegrationTypeName = 719,
        /// Breaks down reporting data by hour in one day.
        ///
        /// Corresponds to "Hour" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        Hour = 100,
        /// Impression Counting Method ENUM.
        ///
        /// Corresponds to "Impression counting method value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        ImpressionCountingMethod = 577,
        /// Localized impression counting method name.
        ///
        /// Corresponds to "Impression counting method" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ImpressionCountingMethodName = 578,
        /// The interaction type of an ad.
        ///
        /// Corresponds to "Interaction type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        InteractionType = 223,
        /// The localized name of the interaction type of an ad.
        ///
        /// Corresponds to "Interaction type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InteractionTypeName = 224,
        /// User interest returned from Google Analytics.
        ///
        /// Corresponds to "Interests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        Interest = 510,
        /// Inventory format.
        /// The format of the ad unit (e.g, banner) where the ad was requested.
        ///
        /// Corresponds to "Inventory format value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        InventoryFormat = 17,
        /// Inventory format name.
        /// The format of the ad unit (e.g, banner) where the ad was requested.
        ///
        /// Corresponds to "Inventory format" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InventoryFormatName = 18,
        /// The ID of the inventory share assignment.
        ///
        /// Corresponds to "Inventory share assignment ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        InventoryShareAssignmentId = 648,
        /// The name of the inventory share assignment.
        ///
        /// Corresponds to "Inventory share assignment" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InventoryShareAssignmentName = 649,
        /// The result of an inventory share.
        ///
        /// Corresponds to "Inventory share outcome value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        InventoryShareOutcome = 603,
        /// The localized name of the result of an inventory share.
        ///
        /// Corresponds to "Inventory share outcome" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InventoryShareOutcomeName = 604,
        /// The partner ad server of the inventory share.
        ///
        /// Corresponds to "Inventory share partner ad server value" in the Ad
        /// Manager UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        InventorySharePartnerAdServer = 652,
        /// The localized name of the partner ad server.
        ///
        /// Corresponds to "Inventory share partner ad server" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InventorySharePartnerAdServerName = 653,
        /// The target share percent of the inventory share assignment
        ///
        /// Corresponds to "Partner target share percent" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        InventoryShareTargetSharePercent = 654,
        /// The type of the inventory share.
        ///
        /// Corresponds to "Inventory share type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        InventoryShareType = 650,
        /// The localized name of the inventory share type.
        ///
        /// Corresponds to "Inventory share type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InventoryShareTypeName = 651,
        /// Inventory type.
        /// The kind of web page or device where the ad was requested.
        ///
        /// Corresponds to "Inventory type (expanded) value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        InventoryType = 19,
        /// Inventory type name.
        /// The kind of web page or device where the ad was requested.
        ///
        /// Corresponds to "Inventory type (expanded)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        InventoryTypeName = 20,
        /// Whether traffic is Adx Direct.
        ///
        /// Corresponds to "Is AdX Direct" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        IsAdxDirect = 382,
        /// If curation was targeted by the buyer when buying the impression
        ///
        /// Corresponds to "Is curation targeted" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        IsCurationTargeted = 574,
        /// Whether the query was dropped.
        ///
        /// Corresponds to "Is Dropped" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        IsDropped = 464,
        /// Whether traffic is First Look.
        ///
        /// Corresponds to "Is First Look" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        IsFirstLookDeal = 401,
        /// The Custom Targeting Value ID
        ///
        /// Corresponds to "Key-values ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        KeyValuesId = 214,
        /// The Custom Targeting Value formatted like `{keyName}={valueName}`
        ///
        /// Corresponds to "Key-values" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        KeyValuesName = 215,
        /// The custom criteria key-values specified in ad requests.
        ///
        /// Corresponds to "Key-values" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING_LIST`
        KeyValuesSet = 713,
        /// The agency of the order associated with the line item.
        ///
        /// Corresponds to "Line item agency" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemAgency = 663,
        /// Whether a Line item is archived.
        ///
        /// Corresponds to "Line item is archived" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `BOOLEAN`
        LineItemArchived = 188,
        /// Line item companion delivery option ENUM value.
        ///
        /// Corresponds to "Line item companion delivery option value" in the Ad
        /// Manager UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        LineItemCompanionDeliveryOption = 204,
        /// Localized line item companion delivery option name.
        ///
        /// Corresponds to "Line item companion delivery option" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemCompanionDeliveryOptionName = 205,
        /// The computed status of the LineItem.
        ///
        /// Corresponds to "Line item computed status value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `ENUM`
        LineItemComputedStatus = 250,
        /// The localized name of the computed status of the LineItem.
        ///
        /// Corresponds to "Line item computed status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemComputedStatusName = 251,
        /// The contracted units bought for the Line item.
        ///
        /// Corresponds to "Line item contracted quantity" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `INTEGER`
        LineItemContractedQuantity = 92,
        /// The cost per unit of the Line item.
        ///
        /// Corresponds to "Line item rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `MONEY`
        LineItemCostPerUnit = 85,
        /// Line item cost type ENUM value.
        ///
        /// Corresponds to "Line item cost type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `ENUM`
        LineItemCostType = 212,
        /// Localized line item cost type name.
        ///
        /// Corresponds to "Line item cost type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemCostTypeName = 213,
        /// Represent the end date of a creative associated with line item
        ///
        /// Corresponds to "Line item creative end date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DATE`
        LineItemCreativeEndDate = 176,
        /// The creative rotation type of the LineItem.
        ///
        /// Corresponds to "Line item creative rotation type value" in the Ad Manager
        /// UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        LineItemCreativeRotationType = 189,
        /// The localized name of the creative rotation type of the LineItem.
        ///
        /// Corresponds to "Line item creative rotation type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemCreativeRotationTypeName = 190,
        /// Represent the start date of a creative associated with line item
        ///
        /// Corresponds to "Line item creative start date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DATE`
        LineItemCreativeStartDate = 175,
        /// The 3 letter currency code of the Line Item
        ///
        /// Corresponds to "Line item currency code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemCurrencyCode = 180,
        /// The progress made for the delivery of the Line item.
        ///
        /// Corresponds to "Line item delivery indicator" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `PERCENT`
        LineItemDeliveryIndicator = 87,
        /// The delivery rate type of the LineItem.
        ///
        /// Corresponds to "Line item delivery rate type value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `ENUM`
        LineItemDeliveryRateType = 191,
        /// The localized name of the delivery rate type of the LineItem.
        ///
        /// Corresponds to "Line item delivery rate type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemDeliveryRateTypeName = 192,
        /// The discount of the LineItem in whole units in the LineItem's currency
        /// code, or if unspecified the Network's currency code.
        ///
        /// Corresponds to "Line item discount (absolute)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `MONEY`
        LineItemDiscountAbsolute = 195,
        /// The discount of the LineItem in percentage.
        ///
        /// Corresponds to "Line item discount (percentage)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `WHOLE_PERCENT`
        LineItemDiscountPercentage = 196,
        /// The end date of the Line item.
        ///
        /// Corresponds to "Line item end date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `DATE`
        LineItemEndDate = 81,
        /// The end date and time of the Line item.
        ///
        /// Corresponds to "Line item end time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `TIMESTAMP`
        LineItemEndDateTime = 83,
        /// The ENUM value of the environment a LineItem is targeting.
        ///
        /// Corresponds to "Line item environment type value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        LineItemEnvironmentType = 201,
        /// The localized name of the environment a LineItem is targeting.
        ///
        /// Corresponds to "Line item environment type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemEnvironmentTypeName = 202,
        /// The deal ID of the Line item. Set for Programmatic Direct campaigns.
        ///
        /// Corresponds to "Line item deal ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER`
        LineItemExternalDealId = 97,
        /// The external ID of the Line item.
        ///
        /// Corresponds to "Line item external ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemExternalId = 86,
        /// The frequency cap of the Line item (descriptive string).
        ///
        /// Corresponds to "Line item frequency cap" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemFrequencyCap = 256,
        /// Line item ID.
        ///
        /// Corresponds to "Line item ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        LineItemId = 1,
        /// Line item labels.
        ///
        /// Corresponds to "Line item labels" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        LineItemLabels = 667,
        /// Line item label IDs.
        ///
        /// Corresponds to "Line item label IDs" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        LineItemLabelIds = 665,
        /// The application that last modified the Line Item.
        ///
        /// Corresponds to "Line item last modified by app" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemLastModifiedByApp = 181,
        /// The total number of clicks delivered of the lifetime of the Line item.
        ///
        /// Corresponds to "Line item lifetime clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        LineItemLifetimeClicks = 95,
        /// The total number of impressions delivered over the lifetime of the
        /// Line item.
        ///
        /// Corresponds to "Line item lifetime impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        LineItemLifetimeImpressions = 94,
        /// The total number of viewable impressions delivered over the lifetime of
        /// the Line item.
        ///
        /// Corresponds to "Line item lifetime viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        LineItemLifetimeViewableImpressions = 96,
        /// Whether or not the Line item is Makegood. Makegood refers to free
        /// inventory offered to buyers to compensate for mistakes or under-delivery
        /// in the original campaigns.
        ///
        /// Corresponds to "Line item is makegood" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `BOOLEAN`
        LineItemMakegood = 89,
        /// Line item Name.
        ///
        /// Corresponds to "Line item" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemName = 2,
        /// The cost of booking for the Line item (non-CPD).
        ///
        /// Corresponds to "Line item booked revenue (exclude CPD)" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `MONEY`
        LineItemNonCpdBookedRevenue = 98,
        /// Whether a Line item is eligible for optimization.
        ///
        /// Corresponds to "Line item is optimizable" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `BOOLEAN`
        LineItemOptimizable = 90,
        /// The PO number of the order associated with the line item.
        ///
        /// Corresponds to "Line item PO number" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemPoNumber = 669,
        /// Goal type ENUM value of the primary goal of the line item.
        ///
        /// Corresponds to "Line item primary goal type value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        LineItemPrimaryGoalType = 210,
        /// Localized goal type name of the primary goal of the line item.
        ///
        /// Corresponds to "Line item primary goal type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemPrimaryGoalTypeName = 211,
        /// The total number of impressions or clicks that are reserved for a
        /// line item. For line items of type BULK or PRICE_PRIORITY, this
        /// represents the number of remaining impressions reserved. If the line
        /// item has an impression cap goal, this represents the number of
        /// impressions or conversions that the line item will stop serving at if
        /// reached.
        ///
        /// Corresponds to "Line item primary goal units (absolute)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        LineItemPrimaryGoalUnitsAbsolute = 93,
        /// The percentage of impressions or clicks that are reserved for a
        /// line item. For line items of type SPONSORSHIP, this represents the
        /// percentage of available impressions reserved. For line items of type
        /// NETWORK or HOUSE, this represents the percentage of remaining
        /// impressions reserved.
        ///
        /// Corresponds to "Line item primary goal units (percentage)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `WHOLE_PERCENT`
        LineItemPrimaryGoalUnitsPercentage = 396,
        /// Unit type ENUM value of the primary goal of the line item.
        ///
        /// Corresponds to "Line item primary goal unit type value" in the Ad Manager
        /// UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        LineItemPrimaryGoalUnitType = 208,
        /// Localized unit type name of the primary goal of the line item.
        ///
        /// Corresponds to "Line item primary goal unit type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemPrimaryGoalUnitTypeName = 209,
        /// The priority of this Line item as a value between 1 and 16.
        /// In general, a lower priority means more serving priority for the
        /// Line item.
        ///
        /// Corresponds to "Line item priority" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        LineItemPriority = 24,
        /// ENUM value describing the state of inventory reservation for the
        /// LineItem.
        ///
        /// Corresponds to "Line item reservation status value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        LineItemReservationStatus = 304,
        /// Localized string describing the state of inventory reservation for the
        /// LineItem.
        ///
        /// Corresponds to "Line item reservation status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemReservationStatusName = 305,
        /// The sales person of the order associated with the line item.
        ///
        /// Corresponds to "Line item salesperson" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemSalesperson = 671,
        /// The secondary sales people of the order associated with the line item.
        ///
        /// Corresponds to "Line item secondary salespeople" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        LineItemSecondarySalespeople = 673,
        /// The secondary traffickers of the order associated with the line item.
        ///
        /// Corresponds to "Line item secondary traffickers" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        LineItemSecondaryTraffickers = 675,
        /// The start date of the Line item.
        ///
        /// Corresponds to "Line item start date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `DATE`
        LineItemStartDate = 82,
        /// The start date and time of the Line item.
        ///
        /// Corresponds to "Line item start time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `TIMESTAMP`
        LineItemStartDateTime = 84,
        /// The trafficker of the order associated with the line item.
        ///
        /// Corresponds to "Line item trafficker" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemTrafficker = 677,
        /// Line item type ENUM value.
        ///
        /// Corresponds to "Line item type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `ENUM`
        LineItemType = 193,
        /// Localized line item type name.
        ///
        /// Corresponds to "Line item type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        LineItemTypeName = 194,
        /// Whether the Line item end time and end date is set to effectively never
        /// end.
        ///
        /// Corresponds to "Line item is unlimited end time" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        LineItemUnlimitedEnd = 187,
        /// The artificial cost per unit used by the Ad server to help rank
        /// inventory.
        ///
        /// Corresponds to "Line item value cost per unit" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `MONEY`
        LineItemValueCostPerUnit = 88,
        /// The web property code used for dynamic allocation Line Items.
        ///
        /// Corresponds to "Line item web property code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        LineItemWebPropertyCode = 179,
        /// The ID of creative, includes regular creatives, and master and companions
        /// in case of creative sets
        ///
        /// Corresponds to "Master and Companion creative ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        MasterCompanionCreativeId = 140,
        /// Name of creative, includes regular creatives, and master and companions
        /// in case of creative sets
        ///
        /// Corresponds to "Master and Companion creative" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        MasterCompanionCreativeName = 141,
        /// Mediation type.
        ///
        /// Corresponds to "Mediation type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        MediationType = 701,
        /// Localized mediation type name.
        ///
        /// Corresponds to "Mediation type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        MediationTypeName = 754,
        /// The ID of the yield partner for Mediation.
        ///
        /// Corresponds to "Yield partner ID (mediation)" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `IDENTIFIER`
        MediationYieldPartnerId = 661,
        /// The name of the yield partner for Mediation.
        ///
        /// Corresponds to "Yield partner (mediation)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        MediationYieldPartnerName = 662,
        /// The criteria ID of the metro area in which the ad served.
        ///
        /// Corresponds to "Metro ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        MetroId = 453,
        /// The name of the metro area in which the ad served.
        ///
        /// Corresponds to "Metro" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        MetroName = 454,
        /// Whether the mobile app is free.
        ///
        /// Corresponds to "App is free" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        MobileAppFree = 128,
        /// URL of app icon for the mobile app.
        ///
        /// Corresponds to "App icon URL" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        MobileAppIconUrl = 129,
        /// The ID of the Mobile App.
        ///
        /// Corresponds to "App ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        MobileAppId = 123,
        /// The name of the mobile app.
        ///
        /// Corresponds to "App" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        MobileAppName = 127,
        /// Ownership status of the mobile app.
        ///
        /// Corresponds to "App ownership status value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        MobileAppOwnershipStatus = 311,
        /// Ownership status of the mobile app.
        ///
        /// Corresponds to "App ownership status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        MobileAppOwnershipStatusName = 312,
        /// The App Store of the mobile app.
        ///
        /// Corresponds to "App store value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        MobileAppStore = 125,
        /// The localized name of the mobile app store.
        ///
        /// Corresponds to "App store" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        MobileAppStoreName = 245,
        /// Mobile inventory type.
        /// Identifies whether a mobile ad came from a regular web page, an AMP web
        /// page, or a mobile app.
        /// Values match the Inventory type dimension available in the Overview Home
        /// dashboard. Note: Video takes precedence over any other value, for
        /// example, if there is an in-stream video impression on a desktop device,
        /// it will be attributed to in-stream video and not desktop web.
        ///
        /// Corresponds to "Inventory type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `ENUM`
        MobileInventoryType = 99,
        /// Mobile inventory type name.
        /// Identifies whether a mobile ad came from a regular web page, an AMP web
        /// page, or a mobile app.
        ///
        /// Corresponds to "Inventory type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        MobileInventoryTypeName = 21,
        /// Mobile rendering SDK.
        ///
        /// Corresponds to "Rendering SDK value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `ENUM`
        MobileRenderingSdk = 646,
        /// Localized name of the Mobile rendering SDK.
        ///
        /// Corresponds to "Rendering SDK" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `STRING`
        MobileRenderingSdkName = 647,
        /// The major version of the mobile SDK.
        ///
        /// Corresponds to "App SDK major version" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        MobileSdkMajorVersion = 692,
        /// The minor version of the mobile SDK.
        ///
        /// Corresponds to "App SDK minor version" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        MobileSdkMinorVersion = 693,
        /// SDK version of the mobile device.
        ///
        /// Corresponds to "App SDK version" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        MobileSdkVersionName = 130,
        /// Breaks down reporting data by month and year.
        ///
        /// Corresponds to "Month and year" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`, `REVENUE_VERIFICATION`, `PARTNER_FINANCE`
        ///
        /// Data format: `INTEGER`
        MonthYear = 6,
        /// Native ad format ID.
        ///
        /// Corresponds to "Native ad format ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        NativeAdFormatId = 255,
        /// Native ad format name.
        ///
        /// Corresponds to "Native ad format" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        NativeAdFormatName = 254,
        /// Native style ID.
        ///
        /// Corresponds to "Native style ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        NativeStyleId = 253,
        /// Native style name.
        ///
        /// Corresponds to "Native style" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        NativeStyleName = 252,
        /// No fill reason category in the Ads traffic navigator report.
        ///
        /// Corresponds to "No fill reason category value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `ENUM`
        NoFillReasonCategory = 586,
        /// No fill reason category name in the Ads traffic navigator report.
        ///
        /// Corresponds to "No fill reason category" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        NoFillReasonCategoryName = 587,
        /// Operating system category.
        ///
        /// Corresponds to "Operating system category value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `ENUM`
        OperatingSystemCategory = 117,
        /// Operating system category name.
        ///
        /// Corresponds to "Operating system category" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        OperatingSystemCategoryName = 118,
        /// ID of the operating system version.
        ///
        /// Corresponds to "Operating system ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        OperatingSystemVersionId = 238,
        /// Details of the operating system, including version.
        ///
        /// Corresponds to "Operating system" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        OperatingSystemVersionName = 237,
        /// Enum value of the optimization type.
        ///
        /// Corresponds to "Optimization type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        OptimizationType = 639,
        /// Localized name of the optimization type.
        ///
        /// Corresponds to "Optimization type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        OptimizationTypeName = 640,
        /// Order agency.
        ///
        /// Corresponds to "Order agency" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        OrderAgency = 150,
        /// Order agency ID.
        ///
        /// Corresponds to "Order agency ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER`
        OrderAgencyId = 151,
        /// Order booked CPC.
        ///
        /// Corresponds to "Order booked CPC" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `INTEGER`
        OrderBookedCpc = 152,
        /// Order booked CPM.
        ///
        /// Corresponds to "Order booked CPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `INTEGER`
        OrderBookedCpm = 153,
        /// Order delivery status ENUM value.
        ///
        /// Corresponds to "Order delivery status value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        OrderDeliveryStatus = 231,
        /// Order delivery status localized name.
        ///
        /// Corresponds to "Order delivery status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        OrderDeliveryStatusName = 239,
        /// Order end date.
        ///
        /// Corresponds to "Order end date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `DATE`
        OrderEndDate = 154,
        /// Order end date and time.
        ///
        /// Corresponds to "Order end time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `TIMESTAMP`
        OrderEndDateTime = 155,
        /// Order external ID.
        ///
        /// Corresponds to "Order external ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER`
        OrderExternalId = 156,
        /// Order ID.
        ///
        /// Corresponds to "Order ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        OrderId = 7,
        /// Order labels.
        ///
        /// Corresponds to "Order labels" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        OrderLabels = 170,
        /// Order labels IDs.
        ///
        /// Corresponds to "Order label IDs" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        OrderLabelIds = 171,
        /// Order lifetime clicks.
        ///
        /// Corresponds to "Order lifetime clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        OrderLifetimeClicks = 158,
        /// Order lifetime impressions.
        ///
        /// Corresponds to "Order lifetime impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        OrderLifetimeImpressions = 159,
        /// Order name.
        ///
        /// Corresponds to "Order" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        OrderName = 8,
        /// Order PO number.
        ///
        /// Corresponds to "Order PO number" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `STRING`
        OrderPoNumber = 160,
        /// Whether the Order is programmatic.
        ///
        /// Corresponds to "Order is programmatic" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `BOOLEAN`
        OrderProgrammatic = 157,
        /// Order sales person.
        ///
        /// Corresponds to "Order salesperson" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        OrderSalesperson = 161,
        /// Order sales person ID.
        ///
        /// Corresponds to "Order salesperson ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER`
        OrderSalespersonId = 629,
        /// Order secondary sales people.
        ///
        /// Corresponds to "Order secondary salespeople" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        OrderSecondarySalespeople = 164,
        /// Order secondary sales people ID.
        ///
        /// Corresponds to "Order secondary salespeople ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        OrderSecondarySalespeopleId = 165,
        /// Order secondary traffickers.
        ///
        /// Corresponds to "Order secondary traffickers" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        OrderSecondaryTraffickers = 166,
        /// Order secondary traffickers ID.
        ///
        /// Corresponds to "Order secondary trafficker IDs" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        OrderSecondaryTraffickersId = 167,
        /// Order start date.
        ///
        /// Corresponds to "Order start date" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `DATE`
        OrderStartDate = 168,
        /// Order start date and time.
        ///
        /// Corresponds to "Order start time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `AD_SPEED`
        ///
        /// Data format: `TIMESTAMP`
        OrderStartDateTime = 169,
        /// Order trafficker.
        ///
        /// Corresponds to "Order trafficker" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        OrderTrafficker = 162,
        /// Order trafficker ID.
        ///
        /// Corresponds to "Order trafficker ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER`
        OrderTraffickerId = 163,
        /// Whether the Order end time and end date is set to effectively never
        /// end.
        ///
        /// Corresponds to "Order is unlimited end time" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        OrderUnlimitedEnd = 203,
        /// Page path is the part of a page URL that comes after the domain but
        /// before the query strings from Google Analytics.
        ///
        /// Corresponds to "Page path" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PagePath = 511,
        /// Page title (web) and screen class (mobile) returned from Google
        /// Analytics.
        ///
        /// Corresponds to "Page title and screen class" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PageTitleAndScreenClass = 512,
        /// Page title (web) and screen name (mobile) returned from Google Analytics.
        ///
        /// Corresponds to "Page title and screen name" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PageTitleAndScreenName = 513,
        /// The ID of a partner management assignment.
        ///
        /// Corresponds to "Partner management assignment ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PARTNER_FINANCE`
        ///
        /// Data format: `INTEGER`
        PartnerManagementAssignmentId = 657,
        /// The name of a partner management assignment.
        ///
        /// Corresponds to "Partner management assignment" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PARTNER_FINANCE`
        ///
        /// Data format: `STRING`
        PartnerManagementAssignmentName = 658,
        /// The ID of a partner in a partner management assignment.
        ///
        /// Corresponds to "Partner management partner ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PARTNER_FINANCE`
        ///
        /// Data format: `INTEGER`
        PartnerManagementPartnerId = 655,
        /// The name of a partner in a partner management assignment.
        ///
        /// Corresponds to "Partner management partner" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PARTNER_FINANCE`
        ///
        /// Data format: `STRING`
        PartnerManagementPartnerName = 656,
        /// Placement ID
        ///
        /// Corresponds to "Placement ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER`
        PlacementId = 113,
        /// The full list of placement IDs associated with the ad unit.
        ///
        /// Corresponds to "Placement ID (all)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `IDENTIFIER_LIST`
        PlacementIdAll = 144,
        /// Placement name
        ///
        /// Corresponds to "Placement" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING`
        PlacementName = 114,
        /// The full list of placement names associated with the ad unit.
        ///
        /// Corresponds to "Placement (all)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`
        ///
        /// Data format: `STRING_LIST`
        PlacementNameAll = 145,
        /// Placement status ENUM value
        ///
        /// Corresponds to "Placement status value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        PlacementStatus = 362,
        /// Localized placement status name.
        ///
        /// Corresponds to "Placement status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PlacementStatusName = 364,
        /// The full list of localized placement status names associated with the ad
        /// unit.
        ///
        /// Corresponds to "Placement status (all)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING_LIST`
        PlacementStatusNameAll = 365,
        /// The criteria ID of the postal code in which the ad served.
        ///
        /// Corresponds to "Postal code ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        PostalCodeId = 455,
        /// The name of the postal code in which the ad served.
        ///
        /// Corresponds to "Postal code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        PostalCodeName = 456,
        /// Indicates the valid PPID (Publisher provided identifier) status on a
        /// given ad request.
        ///
        /// Corresponds to "PPID status value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        PpidStatus = 406,
        /// The localized name of that indicates the valid PPID (Publisher provided
        /// identifier) status on a given ad request.
        ///
        /// Corresponds to "PPID status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PpidStatusName = 407,
        /// Predicted viewability score bucket.
        ///
        /// Corresponds to "Predicted viewability bucket value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        PredictedViewabilityBucket = 633,
        /// The localized name of the predicted viewability score bucket.
        ///
        /// Corresponds to "Predicted viewability bucket" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PredictedViewabilityBucketName = 634,
        /// The ID of the secure signals sent in the ad request.
        ///
        /// Corresponds to "Secure signal ID (presented)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        PresentedSecureSignalId = 495,
        /// The name of the secure signals sent in the ad request.
        ///
        /// Corresponds to "Secure signal name (presented)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PresentedSecureSignalName = 496,
        /// The ID type selected for personalization.
        ///
        /// Corresponds to "Primary personalization ID type value" in the Ad Manager
        /// UI (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        PrimaryPersonalizationIdType = 408,
        /// The localized name of the ID type selected for personalization.
        ///
        /// Corresponds to "Primary personalization ID type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PrimaryPersonalizationIdTypeName = 409,
        /// Programmatic channel.
        /// The type of transaction that occurred in Ad Exchange.
        ///
        /// Corresponds to "Programmatic channel value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `ENUM`
        ProgrammaticChannel = 13,
        /// Programmatic channel name.
        /// The type of transaction that occurred in Ad Exchange.
        ///
        /// Corresponds to "Programmatic channel" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `REVENUE_VERIFICATION`
        ///
        /// Data format: `STRING`
        ProgrammaticChannelName = 14,
        /// External code ID of a publisher provided signal (all levels).
        ///
        /// Corresponds to "Publisher provided signals external code (all levels)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalsAllLevelsExternalCode = 410,
        /// The ancestor chain of IDs of a publisher provided signal (all levels).
        ///
        /// Corresponds to "Publisher provided signals ID (all levels)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER_LIST`
        PublisherProvidedSignalsAllLevelsIds = 546,
        /// The ancestor chain of names of a publisher provided signal (all levels).
        ///
        /// Corresponds to "Publisher provided signals (all levels)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING_LIST`
        PublisherProvidedSignalsAllLevelsName = 412,
        /// Tier of a publisher provided signal (all levels).
        ///
        /// Corresponds to "Publisher provided signals tier (all levels)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PublisherProvidedSignalsAllLevelsTier = 413,
        /// Type of a publisher provided signal (all levels).
        ///
        /// Corresponds to "Publisher provided signals type (all levels)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalsAllLevelsType = 414,
        /// External code ID of a publisher provided signal (delivered).
        ///
        /// Corresponds to "Publisher provided signals external code (delivered)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalsDeliveredExternalCode = 425,
        /// The ancestor chain of IDs of a publisher provided signal (delivered).
        ///
        /// Corresponds to "Publisher provided signals ID (delivered)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER_LIST`
        PublisherProvidedSignalsDeliveredIds = 545,
        /// The ancestor chain of names of a publisher provided signal (delivered).
        ///
        /// Corresponds to "Publisher provided signals (delivered)" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING_LIST`
        PublisherProvidedSignalsDeliveredName = 427,
        /// Tier of a publisher provided signal (delivered).
        ///
        /// Corresponds to "Publisher provided signals tier (delivered)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PublisherProvidedSignalsDeliveredTier = 428,
        /// Type of a publisher provided signal (delivered).
        ///
        /// Corresponds to "Publisher provided signals type (delivered)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalsDeliveredType = 429,
        /// External code ID of a publisher provided signal (top level).
        ///
        /// Corresponds to "Publisher provided signals external code (top level)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalsTopLevelExternalCode = 415,
        /// ID of a publisher provided signal (top level).
        ///
        /// Corresponds to "Publisher provided signals ID (top level)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        PublisherProvidedSignalsTopLevelId = 416,
        /// Name of a publisher provided signal (top level).
        ///
        /// Corresponds to "Publisher provided signals (top level)" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING_LIST`
        PublisherProvidedSignalsTopLevelName = 417,
        /// Tier of a publisher provided signal (top level).
        ///
        /// Corresponds to "Publisher provided signals tier (top level)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PublisherProvidedSignalsTopLevelTier = 418,
        /// Type of a publisher provided signal (top level).
        ///
        /// Corresponds to "Publisher provided signals type (top level)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalsTopLevelType = 419,
        /// Data provider ID associated with a publisher provided signal.
        ///
        /// Corresponds to "Publisher provided signals (data provider ID)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        PublisherProvidedSignalDataProviderId = 136,
        /// Data provider name associated with a publisher provided signal.
        ///
        /// Corresponds to "Publisher provided signals (data provider)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        PublisherProvidedSignalDataProviderName = 137,
        /// The criteria ID of the region (for example, US state) in which the ad
        /// served.
        ///
        /// Corresponds to "Region ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `IDENTIFIER`
        RegionId = 457,
        /// The name of the region (for example, US state) in which the ad
        /// served.
        ///
        /// Corresponds to "Region" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        RegionName = 458,
        /// The rejection class category in the Ads traffic navigator report.
        ///
        /// Corresponds to "Rejection class category value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `ENUM`
        RejectionClassCategory = 590,
        /// The rejection class category name in the Ads traffic navigator report.
        ///
        /// Corresponds to "Rejection class category" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        RejectionClassCategoryName = 591,
        /// The size of a rendered creative, It can differ with the creative's size
        /// if a creative is shown in an ad slot of a different size.
        ///
        /// Corresponds to "Rendered creative size" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        RenderedCreativeSize = 343,
        /// Inventory Requested Ad Sizes dimension
        ///
        /// Corresponds to "Requested ad sizes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        RequestedAdSizes = 352,
        /// Request type ENUM
        ///
        /// Corresponds to "Request type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `ENUM`
        RequestType = 146,
        /// Request type localized name
        ///
        /// Corresponds to "Request type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `STRING`
        RequestTypeName = 147,
        /// Revenue Verification bidder-provided ID.
        ///
        /// Corresponds to "Revenue verification ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REVENUE_VERIFICATION`
        ///
        /// Data format: `IDENTIFIER`
        RevenueVerificationId = 645,
        /// Indicates if a request was eligible for server-side unwrapping.
        ///
        /// Corresponds to "Server-side unwrapping eligible" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `BOOLEAN`
        ServerSideUnwrappingEligible = 597,
        /// The serving restriction mode for privacy.
        ///
        /// Corresponds to "Serving restriction value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        ServingRestriction = 631,
        /// The localized name of the serving restriction mode for privacy.
        ///
        /// Corresponds to "Serving restriction" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ServingRestrictionName = 632,
        /// Information about domain or subdomains.
        ///
        /// Corresponds to "Site" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        Site = 387,
        /// The ID of the browser, device or other environment into which a line item
        /// or creative was served.
        ///
        /// Corresponds to "Targeting ID" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        TargetingId = 232,
        /// Information about the browser, device and other environments into which
        /// a line item or creative was served.
        ///
        /// Corresponds to "Targeting" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        TargetingName = 233,
        /// The way in which advertisers targeted their ads.
        ///
        /// Corresponds to "Targeting type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        TargetingType = 385,
        /// The localized name of the way in which advertisers targeted their ads.
        ///
        /// Corresponds to "Targeting type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        TargetingTypeName = 386,
        /// Whether a third-party cookie or device ID was present on a given ad
        /// request.
        ///
        /// Corresponds to "Third-party ID status value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        ThirdPartyIdStatus = 402,
        /// The localized name of whether a third-party cookie or device ID was
        /// present on a given ad request.
        ///
        /// Corresponds to "Third-party ID status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        ThirdPartyIdStatusName = 403,
        /// Reports the status of Topics in the ad request.
        ///
        /// Corresponds to "Topics status value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        TopicsStatus = 504,
        /// The localized name of the status of Topics in the ad request.
        ///
        /// Corresponds to "Topics status" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        TopicsStatusName = 505,
        /// Inventory top private domain dimension
        ///
        /// Corresponds to "Domain" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        TopPrivateDomain = 444,
        /// Inventory Traffic source dimension
        ///
        /// Corresponds to "Traffic source value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        TrafficSource = 388,
        /// Inventory Traffic source dimension name
        ///
        /// Corresponds to "Traffic source" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        TrafficSourceName = 389,
        /// Unified pricing rule ID dimension
        ///
        /// Corresponds to "Unified pricing rule ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        UnifiedPricingRuleId = 393,
        /// Unified pricing rule name dimension
        ///
        /// Corresponds to "Unified pricing rule" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        UnifiedPricingRuleName = 394,
        /// A URL defined under a publisher's inventory.
        ///
        /// Corresponds to "URL" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        Url = 506,
        /// A URL defined under a publisher's inventory.
        ///
        /// Corresponds to "URL ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        UrlId = 507,
        /// The choice made in a user message.
        ///
        /// Corresponds to "User choice value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `ENUM`
        UserMessagesChoice = 702,
        /// Localized name of the choice made in a user message.
        ///
        /// Corresponds to "User choice" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        UserMessagesChoiceName = 703,
        /// Enum value for the entitlement source.
        ///
        /// Corresponds to "Entitlement source value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `ENUM`
        UserMessagesEntitlementSource = 635,
        /// The localized name of the entitlement source.
        ///
        /// Corresponds to "Entitlement source" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        UserMessagesEntitlementSourceName = 636,
        /// Targeting criteria ID for the operating system group. Used for User
        /// Messages reports.
        ///
        /// Corresponds to "Operating system group ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesOperatingSystemCriteriaId = 637,
        /// The name of the operating system group. Used for User Messages reports.
        ///
        /// Corresponds to "Operating system group" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `STRING`
        UserMessagesOperatingSystemCriteriaName = 638,
        /// The VAST version of the creative that is returned for an ad request.
        ///
        /// Corresponds to "Vast version value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VastVersion = 554,
        /// The localized name of the VAST version of the creative that is returned
        /// for an ad request.
        ///
        /// Corresponds to "Vast version" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VastVersionName = 555,
        /// The break type of a video ad request.
        ///
        /// Corresponds to "Video ad break type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoAdBreakType = 556,
        /// The localized name of the break type of a video ad request.
        ///
        /// Corresponds to "Video ad break type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdBreakTypeName = 557,
        /// Video ad duration
        ///
        /// Corresponds to "Video ad duration" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdDuration = 450,
        /// The name of the video ad formats rule used to control the ad formats
        /// eligible for your inventory.
        ///
        /// Corresponds to "Video ad formats rule" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdFormatsRule = 561,
        /// The ID of the video ad formats rule used to control the ad formats
        /// eligible for your inventory.
        ///
        /// Corresponds to "Video ad formats rule ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        VideoAdFormatsRuleId = 560,
        /// The duration of a video ad request.
        ///
        /// Corresponds to "Video ad request duration value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoAdRequestDuration = 558,
        /// The localized name of the midpoint of the duration of a video ad request.
        ///
        /// Corresponds to "Video ad request duration midpoint" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdRequestDurationMidpointName = 751,
        /// The localized name of the duration of a video ad request.
        ///
        /// Corresponds to "Video ad request duration" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdRequestDurationName = 559,
        /// The video ad request source enum.
        ///
        /// Corresponds to "Ad request source value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoAdRequestSource = 438,
        /// The localized name of the video ad request source.
        ///
        /// Corresponds to "Ad request source" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdRequestSourceName = 439,
        /// Video ad type
        ///
        /// Corresponds to "Video ad type value" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoAdType = 432,
        /// Video ad type localized name
        ///
        /// Corresponds to "Video ad type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoAdTypeName = 433,
        /// The continuous play type of the video ad impression.
        ///
        /// Corresponds to "Video continuous play type value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoContinuousPlayType = 721,
        /// Video continuous play type localized name.
        ///
        /// Corresponds to "Video continuous play type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoContinuousPlayTypeName = 722,
        /// Fallback position of the video ad.
        ///
        /// Corresponds to "Fallback position" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoFallbackPosition = 530,
        /// The duration of the ad break in seconds for a live stream event.
        ///
        /// Corresponds to "Ad break duration (seconds)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoLiveStreamEventAdBreakDuration = 547,
        /// The ID of the ad break in a live stream event.
        ///
        /// Corresponds to "Live stream ad break ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoLiveStreamEventAdBreakId = 548,
        /// The name of the ad break in a live stream event.
        ///
        /// Corresponds to "Live stream ad break" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoLiveStreamEventAdBreakName = 549,
        /// The time of the ad break in a live stream event in the format of
        /// YYYY-MM-DD HH:MM:SS+Timezone.
        ///
        /// Corresponds to "Ad break time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `TIMESTAMP`
        VideoLiveStreamEventAdBreakTime = 550,
        /// The ID of the live stream event.
        ///
        /// Corresponds to "Live stream ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoLiveStreamEventId = 551,
        /// The name of the live stream event.
        ///
        /// Corresponds to "Live stream" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoLiveStreamEventName = 552,
        /// The performance of the video ad inventory broken out by source.
        ///
        /// Corresponds to "Video measurement source value" in the Ad Manager UI
        /// (when showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoMeasurementSource = 601,
        /// Video measurement source localized name.
        ///
        /// Corresponds to "Video measurement source" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoMeasurementSourceName = 602,
        /// The video placement enum as defined by ADCOM 1.0-202303.
        ///
        /// Corresponds to "Video placement value (new)" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoPlcmt = 172,
        /// The localized name of the video placement as defined by ADCOM 1.0-202303.
        ///
        /// Corresponds to "Video placement (new)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoPlcmtName = 173,
        /// The position in the video pod. For example 0, 1, 2, etc.
        ///
        /// Corresponds to "Position in pod" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoPositionInPod = 538,
        /// The position of the pod in the video stream. For example pre-roll,
        /// mid-roll, post-roll.
        ///
        /// Corresponds to "Position of pod" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoPositionOfPod = 539,
        /// The video SDK version enum.
        ///
        /// Corresponds to "Video SDK version value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoSdkVersion = 440,
        /// The localized name of the video SDK version.
        ///
        /// Corresponds to "Video SDK version" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoSdkVersionName = 441,
        /// Video stitcher type.
        ///
        /// Corresponds to "Video stitcher type value" in the Ad Manager UI (when
        /// showing API fields).
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `ENUM`
        VideoStitcherType = 752,
        /// Localized name of the video stitcher type.
        ///
        /// Corresponds to "Video stitcher type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        VideoStitcherTypeName = 753,
        /// Web property code
        ///
        /// Corresponds to "Web property code" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        WebPropertyCode = 730,
        /// Breaks down reporting data by week of the year.
        ///
        /// Corresponds to "Week" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `REACH`,
        /// `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        Week = 5,
        /// Name of the company within a yield group
        ///
        /// Corresponds to "Yield partner" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        YieldGroupBuyerName = 184,
        /// Tag of the company within a yield group.
        ///
        /// Corresponds to "Yield group buyer tag" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        YieldGroupBuyerTagName = 627,
        /// ID of the group of ad networks or exchanges used for Mediation and Open
        /// Bidding
        ///
        /// Corresponds to "Yield group ID" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `IDENTIFIER`
        YieldGroupId = 182,
        /// Name of the group of ad networks or exchanges used for Mediation and Open
        /// Bidding
        ///
        /// Corresponds to "Yield group" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `STRING`
        YieldGroupName = 183,
        /// YouTube instream ad duration bucket.
        ///
        /// Corresponds to "Ad duration value" in the Ad Manager UI (when showing API
        /// fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `ENUM`
        YoutubeAdDurationBucket = 430,
        /// YouTube instream ad duration bucket name.
        ///
        /// Corresponds to "Ad duration" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        YoutubeAdDurationBucketName = 431,
        /// YouTube instream Ad Type.
        ///
        /// Corresponds to "YouTube ad type ID" in the Ad Manager UI (when showing
        /// API fields).
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `ENUM`
        YoutubeAdType = 399,
        /// YouTube instream Ad Type localized name.
        ///
        /// Corresponds to "YouTube ad type" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `STRING`
        YoutubeAdTypeName = 400,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 0 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField0OptionId = 10000,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 1 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField1OptionId = 10001,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 2 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField2OptionId = 10002,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 3 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField3OptionId = 10003,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 4 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField4OptionId = 10004,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 5 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField5OptionId = 10005,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 6 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField6OptionId = 10006,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 7 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField7OptionId = 10007,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 8 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField8OptionId = 10008,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 9 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField9OptionId = 10009,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 10 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField10OptionId = 10010,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 11 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField11OptionId = 10011,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 12 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField12OptionId = 10012,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 13 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField13OptionId = 10013,
        /// Custom field option ID for Line Item with custom field ID equal to the ID
        /// in index 14 of `ReportDefinition.line_item_custom_field_ids`.
        LineItemCustomField14OptionId = 10014,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 0 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 0 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField0Value = 11000,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 1 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 1 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField1Value = 11001,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 2 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 2 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField2Value = 11002,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 3 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 3 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField3Value = 11003,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 4 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 4 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField4Value = 11004,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 5 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 5 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField5Value = 11005,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 6 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 6 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField6Value = 11006,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 7 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 7 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField7Value = 11007,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 8 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 8 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField8Value = 11008,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 9 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 9 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField9Value = 11009,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 10 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 10 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField10Value = 11010,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 11 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 11 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField11Value = 11011,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 12 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 12 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField12Value = 11012,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 13 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 13 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField13Value = 11013,
        /// Custom field value for Line Item with custom field ID equal to the ID
        /// in index 14 of `ReportDefinition.line_item_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 14 is of
        /// type `STRING` or `DROPDOWN`.
        LineItemCustomField14Value = 11014,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 0 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField0OptionId = 12000,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 1 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField1OptionId = 12001,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 2 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField2OptionId = 12002,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 3 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField3OptionId = 12003,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 4 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField4OptionId = 12004,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 5 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField5OptionId = 12005,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 6 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField6OptionId = 12006,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 7 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField7OptionId = 12007,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 8 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField8OptionId = 12008,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 9 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField9OptionId = 12009,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 10 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField10OptionId = 12010,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 11 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField11OptionId = 12011,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 12 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField12OptionId = 12012,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 13 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField13OptionId = 12013,
        /// Custom field option ID for Order with custom field ID equal to the ID
        /// in index 14 of `ReportDefinition.order_custom_field_ids`.
        OrderCustomField14OptionId = 12014,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 0 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 0 is of type
        /// STRING.
        OrderCustomField0Value = 13000,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 1 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 1 is of type
        /// STRING.
        OrderCustomField1Value = 13001,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 2 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 2 is of type
        /// STRING.
        OrderCustomField2Value = 13002,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 3 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 3 is of type
        /// STRING.
        OrderCustomField3Value = 13003,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 4 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 4 is of type
        /// STRING.
        OrderCustomField4Value = 13004,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 5 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 5 is of type
        /// STRING.
        OrderCustomField5Value = 13005,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 6 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 6 is of type
        /// STRING.
        OrderCustomField6Value = 13006,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 7 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 7 is of type
        /// STRING.
        OrderCustomField7Value = 13007,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 8 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 8 is of type
        /// STRING.
        OrderCustomField8Value = 13008,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 9 of `ReportDefinition.order_custom_field_ids`. Treats the value
        /// as a string. Can only be used if the custom field at index 9 is of type
        /// STRING.
        OrderCustomField9Value = 13009,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 10 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 10 is of
        /// type STRING.
        OrderCustomField10Value = 13010,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 11 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 11 is of
        /// type STRING.
        OrderCustomField11Value = 13011,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 12 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 12 is of
        /// type STRING.
        OrderCustomField12Value = 13012,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 13 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 13 is of
        /// type STRING.
        OrderCustomField13Value = 13013,
        /// Custom field value for Order with custom field ID equal to the ID
        /// in index 14 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 14 is of
        /// type STRING.
        OrderCustomField14Value = 13014,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 0 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField0OptionId = 14000,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 1 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField1OptionId = 14001,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 2 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField2OptionId = 14002,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 3 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField3OptionId = 14003,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 4 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField4OptionId = 14004,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 5 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField5OptionId = 14005,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 6 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField6OptionId = 14006,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 7 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField7OptionId = 14007,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 8 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField8OptionId = 14008,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 9 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField9OptionId = 14009,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 10 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField10OptionId = 14010,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 11 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField11OptionId = 14011,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 12 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField12OptionId = 14012,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 13 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField13OptionId = 14013,
        /// Custom field option ID for Creative with custom field ID equal to the ID
        /// in index 14 of `ReportDefinition.creative_custom_field_ids`.
        CreativeCustomField14OptionId = 14014,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 0 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 0 is of
        /// type STRING.
        CreativeCustomField0Value = 15000,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 1 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 1 is of
        /// type STRING.
        CreativeCustomField1Value = 15001,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 2 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 2 is of
        /// type STRING.
        CreativeCustomField2Value = 15002,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 3 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 3 is of
        /// type STRING.
        CreativeCustomField3Value = 15003,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 4 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 4 is of
        /// type STRING.
        CreativeCustomField4Value = 15004,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 5 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 5 is of
        /// type STRING.
        CreativeCustomField5Value = 15005,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 6 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 6 is of
        /// type STRING.
        CreativeCustomField6Value = 15006,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 7 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 7 is of
        /// type STRING.
        CreativeCustomField7Value = 15007,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 8 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 8 is of
        /// type STRING.
        CreativeCustomField8Value = 15008,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 9 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 9 is of
        /// type STRING.
        CreativeCustomField9Value = 15009,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 10 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 10 is of
        /// type STRING.
        CreativeCustomField10Value = 15010,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 11 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 11 is of
        /// type STRING.
        CreativeCustomField11Value = 15011,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 12 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 12 is of
        /// type STRING.
        CreativeCustomField12Value = 15012,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 13 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 13 is of
        /// type STRING.
        CreativeCustomField13Value = 15013,
        /// Custom field value for Creative with custom field ID equal to the ID
        /// in index 14 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 14 is of
        /// type STRING.
        CreativeCustomField14Value = 15014,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 0 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField0OptionId = 16000,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 1 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField1OptionId = 16001,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 2 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField2OptionId = 16002,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 3 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField3OptionId = 16003,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 4 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField4OptionId = 16004,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 5 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField5OptionId = 16005,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 6 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField6OptionId = 16006,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 7 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField7OptionId = 16007,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 8 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField8OptionId = 16008,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 9 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField9OptionId = 16009,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 10 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField10OptionId = 16010,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 11 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField11OptionId = 16011,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 12 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField12OptionId = 16012,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 13 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField13OptionId = 16013,
        /// Custom field option ID for Backfill line item with custom field ID equal
        /// to the ID in index 14 of `ReportDefinition.line_item_custom_field_ids`.
        BackfillLineItemCustomField14OptionId = 16014,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 0 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 0 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField0Value = 17000,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 1 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 1 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField1Value = 17001,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 2 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 2 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField2Value = 17002,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 3 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 3 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField3Value = 17003,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 4 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 4 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField4Value = 17004,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 5 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 5 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField5Value = 17005,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 6 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 6 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField6Value = 17006,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 7 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 7 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField7Value = 17007,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 8 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 8 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField8Value = 17008,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 9 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 9 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField9Value = 17009,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 10 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 10 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField10Value = 17010,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 11 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 11 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField11Value = 17011,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 12 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 12 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField12Value = 17012,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 13 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 13 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField13Value = 17013,
        /// Custom field value for Backfill line item with custom field ID equal to
        /// the ID in index 14 of `ReportDefinition.line_item_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 14 is of type `STRING` or `DROPDOWN`.
        BackfillLineItemCustomField14Value = 17014,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 0 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField0OptionId = 18000,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 1 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField1OptionId = 18001,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 2 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField2OptionId = 18002,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 3 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField3OptionId = 18003,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 4 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField4OptionId = 18004,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 5 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField5OptionId = 18005,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 6 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField6OptionId = 18006,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 7 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField7OptionId = 18007,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 8 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField8OptionId = 18008,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 9 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField9OptionId = 18009,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 10 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField10OptionId = 18010,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 11 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField11OptionId = 18011,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 12 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField12OptionId = 18012,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 13 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField13OptionId = 18013,
        /// Custom field option ID for Backfill order with custom field ID equal to
        /// the ID in index 14 of `ReportDefinition.order_custom_field_ids`.
        BackfillOrderCustomField14OptionId = 18014,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID
        /// in index 0 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 0 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField0Value = 19000,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 1 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 1 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField1Value = 19001,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 2 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 2 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField2Value = 19002,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 3 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 3 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField3Value = 19003,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 4 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 4 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField4Value = 19004,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 5 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 5 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField5Value = 19005,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 6 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 6 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField6Value = 19006,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 7 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 7 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField7Value = 19007,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 8 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 8 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField8Value = 19008,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 9 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 9 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField9Value = 19009,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 10 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 10 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField10Value = 19010,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 11 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 11 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField11Value = 19011,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 12 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 12 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField12Value = 19012,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 13 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 13 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField13Value = 19013,
        /// Custom field value for Backfill order with custom field ID equal to the
        /// ID in index 14 of `ReportDefinition.order_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 14 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillOrderCustomField14Value = 19014,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 0 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField0OptionId = 20000,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 1 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField1OptionId = 20001,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 2 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField2OptionId = 20002,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 3 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField3OptionId = 20003,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 4 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField4OptionId = 20004,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 5 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField5OptionId = 20005,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 6 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField6OptionId = 20006,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 7 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField7OptionId = 20007,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 8 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField8OptionId = 20008,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 9 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField9OptionId = 20009,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 10 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField10OptionId = 20010,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 11 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField11OptionId = 20011,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 12 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField12OptionId = 20012,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 13 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField13OptionId = 20013,
        /// Custom field option ID for Backfill creative with custom field ID equal
        /// to the ID in index 14 of `ReportDefinition.creative_custom_field_ids`.
        BackfillCreativeCustomField14OptionId = 20014,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID
        /// in index 0 of `ReportDefinition.creative_custom_field_ids`. Treats the
        /// value as a string. Can only be used if the custom field at index 0 is of
        /// type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField0Value = 21000,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 1 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 1 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField1Value = 21001,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 2 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 2 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField2Value = 21002,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 3 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 3 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField3Value = 21003,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 4 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 4 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField4Value = 21004,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 5 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 5 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField5Value = 21005,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 6 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 6 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField6Value = 21006,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 7 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 7 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField7Value = 21007,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 8 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 8 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField8Value = 21008,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 9 of `ReportDefinition.creative_custom_field_ids`. Treats
        /// the value as a string. Can only be used if the custom field at index 9 is
        /// of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField9Value = 21009,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 10 of `ReportDefinition.creative_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 10 is of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField10Value = 21010,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 11 of `ReportDefinition.creative_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 11 is of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField11Value = 21011,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 12 of `ReportDefinition.creative_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 12 is of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField12Value = 21012,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 13 of `ReportDefinition.creative_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 13 is of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField13Value = 21013,
        /// Custom field value for Backfill creative with custom field ID equal to
        /// the ID in index 14 of `ReportDefinition.creative_custom_field_ids`.
        /// Treats the value as a string. Can only be used if the custom field at
        /// index 14 is of type `STRING` or `DROPDOWN`.
        BackfillCreativeCustomField14Value = 21014,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 0 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension0ValueId = 100000,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 1 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension1ValueId = 100001,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 2 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension2ValueId = 100002,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 3 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension3ValueId = 100003,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 4 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension4ValueId = 100004,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 5 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension5ValueId = 100005,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 6 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension6ValueId = 100006,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 9 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension7ValueId = 100007,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 8 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension8ValueId = 100008,
        /// Custom Dimension Value ID for Custom Dimension with key equal to the key
        /// in index 9 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension9ValueId = 100009,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 0 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension0Value = 101000,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 1 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension1Value = 101001,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 2 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension2Value = 101002,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 3 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension3Value = 101003,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 4 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension4Value = 101004,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 5 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension5Value = 101005,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 6 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension6Value = 101006,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 7 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension7Value = 101007,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 8 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension8Value = 101008,
        /// Custom Dimension Value name for Custom Dimension with key equal to the
        /// ID in index 9 of `ReportDefinition.custom_dimension_key_ids`.
        CustomDimension9Value = 101009,
    }
    impl Dimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "DIMENSION_UNSPECIFIED",
                Self::ActiveViewMeasurementSource => "ACTIVE_VIEW_MEASUREMENT_SOURCE",
                Self::ActiveViewMeasurementSourceName => {
                    "ACTIVE_VIEW_MEASUREMENT_SOURCE_NAME"
                }
                Self::AdvertiserCreditStatus => "ADVERTISER_CREDIT_STATUS",
                Self::AdvertiserCreditStatusName => "ADVERTISER_CREDIT_STATUS_NAME",
                Self::AdvertiserDomainName => "ADVERTISER_DOMAIN_NAME",
                Self::AdvertiserExternalId => "ADVERTISER_EXTERNAL_ID",
                Self::AdvertiserId => "ADVERTISER_ID",
                Self::AdvertiserLabels => "ADVERTISER_LABELS",
                Self::AdvertiserLabelIds => "ADVERTISER_LABEL_IDS",
                Self::AdvertiserName => "ADVERTISER_NAME",
                Self::AdvertiserPrimaryContact => "ADVERTISER_PRIMARY_CONTACT",
                Self::AdvertiserStatus => "ADVERTISER_STATUS",
                Self::AdvertiserStatusName => "ADVERTISER_STATUS_NAME",
                Self::AdvertiserType => "ADVERTISER_TYPE",
                Self::AdvertiserTypeName => "ADVERTISER_TYPE_NAME",
                Self::AdvertiserVertical => "ADVERTISER_VERTICAL",
                Self::AdxProduct => "ADX_PRODUCT",
                Self::AdxProductName => "ADX_PRODUCT_NAME",
                Self::AdExperiencesType => "AD_EXPERIENCES_TYPE",
                Self::AdExperiencesTypeName => "AD_EXPERIENCES_TYPE_NAME",
                Self::AdLocation => "AD_LOCATION",
                Self::AdLocationName => "AD_LOCATION_NAME",
                Self::AdRequestSizes => "AD_REQUEST_SIZES",
                Self::AdTechnologyProviderDomain => "AD_TECHNOLOGY_PROVIDER_DOMAIN",
                Self::AdTechnologyProviderId => "AD_TECHNOLOGY_PROVIDER_ID",
                Self::AdTechnologyProviderName => "AD_TECHNOLOGY_PROVIDER_NAME",
                Self::AdType => "AD_TYPE",
                Self::AdTypeName => "AD_TYPE_NAME",
                Self::AdUnitCode => "AD_UNIT_CODE",
                Self::AdUnitCodeLevel1 => "AD_UNIT_CODE_LEVEL_1",
                Self::AdUnitCodeLevel10 => "AD_UNIT_CODE_LEVEL_10",
                Self::AdUnitCodeLevel11 => "AD_UNIT_CODE_LEVEL_11",
                Self::AdUnitCodeLevel12 => "AD_UNIT_CODE_LEVEL_12",
                Self::AdUnitCodeLevel13 => "AD_UNIT_CODE_LEVEL_13",
                Self::AdUnitCodeLevel14 => "AD_UNIT_CODE_LEVEL_14",
                Self::AdUnitCodeLevel15 => "AD_UNIT_CODE_LEVEL_15",
                Self::AdUnitCodeLevel16 => "AD_UNIT_CODE_LEVEL_16",
                Self::AdUnitCodeLevel2 => "AD_UNIT_CODE_LEVEL_2",
                Self::AdUnitCodeLevel3 => "AD_UNIT_CODE_LEVEL_3",
                Self::AdUnitCodeLevel4 => "AD_UNIT_CODE_LEVEL_4",
                Self::AdUnitCodeLevel5 => "AD_UNIT_CODE_LEVEL_5",
                Self::AdUnitCodeLevel6 => "AD_UNIT_CODE_LEVEL_6",
                Self::AdUnitCodeLevel7 => "AD_UNIT_CODE_LEVEL_7",
                Self::AdUnitCodeLevel8 => "AD_UNIT_CODE_LEVEL_8",
                Self::AdUnitCodeLevel9 => "AD_UNIT_CODE_LEVEL_9",
                Self::AdUnitId => "AD_UNIT_ID",
                Self::AdUnitIdAllLevel => "AD_UNIT_ID_ALL_LEVEL",
                Self::AdUnitIdLevel1 => "AD_UNIT_ID_LEVEL_1",
                Self::AdUnitIdLevel10 => "AD_UNIT_ID_LEVEL_10",
                Self::AdUnitIdLevel11 => "AD_UNIT_ID_LEVEL_11",
                Self::AdUnitIdLevel12 => "AD_UNIT_ID_LEVEL_12",
                Self::AdUnitIdLevel13 => "AD_UNIT_ID_LEVEL_13",
                Self::AdUnitIdLevel14 => "AD_UNIT_ID_LEVEL_14",
                Self::AdUnitIdLevel15 => "AD_UNIT_ID_LEVEL_15",
                Self::AdUnitIdLevel16 => "AD_UNIT_ID_LEVEL_16",
                Self::AdUnitIdLevel2 => "AD_UNIT_ID_LEVEL_2",
                Self::AdUnitIdLevel3 => "AD_UNIT_ID_LEVEL_3",
                Self::AdUnitIdLevel4 => "AD_UNIT_ID_LEVEL_4",
                Self::AdUnitIdLevel5 => "AD_UNIT_ID_LEVEL_5",
                Self::AdUnitIdLevel6 => "AD_UNIT_ID_LEVEL_6",
                Self::AdUnitIdLevel7 => "AD_UNIT_ID_LEVEL_7",
                Self::AdUnitIdLevel8 => "AD_UNIT_ID_LEVEL_8",
                Self::AdUnitIdLevel9 => "AD_UNIT_ID_LEVEL_9",
                Self::AdUnitIdTopLevel => "AD_UNIT_ID_TOP_LEVEL",
                Self::AdUnitName => "AD_UNIT_NAME",
                Self::AdUnitNameAllLevel => "AD_UNIT_NAME_ALL_LEVEL",
                Self::AdUnitNameLevel1 => "AD_UNIT_NAME_LEVEL_1",
                Self::AdUnitNameLevel10 => "AD_UNIT_NAME_LEVEL_10",
                Self::AdUnitNameLevel11 => "AD_UNIT_NAME_LEVEL_11",
                Self::AdUnitNameLevel12 => "AD_UNIT_NAME_LEVEL_12",
                Self::AdUnitNameLevel13 => "AD_UNIT_NAME_LEVEL_13",
                Self::AdUnitNameLevel14 => "AD_UNIT_NAME_LEVEL_14",
                Self::AdUnitNameLevel15 => "AD_UNIT_NAME_LEVEL_15",
                Self::AdUnitNameLevel16 => "AD_UNIT_NAME_LEVEL_16",
                Self::AdUnitNameLevel2 => "AD_UNIT_NAME_LEVEL_2",
                Self::AdUnitNameLevel3 => "AD_UNIT_NAME_LEVEL_3",
                Self::AdUnitNameLevel4 => "AD_UNIT_NAME_LEVEL_4",
                Self::AdUnitNameLevel5 => "AD_UNIT_NAME_LEVEL_5",
                Self::AdUnitNameLevel6 => "AD_UNIT_NAME_LEVEL_6",
                Self::AdUnitNameLevel7 => "AD_UNIT_NAME_LEVEL_7",
                Self::AdUnitNameLevel8 => "AD_UNIT_NAME_LEVEL_8",
                Self::AdUnitNameLevel9 => "AD_UNIT_NAME_LEVEL_9",
                Self::AdUnitNameTopLevel => "AD_UNIT_NAME_TOP_LEVEL",
                Self::AdUnitRewardAmount => "AD_UNIT_REWARD_AMOUNT",
                Self::AdUnitRewardType => "AD_UNIT_REWARD_TYPE",
                Self::AdUnitStatus => "AD_UNIT_STATUS",
                Self::AdUnitStatusName => "AD_UNIT_STATUS_NAME",
                Self::AgencyLevel1Id => "AGENCY_LEVEL_1_ID",
                Self::AgencyLevel1Name => "AGENCY_LEVEL_1_NAME",
                Self::AgencyLevel2Id => "AGENCY_LEVEL_2_ID",
                Self::AgencyLevel2Name => "AGENCY_LEVEL_2_NAME",
                Self::AgencyLevel3Id => "AGENCY_LEVEL_3_ID",
                Self::AgencyLevel3Name => "AGENCY_LEVEL_3_NAME",
                Self::AgeBracket => "AGE_BRACKET",
                Self::AgeBracketName => "AGE_BRACKET_NAME",
                Self::AnalyticsPropertyId => "ANALYTICS_PROPERTY_ID",
                Self::AnalyticsPropertyName => "ANALYTICS_PROPERTY_NAME",
                Self::AppTrackingTransparencyConsentStatus => {
                    "APP_TRACKING_TRANSPARENCY_CONSENT_STATUS"
                }
                Self::AppTrackingTransparencyConsentStatusName => {
                    "APP_TRACKING_TRANSPARENCY_CONSENT_STATUS_NAME"
                }
                Self::AppVersion => "APP_VERSION",
                Self::AuctionPackageDeal => "AUCTION_PACKAGE_DEAL",
                Self::AuctionPackageDealId => "AUCTION_PACKAGE_DEAL_ID",
                Self::AudienceSegmentBillable => "AUDIENCE_SEGMENT_BILLABLE",
                Self::AudienceSegmentDataProviderId => {
                    "AUDIENCE_SEGMENT_DATA_PROVIDER_ID"
                }
                Self::AudienceSegmentDataProviderName => {
                    "AUDIENCE_SEGMENT_DATA_PROVIDER_NAME"
                }
                Self::AudienceSegmentIdBillable => "AUDIENCE_SEGMENT_ID_BILLABLE",
                Self::AudienceSegmentIdTargeted => "AUDIENCE_SEGMENT_ID_TARGETED",
                Self::AudienceSegmentTargeted => "AUDIENCE_SEGMENT_TARGETED",
                Self::AudienceSegmentTargetedAdIdUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_AD_ID_USER_SIZE"
                }
                Self::AudienceSegmentTargetedAmazonFireUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_AMAZON_FIRE_USER_SIZE"
                }
                Self::AudienceSegmentTargetedAndroidTvUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_ANDROID_TV_USER_SIZE"
                }
                Self::AudienceSegmentTargetedAppleTvUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_APPLE_TV_USER_SIZE"
                }
                Self::AudienceSegmentTargetedIdfaUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_IDFA_USER_SIZE"
                }
                Self::AudienceSegmentTargetedMobileWebUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_MOBILE_WEB_USER_SIZE"
                }
                Self::AudienceSegmentTargetedPlaystationUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_PLAYSTATION_USER_SIZE"
                }
                Self::AudienceSegmentTargetedPpidUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_PPID_USER_SIZE"
                }
                Self::AudienceSegmentTargetedRokuUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_ROKU_USER_SIZE"
                }
                Self::AudienceSegmentTargetedSamsungTvUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_SAMSUNG_TV_USER_SIZE"
                }
                Self::AudienceSegmentTargetedSize => "AUDIENCE_SEGMENT_TARGETED_SIZE",
                Self::AudienceSegmentTargetedStatus => "AUDIENCE_SEGMENT_TARGETED_STATUS",
                Self::AudienceSegmentTargetedStatusName => {
                    "AUDIENCE_SEGMENT_TARGETED_STATUS_NAME"
                }
                Self::AudienceSegmentTargetedXboxUserSize => {
                    "AUDIENCE_SEGMENT_TARGETED_XBOX_USER_SIZE"
                }
                Self::AutoRefreshedTraffic => "AUTO_REFRESHED_TRAFFIC",
                Self::AutoRefreshedTrafficName => "AUTO_REFRESHED_TRAFFIC_NAME",
                Self::BidderEncryptedId => "BIDDER_ENCRYPTED_ID",
                Self::BidderName => "BIDDER_NAME",
                Self::BidRange => "BID_RANGE",
                Self::BidRejectionReason => "BID_REJECTION_REASON",
                Self::BidRejectionReasonName => "BID_REJECTION_REASON_NAME",
                Self::BrandingType => "BRANDING_TYPE",
                Self::BrandingTypeName => "BRANDING_TYPE_NAME",
                Self::BrowserCategory => "BROWSER_CATEGORY",
                Self::BrowserCategoryName => "BROWSER_CATEGORY_NAME",
                Self::BrowserId => "BROWSER_ID",
                Self::BrowserName => "BROWSER_NAME",
                Self::BuyerNetworkId => "BUYER_NETWORK_ID",
                Self::BuyerNetworkName => "BUYER_NETWORK_NAME",
                Self::CalloutStatusCategory => "CALLOUT_STATUS_CATEGORY",
                Self::CalloutStatusCategoryName => "CALLOUT_STATUS_CATEGORY_NAME",
                Self::CarrierId => "CARRIER_ID",
                Self::CarrierName => "CARRIER_NAME",
                Self::Channel => "CHANNEL",
                Self::ChildNetworkCode => "CHILD_NETWORK_CODE",
                Self::ChildNetworkId => "CHILD_NETWORK_ID",
                Self::ChildPartnerName => "CHILD_PARTNER_NAME",
                Self::CityId => "CITY_ID",
                Self::CityName => "CITY_NAME",
                Self::ClassifiedAdvertiserId => "CLASSIFIED_ADVERTISER_ID",
                Self::ClassifiedAdvertiserName => "CLASSIFIED_ADVERTISER_NAME",
                Self::ClassifiedBrandId => "CLASSIFIED_BRAND_ID",
                Self::ClassifiedBrandName => "CLASSIFIED_BRAND_NAME",
                Self::ContentBundleId => "CONTENT_BUNDLE_ID",
                Self::ContentBundleName => "CONTENT_BUNDLE_NAME",
                Self::ContentCmsMetadataKvNamespaceId => {
                    "CONTENT_CMS_METADATA_KV_NAMESPACE_ID"
                }
                Self::ContentCmsMetadataKvNamespaceName => {
                    "CONTENT_CMS_METADATA_KV_NAMESPACE_NAME"
                }
                Self::ContentCmsName => "CONTENT_CMS_NAME",
                Self::ContentCmsVideoId => "CONTENT_CMS_VIDEO_ID",
                Self::ContentId => "CONTENT_ID",
                Self::ContentMappingPresence => "CONTENT_MAPPING_PRESENCE",
                Self::ContentMappingPresenceName => "CONTENT_MAPPING_PRESENCE_NAME",
                Self::ContentName => "CONTENT_NAME",
                Self::Continent => "CONTINENT",
                Self::ContinentName => "CONTINENT_NAME",
                Self::CountryCode => "COUNTRY_CODE",
                Self::CountryId => "COUNTRY_ID",
                Self::CountryName => "COUNTRY_NAME",
                Self::CreativeBillingType => "CREATIVE_BILLING_TYPE",
                Self::CreativeBillingTypeName => "CREATIVE_BILLING_TYPE_NAME",
                Self::CreativeClickThroughUrl => "CREATIVE_CLICK_THROUGH_URL",
                Self::CreativeId => "CREATIVE_ID",
                Self::CreativeName => "CREATIVE_NAME",
                Self::CreativePoliciesFiltering => "CREATIVE_POLICIES_FILTERING",
                Self::CreativePoliciesFilteringName => "CREATIVE_POLICIES_FILTERING_NAME",
                Self::CreativeProtectionsFiltering => "CREATIVE_PROTECTIONS_FILTERING",
                Self::CreativeProtectionsFilteringName => {
                    "CREATIVE_PROTECTIONS_FILTERING_NAME"
                }
                Self::CreativeSetRoleType => "CREATIVE_SET_ROLE_TYPE",
                Self::CreativeSetRoleTypeName => "CREATIVE_SET_ROLE_TYPE_NAME",
                Self::CreativeTechnology => "CREATIVE_TECHNOLOGY",
                Self::CreativeTechnologyName => "CREATIVE_TECHNOLOGY_NAME",
                Self::CreativeThirdPartyVendor => "CREATIVE_THIRD_PARTY_VENDOR",
                Self::CreativeType => "CREATIVE_TYPE",
                Self::CreativeTypeName => "CREATIVE_TYPE_NAME",
                Self::CreativeVendorId => "CREATIVE_VENDOR_ID",
                Self::CreativeVendorName => "CREATIVE_VENDOR_NAME",
                Self::CreativeVideoRedirectThirdParty => {
                    "CREATIVE_VIDEO_REDIRECT_THIRD_PARTY"
                }
                Self::CuratorId => "CURATOR_ID",
                Self::CuratorName => "CURATOR_NAME",
                Self::CustomEventId => "CUSTOM_EVENT_ID",
                Self::CustomEventName => "CUSTOM_EVENT_NAME",
                Self::CustomEventType => "CUSTOM_EVENT_TYPE",
                Self::CustomEventTypeName => "CUSTOM_EVENT_TYPE_NAME",
                Self::CustomSpotId => "CUSTOM_SPOT_ID",
                Self::CustomSpotName => "CUSTOM_SPOT_NAME",
                Self::Date => "DATE",
                Self::DayOfWeek => "DAY_OF_WEEK",
                Self::DealBuyerId => "DEAL_BUYER_ID",
                Self::DealBuyerName => "DEAL_BUYER_NAME",
                Self::DealId => "DEAL_ID",
                Self::DealName => "DEAL_NAME",
                Self::DeliveredSecureSignalId => "DELIVERED_SECURE_SIGNAL_ID",
                Self::DeliveredSecureSignalName => "DELIVERED_SECURE_SIGNAL_NAME",
                Self::DemandChannel => "DEMAND_CHANNEL",
                Self::DemandChannelName => "DEMAND_CHANNEL_NAME",
                Self::DemandSource => "DEMAND_SOURCE",
                Self::DemandSourceName => "DEMAND_SOURCE_NAME",
                Self::DemandSubchannel => "DEMAND_SUBCHANNEL",
                Self::DemandSubchannelName => "DEMAND_SUBCHANNEL_NAME",
                Self::Device => "DEVICE",
                Self::DeviceCategory => "DEVICE_CATEGORY",
                Self::DeviceCategoryName => "DEVICE_CATEGORY_NAME",
                Self::DeviceManufacturerId => "DEVICE_MANUFACTURER_ID",
                Self::DeviceManufacturerName => "DEVICE_MANUFACTURER_NAME",
                Self::DeviceModelId => "DEVICE_MODEL_ID",
                Self::DeviceModelName => "DEVICE_MODEL_NAME",
                Self::DeviceName => "DEVICE_NAME",
                Self::DspSeatId => "DSP_SEAT_ID",
                Self::DynamicAllocationType => "DYNAMIC_ALLOCATION_TYPE",
                Self::DynamicAllocationTypeName => "DYNAMIC_ALLOCATION_TYPE_NAME",
                Self::EspDelivery => "ESP_DELIVERY",
                Self::EspDeliveryName => "ESP_DELIVERY_NAME",
                Self::EspPresence => "ESP_PRESENCE",
                Self::EspPresenceName => "ESP_PRESENCE_NAME",
                Self::ExchangeBiddingDealId => "EXCHANGE_BIDDING_DEAL_ID",
                Self::ExchangeBiddingDealType => "EXCHANGE_BIDDING_DEAL_TYPE",
                Self::ExchangeBiddingDealTypeName => "EXCHANGE_BIDDING_DEAL_TYPE_NAME",
                Self::ExchangeThirdPartyCompanyId => "EXCHANGE_THIRD_PARTY_COMPANY_ID",
                Self::ExchangeThirdPartyCompanyName => {
                    "EXCHANGE_THIRD_PARTY_COMPANY_NAME"
                }
                Self::FirstLookPricingRuleId => "FIRST_LOOK_PRICING_RULE_ID",
                Self::FirstLookPricingRuleName => "FIRST_LOOK_PRICING_RULE_NAME",
                Self::FirstPartyIdStatus => "FIRST_PARTY_ID_STATUS",
                Self::FirstPartyIdStatusName => "FIRST_PARTY_ID_STATUS_NAME",
                Self::Gender => "GENDER",
                Self::GenderName => "GENDER_NAME",
                Self::GoogleAnalyticsStreamId => "GOOGLE_ANALYTICS_STREAM_ID",
                Self::GoogleAnalyticsStreamName => "GOOGLE_ANALYTICS_STREAM_NAME",
                Self::HbtYieldPartnerId => "HBT_YIELD_PARTNER_ID",
                Self::HbtYieldPartnerName => "HBT_YIELD_PARTNER_NAME",
                Self::HeaderBidderIntegrationType => "HEADER_BIDDER_INTEGRATION_TYPE",
                Self::HeaderBidderIntegrationTypeName => {
                    "HEADER_BIDDER_INTEGRATION_TYPE_NAME"
                }
                Self::Hour => "HOUR",
                Self::ImpressionCountingMethod => "IMPRESSION_COUNTING_METHOD",
                Self::ImpressionCountingMethodName => "IMPRESSION_COUNTING_METHOD_NAME",
                Self::InteractionType => "INTERACTION_TYPE",
                Self::InteractionTypeName => "INTERACTION_TYPE_NAME",
                Self::Interest => "INTEREST",
                Self::InventoryFormat => "INVENTORY_FORMAT",
                Self::InventoryFormatName => "INVENTORY_FORMAT_NAME",
                Self::InventoryShareAssignmentId => "INVENTORY_SHARE_ASSIGNMENT_ID",
                Self::InventoryShareAssignmentName => "INVENTORY_SHARE_ASSIGNMENT_NAME",
                Self::InventoryShareOutcome => "INVENTORY_SHARE_OUTCOME",
                Self::InventoryShareOutcomeName => "INVENTORY_SHARE_OUTCOME_NAME",
                Self::InventorySharePartnerAdServer => {
                    "INVENTORY_SHARE_PARTNER_AD_SERVER"
                }
                Self::InventorySharePartnerAdServerName => {
                    "INVENTORY_SHARE_PARTNER_AD_SERVER_NAME"
                }
                Self::InventoryShareTargetSharePercent => {
                    "INVENTORY_SHARE_TARGET_SHARE_PERCENT"
                }
                Self::InventoryShareType => "INVENTORY_SHARE_TYPE",
                Self::InventoryShareTypeName => "INVENTORY_SHARE_TYPE_NAME",
                Self::InventoryType => "INVENTORY_TYPE",
                Self::InventoryTypeName => "INVENTORY_TYPE_NAME",
                Self::IsAdxDirect => "IS_ADX_DIRECT",
                Self::IsCurationTargeted => "IS_CURATION_TARGETED",
                Self::IsDropped => "IS_DROPPED",
                Self::IsFirstLookDeal => "IS_FIRST_LOOK_DEAL",
                Self::KeyValuesId => "KEY_VALUES_ID",
                Self::KeyValuesName => "KEY_VALUES_NAME",
                Self::KeyValuesSet => "KEY_VALUES_SET",
                Self::LineItemAgency => "LINE_ITEM_AGENCY",
                Self::LineItemArchived => "LINE_ITEM_ARCHIVED",
                Self::LineItemCompanionDeliveryOption => {
                    "LINE_ITEM_COMPANION_DELIVERY_OPTION"
                }
                Self::LineItemCompanionDeliveryOptionName => {
                    "LINE_ITEM_COMPANION_DELIVERY_OPTION_NAME"
                }
                Self::LineItemComputedStatus => "LINE_ITEM_COMPUTED_STATUS",
                Self::LineItemComputedStatusName => "LINE_ITEM_COMPUTED_STATUS_NAME",
                Self::LineItemContractedQuantity => "LINE_ITEM_CONTRACTED_QUANTITY",
                Self::LineItemCostPerUnit => "LINE_ITEM_COST_PER_UNIT",
                Self::LineItemCostType => "LINE_ITEM_COST_TYPE",
                Self::LineItemCostTypeName => "LINE_ITEM_COST_TYPE_NAME",
                Self::LineItemCreativeEndDate => "LINE_ITEM_CREATIVE_END_DATE",
                Self::LineItemCreativeRotationType => "LINE_ITEM_CREATIVE_ROTATION_TYPE",
                Self::LineItemCreativeRotationTypeName => {
                    "LINE_ITEM_CREATIVE_ROTATION_TYPE_NAME"
                }
                Self::LineItemCreativeStartDate => "LINE_ITEM_CREATIVE_START_DATE",
                Self::LineItemCurrencyCode => "LINE_ITEM_CURRENCY_CODE",
                Self::LineItemDeliveryIndicator => "LINE_ITEM_DELIVERY_INDICATOR",
                Self::LineItemDeliveryRateType => "LINE_ITEM_DELIVERY_RATE_TYPE",
                Self::LineItemDeliveryRateTypeName => "LINE_ITEM_DELIVERY_RATE_TYPE_NAME",
                Self::LineItemDiscountAbsolute => "LINE_ITEM_DISCOUNT_ABSOLUTE",
                Self::LineItemDiscountPercentage => "LINE_ITEM_DISCOUNT_PERCENTAGE",
                Self::LineItemEndDate => "LINE_ITEM_END_DATE",
                Self::LineItemEndDateTime => "LINE_ITEM_END_DATE_TIME",
                Self::LineItemEnvironmentType => "LINE_ITEM_ENVIRONMENT_TYPE",
                Self::LineItemEnvironmentTypeName => "LINE_ITEM_ENVIRONMENT_TYPE_NAME",
                Self::LineItemExternalDealId => "LINE_ITEM_EXTERNAL_DEAL_ID",
                Self::LineItemExternalId => "LINE_ITEM_EXTERNAL_ID",
                Self::LineItemFrequencyCap => "LINE_ITEM_FREQUENCY_CAP",
                Self::LineItemId => "LINE_ITEM_ID",
                Self::LineItemLabels => "LINE_ITEM_LABELS",
                Self::LineItemLabelIds => "LINE_ITEM_LABEL_IDS",
                Self::LineItemLastModifiedByApp => "LINE_ITEM_LAST_MODIFIED_BY_APP",
                Self::LineItemLifetimeClicks => "LINE_ITEM_LIFETIME_CLICKS",
                Self::LineItemLifetimeImpressions => "LINE_ITEM_LIFETIME_IMPRESSIONS",
                Self::LineItemLifetimeViewableImpressions => {
                    "LINE_ITEM_LIFETIME_VIEWABLE_IMPRESSIONS"
                }
                Self::LineItemMakegood => "LINE_ITEM_MAKEGOOD",
                Self::LineItemName => "LINE_ITEM_NAME",
                Self::LineItemNonCpdBookedRevenue => "LINE_ITEM_NON_CPD_BOOKED_REVENUE",
                Self::LineItemOptimizable => "LINE_ITEM_OPTIMIZABLE",
                Self::LineItemPoNumber => "LINE_ITEM_PO_NUMBER",
                Self::LineItemPrimaryGoalType => "LINE_ITEM_PRIMARY_GOAL_TYPE",
                Self::LineItemPrimaryGoalTypeName => "LINE_ITEM_PRIMARY_GOAL_TYPE_NAME",
                Self::LineItemPrimaryGoalUnitsAbsolute => {
                    "LINE_ITEM_PRIMARY_GOAL_UNITS_ABSOLUTE"
                }
                Self::LineItemPrimaryGoalUnitsPercentage => {
                    "LINE_ITEM_PRIMARY_GOAL_UNITS_PERCENTAGE"
                }
                Self::LineItemPrimaryGoalUnitType => "LINE_ITEM_PRIMARY_GOAL_UNIT_TYPE",
                Self::LineItemPrimaryGoalUnitTypeName => {
                    "LINE_ITEM_PRIMARY_GOAL_UNIT_TYPE_NAME"
                }
                Self::LineItemPriority => "LINE_ITEM_PRIORITY",
                Self::LineItemReservationStatus => "LINE_ITEM_RESERVATION_STATUS",
                Self::LineItemReservationStatusName => {
                    "LINE_ITEM_RESERVATION_STATUS_NAME"
                }
                Self::LineItemSalesperson => "LINE_ITEM_SALESPERSON",
                Self::LineItemSecondarySalespeople => "LINE_ITEM_SECONDARY_SALESPEOPLE",
                Self::LineItemSecondaryTraffickers => "LINE_ITEM_SECONDARY_TRAFFICKERS",
                Self::LineItemStartDate => "LINE_ITEM_START_DATE",
                Self::LineItemStartDateTime => "LINE_ITEM_START_DATE_TIME",
                Self::LineItemTrafficker => "LINE_ITEM_TRAFFICKER",
                Self::LineItemType => "LINE_ITEM_TYPE",
                Self::LineItemTypeName => "LINE_ITEM_TYPE_NAME",
                Self::LineItemUnlimitedEnd => "LINE_ITEM_UNLIMITED_END",
                Self::LineItemValueCostPerUnit => "LINE_ITEM_VALUE_COST_PER_UNIT",
                Self::LineItemWebPropertyCode => "LINE_ITEM_WEB_PROPERTY_CODE",
                Self::MasterCompanionCreativeId => "MASTER_COMPANION_CREATIVE_ID",
                Self::MasterCompanionCreativeName => "MASTER_COMPANION_CREATIVE_NAME",
                Self::MediationType => "MEDIATION_TYPE",
                Self::MediationTypeName => "MEDIATION_TYPE_NAME",
                Self::MediationYieldPartnerId => "MEDIATION_YIELD_PARTNER_ID",
                Self::MediationYieldPartnerName => "MEDIATION_YIELD_PARTNER_NAME",
                Self::MetroId => "METRO_ID",
                Self::MetroName => "METRO_NAME",
                Self::MobileAppFree => "MOBILE_APP_FREE",
                Self::MobileAppIconUrl => "MOBILE_APP_ICON_URL",
                Self::MobileAppId => "MOBILE_APP_ID",
                Self::MobileAppName => "MOBILE_APP_NAME",
                Self::MobileAppOwnershipStatus => "MOBILE_APP_OWNERSHIP_STATUS",
                Self::MobileAppOwnershipStatusName => "MOBILE_APP_OWNERSHIP_STATUS_NAME",
                Self::MobileAppStore => "MOBILE_APP_STORE",
                Self::MobileAppStoreName => "MOBILE_APP_STORE_NAME",
                Self::MobileInventoryType => "MOBILE_INVENTORY_TYPE",
                Self::MobileInventoryTypeName => "MOBILE_INVENTORY_TYPE_NAME",
                Self::MobileRenderingSdk => "MOBILE_RENDERING_SDK",
                Self::MobileRenderingSdkName => "MOBILE_RENDERING_SDK_NAME",
                Self::MobileSdkMajorVersion => "MOBILE_SDK_MAJOR_VERSION",
                Self::MobileSdkMinorVersion => "MOBILE_SDK_MINOR_VERSION",
                Self::MobileSdkVersionName => "MOBILE_SDK_VERSION_NAME",
                Self::MonthYear => "MONTH_YEAR",
                Self::NativeAdFormatId => "NATIVE_AD_FORMAT_ID",
                Self::NativeAdFormatName => "NATIVE_AD_FORMAT_NAME",
                Self::NativeStyleId => "NATIVE_STYLE_ID",
                Self::NativeStyleName => "NATIVE_STYLE_NAME",
                Self::NoFillReasonCategory => "NO_FILL_REASON_CATEGORY",
                Self::NoFillReasonCategoryName => "NO_FILL_REASON_CATEGORY_NAME",
                Self::OperatingSystemCategory => "OPERATING_SYSTEM_CATEGORY",
                Self::OperatingSystemCategoryName => "OPERATING_SYSTEM_CATEGORY_NAME",
                Self::OperatingSystemVersionId => "OPERATING_SYSTEM_VERSION_ID",
                Self::OperatingSystemVersionName => "OPERATING_SYSTEM_VERSION_NAME",
                Self::OptimizationType => "OPTIMIZATION_TYPE",
                Self::OptimizationTypeName => "OPTIMIZATION_TYPE_NAME",
                Self::OrderAgency => "ORDER_AGENCY",
                Self::OrderAgencyId => "ORDER_AGENCY_ID",
                Self::OrderBookedCpc => "ORDER_BOOKED_CPC",
                Self::OrderBookedCpm => "ORDER_BOOKED_CPM",
                Self::OrderDeliveryStatus => "ORDER_DELIVERY_STATUS",
                Self::OrderDeliveryStatusName => "ORDER_DELIVERY_STATUS_NAME",
                Self::OrderEndDate => "ORDER_END_DATE",
                Self::OrderEndDateTime => "ORDER_END_DATE_TIME",
                Self::OrderExternalId => "ORDER_EXTERNAL_ID",
                Self::OrderId => "ORDER_ID",
                Self::OrderLabels => "ORDER_LABELS",
                Self::OrderLabelIds => "ORDER_LABEL_IDS",
                Self::OrderLifetimeClicks => "ORDER_LIFETIME_CLICKS",
                Self::OrderLifetimeImpressions => "ORDER_LIFETIME_IMPRESSIONS",
                Self::OrderName => "ORDER_NAME",
                Self::OrderPoNumber => "ORDER_PO_NUMBER",
                Self::OrderProgrammatic => "ORDER_PROGRAMMATIC",
                Self::OrderSalesperson => "ORDER_SALESPERSON",
                Self::OrderSalespersonId => "ORDER_SALESPERSON_ID",
                Self::OrderSecondarySalespeople => "ORDER_SECONDARY_SALESPEOPLE",
                Self::OrderSecondarySalespeopleId => "ORDER_SECONDARY_SALESPEOPLE_ID",
                Self::OrderSecondaryTraffickers => "ORDER_SECONDARY_TRAFFICKERS",
                Self::OrderSecondaryTraffickersId => "ORDER_SECONDARY_TRAFFICKERS_ID",
                Self::OrderStartDate => "ORDER_START_DATE",
                Self::OrderStartDateTime => "ORDER_START_DATE_TIME",
                Self::OrderTrafficker => "ORDER_TRAFFICKER",
                Self::OrderTraffickerId => "ORDER_TRAFFICKER_ID",
                Self::OrderUnlimitedEnd => "ORDER_UNLIMITED_END",
                Self::PagePath => "PAGE_PATH",
                Self::PageTitleAndScreenClass => "PAGE_TITLE_AND_SCREEN_CLASS",
                Self::PageTitleAndScreenName => "PAGE_TITLE_AND_SCREEN_NAME",
                Self::PartnerManagementAssignmentId => "PARTNER_MANAGEMENT_ASSIGNMENT_ID",
                Self::PartnerManagementAssignmentName => {
                    "PARTNER_MANAGEMENT_ASSIGNMENT_NAME"
                }
                Self::PartnerManagementPartnerId => "PARTNER_MANAGEMENT_PARTNER_ID",
                Self::PartnerManagementPartnerName => "PARTNER_MANAGEMENT_PARTNER_NAME",
                Self::PlacementId => "PLACEMENT_ID",
                Self::PlacementIdAll => "PLACEMENT_ID_ALL",
                Self::PlacementName => "PLACEMENT_NAME",
                Self::PlacementNameAll => "PLACEMENT_NAME_ALL",
                Self::PlacementStatus => "PLACEMENT_STATUS",
                Self::PlacementStatusName => "PLACEMENT_STATUS_NAME",
                Self::PlacementStatusNameAll => "PLACEMENT_STATUS_NAME_ALL",
                Self::PostalCodeId => "POSTAL_CODE_ID",
                Self::PostalCodeName => "POSTAL_CODE_NAME",
                Self::PpidStatus => "PPID_STATUS",
                Self::PpidStatusName => "PPID_STATUS_NAME",
                Self::PredictedViewabilityBucket => "PREDICTED_VIEWABILITY_BUCKET",
                Self::PredictedViewabilityBucketName => {
                    "PREDICTED_VIEWABILITY_BUCKET_NAME"
                }
                Self::PresentedSecureSignalId => "PRESENTED_SECURE_SIGNAL_ID",
                Self::PresentedSecureSignalName => "PRESENTED_SECURE_SIGNAL_NAME",
                Self::PrimaryPersonalizationIdType => "PRIMARY_PERSONALIZATION_ID_TYPE",
                Self::PrimaryPersonalizationIdTypeName => {
                    "PRIMARY_PERSONALIZATION_ID_TYPE_NAME"
                }
                Self::ProgrammaticChannel => "PROGRAMMATIC_CHANNEL",
                Self::ProgrammaticChannelName => "PROGRAMMATIC_CHANNEL_NAME",
                Self::PublisherProvidedSignalsAllLevelsExternalCode => {
                    "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_EXTERNAL_CODE"
                }
                Self::PublisherProvidedSignalsAllLevelsIds => {
                    "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_IDS"
                }
                Self::PublisherProvidedSignalsAllLevelsName => {
                    "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_NAME"
                }
                Self::PublisherProvidedSignalsAllLevelsTier => {
                    "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_TIER"
                }
                Self::PublisherProvidedSignalsAllLevelsType => {
                    "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_TYPE"
                }
                Self::PublisherProvidedSignalsDeliveredExternalCode => {
                    "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_EXTERNAL_CODE"
                }
                Self::PublisherProvidedSignalsDeliveredIds => {
                    "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_IDS"
                }
                Self::PublisherProvidedSignalsDeliveredName => {
                    "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_NAME"
                }
                Self::PublisherProvidedSignalsDeliveredTier => {
                    "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_TIER"
                }
                Self::PublisherProvidedSignalsDeliveredType => {
                    "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_TYPE"
                }
                Self::PublisherProvidedSignalsTopLevelExternalCode => {
                    "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_EXTERNAL_CODE"
                }
                Self::PublisherProvidedSignalsTopLevelId => {
                    "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_ID"
                }
                Self::PublisherProvidedSignalsTopLevelName => {
                    "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_NAME"
                }
                Self::PublisherProvidedSignalsTopLevelTier => {
                    "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_TIER"
                }
                Self::PublisherProvidedSignalsTopLevelType => {
                    "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_TYPE"
                }
                Self::PublisherProvidedSignalDataProviderId => {
                    "PUBLISHER_PROVIDED_SIGNAL_DATA_PROVIDER_ID"
                }
                Self::PublisherProvidedSignalDataProviderName => {
                    "PUBLISHER_PROVIDED_SIGNAL_DATA_PROVIDER_NAME"
                }
                Self::RegionId => "REGION_ID",
                Self::RegionName => "REGION_NAME",
                Self::RejectionClassCategory => "REJECTION_CLASS_CATEGORY",
                Self::RejectionClassCategoryName => "REJECTION_CLASS_CATEGORY_NAME",
                Self::RenderedCreativeSize => "RENDERED_CREATIVE_SIZE",
                Self::RequestedAdSizes => "REQUESTED_AD_SIZES",
                Self::RequestType => "REQUEST_TYPE",
                Self::RequestTypeName => "REQUEST_TYPE_NAME",
                Self::RevenueVerificationId => "REVENUE_VERIFICATION_ID",
                Self::ServerSideUnwrappingEligible => "SERVER_SIDE_UNWRAPPING_ELIGIBLE",
                Self::ServingRestriction => "SERVING_RESTRICTION",
                Self::ServingRestrictionName => "SERVING_RESTRICTION_NAME",
                Self::Site => "SITE",
                Self::TargetingId => "TARGETING_ID",
                Self::TargetingName => "TARGETING_NAME",
                Self::TargetingType => "TARGETING_TYPE",
                Self::TargetingTypeName => "TARGETING_TYPE_NAME",
                Self::ThirdPartyIdStatus => "THIRD_PARTY_ID_STATUS",
                Self::ThirdPartyIdStatusName => "THIRD_PARTY_ID_STATUS_NAME",
                Self::TopicsStatus => "TOPICS_STATUS",
                Self::TopicsStatusName => "TOPICS_STATUS_NAME",
                Self::TopPrivateDomain => "TOP_PRIVATE_DOMAIN",
                Self::TrafficSource => "TRAFFIC_SOURCE",
                Self::TrafficSourceName => "TRAFFIC_SOURCE_NAME",
                Self::UnifiedPricingRuleId => "UNIFIED_PRICING_RULE_ID",
                Self::UnifiedPricingRuleName => "UNIFIED_PRICING_RULE_NAME",
                Self::Url => "URL",
                Self::UrlId => "URL_ID",
                Self::UserMessagesChoice => "USER_MESSAGES_CHOICE",
                Self::UserMessagesChoiceName => "USER_MESSAGES_CHOICE_NAME",
                Self::UserMessagesEntitlementSource => "USER_MESSAGES_ENTITLEMENT_SOURCE",
                Self::UserMessagesEntitlementSourceName => {
                    "USER_MESSAGES_ENTITLEMENT_SOURCE_NAME"
                }
                Self::UserMessagesOperatingSystemCriteriaId => {
                    "USER_MESSAGES_OPERATING_SYSTEM_CRITERIA_ID"
                }
                Self::UserMessagesOperatingSystemCriteriaName => {
                    "USER_MESSAGES_OPERATING_SYSTEM_CRITERIA_NAME"
                }
                Self::VastVersion => "VAST_VERSION",
                Self::VastVersionName => "VAST_VERSION_NAME",
                Self::VideoAdBreakType => "VIDEO_AD_BREAK_TYPE",
                Self::VideoAdBreakTypeName => "VIDEO_AD_BREAK_TYPE_NAME",
                Self::VideoAdDuration => "VIDEO_AD_DURATION",
                Self::VideoAdFormatsRule => "VIDEO_AD_FORMATS_RULE",
                Self::VideoAdFormatsRuleId => "VIDEO_AD_FORMATS_RULE_ID",
                Self::VideoAdRequestDuration => "VIDEO_AD_REQUEST_DURATION",
                Self::VideoAdRequestDurationMidpointName => {
                    "VIDEO_AD_REQUEST_DURATION_MIDPOINT_NAME"
                }
                Self::VideoAdRequestDurationName => "VIDEO_AD_REQUEST_DURATION_NAME",
                Self::VideoAdRequestSource => "VIDEO_AD_REQUEST_SOURCE",
                Self::VideoAdRequestSourceName => "VIDEO_AD_REQUEST_SOURCE_NAME",
                Self::VideoAdType => "VIDEO_AD_TYPE",
                Self::VideoAdTypeName => "VIDEO_AD_TYPE_NAME",
                Self::VideoContinuousPlayType => "VIDEO_CONTINUOUS_PLAY_TYPE",
                Self::VideoContinuousPlayTypeName => "VIDEO_CONTINUOUS_PLAY_TYPE_NAME",
                Self::VideoFallbackPosition => "VIDEO_FALLBACK_POSITION",
                Self::VideoLiveStreamEventAdBreakDuration => {
                    "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_DURATION"
                }
                Self::VideoLiveStreamEventAdBreakId => {
                    "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_ID"
                }
                Self::VideoLiveStreamEventAdBreakName => {
                    "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_NAME"
                }
                Self::VideoLiveStreamEventAdBreakTime => {
                    "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_TIME"
                }
                Self::VideoLiveStreamEventId => "VIDEO_LIVE_STREAM_EVENT_ID",
                Self::VideoLiveStreamEventName => "VIDEO_LIVE_STREAM_EVENT_NAME",
                Self::VideoMeasurementSource => "VIDEO_MEASUREMENT_SOURCE",
                Self::VideoMeasurementSourceName => "VIDEO_MEASUREMENT_SOURCE_NAME",
                Self::VideoPlcmt => "VIDEO_PLCMT",
                Self::VideoPlcmtName => "VIDEO_PLCMT_NAME",
                Self::VideoPositionInPod => "VIDEO_POSITION_IN_POD",
                Self::VideoPositionOfPod => "VIDEO_POSITION_OF_POD",
                Self::VideoSdkVersion => "VIDEO_SDK_VERSION",
                Self::VideoSdkVersionName => "VIDEO_SDK_VERSION_NAME",
                Self::VideoStitcherType => "VIDEO_STITCHER_TYPE",
                Self::VideoStitcherTypeName => "VIDEO_STITCHER_TYPE_NAME",
                Self::WebPropertyCode => "WEB_PROPERTY_CODE",
                Self::Week => "WEEK",
                Self::YieldGroupBuyerName => "YIELD_GROUP_BUYER_NAME",
                Self::YieldGroupBuyerTagName => "YIELD_GROUP_BUYER_TAG_NAME",
                Self::YieldGroupId => "YIELD_GROUP_ID",
                Self::YieldGroupName => "YIELD_GROUP_NAME",
                Self::YoutubeAdDurationBucket => "YOUTUBE_AD_DURATION_BUCKET",
                Self::YoutubeAdDurationBucketName => "YOUTUBE_AD_DURATION_BUCKET_NAME",
                Self::YoutubeAdType => "YOUTUBE_AD_TYPE",
                Self::YoutubeAdTypeName => "YOUTUBE_AD_TYPE_NAME",
                Self::LineItemCustomField0OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_0_OPTION_ID"
                }
                Self::LineItemCustomField1OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_1_OPTION_ID"
                }
                Self::LineItemCustomField2OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_2_OPTION_ID"
                }
                Self::LineItemCustomField3OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_3_OPTION_ID"
                }
                Self::LineItemCustomField4OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_4_OPTION_ID"
                }
                Self::LineItemCustomField5OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_5_OPTION_ID"
                }
                Self::LineItemCustomField6OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_6_OPTION_ID"
                }
                Self::LineItemCustomField7OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_7_OPTION_ID"
                }
                Self::LineItemCustomField8OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_8_OPTION_ID"
                }
                Self::LineItemCustomField9OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_9_OPTION_ID"
                }
                Self::LineItemCustomField10OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_10_OPTION_ID"
                }
                Self::LineItemCustomField11OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_11_OPTION_ID"
                }
                Self::LineItemCustomField12OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_12_OPTION_ID"
                }
                Self::LineItemCustomField13OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_13_OPTION_ID"
                }
                Self::LineItemCustomField14OptionId => {
                    "LINE_ITEM_CUSTOM_FIELD_14_OPTION_ID"
                }
                Self::LineItemCustomField0Value => "LINE_ITEM_CUSTOM_FIELD_0_VALUE",
                Self::LineItemCustomField1Value => "LINE_ITEM_CUSTOM_FIELD_1_VALUE",
                Self::LineItemCustomField2Value => "LINE_ITEM_CUSTOM_FIELD_2_VALUE",
                Self::LineItemCustomField3Value => "LINE_ITEM_CUSTOM_FIELD_3_VALUE",
                Self::LineItemCustomField4Value => "LINE_ITEM_CUSTOM_FIELD_4_VALUE",
                Self::LineItemCustomField5Value => "LINE_ITEM_CUSTOM_FIELD_5_VALUE",
                Self::LineItemCustomField6Value => "LINE_ITEM_CUSTOM_FIELD_6_VALUE",
                Self::LineItemCustomField7Value => "LINE_ITEM_CUSTOM_FIELD_7_VALUE",
                Self::LineItemCustomField8Value => "LINE_ITEM_CUSTOM_FIELD_8_VALUE",
                Self::LineItemCustomField9Value => "LINE_ITEM_CUSTOM_FIELD_9_VALUE",
                Self::LineItemCustomField10Value => "LINE_ITEM_CUSTOM_FIELD_10_VALUE",
                Self::LineItemCustomField11Value => "LINE_ITEM_CUSTOM_FIELD_11_VALUE",
                Self::LineItemCustomField12Value => "LINE_ITEM_CUSTOM_FIELD_12_VALUE",
                Self::LineItemCustomField13Value => "LINE_ITEM_CUSTOM_FIELD_13_VALUE",
                Self::LineItemCustomField14Value => "LINE_ITEM_CUSTOM_FIELD_14_VALUE",
                Self::OrderCustomField0OptionId => "ORDER_CUSTOM_FIELD_0_OPTION_ID",
                Self::OrderCustomField1OptionId => "ORDER_CUSTOM_FIELD_1_OPTION_ID",
                Self::OrderCustomField2OptionId => "ORDER_CUSTOM_FIELD_2_OPTION_ID",
                Self::OrderCustomField3OptionId => "ORDER_CUSTOM_FIELD_3_OPTION_ID",
                Self::OrderCustomField4OptionId => "ORDER_CUSTOM_FIELD_4_OPTION_ID",
                Self::OrderCustomField5OptionId => "ORDER_CUSTOM_FIELD_5_OPTION_ID",
                Self::OrderCustomField6OptionId => "ORDER_CUSTOM_FIELD_6_OPTION_ID",
                Self::OrderCustomField7OptionId => "ORDER_CUSTOM_FIELD_7_OPTION_ID",
                Self::OrderCustomField8OptionId => "ORDER_CUSTOM_FIELD_8_OPTION_ID",
                Self::OrderCustomField9OptionId => "ORDER_CUSTOM_FIELD_9_OPTION_ID",
                Self::OrderCustomField10OptionId => "ORDER_CUSTOM_FIELD_10_OPTION_ID",
                Self::OrderCustomField11OptionId => "ORDER_CUSTOM_FIELD_11_OPTION_ID",
                Self::OrderCustomField12OptionId => "ORDER_CUSTOM_FIELD_12_OPTION_ID",
                Self::OrderCustomField13OptionId => "ORDER_CUSTOM_FIELD_13_OPTION_ID",
                Self::OrderCustomField14OptionId => "ORDER_CUSTOM_FIELD_14_OPTION_ID",
                Self::OrderCustomField0Value => "ORDER_CUSTOM_FIELD_0_VALUE",
                Self::OrderCustomField1Value => "ORDER_CUSTOM_FIELD_1_VALUE",
                Self::OrderCustomField2Value => "ORDER_CUSTOM_FIELD_2_VALUE",
                Self::OrderCustomField3Value => "ORDER_CUSTOM_FIELD_3_VALUE",
                Self::OrderCustomField4Value => "ORDER_CUSTOM_FIELD_4_VALUE",
                Self::OrderCustomField5Value => "ORDER_CUSTOM_FIELD_5_VALUE",
                Self::OrderCustomField6Value => "ORDER_CUSTOM_FIELD_6_VALUE",
                Self::OrderCustomField7Value => "ORDER_CUSTOM_FIELD_7_VALUE",
                Self::OrderCustomField8Value => "ORDER_CUSTOM_FIELD_8_VALUE",
                Self::OrderCustomField9Value => "ORDER_CUSTOM_FIELD_9_VALUE",
                Self::OrderCustomField10Value => "ORDER_CUSTOM_FIELD_10_VALUE",
                Self::OrderCustomField11Value => "ORDER_CUSTOM_FIELD_11_VALUE",
                Self::OrderCustomField12Value => "ORDER_CUSTOM_FIELD_12_VALUE",
                Self::OrderCustomField13Value => "ORDER_CUSTOM_FIELD_13_VALUE",
                Self::OrderCustomField14Value => "ORDER_CUSTOM_FIELD_14_VALUE",
                Self::CreativeCustomField0OptionId => "CREATIVE_CUSTOM_FIELD_0_OPTION_ID",
                Self::CreativeCustomField1OptionId => "CREATIVE_CUSTOM_FIELD_1_OPTION_ID",
                Self::CreativeCustomField2OptionId => "CREATIVE_CUSTOM_FIELD_2_OPTION_ID",
                Self::CreativeCustomField3OptionId => "CREATIVE_CUSTOM_FIELD_3_OPTION_ID",
                Self::CreativeCustomField4OptionId => "CREATIVE_CUSTOM_FIELD_4_OPTION_ID",
                Self::CreativeCustomField5OptionId => "CREATIVE_CUSTOM_FIELD_5_OPTION_ID",
                Self::CreativeCustomField6OptionId => "CREATIVE_CUSTOM_FIELD_6_OPTION_ID",
                Self::CreativeCustomField7OptionId => "CREATIVE_CUSTOM_FIELD_7_OPTION_ID",
                Self::CreativeCustomField8OptionId => "CREATIVE_CUSTOM_FIELD_8_OPTION_ID",
                Self::CreativeCustomField9OptionId => "CREATIVE_CUSTOM_FIELD_9_OPTION_ID",
                Self::CreativeCustomField10OptionId => {
                    "CREATIVE_CUSTOM_FIELD_10_OPTION_ID"
                }
                Self::CreativeCustomField11OptionId => {
                    "CREATIVE_CUSTOM_FIELD_11_OPTION_ID"
                }
                Self::CreativeCustomField12OptionId => {
                    "CREATIVE_CUSTOM_FIELD_12_OPTION_ID"
                }
                Self::CreativeCustomField13OptionId => {
                    "CREATIVE_CUSTOM_FIELD_13_OPTION_ID"
                }
                Self::CreativeCustomField14OptionId => {
                    "CREATIVE_CUSTOM_FIELD_14_OPTION_ID"
                }
                Self::CreativeCustomField0Value => "CREATIVE_CUSTOM_FIELD_0_VALUE",
                Self::CreativeCustomField1Value => "CREATIVE_CUSTOM_FIELD_1_VALUE",
                Self::CreativeCustomField2Value => "CREATIVE_CUSTOM_FIELD_2_VALUE",
                Self::CreativeCustomField3Value => "CREATIVE_CUSTOM_FIELD_3_VALUE",
                Self::CreativeCustomField4Value => "CREATIVE_CUSTOM_FIELD_4_VALUE",
                Self::CreativeCustomField5Value => "CREATIVE_CUSTOM_FIELD_5_VALUE",
                Self::CreativeCustomField6Value => "CREATIVE_CUSTOM_FIELD_6_VALUE",
                Self::CreativeCustomField7Value => "CREATIVE_CUSTOM_FIELD_7_VALUE",
                Self::CreativeCustomField8Value => "CREATIVE_CUSTOM_FIELD_8_VALUE",
                Self::CreativeCustomField9Value => "CREATIVE_CUSTOM_FIELD_9_VALUE",
                Self::CreativeCustomField10Value => "CREATIVE_CUSTOM_FIELD_10_VALUE",
                Self::CreativeCustomField11Value => "CREATIVE_CUSTOM_FIELD_11_VALUE",
                Self::CreativeCustomField12Value => "CREATIVE_CUSTOM_FIELD_12_VALUE",
                Self::CreativeCustomField13Value => "CREATIVE_CUSTOM_FIELD_13_VALUE",
                Self::CreativeCustomField14Value => "CREATIVE_CUSTOM_FIELD_14_VALUE",
                Self::BackfillLineItemCustomField0OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_0_OPTION_ID"
                }
                Self::BackfillLineItemCustomField1OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_1_OPTION_ID"
                }
                Self::BackfillLineItemCustomField2OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_2_OPTION_ID"
                }
                Self::BackfillLineItemCustomField3OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_3_OPTION_ID"
                }
                Self::BackfillLineItemCustomField4OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_4_OPTION_ID"
                }
                Self::BackfillLineItemCustomField5OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_5_OPTION_ID"
                }
                Self::BackfillLineItemCustomField6OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_6_OPTION_ID"
                }
                Self::BackfillLineItemCustomField7OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_7_OPTION_ID"
                }
                Self::BackfillLineItemCustomField8OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_8_OPTION_ID"
                }
                Self::BackfillLineItemCustomField9OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_9_OPTION_ID"
                }
                Self::BackfillLineItemCustomField10OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_10_OPTION_ID"
                }
                Self::BackfillLineItemCustomField11OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_11_OPTION_ID"
                }
                Self::BackfillLineItemCustomField12OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_12_OPTION_ID"
                }
                Self::BackfillLineItemCustomField13OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_13_OPTION_ID"
                }
                Self::BackfillLineItemCustomField14OptionId => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_14_OPTION_ID"
                }
                Self::BackfillLineItemCustomField0Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_0_VALUE"
                }
                Self::BackfillLineItemCustomField1Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_1_VALUE"
                }
                Self::BackfillLineItemCustomField2Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_2_VALUE"
                }
                Self::BackfillLineItemCustomField3Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_3_VALUE"
                }
                Self::BackfillLineItemCustomField4Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_4_VALUE"
                }
                Self::BackfillLineItemCustomField5Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_5_VALUE"
                }
                Self::BackfillLineItemCustomField6Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_6_VALUE"
                }
                Self::BackfillLineItemCustomField7Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_7_VALUE"
                }
                Self::BackfillLineItemCustomField8Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_8_VALUE"
                }
                Self::BackfillLineItemCustomField9Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_9_VALUE"
                }
                Self::BackfillLineItemCustomField10Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_10_VALUE"
                }
                Self::BackfillLineItemCustomField11Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_11_VALUE"
                }
                Self::BackfillLineItemCustomField12Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_12_VALUE"
                }
                Self::BackfillLineItemCustomField13Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_13_VALUE"
                }
                Self::BackfillLineItemCustomField14Value => {
                    "BACKFILL_LINE_ITEM_CUSTOM_FIELD_14_VALUE"
                }
                Self::BackfillOrderCustomField0OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_0_OPTION_ID"
                }
                Self::BackfillOrderCustomField1OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_1_OPTION_ID"
                }
                Self::BackfillOrderCustomField2OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_2_OPTION_ID"
                }
                Self::BackfillOrderCustomField3OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_3_OPTION_ID"
                }
                Self::BackfillOrderCustomField4OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_4_OPTION_ID"
                }
                Self::BackfillOrderCustomField5OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_5_OPTION_ID"
                }
                Self::BackfillOrderCustomField6OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_6_OPTION_ID"
                }
                Self::BackfillOrderCustomField7OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_7_OPTION_ID"
                }
                Self::BackfillOrderCustomField8OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_8_OPTION_ID"
                }
                Self::BackfillOrderCustomField9OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_9_OPTION_ID"
                }
                Self::BackfillOrderCustomField10OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_10_OPTION_ID"
                }
                Self::BackfillOrderCustomField11OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_11_OPTION_ID"
                }
                Self::BackfillOrderCustomField12OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_12_OPTION_ID"
                }
                Self::BackfillOrderCustomField13OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_13_OPTION_ID"
                }
                Self::BackfillOrderCustomField14OptionId => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_14_OPTION_ID"
                }
                Self::BackfillOrderCustomField0Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_0_VALUE"
                }
                Self::BackfillOrderCustomField1Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_1_VALUE"
                }
                Self::BackfillOrderCustomField2Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_2_VALUE"
                }
                Self::BackfillOrderCustomField3Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_3_VALUE"
                }
                Self::BackfillOrderCustomField4Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_4_VALUE"
                }
                Self::BackfillOrderCustomField5Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_5_VALUE"
                }
                Self::BackfillOrderCustomField6Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_6_VALUE"
                }
                Self::BackfillOrderCustomField7Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_7_VALUE"
                }
                Self::BackfillOrderCustomField8Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_8_VALUE"
                }
                Self::BackfillOrderCustomField9Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_9_VALUE"
                }
                Self::BackfillOrderCustomField10Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_10_VALUE"
                }
                Self::BackfillOrderCustomField11Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_11_VALUE"
                }
                Self::BackfillOrderCustomField12Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_12_VALUE"
                }
                Self::BackfillOrderCustomField13Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_13_VALUE"
                }
                Self::BackfillOrderCustomField14Value => {
                    "BACKFILL_ORDER_CUSTOM_FIELD_14_VALUE"
                }
                Self::BackfillCreativeCustomField0OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_0_OPTION_ID"
                }
                Self::BackfillCreativeCustomField1OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_1_OPTION_ID"
                }
                Self::BackfillCreativeCustomField2OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_2_OPTION_ID"
                }
                Self::BackfillCreativeCustomField3OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_3_OPTION_ID"
                }
                Self::BackfillCreativeCustomField4OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_4_OPTION_ID"
                }
                Self::BackfillCreativeCustomField5OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_5_OPTION_ID"
                }
                Self::BackfillCreativeCustomField6OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_6_OPTION_ID"
                }
                Self::BackfillCreativeCustomField7OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_7_OPTION_ID"
                }
                Self::BackfillCreativeCustomField8OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_8_OPTION_ID"
                }
                Self::BackfillCreativeCustomField9OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_9_OPTION_ID"
                }
                Self::BackfillCreativeCustomField10OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_10_OPTION_ID"
                }
                Self::BackfillCreativeCustomField11OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_11_OPTION_ID"
                }
                Self::BackfillCreativeCustomField12OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_12_OPTION_ID"
                }
                Self::BackfillCreativeCustomField13OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_13_OPTION_ID"
                }
                Self::BackfillCreativeCustomField14OptionId => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_14_OPTION_ID"
                }
                Self::BackfillCreativeCustomField0Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_0_VALUE"
                }
                Self::BackfillCreativeCustomField1Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_1_VALUE"
                }
                Self::BackfillCreativeCustomField2Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_2_VALUE"
                }
                Self::BackfillCreativeCustomField3Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_3_VALUE"
                }
                Self::BackfillCreativeCustomField4Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_4_VALUE"
                }
                Self::BackfillCreativeCustomField5Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_5_VALUE"
                }
                Self::BackfillCreativeCustomField6Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_6_VALUE"
                }
                Self::BackfillCreativeCustomField7Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_7_VALUE"
                }
                Self::BackfillCreativeCustomField8Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_8_VALUE"
                }
                Self::BackfillCreativeCustomField9Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_9_VALUE"
                }
                Self::BackfillCreativeCustomField10Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_10_VALUE"
                }
                Self::BackfillCreativeCustomField11Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_11_VALUE"
                }
                Self::BackfillCreativeCustomField12Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_12_VALUE"
                }
                Self::BackfillCreativeCustomField13Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_13_VALUE"
                }
                Self::BackfillCreativeCustomField14Value => {
                    "BACKFILL_CREATIVE_CUSTOM_FIELD_14_VALUE"
                }
                Self::CustomDimension0ValueId => "CUSTOM_DIMENSION_0_VALUE_ID",
                Self::CustomDimension1ValueId => "CUSTOM_DIMENSION_1_VALUE_ID",
                Self::CustomDimension2ValueId => "CUSTOM_DIMENSION_2_VALUE_ID",
                Self::CustomDimension3ValueId => "CUSTOM_DIMENSION_3_VALUE_ID",
                Self::CustomDimension4ValueId => "CUSTOM_DIMENSION_4_VALUE_ID",
                Self::CustomDimension5ValueId => "CUSTOM_DIMENSION_5_VALUE_ID",
                Self::CustomDimension6ValueId => "CUSTOM_DIMENSION_6_VALUE_ID",
                Self::CustomDimension7ValueId => "CUSTOM_DIMENSION_7_VALUE_ID",
                Self::CustomDimension8ValueId => "CUSTOM_DIMENSION_8_VALUE_ID",
                Self::CustomDimension9ValueId => "CUSTOM_DIMENSION_9_VALUE_ID",
                Self::CustomDimension0Value => "CUSTOM_DIMENSION_0_VALUE",
                Self::CustomDimension1Value => "CUSTOM_DIMENSION_1_VALUE",
                Self::CustomDimension2Value => "CUSTOM_DIMENSION_2_VALUE",
                Self::CustomDimension3Value => "CUSTOM_DIMENSION_3_VALUE",
                Self::CustomDimension4Value => "CUSTOM_DIMENSION_4_VALUE",
                Self::CustomDimension5Value => "CUSTOM_DIMENSION_5_VALUE",
                Self::CustomDimension6Value => "CUSTOM_DIMENSION_6_VALUE",
                Self::CustomDimension7Value => "CUSTOM_DIMENSION_7_VALUE",
                Self::CustomDimension8Value => "CUSTOM_DIMENSION_8_VALUE",
                Self::CustomDimension9Value => "CUSTOM_DIMENSION_9_VALUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIMENSION_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE_VIEW_MEASUREMENT_SOURCE" => {
                    Some(Self::ActiveViewMeasurementSource)
                }
                "ACTIVE_VIEW_MEASUREMENT_SOURCE_NAME" => {
                    Some(Self::ActiveViewMeasurementSourceName)
                }
                "ADVERTISER_CREDIT_STATUS" => Some(Self::AdvertiserCreditStatus),
                "ADVERTISER_CREDIT_STATUS_NAME" => Some(Self::AdvertiserCreditStatusName),
                "ADVERTISER_DOMAIN_NAME" => Some(Self::AdvertiserDomainName),
                "ADVERTISER_EXTERNAL_ID" => Some(Self::AdvertiserExternalId),
                "ADVERTISER_ID" => Some(Self::AdvertiserId),
                "ADVERTISER_LABELS" => Some(Self::AdvertiserLabels),
                "ADVERTISER_LABEL_IDS" => Some(Self::AdvertiserLabelIds),
                "ADVERTISER_NAME" => Some(Self::AdvertiserName),
                "ADVERTISER_PRIMARY_CONTACT" => Some(Self::AdvertiserPrimaryContact),
                "ADVERTISER_STATUS" => Some(Self::AdvertiserStatus),
                "ADVERTISER_STATUS_NAME" => Some(Self::AdvertiserStatusName),
                "ADVERTISER_TYPE" => Some(Self::AdvertiserType),
                "ADVERTISER_TYPE_NAME" => Some(Self::AdvertiserTypeName),
                "ADVERTISER_VERTICAL" => Some(Self::AdvertiserVertical),
                "ADX_PRODUCT" => Some(Self::AdxProduct),
                "ADX_PRODUCT_NAME" => Some(Self::AdxProductName),
                "AD_EXPERIENCES_TYPE" => Some(Self::AdExperiencesType),
                "AD_EXPERIENCES_TYPE_NAME" => Some(Self::AdExperiencesTypeName),
                "AD_LOCATION" => Some(Self::AdLocation),
                "AD_LOCATION_NAME" => Some(Self::AdLocationName),
                "AD_REQUEST_SIZES" => Some(Self::AdRequestSizes),
                "AD_TECHNOLOGY_PROVIDER_DOMAIN" => Some(Self::AdTechnologyProviderDomain),
                "AD_TECHNOLOGY_PROVIDER_ID" => Some(Self::AdTechnologyProviderId),
                "AD_TECHNOLOGY_PROVIDER_NAME" => Some(Self::AdTechnologyProviderName),
                "AD_TYPE" => Some(Self::AdType),
                "AD_TYPE_NAME" => Some(Self::AdTypeName),
                "AD_UNIT_CODE" => Some(Self::AdUnitCode),
                "AD_UNIT_CODE_LEVEL_1" => Some(Self::AdUnitCodeLevel1),
                "AD_UNIT_CODE_LEVEL_10" => Some(Self::AdUnitCodeLevel10),
                "AD_UNIT_CODE_LEVEL_11" => Some(Self::AdUnitCodeLevel11),
                "AD_UNIT_CODE_LEVEL_12" => Some(Self::AdUnitCodeLevel12),
                "AD_UNIT_CODE_LEVEL_13" => Some(Self::AdUnitCodeLevel13),
                "AD_UNIT_CODE_LEVEL_14" => Some(Self::AdUnitCodeLevel14),
                "AD_UNIT_CODE_LEVEL_15" => Some(Self::AdUnitCodeLevel15),
                "AD_UNIT_CODE_LEVEL_16" => Some(Self::AdUnitCodeLevel16),
                "AD_UNIT_CODE_LEVEL_2" => Some(Self::AdUnitCodeLevel2),
                "AD_UNIT_CODE_LEVEL_3" => Some(Self::AdUnitCodeLevel3),
                "AD_UNIT_CODE_LEVEL_4" => Some(Self::AdUnitCodeLevel4),
                "AD_UNIT_CODE_LEVEL_5" => Some(Self::AdUnitCodeLevel5),
                "AD_UNIT_CODE_LEVEL_6" => Some(Self::AdUnitCodeLevel6),
                "AD_UNIT_CODE_LEVEL_7" => Some(Self::AdUnitCodeLevel7),
                "AD_UNIT_CODE_LEVEL_8" => Some(Self::AdUnitCodeLevel8),
                "AD_UNIT_CODE_LEVEL_9" => Some(Self::AdUnitCodeLevel9),
                "AD_UNIT_ID" => Some(Self::AdUnitId),
                "AD_UNIT_ID_ALL_LEVEL" => Some(Self::AdUnitIdAllLevel),
                "AD_UNIT_ID_LEVEL_1" => Some(Self::AdUnitIdLevel1),
                "AD_UNIT_ID_LEVEL_10" => Some(Self::AdUnitIdLevel10),
                "AD_UNIT_ID_LEVEL_11" => Some(Self::AdUnitIdLevel11),
                "AD_UNIT_ID_LEVEL_12" => Some(Self::AdUnitIdLevel12),
                "AD_UNIT_ID_LEVEL_13" => Some(Self::AdUnitIdLevel13),
                "AD_UNIT_ID_LEVEL_14" => Some(Self::AdUnitIdLevel14),
                "AD_UNIT_ID_LEVEL_15" => Some(Self::AdUnitIdLevel15),
                "AD_UNIT_ID_LEVEL_16" => Some(Self::AdUnitIdLevel16),
                "AD_UNIT_ID_LEVEL_2" => Some(Self::AdUnitIdLevel2),
                "AD_UNIT_ID_LEVEL_3" => Some(Self::AdUnitIdLevel3),
                "AD_UNIT_ID_LEVEL_4" => Some(Self::AdUnitIdLevel4),
                "AD_UNIT_ID_LEVEL_5" => Some(Self::AdUnitIdLevel5),
                "AD_UNIT_ID_LEVEL_6" => Some(Self::AdUnitIdLevel6),
                "AD_UNIT_ID_LEVEL_7" => Some(Self::AdUnitIdLevel7),
                "AD_UNIT_ID_LEVEL_8" => Some(Self::AdUnitIdLevel8),
                "AD_UNIT_ID_LEVEL_9" => Some(Self::AdUnitIdLevel9),
                "AD_UNIT_ID_TOP_LEVEL" => Some(Self::AdUnitIdTopLevel),
                "AD_UNIT_NAME" => Some(Self::AdUnitName),
                "AD_UNIT_NAME_ALL_LEVEL" => Some(Self::AdUnitNameAllLevel),
                "AD_UNIT_NAME_LEVEL_1" => Some(Self::AdUnitNameLevel1),
                "AD_UNIT_NAME_LEVEL_10" => Some(Self::AdUnitNameLevel10),
                "AD_UNIT_NAME_LEVEL_11" => Some(Self::AdUnitNameLevel11),
                "AD_UNIT_NAME_LEVEL_12" => Some(Self::AdUnitNameLevel12),
                "AD_UNIT_NAME_LEVEL_13" => Some(Self::AdUnitNameLevel13),
                "AD_UNIT_NAME_LEVEL_14" => Some(Self::AdUnitNameLevel14),
                "AD_UNIT_NAME_LEVEL_15" => Some(Self::AdUnitNameLevel15),
                "AD_UNIT_NAME_LEVEL_16" => Some(Self::AdUnitNameLevel16),
                "AD_UNIT_NAME_LEVEL_2" => Some(Self::AdUnitNameLevel2),
                "AD_UNIT_NAME_LEVEL_3" => Some(Self::AdUnitNameLevel3),
                "AD_UNIT_NAME_LEVEL_4" => Some(Self::AdUnitNameLevel4),
                "AD_UNIT_NAME_LEVEL_5" => Some(Self::AdUnitNameLevel5),
                "AD_UNIT_NAME_LEVEL_6" => Some(Self::AdUnitNameLevel6),
                "AD_UNIT_NAME_LEVEL_7" => Some(Self::AdUnitNameLevel7),
                "AD_UNIT_NAME_LEVEL_8" => Some(Self::AdUnitNameLevel8),
                "AD_UNIT_NAME_LEVEL_9" => Some(Self::AdUnitNameLevel9),
                "AD_UNIT_NAME_TOP_LEVEL" => Some(Self::AdUnitNameTopLevel),
                "AD_UNIT_REWARD_AMOUNT" => Some(Self::AdUnitRewardAmount),
                "AD_UNIT_REWARD_TYPE" => Some(Self::AdUnitRewardType),
                "AD_UNIT_STATUS" => Some(Self::AdUnitStatus),
                "AD_UNIT_STATUS_NAME" => Some(Self::AdUnitStatusName),
                "AGENCY_LEVEL_1_ID" => Some(Self::AgencyLevel1Id),
                "AGENCY_LEVEL_1_NAME" => Some(Self::AgencyLevel1Name),
                "AGENCY_LEVEL_2_ID" => Some(Self::AgencyLevel2Id),
                "AGENCY_LEVEL_2_NAME" => Some(Self::AgencyLevel2Name),
                "AGENCY_LEVEL_3_ID" => Some(Self::AgencyLevel3Id),
                "AGENCY_LEVEL_3_NAME" => Some(Self::AgencyLevel3Name),
                "AGE_BRACKET" => Some(Self::AgeBracket),
                "AGE_BRACKET_NAME" => Some(Self::AgeBracketName),
                "ANALYTICS_PROPERTY_ID" => Some(Self::AnalyticsPropertyId),
                "ANALYTICS_PROPERTY_NAME" => Some(Self::AnalyticsPropertyName),
                "APP_TRACKING_TRANSPARENCY_CONSENT_STATUS" => {
                    Some(Self::AppTrackingTransparencyConsentStatus)
                }
                "APP_TRACKING_TRANSPARENCY_CONSENT_STATUS_NAME" => {
                    Some(Self::AppTrackingTransparencyConsentStatusName)
                }
                "APP_VERSION" => Some(Self::AppVersion),
                "AUCTION_PACKAGE_DEAL" => Some(Self::AuctionPackageDeal),
                "AUCTION_PACKAGE_DEAL_ID" => Some(Self::AuctionPackageDealId),
                "AUDIENCE_SEGMENT_BILLABLE" => Some(Self::AudienceSegmentBillable),
                "AUDIENCE_SEGMENT_DATA_PROVIDER_ID" => {
                    Some(Self::AudienceSegmentDataProviderId)
                }
                "AUDIENCE_SEGMENT_DATA_PROVIDER_NAME" => {
                    Some(Self::AudienceSegmentDataProviderName)
                }
                "AUDIENCE_SEGMENT_ID_BILLABLE" => Some(Self::AudienceSegmentIdBillable),
                "AUDIENCE_SEGMENT_ID_TARGETED" => Some(Self::AudienceSegmentIdTargeted),
                "AUDIENCE_SEGMENT_TARGETED" => Some(Self::AudienceSegmentTargeted),
                "AUDIENCE_SEGMENT_TARGETED_AD_ID_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedAdIdUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_AMAZON_FIRE_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedAmazonFireUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_ANDROID_TV_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedAndroidTvUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_APPLE_TV_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedAppleTvUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_IDFA_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedIdfaUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_MOBILE_WEB_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedMobileWebUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_PLAYSTATION_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedPlaystationUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_PPID_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedPpidUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_ROKU_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedRokuUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_SAMSUNG_TV_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedSamsungTvUserSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_SIZE" => {
                    Some(Self::AudienceSegmentTargetedSize)
                }
                "AUDIENCE_SEGMENT_TARGETED_STATUS" => {
                    Some(Self::AudienceSegmentTargetedStatus)
                }
                "AUDIENCE_SEGMENT_TARGETED_STATUS_NAME" => {
                    Some(Self::AudienceSegmentTargetedStatusName)
                }
                "AUDIENCE_SEGMENT_TARGETED_XBOX_USER_SIZE" => {
                    Some(Self::AudienceSegmentTargetedXboxUserSize)
                }
                "AUTO_REFRESHED_TRAFFIC" => Some(Self::AutoRefreshedTraffic),
                "AUTO_REFRESHED_TRAFFIC_NAME" => Some(Self::AutoRefreshedTrafficName),
                "BIDDER_ENCRYPTED_ID" => Some(Self::BidderEncryptedId),
                "BIDDER_NAME" => Some(Self::BidderName),
                "BID_RANGE" => Some(Self::BidRange),
                "BID_REJECTION_REASON" => Some(Self::BidRejectionReason),
                "BID_REJECTION_REASON_NAME" => Some(Self::BidRejectionReasonName),
                "BRANDING_TYPE" => Some(Self::BrandingType),
                "BRANDING_TYPE_NAME" => Some(Self::BrandingTypeName),
                "BROWSER_CATEGORY" => Some(Self::BrowserCategory),
                "BROWSER_CATEGORY_NAME" => Some(Self::BrowserCategoryName),
                "BROWSER_ID" => Some(Self::BrowserId),
                "BROWSER_NAME" => Some(Self::BrowserName),
                "BUYER_NETWORK_ID" => Some(Self::BuyerNetworkId),
                "BUYER_NETWORK_NAME" => Some(Self::BuyerNetworkName),
                "CALLOUT_STATUS_CATEGORY" => Some(Self::CalloutStatusCategory),
                "CALLOUT_STATUS_CATEGORY_NAME" => Some(Self::CalloutStatusCategoryName),
                "CARRIER_ID" => Some(Self::CarrierId),
                "CARRIER_NAME" => Some(Self::CarrierName),
                "CHANNEL" => Some(Self::Channel),
                "CHILD_NETWORK_CODE" => Some(Self::ChildNetworkCode),
                "CHILD_NETWORK_ID" => Some(Self::ChildNetworkId),
                "CHILD_PARTNER_NAME" => Some(Self::ChildPartnerName),
                "CITY_ID" => Some(Self::CityId),
                "CITY_NAME" => Some(Self::CityName),
                "CLASSIFIED_ADVERTISER_ID" => Some(Self::ClassifiedAdvertiserId),
                "CLASSIFIED_ADVERTISER_NAME" => Some(Self::ClassifiedAdvertiserName),
                "CLASSIFIED_BRAND_ID" => Some(Self::ClassifiedBrandId),
                "CLASSIFIED_BRAND_NAME" => Some(Self::ClassifiedBrandName),
                "CONTENT_BUNDLE_ID" => Some(Self::ContentBundleId),
                "CONTENT_BUNDLE_NAME" => Some(Self::ContentBundleName),
                "CONTENT_CMS_METADATA_KV_NAMESPACE_ID" => {
                    Some(Self::ContentCmsMetadataKvNamespaceId)
                }
                "CONTENT_CMS_METADATA_KV_NAMESPACE_NAME" => {
                    Some(Self::ContentCmsMetadataKvNamespaceName)
                }
                "CONTENT_CMS_NAME" => Some(Self::ContentCmsName),
                "CONTENT_CMS_VIDEO_ID" => Some(Self::ContentCmsVideoId),
                "CONTENT_ID" => Some(Self::ContentId),
                "CONTENT_MAPPING_PRESENCE" => Some(Self::ContentMappingPresence),
                "CONTENT_MAPPING_PRESENCE_NAME" => Some(Self::ContentMappingPresenceName),
                "CONTENT_NAME" => Some(Self::ContentName),
                "CONTINENT" => Some(Self::Continent),
                "CONTINENT_NAME" => Some(Self::ContinentName),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "COUNTRY_ID" => Some(Self::CountryId),
                "COUNTRY_NAME" => Some(Self::CountryName),
                "CREATIVE_BILLING_TYPE" => Some(Self::CreativeBillingType),
                "CREATIVE_BILLING_TYPE_NAME" => Some(Self::CreativeBillingTypeName),
                "CREATIVE_CLICK_THROUGH_URL" => Some(Self::CreativeClickThroughUrl),
                "CREATIVE_ID" => Some(Self::CreativeId),
                "CREATIVE_NAME" => Some(Self::CreativeName),
                "CREATIVE_POLICIES_FILTERING" => Some(Self::CreativePoliciesFiltering),
                "CREATIVE_POLICIES_FILTERING_NAME" => {
                    Some(Self::CreativePoliciesFilteringName)
                }
                "CREATIVE_PROTECTIONS_FILTERING" => {
                    Some(Self::CreativeProtectionsFiltering)
                }
                "CREATIVE_PROTECTIONS_FILTERING_NAME" => {
                    Some(Self::CreativeProtectionsFilteringName)
                }
                "CREATIVE_SET_ROLE_TYPE" => Some(Self::CreativeSetRoleType),
                "CREATIVE_SET_ROLE_TYPE_NAME" => Some(Self::CreativeSetRoleTypeName),
                "CREATIVE_TECHNOLOGY" => Some(Self::CreativeTechnology),
                "CREATIVE_TECHNOLOGY_NAME" => Some(Self::CreativeTechnologyName),
                "CREATIVE_THIRD_PARTY_VENDOR" => Some(Self::CreativeThirdPartyVendor),
                "CREATIVE_TYPE" => Some(Self::CreativeType),
                "CREATIVE_TYPE_NAME" => Some(Self::CreativeTypeName),
                "CREATIVE_VENDOR_ID" => Some(Self::CreativeVendorId),
                "CREATIVE_VENDOR_NAME" => Some(Self::CreativeVendorName),
                "CREATIVE_VIDEO_REDIRECT_THIRD_PARTY" => {
                    Some(Self::CreativeVideoRedirectThirdParty)
                }
                "CURATOR_ID" => Some(Self::CuratorId),
                "CURATOR_NAME" => Some(Self::CuratorName),
                "CUSTOM_EVENT_ID" => Some(Self::CustomEventId),
                "CUSTOM_EVENT_NAME" => Some(Self::CustomEventName),
                "CUSTOM_EVENT_TYPE" => Some(Self::CustomEventType),
                "CUSTOM_EVENT_TYPE_NAME" => Some(Self::CustomEventTypeName),
                "CUSTOM_SPOT_ID" => Some(Self::CustomSpotId),
                "CUSTOM_SPOT_NAME" => Some(Self::CustomSpotName),
                "DATE" => Some(Self::Date),
                "DAY_OF_WEEK" => Some(Self::DayOfWeek),
                "DEAL_BUYER_ID" => Some(Self::DealBuyerId),
                "DEAL_BUYER_NAME" => Some(Self::DealBuyerName),
                "DEAL_ID" => Some(Self::DealId),
                "DEAL_NAME" => Some(Self::DealName),
                "DELIVERED_SECURE_SIGNAL_ID" => Some(Self::DeliveredSecureSignalId),
                "DELIVERED_SECURE_SIGNAL_NAME" => Some(Self::DeliveredSecureSignalName),
                "DEMAND_CHANNEL" => Some(Self::DemandChannel),
                "DEMAND_CHANNEL_NAME" => Some(Self::DemandChannelName),
                "DEMAND_SOURCE" => Some(Self::DemandSource),
                "DEMAND_SOURCE_NAME" => Some(Self::DemandSourceName),
                "DEMAND_SUBCHANNEL" => Some(Self::DemandSubchannel),
                "DEMAND_SUBCHANNEL_NAME" => Some(Self::DemandSubchannelName),
                "DEVICE" => Some(Self::Device),
                "DEVICE_CATEGORY" => Some(Self::DeviceCategory),
                "DEVICE_CATEGORY_NAME" => Some(Self::DeviceCategoryName),
                "DEVICE_MANUFACTURER_ID" => Some(Self::DeviceManufacturerId),
                "DEVICE_MANUFACTURER_NAME" => Some(Self::DeviceManufacturerName),
                "DEVICE_MODEL_ID" => Some(Self::DeviceModelId),
                "DEVICE_MODEL_NAME" => Some(Self::DeviceModelName),
                "DEVICE_NAME" => Some(Self::DeviceName),
                "DSP_SEAT_ID" => Some(Self::DspSeatId),
                "DYNAMIC_ALLOCATION_TYPE" => Some(Self::DynamicAllocationType),
                "DYNAMIC_ALLOCATION_TYPE_NAME" => Some(Self::DynamicAllocationTypeName),
                "ESP_DELIVERY" => Some(Self::EspDelivery),
                "ESP_DELIVERY_NAME" => Some(Self::EspDeliveryName),
                "ESP_PRESENCE" => Some(Self::EspPresence),
                "ESP_PRESENCE_NAME" => Some(Self::EspPresenceName),
                "EXCHANGE_BIDDING_DEAL_ID" => Some(Self::ExchangeBiddingDealId),
                "EXCHANGE_BIDDING_DEAL_TYPE" => Some(Self::ExchangeBiddingDealType),
                "EXCHANGE_BIDDING_DEAL_TYPE_NAME" => {
                    Some(Self::ExchangeBiddingDealTypeName)
                }
                "EXCHANGE_THIRD_PARTY_COMPANY_ID" => {
                    Some(Self::ExchangeThirdPartyCompanyId)
                }
                "EXCHANGE_THIRD_PARTY_COMPANY_NAME" => {
                    Some(Self::ExchangeThirdPartyCompanyName)
                }
                "FIRST_LOOK_PRICING_RULE_ID" => Some(Self::FirstLookPricingRuleId),
                "FIRST_LOOK_PRICING_RULE_NAME" => Some(Self::FirstLookPricingRuleName),
                "FIRST_PARTY_ID_STATUS" => Some(Self::FirstPartyIdStatus),
                "FIRST_PARTY_ID_STATUS_NAME" => Some(Self::FirstPartyIdStatusName),
                "GENDER" => Some(Self::Gender),
                "GENDER_NAME" => Some(Self::GenderName),
                "GOOGLE_ANALYTICS_STREAM_ID" => Some(Self::GoogleAnalyticsStreamId),
                "GOOGLE_ANALYTICS_STREAM_NAME" => Some(Self::GoogleAnalyticsStreamName),
                "HBT_YIELD_PARTNER_ID" => Some(Self::HbtYieldPartnerId),
                "HBT_YIELD_PARTNER_NAME" => Some(Self::HbtYieldPartnerName),
                "HEADER_BIDDER_INTEGRATION_TYPE" => {
                    Some(Self::HeaderBidderIntegrationType)
                }
                "HEADER_BIDDER_INTEGRATION_TYPE_NAME" => {
                    Some(Self::HeaderBidderIntegrationTypeName)
                }
                "HOUR" => Some(Self::Hour),
                "IMPRESSION_COUNTING_METHOD" => Some(Self::ImpressionCountingMethod),
                "IMPRESSION_COUNTING_METHOD_NAME" => {
                    Some(Self::ImpressionCountingMethodName)
                }
                "INTERACTION_TYPE" => Some(Self::InteractionType),
                "INTERACTION_TYPE_NAME" => Some(Self::InteractionTypeName),
                "INTEREST" => Some(Self::Interest),
                "INVENTORY_FORMAT" => Some(Self::InventoryFormat),
                "INVENTORY_FORMAT_NAME" => Some(Self::InventoryFormatName),
                "INVENTORY_SHARE_ASSIGNMENT_ID" => Some(Self::InventoryShareAssignmentId),
                "INVENTORY_SHARE_ASSIGNMENT_NAME" => {
                    Some(Self::InventoryShareAssignmentName)
                }
                "INVENTORY_SHARE_OUTCOME" => Some(Self::InventoryShareOutcome),
                "INVENTORY_SHARE_OUTCOME_NAME" => Some(Self::InventoryShareOutcomeName),
                "INVENTORY_SHARE_PARTNER_AD_SERVER" => {
                    Some(Self::InventorySharePartnerAdServer)
                }
                "INVENTORY_SHARE_PARTNER_AD_SERVER_NAME" => {
                    Some(Self::InventorySharePartnerAdServerName)
                }
                "INVENTORY_SHARE_TARGET_SHARE_PERCENT" => {
                    Some(Self::InventoryShareTargetSharePercent)
                }
                "INVENTORY_SHARE_TYPE" => Some(Self::InventoryShareType),
                "INVENTORY_SHARE_TYPE_NAME" => Some(Self::InventoryShareTypeName),
                "INVENTORY_TYPE" => Some(Self::InventoryType),
                "INVENTORY_TYPE_NAME" => Some(Self::InventoryTypeName),
                "IS_ADX_DIRECT" => Some(Self::IsAdxDirect),
                "IS_CURATION_TARGETED" => Some(Self::IsCurationTargeted),
                "IS_DROPPED" => Some(Self::IsDropped),
                "IS_FIRST_LOOK_DEAL" => Some(Self::IsFirstLookDeal),
                "KEY_VALUES_ID" => Some(Self::KeyValuesId),
                "KEY_VALUES_NAME" => Some(Self::KeyValuesName),
                "KEY_VALUES_SET" => Some(Self::KeyValuesSet),
                "LINE_ITEM_AGENCY" => Some(Self::LineItemAgency),
                "LINE_ITEM_ARCHIVED" => Some(Self::LineItemArchived),
                "LINE_ITEM_COMPANION_DELIVERY_OPTION" => {
                    Some(Self::LineItemCompanionDeliveryOption)
                }
                "LINE_ITEM_COMPANION_DELIVERY_OPTION_NAME" => {
                    Some(Self::LineItemCompanionDeliveryOptionName)
                }
                "LINE_ITEM_COMPUTED_STATUS" => Some(Self::LineItemComputedStatus),
                "LINE_ITEM_COMPUTED_STATUS_NAME" => {
                    Some(Self::LineItemComputedStatusName)
                }
                "LINE_ITEM_CONTRACTED_QUANTITY" => Some(Self::LineItemContractedQuantity),
                "LINE_ITEM_COST_PER_UNIT" => Some(Self::LineItemCostPerUnit),
                "LINE_ITEM_COST_TYPE" => Some(Self::LineItemCostType),
                "LINE_ITEM_COST_TYPE_NAME" => Some(Self::LineItemCostTypeName),
                "LINE_ITEM_CREATIVE_END_DATE" => Some(Self::LineItemCreativeEndDate),
                "LINE_ITEM_CREATIVE_ROTATION_TYPE" => {
                    Some(Self::LineItemCreativeRotationType)
                }
                "LINE_ITEM_CREATIVE_ROTATION_TYPE_NAME" => {
                    Some(Self::LineItemCreativeRotationTypeName)
                }
                "LINE_ITEM_CREATIVE_START_DATE" => Some(Self::LineItemCreativeStartDate),
                "LINE_ITEM_CURRENCY_CODE" => Some(Self::LineItemCurrencyCode),
                "LINE_ITEM_DELIVERY_INDICATOR" => Some(Self::LineItemDeliveryIndicator),
                "LINE_ITEM_DELIVERY_RATE_TYPE" => Some(Self::LineItemDeliveryRateType),
                "LINE_ITEM_DELIVERY_RATE_TYPE_NAME" => {
                    Some(Self::LineItemDeliveryRateTypeName)
                }
                "LINE_ITEM_DISCOUNT_ABSOLUTE" => Some(Self::LineItemDiscountAbsolute),
                "LINE_ITEM_DISCOUNT_PERCENTAGE" => Some(Self::LineItemDiscountPercentage),
                "LINE_ITEM_END_DATE" => Some(Self::LineItemEndDate),
                "LINE_ITEM_END_DATE_TIME" => Some(Self::LineItemEndDateTime),
                "LINE_ITEM_ENVIRONMENT_TYPE" => Some(Self::LineItemEnvironmentType),
                "LINE_ITEM_ENVIRONMENT_TYPE_NAME" => {
                    Some(Self::LineItemEnvironmentTypeName)
                }
                "LINE_ITEM_EXTERNAL_DEAL_ID" => Some(Self::LineItemExternalDealId),
                "LINE_ITEM_EXTERNAL_ID" => Some(Self::LineItemExternalId),
                "LINE_ITEM_FREQUENCY_CAP" => Some(Self::LineItemFrequencyCap),
                "LINE_ITEM_ID" => Some(Self::LineItemId),
                "LINE_ITEM_LABELS" => Some(Self::LineItemLabels),
                "LINE_ITEM_LABEL_IDS" => Some(Self::LineItemLabelIds),
                "LINE_ITEM_LAST_MODIFIED_BY_APP" => Some(Self::LineItemLastModifiedByApp),
                "LINE_ITEM_LIFETIME_CLICKS" => Some(Self::LineItemLifetimeClicks),
                "LINE_ITEM_LIFETIME_IMPRESSIONS" => {
                    Some(Self::LineItemLifetimeImpressions)
                }
                "LINE_ITEM_LIFETIME_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::LineItemLifetimeViewableImpressions)
                }
                "LINE_ITEM_MAKEGOOD" => Some(Self::LineItemMakegood),
                "LINE_ITEM_NAME" => Some(Self::LineItemName),
                "LINE_ITEM_NON_CPD_BOOKED_REVENUE" => {
                    Some(Self::LineItemNonCpdBookedRevenue)
                }
                "LINE_ITEM_OPTIMIZABLE" => Some(Self::LineItemOptimizable),
                "LINE_ITEM_PO_NUMBER" => Some(Self::LineItemPoNumber),
                "LINE_ITEM_PRIMARY_GOAL_TYPE" => Some(Self::LineItemPrimaryGoalType),
                "LINE_ITEM_PRIMARY_GOAL_TYPE_NAME" => {
                    Some(Self::LineItemPrimaryGoalTypeName)
                }
                "LINE_ITEM_PRIMARY_GOAL_UNITS_ABSOLUTE" => {
                    Some(Self::LineItemPrimaryGoalUnitsAbsolute)
                }
                "LINE_ITEM_PRIMARY_GOAL_UNITS_PERCENTAGE" => {
                    Some(Self::LineItemPrimaryGoalUnitsPercentage)
                }
                "LINE_ITEM_PRIMARY_GOAL_UNIT_TYPE" => {
                    Some(Self::LineItemPrimaryGoalUnitType)
                }
                "LINE_ITEM_PRIMARY_GOAL_UNIT_TYPE_NAME" => {
                    Some(Self::LineItemPrimaryGoalUnitTypeName)
                }
                "LINE_ITEM_PRIORITY" => Some(Self::LineItemPriority),
                "LINE_ITEM_RESERVATION_STATUS" => Some(Self::LineItemReservationStatus),
                "LINE_ITEM_RESERVATION_STATUS_NAME" => {
                    Some(Self::LineItemReservationStatusName)
                }
                "LINE_ITEM_SALESPERSON" => Some(Self::LineItemSalesperson),
                "LINE_ITEM_SECONDARY_SALESPEOPLE" => {
                    Some(Self::LineItemSecondarySalespeople)
                }
                "LINE_ITEM_SECONDARY_TRAFFICKERS" => {
                    Some(Self::LineItemSecondaryTraffickers)
                }
                "LINE_ITEM_START_DATE" => Some(Self::LineItemStartDate),
                "LINE_ITEM_START_DATE_TIME" => Some(Self::LineItemStartDateTime),
                "LINE_ITEM_TRAFFICKER" => Some(Self::LineItemTrafficker),
                "LINE_ITEM_TYPE" => Some(Self::LineItemType),
                "LINE_ITEM_TYPE_NAME" => Some(Self::LineItemTypeName),
                "LINE_ITEM_UNLIMITED_END" => Some(Self::LineItemUnlimitedEnd),
                "LINE_ITEM_VALUE_COST_PER_UNIT" => Some(Self::LineItemValueCostPerUnit),
                "LINE_ITEM_WEB_PROPERTY_CODE" => Some(Self::LineItemWebPropertyCode),
                "MASTER_COMPANION_CREATIVE_ID" => Some(Self::MasterCompanionCreativeId),
                "MASTER_COMPANION_CREATIVE_NAME" => {
                    Some(Self::MasterCompanionCreativeName)
                }
                "MEDIATION_TYPE" => Some(Self::MediationType),
                "MEDIATION_TYPE_NAME" => Some(Self::MediationTypeName),
                "MEDIATION_YIELD_PARTNER_ID" => Some(Self::MediationYieldPartnerId),
                "MEDIATION_YIELD_PARTNER_NAME" => Some(Self::MediationYieldPartnerName),
                "METRO_ID" => Some(Self::MetroId),
                "METRO_NAME" => Some(Self::MetroName),
                "MOBILE_APP_FREE" => Some(Self::MobileAppFree),
                "MOBILE_APP_ICON_URL" => Some(Self::MobileAppIconUrl),
                "MOBILE_APP_ID" => Some(Self::MobileAppId),
                "MOBILE_APP_NAME" => Some(Self::MobileAppName),
                "MOBILE_APP_OWNERSHIP_STATUS" => Some(Self::MobileAppOwnershipStatus),
                "MOBILE_APP_OWNERSHIP_STATUS_NAME" => {
                    Some(Self::MobileAppOwnershipStatusName)
                }
                "MOBILE_APP_STORE" => Some(Self::MobileAppStore),
                "MOBILE_APP_STORE_NAME" => Some(Self::MobileAppStoreName),
                "MOBILE_INVENTORY_TYPE" => Some(Self::MobileInventoryType),
                "MOBILE_INVENTORY_TYPE_NAME" => Some(Self::MobileInventoryTypeName),
                "MOBILE_RENDERING_SDK" => Some(Self::MobileRenderingSdk),
                "MOBILE_RENDERING_SDK_NAME" => Some(Self::MobileRenderingSdkName),
                "MOBILE_SDK_MAJOR_VERSION" => Some(Self::MobileSdkMajorVersion),
                "MOBILE_SDK_MINOR_VERSION" => Some(Self::MobileSdkMinorVersion),
                "MOBILE_SDK_VERSION_NAME" => Some(Self::MobileSdkVersionName),
                "MONTH_YEAR" => Some(Self::MonthYear),
                "NATIVE_AD_FORMAT_ID" => Some(Self::NativeAdFormatId),
                "NATIVE_AD_FORMAT_NAME" => Some(Self::NativeAdFormatName),
                "NATIVE_STYLE_ID" => Some(Self::NativeStyleId),
                "NATIVE_STYLE_NAME" => Some(Self::NativeStyleName),
                "NO_FILL_REASON_CATEGORY" => Some(Self::NoFillReasonCategory),
                "NO_FILL_REASON_CATEGORY_NAME" => Some(Self::NoFillReasonCategoryName),
                "OPERATING_SYSTEM_CATEGORY" => Some(Self::OperatingSystemCategory),
                "OPERATING_SYSTEM_CATEGORY_NAME" => {
                    Some(Self::OperatingSystemCategoryName)
                }
                "OPERATING_SYSTEM_VERSION_ID" => Some(Self::OperatingSystemVersionId),
                "OPERATING_SYSTEM_VERSION_NAME" => Some(Self::OperatingSystemVersionName),
                "OPTIMIZATION_TYPE" => Some(Self::OptimizationType),
                "OPTIMIZATION_TYPE_NAME" => Some(Self::OptimizationTypeName),
                "ORDER_AGENCY" => Some(Self::OrderAgency),
                "ORDER_AGENCY_ID" => Some(Self::OrderAgencyId),
                "ORDER_BOOKED_CPC" => Some(Self::OrderBookedCpc),
                "ORDER_BOOKED_CPM" => Some(Self::OrderBookedCpm),
                "ORDER_DELIVERY_STATUS" => Some(Self::OrderDeliveryStatus),
                "ORDER_DELIVERY_STATUS_NAME" => Some(Self::OrderDeliveryStatusName),
                "ORDER_END_DATE" => Some(Self::OrderEndDate),
                "ORDER_END_DATE_TIME" => Some(Self::OrderEndDateTime),
                "ORDER_EXTERNAL_ID" => Some(Self::OrderExternalId),
                "ORDER_ID" => Some(Self::OrderId),
                "ORDER_LABELS" => Some(Self::OrderLabels),
                "ORDER_LABEL_IDS" => Some(Self::OrderLabelIds),
                "ORDER_LIFETIME_CLICKS" => Some(Self::OrderLifetimeClicks),
                "ORDER_LIFETIME_IMPRESSIONS" => Some(Self::OrderLifetimeImpressions),
                "ORDER_NAME" => Some(Self::OrderName),
                "ORDER_PO_NUMBER" => Some(Self::OrderPoNumber),
                "ORDER_PROGRAMMATIC" => Some(Self::OrderProgrammatic),
                "ORDER_SALESPERSON" => Some(Self::OrderSalesperson),
                "ORDER_SALESPERSON_ID" => Some(Self::OrderSalespersonId),
                "ORDER_SECONDARY_SALESPEOPLE" => Some(Self::OrderSecondarySalespeople),
                "ORDER_SECONDARY_SALESPEOPLE_ID" => {
                    Some(Self::OrderSecondarySalespeopleId)
                }
                "ORDER_SECONDARY_TRAFFICKERS" => Some(Self::OrderSecondaryTraffickers),
                "ORDER_SECONDARY_TRAFFICKERS_ID" => {
                    Some(Self::OrderSecondaryTraffickersId)
                }
                "ORDER_START_DATE" => Some(Self::OrderStartDate),
                "ORDER_START_DATE_TIME" => Some(Self::OrderStartDateTime),
                "ORDER_TRAFFICKER" => Some(Self::OrderTrafficker),
                "ORDER_TRAFFICKER_ID" => Some(Self::OrderTraffickerId),
                "ORDER_UNLIMITED_END" => Some(Self::OrderUnlimitedEnd),
                "PAGE_PATH" => Some(Self::PagePath),
                "PAGE_TITLE_AND_SCREEN_CLASS" => Some(Self::PageTitleAndScreenClass),
                "PAGE_TITLE_AND_SCREEN_NAME" => Some(Self::PageTitleAndScreenName),
                "PARTNER_MANAGEMENT_ASSIGNMENT_ID" => {
                    Some(Self::PartnerManagementAssignmentId)
                }
                "PARTNER_MANAGEMENT_ASSIGNMENT_NAME" => {
                    Some(Self::PartnerManagementAssignmentName)
                }
                "PARTNER_MANAGEMENT_PARTNER_ID" => Some(Self::PartnerManagementPartnerId),
                "PARTNER_MANAGEMENT_PARTNER_NAME" => {
                    Some(Self::PartnerManagementPartnerName)
                }
                "PLACEMENT_ID" => Some(Self::PlacementId),
                "PLACEMENT_ID_ALL" => Some(Self::PlacementIdAll),
                "PLACEMENT_NAME" => Some(Self::PlacementName),
                "PLACEMENT_NAME_ALL" => Some(Self::PlacementNameAll),
                "PLACEMENT_STATUS" => Some(Self::PlacementStatus),
                "PLACEMENT_STATUS_NAME" => Some(Self::PlacementStatusName),
                "PLACEMENT_STATUS_NAME_ALL" => Some(Self::PlacementStatusNameAll),
                "POSTAL_CODE_ID" => Some(Self::PostalCodeId),
                "POSTAL_CODE_NAME" => Some(Self::PostalCodeName),
                "PPID_STATUS" => Some(Self::PpidStatus),
                "PPID_STATUS_NAME" => Some(Self::PpidStatusName),
                "PREDICTED_VIEWABILITY_BUCKET" => Some(Self::PredictedViewabilityBucket),
                "PREDICTED_VIEWABILITY_BUCKET_NAME" => {
                    Some(Self::PredictedViewabilityBucketName)
                }
                "PRESENTED_SECURE_SIGNAL_ID" => Some(Self::PresentedSecureSignalId),
                "PRESENTED_SECURE_SIGNAL_NAME" => Some(Self::PresentedSecureSignalName),
                "PRIMARY_PERSONALIZATION_ID_TYPE" => {
                    Some(Self::PrimaryPersonalizationIdType)
                }
                "PRIMARY_PERSONALIZATION_ID_TYPE_NAME" => {
                    Some(Self::PrimaryPersonalizationIdTypeName)
                }
                "PROGRAMMATIC_CHANNEL" => Some(Self::ProgrammaticChannel),
                "PROGRAMMATIC_CHANNEL_NAME" => Some(Self::ProgrammaticChannelName),
                "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_EXTERNAL_CODE" => {
                    Some(Self::PublisherProvidedSignalsAllLevelsExternalCode)
                }
                "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_IDS" => {
                    Some(Self::PublisherProvidedSignalsAllLevelsIds)
                }
                "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_NAME" => {
                    Some(Self::PublisherProvidedSignalsAllLevelsName)
                }
                "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_TIER" => {
                    Some(Self::PublisherProvidedSignalsAllLevelsTier)
                }
                "PUBLISHER_PROVIDED_SIGNALS_ALL_LEVELS_TYPE" => {
                    Some(Self::PublisherProvidedSignalsAllLevelsType)
                }
                "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_EXTERNAL_CODE" => {
                    Some(Self::PublisherProvidedSignalsDeliveredExternalCode)
                }
                "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_IDS" => {
                    Some(Self::PublisherProvidedSignalsDeliveredIds)
                }
                "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_NAME" => {
                    Some(Self::PublisherProvidedSignalsDeliveredName)
                }
                "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_TIER" => {
                    Some(Self::PublisherProvidedSignalsDeliveredTier)
                }
                "PUBLISHER_PROVIDED_SIGNALS_DELIVERED_TYPE" => {
                    Some(Self::PublisherProvidedSignalsDeliveredType)
                }
                "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_EXTERNAL_CODE" => {
                    Some(Self::PublisherProvidedSignalsTopLevelExternalCode)
                }
                "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_ID" => {
                    Some(Self::PublisherProvidedSignalsTopLevelId)
                }
                "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_NAME" => {
                    Some(Self::PublisherProvidedSignalsTopLevelName)
                }
                "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_TIER" => {
                    Some(Self::PublisherProvidedSignalsTopLevelTier)
                }
                "PUBLISHER_PROVIDED_SIGNALS_TOP_LEVEL_TYPE" => {
                    Some(Self::PublisherProvidedSignalsTopLevelType)
                }
                "PUBLISHER_PROVIDED_SIGNAL_DATA_PROVIDER_ID" => {
                    Some(Self::PublisherProvidedSignalDataProviderId)
                }
                "PUBLISHER_PROVIDED_SIGNAL_DATA_PROVIDER_NAME" => {
                    Some(Self::PublisherProvidedSignalDataProviderName)
                }
                "REGION_ID" => Some(Self::RegionId),
                "REGION_NAME" => Some(Self::RegionName),
                "REJECTION_CLASS_CATEGORY" => Some(Self::RejectionClassCategory),
                "REJECTION_CLASS_CATEGORY_NAME" => Some(Self::RejectionClassCategoryName),
                "RENDERED_CREATIVE_SIZE" => Some(Self::RenderedCreativeSize),
                "REQUESTED_AD_SIZES" => Some(Self::RequestedAdSizes),
                "REQUEST_TYPE" => Some(Self::RequestType),
                "REQUEST_TYPE_NAME" => Some(Self::RequestTypeName),
                "REVENUE_VERIFICATION_ID" => Some(Self::RevenueVerificationId),
                "SERVER_SIDE_UNWRAPPING_ELIGIBLE" => {
                    Some(Self::ServerSideUnwrappingEligible)
                }
                "SERVING_RESTRICTION" => Some(Self::ServingRestriction),
                "SERVING_RESTRICTION_NAME" => Some(Self::ServingRestrictionName),
                "SITE" => Some(Self::Site),
                "TARGETING_ID" => Some(Self::TargetingId),
                "TARGETING_NAME" => Some(Self::TargetingName),
                "TARGETING_TYPE" => Some(Self::TargetingType),
                "TARGETING_TYPE_NAME" => Some(Self::TargetingTypeName),
                "THIRD_PARTY_ID_STATUS" => Some(Self::ThirdPartyIdStatus),
                "THIRD_PARTY_ID_STATUS_NAME" => Some(Self::ThirdPartyIdStatusName),
                "TOPICS_STATUS" => Some(Self::TopicsStatus),
                "TOPICS_STATUS_NAME" => Some(Self::TopicsStatusName),
                "TOP_PRIVATE_DOMAIN" => Some(Self::TopPrivateDomain),
                "TRAFFIC_SOURCE" => Some(Self::TrafficSource),
                "TRAFFIC_SOURCE_NAME" => Some(Self::TrafficSourceName),
                "UNIFIED_PRICING_RULE_ID" => Some(Self::UnifiedPricingRuleId),
                "UNIFIED_PRICING_RULE_NAME" => Some(Self::UnifiedPricingRuleName),
                "URL" => Some(Self::Url),
                "URL_ID" => Some(Self::UrlId),
                "USER_MESSAGES_CHOICE" => Some(Self::UserMessagesChoice),
                "USER_MESSAGES_CHOICE_NAME" => Some(Self::UserMessagesChoiceName),
                "USER_MESSAGES_ENTITLEMENT_SOURCE" => {
                    Some(Self::UserMessagesEntitlementSource)
                }
                "USER_MESSAGES_ENTITLEMENT_SOURCE_NAME" => {
                    Some(Self::UserMessagesEntitlementSourceName)
                }
                "USER_MESSAGES_OPERATING_SYSTEM_CRITERIA_ID" => {
                    Some(Self::UserMessagesOperatingSystemCriteriaId)
                }
                "USER_MESSAGES_OPERATING_SYSTEM_CRITERIA_NAME" => {
                    Some(Self::UserMessagesOperatingSystemCriteriaName)
                }
                "VAST_VERSION" => Some(Self::VastVersion),
                "VAST_VERSION_NAME" => Some(Self::VastVersionName),
                "VIDEO_AD_BREAK_TYPE" => Some(Self::VideoAdBreakType),
                "VIDEO_AD_BREAK_TYPE_NAME" => Some(Self::VideoAdBreakTypeName),
                "VIDEO_AD_DURATION" => Some(Self::VideoAdDuration),
                "VIDEO_AD_FORMATS_RULE" => Some(Self::VideoAdFormatsRule),
                "VIDEO_AD_FORMATS_RULE_ID" => Some(Self::VideoAdFormatsRuleId),
                "VIDEO_AD_REQUEST_DURATION" => Some(Self::VideoAdRequestDuration),
                "VIDEO_AD_REQUEST_DURATION_MIDPOINT_NAME" => {
                    Some(Self::VideoAdRequestDurationMidpointName)
                }
                "VIDEO_AD_REQUEST_DURATION_NAME" => {
                    Some(Self::VideoAdRequestDurationName)
                }
                "VIDEO_AD_REQUEST_SOURCE" => Some(Self::VideoAdRequestSource),
                "VIDEO_AD_REQUEST_SOURCE_NAME" => Some(Self::VideoAdRequestSourceName),
                "VIDEO_AD_TYPE" => Some(Self::VideoAdType),
                "VIDEO_AD_TYPE_NAME" => Some(Self::VideoAdTypeName),
                "VIDEO_CONTINUOUS_PLAY_TYPE" => Some(Self::VideoContinuousPlayType),
                "VIDEO_CONTINUOUS_PLAY_TYPE_NAME" => {
                    Some(Self::VideoContinuousPlayTypeName)
                }
                "VIDEO_FALLBACK_POSITION" => Some(Self::VideoFallbackPosition),
                "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_DURATION" => {
                    Some(Self::VideoLiveStreamEventAdBreakDuration)
                }
                "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_ID" => {
                    Some(Self::VideoLiveStreamEventAdBreakId)
                }
                "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_NAME" => {
                    Some(Self::VideoLiveStreamEventAdBreakName)
                }
                "VIDEO_LIVE_STREAM_EVENT_AD_BREAK_TIME" => {
                    Some(Self::VideoLiveStreamEventAdBreakTime)
                }
                "VIDEO_LIVE_STREAM_EVENT_ID" => Some(Self::VideoLiveStreamEventId),
                "VIDEO_LIVE_STREAM_EVENT_NAME" => Some(Self::VideoLiveStreamEventName),
                "VIDEO_MEASUREMENT_SOURCE" => Some(Self::VideoMeasurementSource),
                "VIDEO_MEASUREMENT_SOURCE_NAME" => Some(Self::VideoMeasurementSourceName),
                "VIDEO_PLCMT" => Some(Self::VideoPlcmt),
                "VIDEO_PLCMT_NAME" => Some(Self::VideoPlcmtName),
                "VIDEO_POSITION_IN_POD" => Some(Self::VideoPositionInPod),
                "VIDEO_POSITION_OF_POD" => Some(Self::VideoPositionOfPod),
                "VIDEO_SDK_VERSION" => Some(Self::VideoSdkVersion),
                "VIDEO_SDK_VERSION_NAME" => Some(Self::VideoSdkVersionName),
                "VIDEO_STITCHER_TYPE" => Some(Self::VideoStitcherType),
                "VIDEO_STITCHER_TYPE_NAME" => Some(Self::VideoStitcherTypeName),
                "WEB_PROPERTY_CODE" => Some(Self::WebPropertyCode),
                "WEEK" => Some(Self::Week),
                "YIELD_GROUP_BUYER_NAME" => Some(Self::YieldGroupBuyerName),
                "YIELD_GROUP_BUYER_TAG_NAME" => Some(Self::YieldGroupBuyerTagName),
                "YIELD_GROUP_ID" => Some(Self::YieldGroupId),
                "YIELD_GROUP_NAME" => Some(Self::YieldGroupName),
                "YOUTUBE_AD_DURATION_BUCKET" => Some(Self::YoutubeAdDurationBucket),
                "YOUTUBE_AD_DURATION_BUCKET_NAME" => {
                    Some(Self::YoutubeAdDurationBucketName)
                }
                "YOUTUBE_AD_TYPE" => Some(Self::YoutubeAdType),
                "YOUTUBE_AD_TYPE_NAME" => Some(Self::YoutubeAdTypeName),
                "LINE_ITEM_CUSTOM_FIELD_0_OPTION_ID" => {
                    Some(Self::LineItemCustomField0OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_1_OPTION_ID" => {
                    Some(Self::LineItemCustomField1OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_2_OPTION_ID" => {
                    Some(Self::LineItemCustomField2OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_3_OPTION_ID" => {
                    Some(Self::LineItemCustomField3OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_4_OPTION_ID" => {
                    Some(Self::LineItemCustomField4OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_5_OPTION_ID" => {
                    Some(Self::LineItemCustomField5OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_6_OPTION_ID" => {
                    Some(Self::LineItemCustomField6OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_7_OPTION_ID" => {
                    Some(Self::LineItemCustomField7OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_8_OPTION_ID" => {
                    Some(Self::LineItemCustomField8OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_9_OPTION_ID" => {
                    Some(Self::LineItemCustomField9OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_10_OPTION_ID" => {
                    Some(Self::LineItemCustomField10OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_11_OPTION_ID" => {
                    Some(Self::LineItemCustomField11OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_12_OPTION_ID" => {
                    Some(Self::LineItemCustomField12OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_13_OPTION_ID" => {
                    Some(Self::LineItemCustomField13OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_14_OPTION_ID" => {
                    Some(Self::LineItemCustomField14OptionId)
                }
                "LINE_ITEM_CUSTOM_FIELD_0_VALUE" => Some(Self::LineItemCustomField0Value),
                "LINE_ITEM_CUSTOM_FIELD_1_VALUE" => Some(Self::LineItemCustomField1Value),
                "LINE_ITEM_CUSTOM_FIELD_2_VALUE" => Some(Self::LineItemCustomField2Value),
                "LINE_ITEM_CUSTOM_FIELD_3_VALUE" => Some(Self::LineItemCustomField3Value),
                "LINE_ITEM_CUSTOM_FIELD_4_VALUE" => Some(Self::LineItemCustomField4Value),
                "LINE_ITEM_CUSTOM_FIELD_5_VALUE" => Some(Self::LineItemCustomField5Value),
                "LINE_ITEM_CUSTOM_FIELD_6_VALUE" => Some(Self::LineItemCustomField6Value),
                "LINE_ITEM_CUSTOM_FIELD_7_VALUE" => Some(Self::LineItemCustomField7Value),
                "LINE_ITEM_CUSTOM_FIELD_8_VALUE" => Some(Self::LineItemCustomField8Value),
                "LINE_ITEM_CUSTOM_FIELD_9_VALUE" => Some(Self::LineItemCustomField9Value),
                "LINE_ITEM_CUSTOM_FIELD_10_VALUE" => {
                    Some(Self::LineItemCustomField10Value)
                }
                "LINE_ITEM_CUSTOM_FIELD_11_VALUE" => {
                    Some(Self::LineItemCustomField11Value)
                }
                "LINE_ITEM_CUSTOM_FIELD_12_VALUE" => {
                    Some(Self::LineItemCustomField12Value)
                }
                "LINE_ITEM_CUSTOM_FIELD_13_VALUE" => {
                    Some(Self::LineItemCustomField13Value)
                }
                "LINE_ITEM_CUSTOM_FIELD_14_VALUE" => {
                    Some(Self::LineItemCustomField14Value)
                }
                "ORDER_CUSTOM_FIELD_0_OPTION_ID" => Some(Self::OrderCustomField0OptionId),
                "ORDER_CUSTOM_FIELD_1_OPTION_ID" => Some(Self::OrderCustomField1OptionId),
                "ORDER_CUSTOM_FIELD_2_OPTION_ID" => Some(Self::OrderCustomField2OptionId),
                "ORDER_CUSTOM_FIELD_3_OPTION_ID" => Some(Self::OrderCustomField3OptionId),
                "ORDER_CUSTOM_FIELD_4_OPTION_ID" => Some(Self::OrderCustomField4OptionId),
                "ORDER_CUSTOM_FIELD_5_OPTION_ID" => Some(Self::OrderCustomField5OptionId),
                "ORDER_CUSTOM_FIELD_6_OPTION_ID" => Some(Self::OrderCustomField6OptionId),
                "ORDER_CUSTOM_FIELD_7_OPTION_ID" => Some(Self::OrderCustomField7OptionId),
                "ORDER_CUSTOM_FIELD_8_OPTION_ID" => Some(Self::OrderCustomField8OptionId),
                "ORDER_CUSTOM_FIELD_9_OPTION_ID" => Some(Self::OrderCustomField9OptionId),
                "ORDER_CUSTOM_FIELD_10_OPTION_ID" => {
                    Some(Self::OrderCustomField10OptionId)
                }
                "ORDER_CUSTOM_FIELD_11_OPTION_ID" => {
                    Some(Self::OrderCustomField11OptionId)
                }
                "ORDER_CUSTOM_FIELD_12_OPTION_ID" => {
                    Some(Self::OrderCustomField12OptionId)
                }
                "ORDER_CUSTOM_FIELD_13_OPTION_ID" => {
                    Some(Self::OrderCustomField13OptionId)
                }
                "ORDER_CUSTOM_FIELD_14_OPTION_ID" => {
                    Some(Self::OrderCustomField14OptionId)
                }
                "ORDER_CUSTOM_FIELD_0_VALUE" => Some(Self::OrderCustomField0Value),
                "ORDER_CUSTOM_FIELD_1_VALUE" => Some(Self::OrderCustomField1Value),
                "ORDER_CUSTOM_FIELD_2_VALUE" => Some(Self::OrderCustomField2Value),
                "ORDER_CUSTOM_FIELD_3_VALUE" => Some(Self::OrderCustomField3Value),
                "ORDER_CUSTOM_FIELD_4_VALUE" => Some(Self::OrderCustomField4Value),
                "ORDER_CUSTOM_FIELD_5_VALUE" => Some(Self::OrderCustomField5Value),
                "ORDER_CUSTOM_FIELD_6_VALUE" => Some(Self::OrderCustomField6Value),
                "ORDER_CUSTOM_FIELD_7_VALUE" => Some(Self::OrderCustomField7Value),
                "ORDER_CUSTOM_FIELD_8_VALUE" => Some(Self::OrderCustomField8Value),
                "ORDER_CUSTOM_FIELD_9_VALUE" => Some(Self::OrderCustomField9Value),
                "ORDER_CUSTOM_FIELD_10_VALUE" => Some(Self::OrderCustomField10Value),
                "ORDER_CUSTOM_FIELD_11_VALUE" => Some(Self::OrderCustomField11Value),
                "ORDER_CUSTOM_FIELD_12_VALUE" => Some(Self::OrderCustomField12Value),
                "ORDER_CUSTOM_FIELD_13_VALUE" => Some(Self::OrderCustomField13Value),
                "ORDER_CUSTOM_FIELD_14_VALUE" => Some(Self::OrderCustomField14Value),
                "CREATIVE_CUSTOM_FIELD_0_OPTION_ID" => {
                    Some(Self::CreativeCustomField0OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_1_OPTION_ID" => {
                    Some(Self::CreativeCustomField1OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_2_OPTION_ID" => {
                    Some(Self::CreativeCustomField2OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_3_OPTION_ID" => {
                    Some(Self::CreativeCustomField3OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_4_OPTION_ID" => {
                    Some(Self::CreativeCustomField4OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_5_OPTION_ID" => {
                    Some(Self::CreativeCustomField5OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_6_OPTION_ID" => {
                    Some(Self::CreativeCustomField6OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_7_OPTION_ID" => {
                    Some(Self::CreativeCustomField7OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_8_OPTION_ID" => {
                    Some(Self::CreativeCustomField8OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_9_OPTION_ID" => {
                    Some(Self::CreativeCustomField9OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_10_OPTION_ID" => {
                    Some(Self::CreativeCustomField10OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_11_OPTION_ID" => {
                    Some(Self::CreativeCustomField11OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_12_OPTION_ID" => {
                    Some(Self::CreativeCustomField12OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_13_OPTION_ID" => {
                    Some(Self::CreativeCustomField13OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_14_OPTION_ID" => {
                    Some(Self::CreativeCustomField14OptionId)
                }
                "CREATIVE_CUSTOM_FIELD_0_VALUE" => Some(Self::CreativeCustomField0Value),
                "CREATIVE_CUSTOM_FIELD_1_VALUE" => Some(Self::CreativeCustomField1Value),
                "CREATIVE_CUSTOM_FIELD_2_VALUE" => Some(Self::CreativeCustomField2Value),
                "CREATIVE_CUSTOM_FIELD_3_VALUE" => Some(Self::CreativeCustomField3Value),
                "CREATIVE_CUSTOM_FIELD_4_VALUE" => Some(Self::CreativeCustomField4Value),
                "CREATIVE_CUSTOM_FIELD_5_VALUE" => Some(Self::CreativeCustomField5Value),
                "CREATIVE_CUSTOM_FIELD_6_VALUE" => Some(Self::CreativeCustomField6Value),
                "CREATIVE_CUSTOM_FIELD_7_VALUE" => Some(Self::CreativeCustomField7Value),
                "CREATIVE_CUSTOM_FIELD_8_VALUE" => Some(Self::CreativeCustomField8Value),
                "CREATIVE_CUSTOM_FIELD_9_VALUE" => Some(Self::CreativeCustomField9Value),
                "CREATIVE_CUSTOM_FIELD_10_VALUE" => {
                    Some(Self::CreativeCustomField10Value)
                }
                "CREATIVE_CUSTOM_FIELD_11_VALUE" => {
                    Some(Self::CreativeCustomField11Value)
                }
                "CREATIVE_CUSTOM_FIELD_12_VALUE" => {
                    Some(Self::CreativeCustomField12Value)
                }
                "CREATIVE_CUSTOM_FIELD_13_VALUE" => {
                    Some(Self::CreativeCustomField13Value)
                }
                "CREATIVE_CUSTOM_FIELD_14_VALUE" => {
                    Some(Self::CreativeCustomField14Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_0_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField0OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_1_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField1OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_2_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField2OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_3_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField3OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_4_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField4OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_5_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField5OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_6_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField6OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_7_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField7OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_8_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField8OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_9_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField9OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_10_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField10OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_11_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField11OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_12_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField12OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_13_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField13OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_14_OPTION_ID" => {
                    Some(Self::BackfillLineItemCustomField14OptionId)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_0_VALUE" => {
                    Some(Self::BackfillLineItemCustomField0Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_1_VALUE" => {
                    Some(Self::BackfillLineItemCustomField1Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_2_VALUE" => {
                    Some(Self::BackfillLineItemCustomField2Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_3_VALUE" => {
                    Some(Self::BackfillLineItemCustomField3Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_4_VALUE" => {
                    Some(Self::BackfillLineItemCustomField4Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_5_VALUE" => {
                    Some(Self::BackfillLineItemCustomField5Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_6_VALUE" => {
                    Some(Self::BackfillLineItemCustomField6Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_7_VALUE" => {
                    Some(Self::BackfillLineItemCustomField7Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_8_VALUE" => {
                    Some(Self::BackfillLineItemCustomField8Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_9_VALUE" => {
                    Some(Self::BackfillLineItemCustomField9Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_10_VALUE" => {
                    Some(Self::BackfillLineItemCustomField10Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_11_VALUE" => {
                    Some(Self::BackfillLineItemCustomField11Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_12_VALUE" => {
                    Some(Self::BackfillLineItemCustomField12Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_13_VALUE" => {
                    Some(Self::BackfillLineItemCustomField13Value)
                }
                "BACKFILL_LINE_ITEM_CUSTOM_FIELD_14_VALUE" => {
                    Some(Self::BackfillLineItemCustomField14Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_0_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField0OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_1_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField1OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_2_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField2OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_3_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField3OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_4_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField4OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_5_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField5OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_6_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField6OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_7_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField7OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_8_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField8OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_9_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField9OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_10_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField10OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_11_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField11OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_12_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField12OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_13_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField13OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_14_OPTION_ID" => {
                    Some(Self::BackfillOrderCustomField14OptionId)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_0_VALUE" => {
                    Some(Self::BackfillOrderCustomField0Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_1_VALUE" => {
                    Some(Self::BackfillOrderCustomField1Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_2_VALUE" => {
                    Some(Self::BackfillOrderCustomField2Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_3_VALUE" => {
                    Some(Self::BackfillOrderCustomField3Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_4_VALUE" => {
                    Some(Self::BackfillOrderCustomField4Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_5_VALUE" => {
                    Some(Self::BackfillOrderCustomField5Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_6_VALUE" => {
                    Some(Self::BackfillOrderCustomField6Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_7_VALUE" => {
                    Some(Self::BackfillOrderCustomField7Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_8_VALUE" => {
                    Some(Self::BackfillOrderCustomField8Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_9_VALUE" => {
                    Some(Self::BackfillOrderCustomField9Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_10_VALUE" => {
                    Some(Self::BackfillOrderCustomField10Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_11_VALUE" => {
                    Some(Self::BackfillOrderCustomField11Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_12_VALUE" => {
                    Some(Self::BackfillOrderCustomField12Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_13_VALUE" => {
                    Some(Self::BackfillOrderCustomField13Value)
                }
                "BACKFILL_ORDER_CUSTOM_FIELD_14_VALUE" => {
                    Some(Self::BackfillOrderCustomField14Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_0_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField0OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_1_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField1OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_2_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField2OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_3_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField3OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_4_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField4OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_5_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField5OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_6_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField6OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_7_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField7OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_8_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField8OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_9_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField9OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_10_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField10OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_11_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField11OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_12_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField12OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_13_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField13OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_14_OPTION_ID" => {
                    Some(Self::BackfillCreativeCustomField14OptionId)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_0_VALUE" => {
                    Some(Self::BackfillCreativeCustomField0Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_1_VALUE" => {
                    Some(Self::BackfillCreativeCustomField1Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_2_VALUE" => {
                    Some(Self::BackfillCreativeCustomField2Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_3_VALUE" => {
                    Some(Self::BackfillCreativeCustomField3Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_4_VALUE" => {
                    Some(Self::BackfillCreativeCustomField4Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_5_VALUE" => {
                    Some(Self::BackfillCreativeCustomField5Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_6_VALUE" => {
                    Some(Self::BackfillCreativeCustomField6Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_7_VALUE" => {
                    Some(Self::BackfillCreativeCustomField7Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_8_VALUE" => {
                    Some(Self::BackfillCreativeCustomField8Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_9_VALUE" => {
                    Some(Self::BackfillCreativeCustomField9Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_10_VALUE" => {
                    Some(Self::BackfillCreativeCustomField10Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_11_VALUE" => {
                    Some(Self::BackfillCreativeCustomField11Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_12_VALUE" => {
                    Some(Self::BackfillCreativeCustomField12Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_13_VALUE" => {
                    Some(Self::BackfillCreativeCustomField13Value)
                }
                "BACKFILL_CREATIVE_CUSTOM_FIELD_14_VALUE" => {
                    Some(Self::BackfillCreativeCustomField14Value)
                }
                "CUSTOM_DIMENSION_0_VALUE_ID" => Some(Self::CustomDimension0ValueId),
                "CUSTOM_DIMENSION_1_VALUE_ID" => Some(Self::CustomDimension1ValueId),
                "CUSTOM_DIMENSION_2_VALUE_ID" => Some(Self::CustomDimension2ValueId),
                "CUSTOM_DIMENSION_3_VALUE_ID" => Some(Self::CustomDimension3ValueId),
                "CUSTOM_DIMENSION_4_VALUE_ID" => Some(Self::CustomDimension4ValueId),
                "CUSTOM_DIMENSION_5_VALUE_ID" => Some(Self::CustomDimension5ValueId),
                "CUSTOM_DIMENSION_6_VALUE_ID" => Some(Self::CustomDimension6ValueId),
                "CUSTOM_DIMENSION_7_VALUE_ID" => Some(Self::CustomDimension7ValueId),
                "CUSTOM_DIMENSION_8_VALUE_ID" => Some(Self::CustomDimension8ValueId),
                "CUSTOM_DIMENSION_9_VALUE_ID" => Some(Self::CustomDimension9ValueId),
                "CUSTOM_DIMENSION_0_VALUE" => Some(Self::CustomDimension0Value),
                "CUSTOM_DIMENSION_1_VALUE" => Some(Self::CustomDimension1Value),
                "CUSTOM_DIMENSION_2_VALUE" => Some(Self::CustomDimension2Value),
                "CUSTOM_DIMENSION_3_VALUE" => Some(Self::CustomDimension3Value),
                "CUSTOM_DIMENSION_4_VALUE" => Some(Self::CustomDimension4Value),
                "CUSTOM_DIMENSION_5_VALUE" => Some(Self::CustomDimension5Value),
                "CUSTOM_DIMENSION_6_VALUE" => Some(Self::CustomDimension6Value),
                "CUSTOM_DIMENSION_7_VALUE" => Some(Self::CustomDimension7Value),
                "CUSTOM_DIMENSION_8_VALUE" => Some(Self::CustomDimension8Value),
                "CUSTOM_DIMENSION_9_VALUE" => Some(Self::CustomDimension9Value),
                _ => None,
            }
        }
    }
    /// Reporting metrics.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Metric {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The number of people who engaged with your site or app in the specified
        /// date range from Google Analytics.
        ///
        /// Corresponds to "Active users" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveUsers = 223,
        /// Number of impressions with unmuted playback at start.
        ///
        /// Corresponds to "Active View % audible at start" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewAudibleAtStartPercent = 445,
        /// Total Active View audible impressions
        ///
        /// Corresponds to "Total Active View audible impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewAudibleImpressions = 659,
        /// Number of impressions with unmuted playback through the entire stream.
        ///
        /// Corresponds to "Active View % audible through completion" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewAudibleThroughCompletionPercent = 446,
        /// Number of impressions with unmuted playback through at least 25%.
        ///
        /// Corresponds to "Active View % audible through first quartile" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewAudibleThroughFirstQuartilePercent = 447,
        /// Number of impressions with unmuted playback through at least 50%.
        ///
        /// Corresponds to "Active View % audible through midpoint" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewAudibleThroughMidpointPercent = 448,
        /// Number of impressions with unmuted playback through at least 75%.
        ///
        /// Corresponds to "Active View % audible through third quartile" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewAudibleThroughThirdQuartilePercent = 449,
        /// Total Active View audio enabled impressions
        ///
        /// Corresponds to "Total Active View audio eligible impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewAudioEnabledImpressions = 660,
        /// Total Active View audio measurable impressions
        ///
        /// Corresponds to "Total Active View audio measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewAudioMeasurableImpressions = 661,
        /// Active View total average time in seconds that specific impressions are
        /// reported as being viewable.
        ///
        /// Corresponds to "Total Active View average viewable time (seconds)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        ActiveViewAverageViewableTime = 61,
        /// Total number of impressions that were eligible to measure viewability.
        ///
        /// Corresponds to "Total Active View eligible impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewEligibleImpressions = 58,
        /// Number of impressions where the ad player is in the background at any
        /// point during playback with volume > 0.
        ///
        /// Corresponds to "Active View % ever audible while backgrounded" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewEverAudibleBackgroundedPercent = 450,
        /// Number of impressions where volume > 0 at any point.
        ///
        /// Corresponds to "Active View % ever audible" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewEverAudiblePercent = 451,
        /// Number of impressions where the ad player is in the background at any
        /// point during playback.
        ///
        /// Corresponds to "Active View % ever backgrounded" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewEverBackgroundedPercent = 452,
        /// Number of impressions where volume = 0 at any point.
        ///
        /// Corresponds to "Active View % ever muted" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewEverMutedPercent = 453,
        /// The number of measurable impressions that were played to video
        /// completion, and also audible and visible at the time of completion.
        ///
        /// Corresponds to "Total Active View impressions audible and visible at
        /// completion" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewImpressionsAudibleAndVisiblieAtCompletion = 411,
        /// The total number of impressions that were sampled and measured by active
        /// view.
        ///
        /// Corresponds to "Total Active View measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewMeasurableImpressions = 57,
        /// The percentage of total impressions that were measurable by active view
        /// (out of all the total impressions sampled for active view).
        ///
        /// Corresponds to "Total Active View % measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewMeasurableImpressionsRate = 60,
        /// Total Active View non-measurable impressions
        ///
        /// Corresponds to "Total Active View non-measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewNonMeasurableImpressions = 662,
        /// Total Active View non-viewable impressions
        ///
        /// Corresponds to "Total Active View non-viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewNonViewableImpressions = 663,
        /// Total Active View non-viewable impressions distribution
        ///
        /// Corresponds to "Total Active View non-viewable impression distribution"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewNonViewableImpressionsDistribution = 664,
        /// Total Active View percent audible impressions
        ///
        /// Corresponds to "Total Active View % audible impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewPercentAudibleImpressions = 665,
        /// Number of impressions where we were able to collect Active View+ signals.
        ///
        /// Corresponds to "Active View+ measurable impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewPlusMeasurableCount = 454,
        /// Revenue generated from Active View impressions.
        ///
        /// Corresponds to "Total Active View revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        ActiveViewRevenue = 414,
        /// Total Active View undetermined impressions distribution
        ///
        /// Corresponds to "Total Active View undetermined impression distribution"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewUndeterminedImpressionsDistribution = 666,
        /// The total number of impressions viewed on the user's screen.
        ///
        /// Corresponds to "Total Active View viewable impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ActiveViewViewableImpressions = 56,
        /// Total Active View viewable impressions distribution
        ///
        /// Corresponds to "Total Active View viewable impression distribution" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewViewableImpressionsDistribution = 667,
        /// The percentage of total impressions viewed on the user's screen (out of
        /// the total impressions measurable by active view).
        ///
        /// Corresponds to "Total Active View % viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ActiveViewViewableImpressionsRate = 59,
        /// Active View AdSense average time in seconds that specific impressions are
        /// reported as being viewable.
        ///
        /// Corresponds to "AdSense Active View average viewable time (seconds)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdsenseActiveViewAverageViewableTime = 73,
        /// Total number of impressions delivered by AdSense that were eligible to
        /// measure viewability.
        ///
        /// Corresponds to "AdSense Active View eligible impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseActiveViewEligibleImpressions = 70,
        /// The number of impressions delivered by AdSense that were sampled, and
        /// measurable by active view.
        ///
        /// Corresponds to "AdSense Active View measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseActiveViewMeasurableImpressions = 69,
        /// The percentage of impressions delivered by AdSense that were measurable
        /// by active view (out of all AdSense impressions sampled for active view).
        ///
        /// Corresponds to "AdSense Active View % measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsenseActiveViewMeasurableImpressionsRate = 72,
        /// AdSense Active View non-measurable impressions
        ///
        /// Corresponds to "AdSense Active View non-measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseActiveViewNonMeasurableImpressions = 642,
        /// AdSense Active View non-viewable impressions
        ///
        /// Corresponds to "AdSense Active View non-viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseActiveViewNonViewableImpressions = 643,
        /// AdSense Active View non-viewable impressions distribution
        ///
        /// Corresponds to "AdSense Active View non-viewable impression distribution"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsenseActiveViewNonViewableImpressionsDistribution = 644,
        /// AdSense Active View undetermined impressions distribution
        ///
        /// Corresponds to "AdSense Active View undetermined impression distribution"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsenseActiveViewUndeterminedImpressionsDistribution = 645,
        /// The number of impressions delivered by AdSense viewed on the user's
        /// screen.
        ///
        /// Corresponds to "AdSense Active View viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseActiveViewViewableImpressions = 68,
        /// AdSense Active View viewable impressions distribution
        ///
        /// Corresponds to "AdSense Active View viewable impression distribution" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsenseActiveViewViewableImpressionsDistribution = 646,
        /// The percentage of impressions delivered by AdSense viewed on the user's
        /// screen (out of AdSense impressions measurable by active view).
        ///
        /// Corresponds to "AdSense Active View % viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsenseActiveViewViewableImpressionsRate = 71,
        /// The average effective cost-per-thousand-impressions earned from the ads
        /// delivered by AdSense through line item dynamic allocation.
        ///
        /// Corresponds to "AdSense average eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdsenseAverageEcpm = 26,
        /// Number of clicks delivered by AdSense demand channel.
        ///
        /// Corresponds to "AdSense clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseClicks = 23,
        /// The ratio of impressions served by AdSense that resulted in users
        /// clicking on an ad. The clickthrough rate (CTR) is updated nightly. The
        /// AdSense CTR is calculated as: (AdSense clicks / AdSense impressions).
        ///
        /// Corresponds to "AdSense CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsenseCtr = 24,
        /// Total impressions delivered by AdSense.
        ///
        /// Corresponds to "AdSense impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseImpressions = 22,
        /// Ratio of clicks delivered by AdSense through line item dynamic allocation
        /// in relation to the total clicks delivered.
        ///
        /// Corresponds to "AdSense clicks (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsensePercentClicks = 28,
        /// Ratio of impressions delivered by AdSense through line item dynamic
        /// allocation in relation to the total impressions delivered.
        ///
        /// Corresponds to "AdSense impressions (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsensePercentImpressions = 27,
        /// Ratio of revenue generated by AdSense through line item dynamic
        /// allocation in relation to the total revenue.
        ///
        /// Corresponds to "AdSense revenue (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsensePercentRevenue = 29,
        /// Ratio of revenue generated by AdSense through line item dynamic
        /// allocation in relation to the total revenue (excluding CPD).
        ///
        /// Corresponds to "AdSense revenue w/o CPD (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdsensePercentRevenueWithoutCpd = 30,
        /// The total number of times that an AdSense ad is delivered.
        ///
        /// Corresponds to "AdSense responses served" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdsenseResponsesServed = 41,
        /// Revenue generated from AdSense through line item dynamic allocation,
        /// calculated in the network's currency and time zone.
        ///
        /// Corresponds to "AdSense revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdsenseRevenue = 25,
        /// Active View AdExchange average time in seconds that specific impressions
        /// are reported as being viewable.
        ///
        /// Corresponds to "Ad Exchange Active View average viewable time (seconds)"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdExchangeActiveViewAverageViewableTime = 79,
        /// Total number of impressions delivered by Ad Exchange that were eligible
        /// to measure viewability.
        ///
        /// Corresponds to "Ad Exchange Active View eligible impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeActiveViewEligibleImpressions = 76,
        /// The number of impressions delivered by Ad Exchange that were sampled, and
        /// measurable by active view.
        ///
        /// Corresponds to "Ad Exchange Active View measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeActiveViewMeasurableImpressions = 75,
        /// The percentage of impressions delivered by Ad Exchange that were
        /// measurable by active view (out of all Ad Exchange impressions sampled
        /// for active view).
        ///
        /// Corresponds to "Ad Exchange Active View % measurable impressions" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeActiveViewMeasurableImpressionsRate = 78,
        /// Ad Exchange Active View non-measurable impressions
        ///
        /// Corresponds to "Ad Exchange Active View non-measurable impressions" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeActiveViewNonMeasurableImpressions = 654,
        /// Ad Exchange Active View non-viewable impressions
        ///
        /// Corresponds to "Ad Exchange Active View non-viewable impressions" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeActiveViewNonViewableImpressions = 655,
        /// Ad Exchange Active View non-viewable impressions distribution
        ///
        /// Corresponds to "Ad Exchange Active View non-viewable impression
        /// distribution" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeActiveViewNonViewableImpressionsDistribution = 656,
        /// Ad Exchange Active View undetermined impressions distribution
        ///
        /// Corresponds to "Ad Exchange Active View undetermined impression
        /// distribution" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeActiveViewUndeterminedImpressionsDistribution = 657,
        /// The number of impressions delivered by Ad Exchange viewed on the user's
        /// screen.
        ///
        /// Corresponds to "Ad Exchange Active View viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeActiveViewViewableImpressions = 74,
        /// Ad Exchange Active View viewable impressions distribution
        ///
        /// Corresponds to "Ad Exchange Active View viewable impression distribution"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeActiveViewViewableImpressionsDistribution = 658,
        /// The percentage of impressions delivered by Ad Exchange viewed on the
        /// user's screen (out of Ad Exchange impressions measurable by active
        /// view).
        ///
        /// Corresponds to "Ad Exchange Active View % viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeActiveViewViewableImpressionsRate = 77,
        /// The average effective cost-per-thousand-impressions earned from the ads
        /// delivered by Ad Exchange through line item dynamic allocation.
        ///
        /// Corresponds to "Ad Exchange average eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeAverageEcpm = 18,
        /// Number of clicks delivered by the Ad Exchange.
        ///
        /// Corresponds to "Ad Exchange clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeClicks = 15,
        /// The average effective cost-per-click earned from the ads delivered by Ad
        /// Exchange through line item dynamic allocation.
        ///
        /// Corresponds to "Ad Exchange CPC" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeCpc = 244,
        /// The ratio of impressions served by the Ad Exchange that resulted in users
        /// clicking on an ad. The clickthrough rate (CTR) is updated nightly. Ad
        /// Exchange CTR is calculated as: (Ad Exchange clicks / Ad Exchange
        /// impressions).
        ///
        /// Corresponds to "Ad Exchange CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeCtr = 16,
        /// Ratio of impressions delivered by Ad Exchange through line item dynamic
        /// allocation to ad requests.
        ///
        /// Corresponds to "Ad Exchange delivery rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeDeliveryRate = 245,
        /// Total impressions delivered by the Ad Exchange.
        ///
        /// Corresponds to "Ad Exchange impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeImpressions = 14,
        /// The total number of impressions based on the number of ad viewers.
        ///
        /// Corresponds to "Ad Exchange impressions per ad viewer" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdExchangeImpressionsPerAdViewer = 427,
        /// The total number of impressions based on the number of sessions.
        ///
        /// Corresponds to "Ad Exchange impressions per session" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdExchangeImpressionsPerSession = 428,
        /// The increase in revenue gained for won impressions over the applicable
        /// third party price (the minimum CPM or the best price specified during
        /// dynamic allocation),
        ///
        /// Corresponds to "Ad Exchange lift earnings" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeLift = 246,
        /// The ratio of matched ad requests served by the Ad Exchange that
        /// resulted in users clicking on an ad. The clickthrough rate (CTR) is
        /// updated nightly. Ad Exchange Matched Request CTR is calculated as:
        /// (Ad Exchange clicks / Ad Exchange Matched Ad Requests).
        ///
        /// Corresponds to "Ad Exchange matched request CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeMatchedRequestCtr = 247,
        /// The average effective cost per thousand matched ad requests earned from
        /// the ads delivered by Ad Exchange through line item dynamic allocation.
        ///
        /// Corresponds to "Ad Exchange matched request eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeMatchedRequestEcpm = 248,
        /// The number of responses served divided by the number of queries eligible
        /// in ad exchange.
        ///
        /// Corresponds to "Ad Exchange match rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeMatchRate = 249,
        /// Total opportunities from video VAST error within the waterfall for
        /// backfill ads.
        ///
        /// Corresponds to "Ad Exchange opportunities from errors" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeOpportunitiesFromErrors = 250,
        /// Number of opportunities from impressions within the waterfall for
        /// backfill ads.
        ///
        /// Corresponds to "Ad Exchange opportunities from impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeOpportunitiesFromImpressions = 251,
        /// Ratio of clicks delivered by Ad Exchange through line item dynamic
        /// allocation in relation to the total clicks delivered.
        ///
        /// Corresponds to "Ad Exchange clicks (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangePercentClicks = 20,
        /// Ratio of impressions delivered by Ad Exchange through line item dynamic
        /// allocation in relation to the total impressions delivered.
        ///
        /// Corresponds to "Ad Exchange impressions (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangePercentImpressions = 19,
        /// Ratio of revenue generated by Ad Exchange through line item dynamic
        /// allocation in relation to the total revenue.
        ///
        /// Corresponds to "Ad Exchange revenue (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangePercentRevenue = 21,
        /// Ratio of revenue generated by Ad Exchange through line item dynamic
        /// allocation in relation to the total revenue (excluding CPD).
        ///
        /// Corresponds to "Ad Exchange revenue w/o CPD (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangePercentRevenueWithoutCpd = 31,
        /// The average effective cost-per-thousand-impressions earned from the ads
        /// delivered by Ad Exchange through line item dynamic allocation and yield
        /// group partners.
        ///
        /// Corresponds to "Ad Exchange plus yield group eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangePlusYieldGroupEcpm = 252,
        /// Total impressions delivered by the Ad Exchange and third-party networks.
        ///
        /// Corresponds to "Ad Exchange plus yield group impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangePlusYieldGroupImpressions = 253,
        /// Revenue generated from the Ad Exchange and Yield Group, calculated in
        /// your network's currency and time zone.
        ///
        /// Corresponds to "Ad Exchange plus yield group revenue" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangePlusYieldGroupRevenue = 254,
        /// The total number of times that an Ad Exchange ad is delivered.
        ///
        /// Corresponds to "Ad Exchange responses served" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeResponsesServed = 42,
        /// Revenue generated from the Ad Exchange through line item dynamic
        /// allocation, calculated in your network's currency and time zone.
        ///
        /// Corresponds to "Ad Exchange revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeRevenue = 17,
        /// The Ad Exchange revenue accrued in the child network's own account but
        /// paid to their parent network through auto-payment. This metric is only
        /// relevant for a "Manage Account" child network.
        ///
        /// Corresponds to "Ad Exchange revenue paid through MCM auto-payment" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeRevenuePaidThroughMcmAutopayment = 212,
        /// The total amount of Ad Exchange revenue based on the
        /// number of ad viewers.
        ///
        /// Corresponds to "Ad Exchange revenue per ad viewer" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeRevenuePerAdViewer = 429,
        /// The number of programmatic eligible queries in Ad Exchange.
        ///
        /// Corresponds to "Ad Exchange total requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdExchangeTotalRequests = 255,
        /// The ratio of total ad requests served by the Ad Exchange that
        /// resulted in users clicking on an ad. The clickthrough rate (CTR) is
        /// updated nightly. Ad Exchange Total Request CTR is calculated as:
        /// (Ad Exchange clicks / Ad Exchange Total Ad Requests).
        ///
        /// Corresponds to "Ad Exchange total request CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdExchangeTotalRequestCtr = 256,
        /// The average effective cost per thousand ad requests earned from the ads
        /// delivered by Ad Exchange through line item dynamic allocation and yield
        /// group partners.
        ///
        /// Corresponds to "Ad Exchange total request eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdExchangeTotalRequestEcpm = 257,
        /// Length of time in seconds that an ad is visible on the user's screen from
        /// Google Analytics.
        ///
        /// Corresponds to "Ad exposure (seconds)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdExposureSeconds = 241,
        /// The total number of times that an ad request is sent to the ad server
        /// including dynamic allocation.
        ///
        /// Corresponds to "Total ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdRequests = 38,
        /// Active View ad server average time in seconds that specific impressions
        /// are reported as being viewable.
        ///
        /// Corresponds to "Ad server Active View average viewable time (seconds)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdServerActiveViewAverageViewableTime = 67,
        /// Total number of impressions delivered by the ad server that were eligible
        /// to measure viewability.
        ///
        /// Corresponds to "Ad server Active View eligible impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerActiveViewEligibleImpressions = 64,
        /// The number of impressions delivered by the ad server that were sampled,
        /// and measurable by active view.
        ///
        /// Corresponds to "Ad server Active View measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerActiveViewMeasurableImpressions = 63,
        /// The percentage of impressions delivered by the ad server that were
        /// measurable by active view (out of all the ad server impressions sampled
        /// for active view).
        ///
        /// Corresponds to "Ad server Active View % measurable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerActiveViewMeasurableImpressionsRate = 66,
        /// The number of impressions delivered by Ad Server that were not measured.
        /// For example, impressions where measurement was attempted but failed.
        ///
        /// Corresponds to "Ad server Active View non-measurable impressions" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerActiveViewNonMeasurableImpressions = 332,
        /// The number of impressions delivered by Ad Server that were measured by
        /// active view, but deemed not viewable.
        ///
        /// Corresponds to "Ad server Active View non-viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerActiveViewNonViewableImpressions = 331,
        /// The fraction of non-viewable impressions among eligible impressions from
        /// Ad Server in Active View reporting."
        ///
        /// Corresponds to "Ad server Active View non-viewable impression
        /// distribution" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerActiveViewNonViewableImpressionsDistribution = 334,
        /// The fraction of non-eligible impressions among eligible impressions from
        /// Ad Server in Active View reporting."
        ///
        /// Corresponds to "Ad server Active View undetermined impression
        /// distribution" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerActiveViewUndeterminedImpressionsDistribution = 335,
        /// The number of impressions delivered by the ad server viewed on the user's
        /// screen.
        ///
        /// Corresponds to "Ad server Active View viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerActiveViewViewableImpressions = 62,
        /// The fraction of viewable impressions among eligible impressions from Ad
        /// Server in Active View reporting.
        ///
        /// Corresponds to "Ad server Active View viewable impression distribution"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerActiveViewViewableImpressionsDistribution = 333,
        /// The percentage of impressions delivered by the ad server viewed on the
        /// user's screen (out of the ad server impressions measurable by active
        /// view).
        ///
        /// Corresponds to "Ad server Active View % viewable impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerActiveViewViewableImpressionsRate = 65,
        /// Average effective cost-per-thousand-impressions earned from the ads
        /// delivered by the Google Ad Manager server.
        ///
        /// Corresponds to "Ad server average eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerAverageEcpm = 34,
        /// Average effective cost-per-thousand-impressions earned from the ads
        /// delivered by the Google Ad Manager server, excluding CPD value.
        ///
        /// Corresponds to "Ad server average eCPM w/o CPD" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerAverageEcpmWithoutCpd = 10,
        /// Total raw impressions counted when creative begins to render or the
        /// first frame of a video is shown.
        ///
        /// Corresponds to "Ad server begin to render impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerBeginToRenderImpressions = 262,
        /// Total clicks served by the Google Ad Manager server. It usually takes
        /// about 30 minutes for new clicks to be recorded and added to the total
        /// displayed in reporting.
        ///
        /// Corresponds to "Ad server clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerClicks = 7,
        /// The number of completed views for ad server.
        ///
        /// Corresponds to "Ad server completed views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerCompletedViews = 431,
        /// Total coviewed impressions delivered by the Ad Server.
        ///
        /// Corresponds to "Ad server impressions (co-viewed)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerCoviewedImpressions = 554,
        /// CPD revenue earned, calculated in your network's currency, for
        /// the ads delivered by the Google Ad Manager server. Sum of all booked
        /// revenue.
        ///
        /// Corresponds to "Ad server CPD revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerCpdRevenue = 32,
        /// Ratio of impressions served by the Google Ad Manager server that resulted
        /// in users clicking on an ad. The clickthrough rate (CTR) is updated
        /// nightly. The ad server CTR is calculated as: (Ad server clicks / Ad
        /// server impressions).
        ///
        /// Corresponds to "Ad server CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerCtr = 8,
        /// Gross revenue earned, calculated in your network's currency, for the ads
        /// delivered by the Google Ad Manager server.  This includes pre-rev-share
        /// revenue for Programmatic traffic. This metric is to help with the
        /// transition from gross to net revenue reporting.
        ///
        /// Corresponds to "Ad server total revenue (gross)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerGrossRevenue = 483,
        /// Gross revenue earned, calculated in your network's currency, for the ads
        /// delivered by the Google Ad Manager server, excluding CPD revenue. This
        /// includes pre-rev-share revenue for Programmatic traffic. This metric is
        /// to help with the transition from gross to net revenue reporting.
        ///
        /// Corresponds to "Ad server CPM and CPC revenue (gross)" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerGrossRevenueWithoutCpd = 484,
        /// Total impressions delivered by the Ad Server.
        ///
        /// Corresponds to "Ad server impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerImpressions = 6,
        /// Total impressions delivered by the Ad Server with companion impressions.
        ///
        /// Corresponds to "Ad server impressions with companion" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerImpressionsWithCompanion = 222,
        /// Impressions (via begin to render methodology) delivered by the Google Ad
        /// Manager server considered inactive, as defined by served to a device
        /// receiving ad or bid requests continuously for a session of greater than
        /// 16 hours without a "reset" event.
        ///
        /// Corresponds to "Ad server inactive begin to render impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerInactiveBeginToRenderImpressions = 338,
        /// Total number of ad server VAST errors discounting errors generated from
        /// video fallback ads.
        ///
        /// Corresponds to "Ad Server opportunities from errors" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerOpportunitiesFromErrors = 461,
        /// Total number of ad server impressions discounting video fallback
        /// impressions.
        ///
        /// Corresponds to "Ad Server opportunities from impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerOpportunitiesFromImpressions = 462,
        /// Ratio of clicks delivered by the Google Ad Manager server in relation to
        /// the total clicks delivered.
        ///
        /// Corresponds to "Ad server clicks (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerPercentClicks = 12,
        /// Ratio of impressions delivered by the Google Ad Manager server in
        /// relation to the total impressions delivered.
        ///
        /// Corresponds to "Ad server impressions (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerPercentImpressions = 11,
        /// Ratio of revenue generated by the Google Ad Manager server in relation
        /// to the total revenue.
        ///
        /// Corresponds to "Ad server revenue (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerPercentRevenue = 35,
        /// Ratio of revenue generated by the Google Ad Manager server (excluding
        /// CPD) in relation to the total revenue.
        ///
        /// Corresponds to "Ad server revenue w/o CPD (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        AdServerPercentRevenueWithoutCpd = 13,
        /// The total number of times that an ad is served by the ad server.
        ///
        /// Corresponds to "Ad server responses served" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerResponsesServed = 40,
        /// All CPM, CPC, and CPD revenue earned, calculated in your network's
        /// currency, for the ads delivered by the Google Ad Manager server.
        /// Sum of all booked revenue.
        ///
        /// Corresponds to "Ad server total revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerRevenue = 33,
        /// The Google Ad Manager server revenue accrued in the child network's own
        /// account but paid to their parent network through auto-payment. This
        /// metric is only relevant for a "Manage Account" child network.
        ///
        /// Corresponds to "Ad server revenue paid through MCM auto-payment" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerRevenuePaidThroughMcmAutopayment = 213,
        /// Revenue (excluding CPD) earned, calculated in your network's currency,
        /// for the ads delivered by the Google Ad Manager server. Sum of all booked
        /// revenue.
        ///
        /// Corresponds to "Ad server CPM and CPC revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AdServerRevenueWithoutCpd = 9,
        /// The number of clicks delivered by the ad server by explicit custom
        /// criteria targeting.
        ///
        /// Corresponds to "Ad server targeted clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerTargetedClicks = 274,
        /// The number of impressions delivered by the ad server by explicit custom
        /// criteria targeting.
        ///
        /// Corresponds to "Ad server targeted impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerTargetedImpressions = 275,
        /// The number of tracked ads delivered by the ad server.
        ///
        /// Corresponds to "Ad server tracked ads" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerTrackedAds = 264,
        /// Total raw impressions counted when creative begins to render or the
        /// first frame of a video is shown, before invalid traffic filtrations by
        /// Ad Server.
        ///
        /// Corresponds to "Ad server unfiltered begin to render impressions" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerUnfilteredBeginToRenderImpressions = 261,
        /// Total clicks delivered by the Ad Server before spam filtering.
        ///
        /// Corresponds to "Ad server unfiltered clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerUnfilteredClicks = 259,
        /// Total downloaded impressions delivered by the Ad Server before spam
        /// filtering.
        ///
        /// Corresponds to "Ad server unfiltered downloaded impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerUnfilteredDownloadedImpressions = 260,
        /// The number of tracked ads delivered by the ad server before invalid
        /// traffic filtrations.
        ///
        /// Corresponds to "Ad server unfiltered tracked ads" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdServerUnfilteredTrackedAds = 263,
        /// Length of time in seconds that an ad unit is visible on the user's screen
        /// from Google Analytics.
        ///
        /// Corresponds to "Ad unit exposure (seconds)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AdUnitExposureSeconds = 242,
        /// The number of users who viewed an ads on your site or app in the
        /// specified date range from Google Analytics.
        ///
        /// Corresponds to "Ad viewers" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        AdViewers = 425,
        /// Number of ads that Ad Manager failed to render in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Ads failed to render" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnAdsFailedToRender = 430,
        /// Number of line items that matched an ad request in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Eligible line items" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnEligibleLineItems = 342,
        /// Number of ad requests that contain eligible line items for the auction in
        /// the Ads traffic navigator report.
        ///
        /// Corresponds to "Ad requests with eligible line items" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnEligibleLineItemsAdRequests = 343,
        /// Number of ad requests that have header bidding trafficking demand in the
        /// Ads traffic navigator report.
        ///
        /// Corresponds to "Ad requests allowing header bidding trafficking" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtAllowedAdRequests = 344,
        /// Number of header bidding trafficking bids that are able to match an ad
        /// request and enter the auction in the Ads traffic navigator report.
        ///
        /// Corresponds to "Competing header bidding trafficking bids" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtBidsInAuction = 345,
        /// Number of header bidding trafficking ad requests with bids in auction in
        /// the Ads traffic navigator report.
        ///
        /// Corresponds to "Ad requests with competing header bidding trafficking
        /// bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtBidsInAuctionAdRequests = 346,
        /// Number of header bidding trafficking candidate bids that match an ad
        /// request in the Ads traffic navigator report.
        ///
        /// Corresponds to "Header bidding trafficking bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtCandidateBids = 347,
        /// Number of invalid header bidding trafficking ad requests in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Invalid ad requests allowing header bidding trafficking"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtInvalidAdRequests = 348,
        /// Number of header bidding trafficking ad requests with no bids in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Ad requests with no header bidding trafficking bids" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtNoBidsAdRequests = 472,
        /// Number of header bidding trafficking bids that didn't match the ad
        /// request in the Ads traffic navigator report.
        ///
        /// Corresponds to "Rejected header bidding trafficking bids" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtRejectedBids = 349,
        /// Number of ad requests with the header bidding trafficking demand that are
        /// valid in the Ads traffic navigator report.
        ///
        /// Corresponds to "Valid header bidding trafficking ad requests" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtValidAdRequests = 350,
        /// Number of header bidding trafficking ad requests with bids in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Ad requests with header bidding trafficking bids" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnHbtWithBidsAdRequests = 473,
        /// Ad requests that are not valid in the Ads traffic navigator report.
        ///
        /// Corresponds to "Invalid ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnInvalidAdRequests = 351,
        /// Number of line items with no creative retrieved in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Line items with no creative retrieved" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnLineItemsCreativeNotRetrieved = 476,
        /// Number of line items that matched an ad request and entered in auction in
        /// the Ads traffic navigator report.
        ///
        /// Corresponds to "Competing line items" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnLineItemsInAuction = 352,
        /// Number of line items that were ranked but did not compete in auction in
        /// the Ads traffic navigator report.
        ///
        /// Corresponds to "Non-competing line items" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnLineItemsNotCompeting = 515,
        /// Number of line items that matched an ad request but were not selected to
        /// compete in the auction in the Ads traffic navigator report.
        ///
        /// Corresponds to "Line items not selected to compete" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnLineItemsNotSelected = 353,
        /// Number of line item ad requests in auction in the Ads traffic navigator
        /// report.
        ///
        /// Corresponds to "Ad requests with competing line items" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnLineItemInAuctionAdRequests = 354,
        /// Number of line item targeted ad requests in the Ads traffic navigator
        /// report.
        ///
        /// Corresponds to "Ad requests with targeted line items" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnLineItemTargetedAdRequests = 355,
        /// Number of ad requests with the mediation demand in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Ad requests allowing mediation" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationAllowedAdRequests = 356,
        /// Number of invalid mediation ad requests in the Ads traffic navigator
        /// report.
        ///
        /// Corresponds to "Invalid ad requests allowing mediation" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationInvalidAdRequests = 357,
        /// Number of times the Yield Partner's ad was loaded in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Loaded ads from chains" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationLoadedAdsFromChains = 358,
        /// Number of ad requests with mediation demand having no partners in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Ad requests with no targeted mediation partners" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationNoPartnerAdRequests = 474,
        /// Number of mediation yield partners in auction in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Competing mediation partners" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationPartnersInAuction = 359,
        /// Number of ad requests in auction that serve mediation chains in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Ad requests with competing mediation partners" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationPartnersInAuctionAdRequests = 360,
        /// Number of mediation partners that didn't match an ad request in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Rejected partners" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationRejectedPartners = 361,
        /// Number of mediation partners that have targeted an ad request and are
        /// able to match it in the Ads traffic navigator report.
        ///
        /// Corresponds to "Targeted mediation partners" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationTargetedPartners = 362,
        /// Number of partners on served mediation chains in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Total yield partners" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationTotalYieldPartners = 442,
        /// Number of ads from mediation chains that Ad Manager won't serve in the
        /// Ads traffic navigator report.
        ///
        /// Corresponds to "Unloaded ads from chains" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationUnloadedAdsFromChains = 363,
        /// Number of times the Yield Partner's mediation chain ad was not reached
        /// in the Ads traffic navigator report.
        ///
        /// Corresponds to "Unused bids or partners" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationUnusedBidsOrPartners = 364,
        /// Number of ad requests that have mediation demand in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Valid mediation ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationValidAdRequests = 365,
        /// Number of ad requests with mediation demand having partners in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Ad requests with targeted mediation partners" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnMediationWithPartnersAdRequests = 475,
        /// Number of ad requests with programmatic demand that have received a bid
        /// in the Ads traffic navigator report.
        ///
        /// Corresponds to "Ad requests with bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticAdRequestsWithBids = 366,
        /// Number of ad requests with programmatic demand that have sent a bid to at
        /// least one buyer in the Ads traffic navigator report.
        ///
        /// Corresponds to "Ad requests with bid requests sent" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticAdRequestsWithBidRequestsSent = 367,
        /// Number of ad requests with programmatic demand in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Ad requests allowing programmatic" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticAllowedAdRequests = 368,
        /// Number of ads with programmatic bids that entered the auction
        /// in the Ads traffic navigator report.
        ///
        /// Corresponds to "Competing programmatic bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticBidsInAuction = 369,
        /// Number of ad requests that have received eligible programmatic bids to
        /// compete in the auction in the Ads traffic navigator report.
        ///
        /// Corresponds to "Ad requests with competing programmatic bids" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticBidInAuctionAdRequests = 370,
        /// Number of programmatic callout bid requests sent to buyers in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Bid requests sent" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticBidRequestsSent = 371,
        /// Number of programmatic callout bid requests that resulted with a response
        /// in the Ads traffic navigator report.
        ///
        /// Corresponds to "Bid requests with response" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticBidRequestsWithResponse = 372,
        /// All buyers that Ad Manager could potentially send a programmatic bid
        /// request to in the Ads traffic navigator report.
        ///
        /// Corresponds to "Bid request candidates" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticBidRequestCandidates = 373,
        /// Number of programmatic callout bid requests with errors in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Bid request errors" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticBidRequestErrors = 374,
        /// Number of ad requests that are ineligible for programmatic in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Invalid ad requests allowing programmatic" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticIneligibleAdRequests = 375,
        /// Number of programmatic callout bids rejected in the Ads traffic navigator
        /// report.
        ///
        /// Corresponds to "Rejected bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticRejectedBids = 376,
        /// Number of programmatic callout bid requests Ad Manager won't send to
        /// buyers in the Ads traffic navigator report.
        ///
        /// Corresponds to "Skipped bid requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticSkippedBidRequests = 377,
        /// Number of programmatic bids that Ad Manager received from buyers in the
        /// Ads traffic navigator report.
        ///
        /// Corresponds to "Total programmatic bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticTotalBids = 378,
        /// Number of ad requests that allow programmatic in the Ads traffic
        /// navigator report.
        ///
        /// Corresponds to "Valid ad requests allowing programmatic" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnProgrammaticValidAdRequests = 379,
        /// Number of line items targeted that didn't match an ad request in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Rejected line items" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnRejectedLineItems = 380,
        /// Number of mediation chains Ad Manager serves in the Ads traffic navigator
        /// report.
        ///
        /// Corresponds to "Served mediation chains" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnServedMediationChains = 381,
        /// Number of single ads served in the Ads traffic navigator report.
        ///
        /// Corresponds to "Served single ads" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnServedSingleAds = 382,
        /// Number of line items with targeting that matches an ad request in the Ads
        /// traffic navigator report.
        ///
        /// Corresponds to "Targeted line items" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnTargetedLineItems = 383,
        /// Total number of ad requests which counts optimized pod request as a
        /// single request in the Ads traffic navigator report.
        ///
        /// Corresponds to "Total ad requests (Ads traffic navigator)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnTotalAdRequests = 384,
        /// Number of competing ads in auction in the Ads traffic navigator report.
        ///
        /// Corresponds to "Total competing ads" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnTotalCompetingAdsInAuction = 385,
        /// Total number of ads loaded in the Ads traffic navigator report.
        ///
        /// Corresponds to "Total loaded ads" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnTotalLoadedAds = 387,
        /// Ad requests that are valid in the Ads traffic navigator report.
        ///
        /// Corresponds to "Valid ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnValidAdRequests = 389,
        /// Number of times the Yield Partner passed-back on a Mediation chain ad in
        /// the Ads traffic navigator report.
        ///
        /// Corresponds to "Yield group mediation passbacks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        AtnYieldGroupMediationPassbacks = 390,
        /// Cost of the audience segment.
        ///
        /// Corresponds to "Audience segment cost" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AudienceSegmentCost = 558,
        /// eCPM averaged across the Google Ad Manager server, AdSense,
        /// and Ad Exchange.
        ///
        /// Corresponds to "Total average eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AverageEcpm = 37,
        /// eCPM averaged across the Google Ad Manager server (excluding CPD),
        /// AdSense, and Ad Exchange.
        ///
        /// Corresponds to "Total average eCPM w/o CPD" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `MONEY`
        AverageEcpmWithoutCpd = 5,
        /// Average user engagement seconds per session in Google Analytics.
        ///
        /// Corresponds to "Average engagement time per session (seconds)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AverageEngagementSecondsPerSession = 224,
        /// Average user engagement seconds per user in Google Analytics.
        ///
        /// Corresponds to "Average engagement time per user (seconds)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AverageEngagementSecondsPerUser = 225,
        /// The average number of unique users reached per ad impression.
        ///
        /// Corresponds to "Average impressions/unique visitor" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REACH`
        ///
        /// Data format: `DOUBLE`
        AverageImpressionsPerUniqueVisitor = 418,
        /// Average total purchase revenue per user in Google Analytics.
        ///
        /// Corresponds to "ARPPU" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AveragePurchaseRevenuePerPayingUser = 226,
        /// Average revenue earned from each active user in Google Analytics.
        ///
        /// Corresponds to "ARPU" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        AverageRevenuePerUser = 227,
        /// Average length of a session in Google Analytics.
        ///
        /// Corresponds to "Average session duration (seconds)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        AverageSessionSeconds = 228,
        /// The number of bids.
        ///
        /// Corresponds to "Bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        Bids = 443,
        /// The average CPM of the bids submitted by bidders.
        ///
        /// Corresponds to "Average bid CPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        BidAverageCpm = 444,
        /// The ratio of (sessions - engaged sessions) / sessions.
        ///
        /// Corresponds to "Bounce rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        BounceRate = 433,
        /// The number of times a user clicked on an ad.
        ///
        /// Corresponds to "Total clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        Clicks = 2,
        /// The total number of times that the code for an ad is served by the ad
        /// server including dynamic allocation.
        ///
        /// Corresponds to "Total code served count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        CodeServedCount = 44,
        /// Total amount of CPC revenue.
        ///
        /// Corresponds to "CPC revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `MONEY`
        CpcRevenue = 440,
        /// Total amount of CPM revenue.
        ///
        /// Corresponds to "CPM revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `MONEY`
        CpmRevenue = 441,
        /// Percent of creatives whose load time is between \[0, 500ms).
        ///
        /// Corresponds to "Creative load time 0 - 500ms (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        CreativeLoadTime0500Percent = 324,
        /// Percent of creatives whose load time is between \[1000, 2000ms).
        ///
        /// Corresponds to "Creative load time 1s - 2s (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        CreativeLoadTime10002000Percent = 326,
        /// Percent of creatives whose load time is between \[2000, 4000ms).
        ///
        /// Corresponds to "Creative load time 2s - 4s (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        CreativeLoadTime20004000Percent = 327,
        /// Percent of creatives whose load time is between \[4000, 8000ms).
        ///
        /// Corresponds to "Creative load time 4s - 8s (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        CreativeLoadTime40008000Percent = 328,
        /// Percent of creatives whose load time is between \[500, 1000ms).
        ///
        /// Corresponds to "Creative load time 500ms - 1s (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        CreativeLoadTime5001000Percent = 325,
        /// Percent of creatives load time is greater than 8000ms.
        ///
        /// Corresponds to "Creative load time >8s (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        CreativeLoadTimeGt8000Percent = 329,
        /// For standard ads, your ad clickthrough rate (CTR) is the number of ad
        /// clicks divided by the number of individual ad impressions expressed as a
        /// fraction. Ad CTR = Clicks / Ad impressions.
        ///
        /// Corresponds to "Total CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        Ctr = 3,
        /// Number of bids received for a deal.
        ///
        /// Corresponds to "Deals bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        DealsBids = 542,
        /// Bid rate for a deal.
        ///
        /// Corresponds to "Deals bid rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        DealsBidRate = 543,
        /// Number of bid requests sent for a deal.
        ///
        /// Corresponds to "Deals bid requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        DealsBidRequests = 544,
        /// Number of winning bids for a deal.
        ///
        /// Corresponds to "Deals winning bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        DealsWinningBids = 545,
        /// Bid win rate for a deal.
        ///
        /// Corresponds to "Deals win rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        DealsWinRate = 546,
        /// Percent of dom load time to 1st ad request in \[0, 500ms) range.
        ///
        /// Corresponds to "Page navigation to first ad request time 0 - 500ms (%)"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToFirstAdRequest0500Percent = 521,
        /// Percent of dom load time to 1st ad request in \[1000ms, 2000ms) range.
        ///
        /// Corresponds to "Page navigation to first ad request time 1s - 2s (%)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToFirstAdRequest10002000Percent = 522,
        /// Percent of dom load time to 1st ad request in \[2000ms, 4000ms) range.
        ///
        /// Corresponds to "Page navigation to first ad request time 2s - 4s (%)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToFirstAdRequest20004000Percent = 523,
        /// Percent of dom load time to 1st ad request in \[4000ms, 8000ms) range.
        ///
        /// Corresponds to "Page navigation to first ad request time 4s - 8s (%)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToFirstAdRequest40008000Percent = 524,
        /// Percent of dom load time to 1st ad request in \[500ms, 1000ms) range.
        ///
        /// Corresponds to "Page navigation to first ad request time 500ms - 1s (%)"
        /// in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToFirstAdRequest5001000Percent = 525,
        /// Percent of dom load time to 1st ad request in \[8000ms, +inf) range.
        ///
        /// Corresponds to "Page navigation to first ad request time >8s (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToFirstAdRequestGt8000Percent = 520,
        /// Percent of dom load time to tag load time in \[0, 500ms) range.
        ///
        /// Corresponds to "Page navigation to tag loaded time 0 - 500ms (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToTagLoadTime0500Percent = 526,
        /// Percent of dom load time to tag load time in \[1000ms, 2000ms) range.
        ///
        /// Corresponds to "Page navigation to tag loaded time 1s - 2s (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToTagLoadTime10002000Percent = 527,
        /// Percent of dom load time to tag load time in \[2000ms, 4000ms) range.
        ///
        /// Corresponds to "Page navigation to tag loaded time 2s - 4s (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToTagLoadTime20004000Percent = 528,
        /// Percent of dom load time to tag load time in \[4000ms, 8000ms) range.
        ///
        /// Corresponds to "Page navigation to tag loaded time 4s - 8s (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToTagLoadTime40008000Percent = 529,
        /// Percent of dom load time to tag load time in \[500ms, 1000ms) range.
        ///
        /// Corresponds to "Page navigation to tag loaded time 500ms - 1s (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToTagLoadTime5001000Percent = 531,
        /// Percent of dom load time to tag load time in \[8000ms, +inf) range.
        ///
        /// Corresponds to "Page navigation to tag loaded time >8s (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        DomLoadToTagLoadTimeGt8000Percent = 530,
        /// Percentage of ad responses that didn't result in an impression.
        ///
        /// Corresponds to "Drop-off rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        DropoffRate = 415,
        /// Engaged session count from Google Analytics.
        ///
        /// Corresponds to "Engaged sessions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        EngagedSessions = 229,
        /// Engaged sessions per user from Google Analytics.
        ///
        /// Corresponds to "Engaged sessions per user" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        EngagedSessionsPerUser = 230,
        /// The ratio of engaged sessions to sessions.
        ///
        /// Corresponds to "Engagement rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        EngagementRate = 426,
        /// Percentage of European regulations messages where the user consented to
        /// all of the purposes and vendors.
        ///
        /// Corresponds to "European regulations consent rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        EuropeanRegulationsConsentRate = 270,
        /// Percentage of European regulations messages where users made a consent
        /// choice after selecting "Manage options".
        ///
        /// Corresponds to "European regulations custom consent rate" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        EuropeanRegulationsCustomConsentRate = 271,
        /// Number of times a European regulations message was shown to users.
        ///
        /// Corresponds to "European regulations messages shown" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        EuropeanRegulationsMessagesShown = 272,
        /// Percentage of European regulations messages where the user rejected all
        /// purposes and vendors.
        ///
        /// Corresponds to "European regulations no consent rate" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        EuropeanRegulationsNoConsentRate = 273,
        /// The rate at which an ad request is filled by the ad server including
        /// dynamic allocation.
        ///
        /// Corresponds to "Total fill rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        FillRate = 258,
        /// The number of clicks joined with Google Analytics data.
        ///
        /// Corresponds to "Google Analytics clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        GoogleAnalyticsClicks = 231,
        /// The click-through rate from Google Analytics data.
        ///
        /// Corresponds to "Google Analytics CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        GoogleAnalyticsCtr = 232,
        /// The eCPM revenue data from Google Analytics.
        ///
        /// Corresponds to "Google Analytics eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        GoogleAnalyticsEcpm = 233,
        /// The number of impressions joined with Google Analytics data.
        ///
        /// Corresponds to "Google Analytics impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        GoogleAnalyticsImpressions = 234,
        /// The amount of revenue joined with Google Analytics data.
        ///
        /// Corresponds to "Google Analytics revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        GoogleAnalyticsRevenue = 235,
        /// Number of views of a web site or mobile screen from Google Analytics.
        ///
        /// Corresponds to "Views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        GoogleAnalyticsViews = 236,
        /// Number of views per user from Google Analytics.
        ///
        /// Corresponds to "Views per user" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        GoogleAnalyticsViewsPerUser = 237,
        /// The number of coviewed impressions sold by Google in partner sales.
        ///
        /// Corresponds to "Google-sold auction impressions (co-viewed)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        GoogleSoldAuctionCoviewedImpressions = 129,
        /// The number of auction impressions sold by Google in partner sales.
        ///
        /// Corresponds to "Google-sold auction impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        GoogleSoldAuctionImpressions = 128,
        /// The number of coviewed impressions sold by Google in partner sales.
        ///
        /// Corresponds to "Google-sold impressions (co-viewed)" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        GoogleSoldCoviewedImpressions = 131,
        /// The number of impressions sold by Google in partner sales.
        ///
        /// Corresponds to "Google-sold impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        GoogleSoldImpressions = 130,
        /// The number of coviewed impressions sold by Google in partner sales.
        ///
        /// Corresponds to "Google-sold reservation impressions (co-viewed)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        GoogleSoldReservationCoviewedImpressions = 127,
        /// The number of reservation impressions sold by Google in partner sales.
        ///
        /// Corresponds to "Google-sold reservation impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        GoogleSoldReservationImpressions = 126,
        /// Total impressions from the Google Ad Manager server, AdSense,
        /// Ad Exchange, and yield group partners.
        ///
        /// Corresponds to "Total impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `INTEGER`
        Impressions = 1,
        /// The number of impressions (via begin to render methodology) considered
        /// inactive, as defined by served to a device receiving ad or bid requests
        /// continuously for a session of greater than 16 hours without a "reset"
        /// event. Only applied to CTV ads.
        ///
        /// Corresponds to "Inactive begin to render impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        InactiveBeginToRenderImpressions = 407,
        /// The total number of inventory shares
        ///
        /// Corresponds to "Inventory shares" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        InventoryShares = 547,
        /// The total number of partner unfilled opportunities from an inventory
        /// share
        ///
        /// Corresponds to "Inventory share partner unfilled opportunities" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        InventorySharePartnerUnfilledOpportunities = 548,
        /// The number of invoiced impressions.
        ///
        /// Corresponds to "Invoiced impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        InvoicedImpressions = 404,
        /// The number of invoiced unfilled impressions.
        ///
        /// Corresponds to "Invoiced unfilled impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        InvoicedUnfilledImpressions = 405,
        /// The number of mediation chains that were filled.
        ///
        /// Corresponds to "Mediation chains filled" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        MediationChainsFilled = 584,
        /// The number of impressions where the user chose to mute the ad.
        ///
        /// Corresponds to "Total muted impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        MutedImpressions = 412,
        /// The number of impressions that had the "Mute This Ad" overlay applied.
        ///
        /// Corresponds to "Total mute eligible impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        MuteEligibleImpressions = 409,
        /// The total number of opportunities from impressions and errors.
        ///
        /// Corresponds to "Total opportunities" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        Opportunities = 463,
        /// The number of impressions that were overdelivered.
        ///
        /// Corresponds to "Total overdelivered impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        OverdeliveredImpressions = 432,
        /// The gross revenue for partner finance reports.
        ///
        /// Corresponds to "Gross revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PARTNER_FINANCE`
        ///
        /// Data format: `MONEY`
        PartnerFinanceGrossRevenue = 648,
        /// Monthly host eCPM for partner finance reports
        ///
        /// Corresponds to "Host eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PARTNER_FINANCE`
        ///
        /// Data format: `MONEY`
        PartnerFinanceHostEcpm = 649,
        /// The host impressions for partner finance reports.
        ///
        /// Corresponds to "Host impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PARTNER_FINANCE`
        ///
        /// Data format: `INTEGER`
        PartnerFinanceHostImpressions = 650,
        /// Monthly host revenue for partner finance reports
        ///
        /// Corresponds to "Host revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PARTNER_FINANCE`
        ///
        /// Data format: `MONEY`
        PartnerFinanceHostRevenue = 651,
        /// Monthly partner eCPM for partner finance reports
        ///
        /// Corresponds to "Partner eCPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PARTNER_FINANCE`
        ///
        /// Data format: `MONEY`
        PartnerFinancePartnerEcpm = 652,
        /// Monthly partner revenue for partner finance reports
        ///
        /// Corresponds to "Partner revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PARTNER_FINANCE`
        ///
        /// Data format: `MONEY`
        PartnerFinancePartnerRevenue = 653,
        /// The gross revenue in the partner management.
        ///
        /// Corresponds to "Partner management gross revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        PartnerManagementGrossRevenue = 533,
        /// The host clicks in the partner management.
        ///
        /// Corresponds to "Partner management host clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PartnerManagementHostClicks = 534,
        /// The host CTR in the partner management.
        ///
        /// Corresponds to "Partner management host CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        PartnerManagementHostCtr = 535,
        /// The host impressions in the partner management.
        ///
        /// Corresponds to "Partner management host impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PartnerManagementHostImpressions = 536,
        /// The partner clicks in the partner management.
        ///
        /// Corresponds to "Partner management partner clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PartnerManagementPartnerClicks = 537,
        /// The partner CTR in the partner management.
        ///
        /// Corresponds to "Partner management partner CTR" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        PartnerManagementPartnerCtr = 538,
        /// The partner impressions in the partner management.
        ///
        /// Corresponds to "Partner management partner impressions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PartnerManagementPartnerImpressions = 539,
        /// The total content views in the partner management.
        ///
        /// Corresponds to "Partner management total monetizable content views" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        PartnerManagementTotalContentViews = 540,
        /// The unfilled impressions in the partner management.
        ///
        /// Corresponds to "Partner management unfilled impressions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`,
        /// `PARTNER_FINANCE`
        ///
        /// Data format: `INTEGER`
        PartnerManagementUnfilledImpressions = 541,
        /// The number of filled pod requests (filled by partner or Google) in
        /// partner sales.
        ///
        /// Corresponds to "Filled pod requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSalesFilledPodRequests = 135,
        /// The percent of filled requests to total ad requests in
        /// partner sales.
        ///
        /// Corresponds to "Fill rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `PERCENT`
        PartnerSalesFillRate = 136,
        /// The percent of partner filled requests to total ad requests
        /// in partner sales.
        ///
        /// Corresponds to "Partner match rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `PERCENT`
        PartnerSalesPartnerMatchRate = 137,
        /// The number of queries eligible for partner sales.
        ///
        /// Corresponds to "Total partner sales ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSalesQueries = 132,
        /// The number of partner unfilled impressions in partner sales.
        /// If a pod request is not filled by partner but filled by Google, this
        /// metric will still count 1.
        ///
        /// Corresponds to "Partner unfilled impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSalesUnfilledImpressions = 133,
        /// The number of partner unmatched queries in partner sales.
        /// If an ad request is not filled by partner but filled by Google, this
        /// metric will still count 1.
        ///
        /// Corresponds to "Partner unmatched ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSalesUnmatchedQueries = 134,
        /// The number of code served sold by partner in partner sales.
        ///
        /// Corresponds to "Partner-sold code served count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSoldCodeServed = 125,
        /// The number of coviewed impressions sold by partner in partner sales.
        ///
        /// Corresponds to "Partner-sold impressions (co-viewed)" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSoldCoviewedImpressions = 124,
        /// The number of impressions sold by partner in partner sales.
        ///
        /// Corresponds to "Partner-sold impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        PartnerSoldImpressions = 123,
        /// The total number of ad requests eligible for programmatic inventory,
        /// including Programmatic Guaranteed, Preferred Deals, backfill, and open
        /// auction.
        ///
        /// Corresponds to "Programmatic eligible ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ProgrammaticEligibleAdRequests = 177,
        /// The number of programmatic responses served divided by the number of
        /// programmatic eligible ad requests. Includes Ad Exchange, Open Bidding,
        /// and Preferred Deals.
        ///
        /// Corresponds to "Programmatic match rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        ProgrammaticMatchRate = 178,
        /// Total number of ad responses served from programmatic demand sources.
        /// Includes Ad Exchange, Open Bidding, and Preferred Deals.
        ///
        /// Differs from AD_EXCHANGE_RESPONSES_SERVED, which doesn't include Open
        /// Bidding ad requests.
        ///
        /// Corresponds to "Programmatic responses served" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ProgrammaticResponsesServed = 176,
        /// Number of impressions for reach reports.
        ///
        /// Corresponds to "Total reach impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REACH`
        ///
        /// Data format: `INTEGER`
        ReachImpressions = 416,
        /// The total number of times that an ad is served by the ad server including
        /// dynamic allocation.
        ///
        /// Corresponds to "Total responses served" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ResponsesServed = 39,
        /// Retention of users in Google Analytics
        ///
        /// Corresponds to "Retention" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        Retention = 238,
        /// Total amount of CPM, CPC, and CPD revenue based on the number of units
        /// served by the Google Ad Manager server, AdSense, Ad Exchange, and
        /// third-party Mediation networks.
        ///
        /// Corresponds to "Total revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`, `AD_SPEED`
        ///
        /// Data format: `MONEY`
        Revenue = 36,
        /// The total revenue accrued in the child network's own account but paid to
        /// their parent network through auto-payment. This metric is only relevant
        /// for a "Manage Account" child network.
        ///
        /// Corresponds to "Total revenue paid through MCM auto-payment" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        RevenuePaidThroughMcmAutopayment = 214,
        /// The total CPD net revenue for Revenue Verification reporting.
        ///
        /// Corresponds to "Total CPD revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REVENUE_VERIFICATION`
        ///
        /// Data format: `MONEY`
        RevenueVerificationCpdRevenue = 560,
        /// The total CPD gross revenue for Revenue Verification reporting.
        ///
        /// Corresponds to "Total CPD revenue (gross)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REVENUE_VERIFICATION`
        ///
        /// Data format: `MONEY`
        RevenueVerificationGrossCpdRevenue = 559,
        /// The total gross revenue (excluding CPD) for Revenue Verification
        /// reporting.
        ///
        /// Corresponds to "Total CPM and CPC revenue (gross)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REVENUE_VERIFICATION`
        ///
        /// Data format: `MONEY`
        RevenueVerificationGrossRevenueWithoutCpd = 561,
        /// The total impressions for Revenue Verification reporting.
        ///
        /// Corresponds to "Total impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REVENUE_VERIFICATION`
        ///
        /// Data format: `INTEGER`
        RevenueVerificationImpressions = 564,
        /// The total net revenue (excluding CPD) for Revenue Verification reporting.
        ///
        /// Corresponds to "Total CPM and CPC revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REVENUE_VERIFICATION`
        ///
        /// Data format: `MONEY`
        RevenueVerificationRevenueWithoutCpd = 567,
        /// Total revenue (excluding CPD) based on the number of units
        /// served by the Google Ad Manager server, AdSense, Ad Exchange, and
        /// third-party Mediation networks.
        ///
        /// Corresponds to "Total CPM and CPC revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        RevenueWithoutCpd = 4,
        /// The number of rewards granted to users from watching ads.
        ///
        /// Corresponds to "Total rewards granted" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RewardsGranted = 413,
        /// The average amount of time (in seconds) that each rich media ad is
        /// displayed to users.
        ///
        /// Corresponds to "Average display time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaAverageDisplayTime = 587,
        /// The average amount of time (in seconds) that a user interacts with a rich
        /// media ad.
        ///
        /// Corresponds to "Average interaction time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaAverageInteractionTime = 588,
        /// The total number of times a backup image is served in place of a rich
        /// media ad.
        ///
        /// Corresponds to "Backup image impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaBackupImages = 589,
        /// The number of times a user interacts with a specific part of a rich media
        /// ad.
        ///
        /// Corresponds to "Custom event - count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaCustomEventCount = 599,
        /// The amount of time (in seconds) that a user interacts with a specific
        /// part of a rich media ad.
        ///
        /// Corresponds to "Custom event - time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaCustomEventTime = 600,
        /// The amount of time (in seconds) that each rich media ad is displayed to
        /// users.
        ///
        /// Corresponds to "Total display time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaDisplayTime = 590,
        /// The average amount of time (in seconds) that an expanding ad is viewed in
        /// an expanded state.
        ///
        /// Corresponds to "Average expanding time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaExpandingTime = 591,
        /// The number of times an expanding ad was expanded.
        ///
        /// Corresponds to "Total expansions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaExpansions = 592,
        /// The number of times a user opens a rich media ad in full screen mode.
        ///
        /// Corresponds to "Full-screen impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaFullScreenImpressions = 593,
        /// The number of times that a user interacts with a rich media ad.
        ///
        /// Corresponds to "Total interactions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaInteractionCount = 594,
        /// The ratio of rich media ad interactions to the number of times the ad
        /// was displayed.
        ///
        /// Corresponds to "Interaction rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        RichMediaInteractionRate = 595,
        /// The total amount of time (in seconds) that a user interacts with a rich
        /// media ad.
        ///
        /// Corresponds to "Interaction time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaInteractionTime = 596,
        /// The number of impressions where a user interacted with a rich media ad.
        ///
        /// Corresponds to "Interactive impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaInteractiveImpressions = 597,
        /// The number of times that a user manually closes a rich media ad.
        ///
        /// Corresponds to "Manual closes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaManualCloses = 598,
        /// The number of times a rich media video was fully played.
        ///
        /// Corresponds to "Rich media video completes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoCompletes = 503,
        /// The number of times a user clicked on the graphical controls of a video
        /// player.
        ///
        /// Corresponds to "Rich media total video interactions" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoInteractions = 505,
        /// The ratio of video interactions to video plays. Represented as a
        /// percentage.
        ///
        /// Corresponds to "Rich media video interaction rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        RichMediaVideoInteractionRate = 504,
        /// The number of times a rich media video was played up to midpoint.
        ///
        /// Corresponds to "Rich media video midpoints" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoMidpoints = 506,
        /// The number of times a rich media video was muted.
        ///
        /// Corresponds to "Rich media video mutes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoMutes = 507,
        /// The number of times a rich media video was paused.
        ///
        /// Corresponds to "Rich media video pauses" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoPauses = 508,
        /// The number of times a rich media video was played.
        ///
        /// Corresponds to "Rich media video plays" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoPlays = 509,
        /// The number of times a rich media video was restarted.
        ///
        /// Corresponds to "Rich media video replays" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoReplays = 510,
        /// The number of times a rich media video was stopped.
        ///
        /// Corresponds to "Rich media video stops" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoStops = 511,
        /// The number of times a rich media video was unmuted.
        ///
        /// Corresponds to "Rich media video unmutes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        RichMediaVideoUnmutes = 512,
        /// The percentage of a video watched by a user.
        ///
        /// Corresponds to "Rich media video view rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        RichMediaVideoViewRate = 513,
        /// The average amount of time(seconds) that a rich media video was viewed
        /// per view.
        ///
        /// Corresponds to "Rich media video average view time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        RichMediaVideoViewTime = 514,
        /// The number of forecasted impressions not reserved by any line item.
        ///
        /// Corresponds to "Available impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        SellThroughAvailableImpressions = 477,
        /// The total number of forecasted impressions.
        ///
        /// Corresponds to "Forecasted impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        SellThroughForecastedImpressions = 478,
        /// The number of forecasted impressions reserved by line items.
        ///
        /// Corresponds to "Reserved impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        SellThroughReservedImpressions = 479,
        /// The fraction of forecasted impressions reserved by line items.
        ///
        /// Corresponds to "Sell-through rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `PERCENT`
        SellThroughSellThroughRate = 480,
        /// The average latency in milliseconds across all server-side unwrapping
        /// callout requests. There is no special handling for error or timeout
        /// responses. This reflects the entire chain of a parent callout request,
        /// which may result in multiple child callouts. This metric is not sliced
        /// by child callout dimensions.
        ///
        /// Corresponds to "Server-side unwrapping average latency (milliseconds)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        ServerSideUnwrappingAverageLatencyMs = 434,
        /// The total number of server-side unwrapping callout requests.
        ///
        /// Corresponds to "Server-side unwrapping callouts" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ServerSideUnwrappingCallouts = 435,
        /// The total number of server-side unwrapping callouts that returned an
        /// empty response. Timeouts are not considered empty responses.
        ///
        /// Corresponds to "Server-side unwrapping empty responses" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ServerSideUnwrappingEmptyResponses = 436,
        /// The total number of server-side unwrapping callouts that returned an
        /// error response. Timeouts and empty responses are not considered errors.
        ///
        /// Corresponds to "Server-side unwrapping error responses" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ServerSideUnwrappingErrorResponses = 437,
        /// The total number of successfully unwrapped, non-empty server-side
        /// wrapping callouts. Successful unwrapping does not indicate that the
        /// resulting creative was served.
        ///
        /// Corresponds to "Server-side unwrapping successful responses" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ServerSideUnwrappingSuccessfulResponses = 438,
        /// The total number of server-side unwrapping callouts that timed out before
        /// returning a response.
        ///
        /// Corresponds to "Server-side unwrapping timeouts" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        ServerSideUnwrappingTimeouts = 439,
        /// Count of sessions from Google Analytics.
        ///
        /// Corresponds to "Sessions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        Sessions = 239,
        /// Percent of tag load time to 1st ad request in \[0, 500ms) range.
        ///
        /// Corresponds to "Tag loaded to first ad request time 0 - 500ms (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        TagLoadToFirstAdRequest0500Percent = 455,
        /// Percent of tag load time to 1st ad request in \[1000ms, 2000ms) range.
        ///
        /// Corresponds to "Tag loaded to first ad request time 1s - 2s (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        TagLoadToFirstAdRequest10002000Percent = 457,
        /// Percent of tag load time to 1st ad request in \[2000ms, 4000ms) range.
        ///
        /// Corresponds to "Tag loaded to first ad request time 2s - 4s (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        TagLoadToFirstAdRequest20004000Percent = 458,
        /// Percent of tag load time to 1st ad request in \[4000ms, 8000ms) range.
        ///
        /// Corresponds to "Tag loaded to first ad request time 4s - 8s (%)" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        TagLoadToFirstAdRequest40008000Percent = 459,
        /// Percent of tag load time to 1st ad request in \[500ms, 1000ms) range.
        ///
        /// Corresponds to "Tag loaded to first ad request time 500ms - 1s (%)" in
        /// the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        TagLoadToFirstAdRequest5001000Percent = 456,
        /// Percent of tag load time to 1st ad request in \[8000ms, +inf) range.
        ///
        /// Corresponds to "Tag loaded to first ad request time >8s (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        TagLoadToFirstAdRequestGt8000Percent = 460,
        /// The total number of clicks delivered including line item-level dynamic
        /// allocation by explicit custom criteria targeting.
        ///
        /// Corresponds to "Total targeted clicks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        TargetedClicks = 276,
        /// The total number of impressions delivered including line item-level
        /// dynamic allocation by explicit custom criteria targeting.
        ///
        /// Corresponds to "Total targeted impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        TargetedImpressions = 277,
        /// The total number of missed impressions due to the ad servers' inability
        /// to find ads to serve including dynamic allocation.
        ///
        /// Corresponds to "Unfilled impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        UnfilledImpressions = 45,
        /// The total number of unique users who viewed the ad.
        ///
        /// Corresponds to "Total unique visitors" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `REACH`
        ///
        /// Data format: `INTEGER`
        UniqueVisitors = 417,
        /// The number of impressions impacted by Chrome Ads Intervention due to CPU
        /// usage.
        ///
        /// Corresponds to "Total unloaded impressions due to CPU" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        UnloadedImpressionsDueToCpu = 408,
        /// The number of impressions impacted by Chrome Ads Intervention due to
        /// network usage.
        ///
        /// Corresponds to "Total unloaded impressions due to Network" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        UnloadedImpressionsDueToNetwork = 406,
        /// The total number of times that an ad is not returned by the ad server.
        ///
        /// Corresponds to "Total unmatched ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        UnmatchedAdRequests = 43,
        /// The percentage of unviewed impressions due to other reasons.
        ///
        /// Corresponds to "Other non-viewable impression reasons (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        UnviewedReasonOtherPercent = 550,
        /// The percentage of unviewed impressions due to slot never entered
        /// viewport.
        ///
        /// Corresponds to "Slot never entered viewport (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        UnviewedReasonSlotNeverEnteredViewportPercent = 553,
        /// The percentage of unviewed impressions due to scrolled past before ad
        /// filled.
        ///
        /// Corresponds to "User scrolled before ad filled (%)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        UnviewedReasonUserScrolledBeforeAdFilledPercent = 551,
        /// The percentage of unviewed impressions due to scrolled past before ad
        /// loaded.
        ///
        /// Corresponds to "User scrolled/navigated before ad loaded (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        UnviewedReasonUserScrolledBeforeAdLoadedPercent = 552,
        /// The percentage of unviewed impressions due to insufficient time on
        /// screen.
        ///
        /// Corresponds to "User scrolled/navigated before 1 second (%)" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `AD_SPEED`
        ///
        /// Data format: `PERCENT`
        UnviewedReasonUserScrolledBeforeOneSecondPercent = 549,
        /// Time of users interacting with web site or mobile app from Google
        /// Analytics in seconds.
        ///
        /// Corresponds to "User engagement duration (seconds)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        UserEngagementDurationInSeconds = 240,
        /// Fraction of page views where users had ad blocker extensions installed.
        /// Includes only Desktop page views.
        ///
        /// Corresponds to "Ad blocking extension rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        UserMessagesAdBlockingExtensionRate = 486,
        /// Number of ad-blocking messages shown in the selected date range that
        /// resulted in users adding the site to their allowlist to view ads
        ///
        /// Corresponds to "Ad blocking recovery message conversions" in the Ad
        /// Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesAdBlockingRecoveryAllowlistedCount = 487,
        /// Number of times an ad blocking recovery message was shown to users.
        ///
        /// Corresponds to "Ad blocking recovery messages shown" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesAdBlockingRecoveryMessagesShown = 488,
        /// The number of page views generated by users with an ad blocking extension
        /// installed who were shown the ad blocking recovery message and later
        /// allowed ads.
        ///
        /// Corresponds to "Allow-ads page views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesAllowAdsPageviews = 489,
        /// Number of iOS ATT alerts that were triggered by an IDFA message (IDFA
        /// messages can be IDFA explainers or GDPR messages).
        ///
        /// Corresponds to "IDFA ATT alerts shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesIdfaAttAlertsShown = 491,
        /// Number of iOS ATT alerts triggered by the IDFA message where the user
        /// chose to allow tracking.
        ///
        /// Corresponds to "IDFA ATT consent" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesIdfaAttConsent = 492,
        /// Percentage of iOS ATT alerts triggered by the IDFA message where the
        /// outcome was to allow tracking.
        ///
        /// Corresponds to "IDFA ATT consent rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        UserMessagesIdfaAttConsentRate = 493,
        /// Number of iOS ATT alerts triggered by the IDFA message where the user
        /// chose to deny tracking.
        ///
        /// Corresponds to "IDFA ATT decline consent" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesIdfaAttDeclineConsent = 494,
        /// Percentage of iOS ATT alerts triggered by the IDFA message where the user
        /// chose to deny tracking.
        ///
        /// Corresponds to "IDFA ATT decline rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        UserMessagesIdfaAttDeclineRate = 495,
        /// Number of times an IDFA explainer message was shown to users.
        ///
        /// Corresponds to "IDFA explainers shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesIdfaExplainersShown = 496,
        /// Number of times a European regulations message was shown immediately
        /// before the iOS ATT alert.
        ///
        /// Corresponds to "IDFA IAB messages shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesIdfaIabMessagesShown = 497,
        /// Number of IDFA explainer messages where the user didn't choose anything.
        ///
        /// Corresponds to "IDFA no decision" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesIdfaNoDecision = 498,
        /// Number of times an Offerwall message was shown to users.
        ///
        /// Corresponds to "Offerwall messages shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesOfferwallMessagesShown = 121,
        /// The number of messages where the user gained an entitlement.
        ///
        /// Corresponds to "Monetized Offerwall engagements" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesOfferwallSuccessfulEngagements = 122,
        /// The number of pages viewed by users after gaining an entitlement. Only
        /// counts pages included for Offerwall.
        ///
        /// Corresponds to "Post-offerwall page views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesPostOfferwallPageviews = 499,
        /// Revenue earned through Offerwall, including Rewarded ad revenue and
        /// third-party integrations.
        ///
        /// Corresponds to "Estimated Offerwall revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `MONEY`
        UserMessagesTotalEstimatedRevenue = 500,
        /// Number of times an ads personalization controls message was shown to
        /// users.
        ///
        /// Corresponds to "Ads personalization messages shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesUptcMessagesShown = 501,
        /// Percentage of ads personalization controls messages where users chose the
        /// opt-out option.
        ///
        /// Corresponds to "Personalization opt-out ratio" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `PERCENT`
        UserMessagesUptcPersonalizationOptOutRatio = 502,
        /// Number of times a US state regulations message was shown to users.
        ///
        /// Corresponds to "US states messages shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesUsStatesMessagesShown = 490,
        /// Number of times users selected the opt-out option in a US states message.
        ///
        /// Corresponds to "US states opt-out selections" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `PRIVACY_AND_MESSAGING`
        ///
        /// Data format: `INTEGER`
        UserMessagesUsStatesOptOutSelections = 586,
        /// The number of errors of type 100 in reporting.
        ///
        /// Corresponds to "VAST error 100 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError100Count = 180,
        /// The number of errors of type 101 in reporting.
        ///
        /// Corresponds to "VAST error 101 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError101Count = 181,
        /// The number of errors of type 102 in reporting.
        ///
        /// Corresponds to "VAST error 102 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError102Count = 182,
        /// The number of errors of type 200 in reporting.
        ///
        /// Corresponds to "VAST error 200 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError200Count = 183,
        /// The number of errors of type 201 in reporting.
        ///
        /// Corresponds to "VAST error 201 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError201Count = 184,
        /// The number of errors of type 202 in reporting.
        ///
        /// Corresponds to "VAST error 202 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError202Count = 185,
        /// The number of errors of type 203 in reporting.
        ///
        /// Corresponds to "VAST error 203 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError203Count = 186,
        /// The number of errors of type 300 in reporting.
        ///
        /// Corresponds to "VAST error 300 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError300Count = 187,
        /// The number of errors of type 301 in reporting.
        ///
        /// Corresponds to "VAST error 301 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError301Count = 188,
        /// The number of errors of type 302 in reporting.
        ///
        /// Corresponds to "VAST error 302 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError302Count = 189,
        /// The number of errors of type 303 in reporting.
        ///
        /// Corresponds to "VAST error 303 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError303Count = 190,
        /// The number of errors of type 400 in reporting.
        ///
        /// Corresponds to "VAST error 400 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError400Count = 191,
        /// The number of errors of type 401 in reporting.
        ///
        /// Corresponds to "VAST error 401 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError401Count = 192,
        /// The number of errors of type 402 in reporting.
        ///
        /// Corresponds to "VAST error 402 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError402Count = 193,
        /// The number of errors of type 403 in reporting.
        ///
        /// Corresponds to "VAST error 403 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError403Count = 194,
        /// The number of errors of type 405 in reporting.
        ///
        /// Corresponds to "VAST error 405 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError405Count = 195,
        /// The number of errors of type 406 in reporting.
        ///
        /// Corresponds to "VAST error 406 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError406Count = 196,
        /// The number of errors of type 407 in reporting.
        ///
        /// Corresponds to "VAST error 407 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError407Count = 197,
        /// The number of errors of type 408 in reporting.
        ///
        /// Corresponds to "VAST error 408 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError408Count = 198,
        /// The number of errors of type 409 in reporting.
        ///
        /// Corresponds to "VAST error 409 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError409Count = 199,
        /// The number of errors of type 410 in reporting.
        ///
        /// Corresponds to "VAST error 410 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError410Count = 200,
        /// The number of errors of type 500 in reporting.
        ///
        /// Corresponds to "VAST error 500 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError500Count = 201,
        /// The number of errors of type 501 in reporting.
        ///
        /// Corresponds to "VAST error 501 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError501Count = 202,
        /// The number of errors of type 502 in reporting.
        ///
        /// Corresponds to "VAST error 502 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError502Count = 203,
        /// The number of errors of type 503 in reporting.
        ///
        /// Corresponds to "VAST error 503 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError503Count = 204,
        /// The number of errors of type 600 in reporting.
        ///
        /// Corresponds to "VAST error 600 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError600Count = 205,
        /// The number of errors of type 601 in reporting.
        ///
        /// Corresponds to "VAST error 601 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError601Count = 206,
        /// The number of errors of type 602 in reporting.
        ///
        /// Corresponds to "VAST error 602 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError602Count = 207,
        /// The number of errors of type 603 in reporting.
        ///
        /// Corresponds to "VAST error 603 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError603Count = 208,
        /// The number of errors of type 604 in reporting.
        ///
        /// Corresponds to "VAST error 604 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError604Count = 209,
        /// The number of errors of type 900 in reporting.
        ///
        /// Corresponds to "VAST error 900 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError900Count = 210,
        /// The number of errors of type 901 in reporting.
        ///
        /// Corresponds to "VAST error 901 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoError901Count = 211,
        /// The number of user interactions with a video, on average, such as pause,
        /// full screen, mute, etc.
        ///
        /// Corresponds to "Average interaction rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoInteractionAverageInteractionRate = 92,
        /// The number of times a user collapses a video, either to its original size
        /// or to a different size.
        ///
        /// Corresponds to "Collapses" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionCollapses = 93,
        /// The number of times a user expands a video.
        ///
        /// Corresponds to "Expands" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionExpands = 95,
        /// The number of times ad clip played in full screen mode.
        ///
        /// Corresponds to "Full screens" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionFullScreens = 96,
        /// The number of times video player was in mute state during play of ad
        /// clip.
        ///
        /// Corresponds to "Mutes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionMutes = 97,
        /// The number of times user paused ad clip.
        ///
        /// Corresponds to "Pauses" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionPauses = 98,
        /// The number of times the user unpaused the video.
        ///
        /// Corresponds to "Resumes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionResumes = 99,
        /// The number of times a user rewinds the video.
        ///
        /// Corresponds to "Rewinds" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionRewinds = 100,
        /// The number of times a user unmutes the video.
        ///
        /// Corresponds to "Unmutes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionUnmutes = 101,
        /// The number of times a skippable video is skipped.
        ///
        /// Corresponds to "Skips" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoInteractionVideoSkips = 102,
        /// The number of views for monetizable video content.
        ///
        /// Corresponds to "Monetizable content views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoMonetizableContentViews = 601,
        /// The number of total creative serves in video realtime reporting.
        ///
        /// Corresponds to "Total creative serves" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeCreativeServes = 139,
        /// The number of errors of type 100 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 100 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError100Count = 143,
        /// The number of errors of type 101 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 101 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError101Count = 144,
        /// The number of errors of type 102 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 102 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError102Count = 145,
        /// The number of errors of type 200 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 200 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError200Count = 146,
        /// The number of errors of type 201 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 201 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError201Count = 147,
        /// The number of errors of type 202 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 202 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError202Count = 148,
        /// The number of errors of type 203 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 203 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError203Count = 149,
        /// The number of errors of type 300 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 300 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError300Count = 150,
        /// The number of errors of type 301 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 301 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError301Count = 151,
        /// The number of errors of type 302 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 302 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError302Count = 152,
        /// The number of errors of type 303 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 303 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError303Count = 153,
        /// The number of errors of type 400 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 400 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError400Count = 154,
        /// The number of errors of type 401 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 401 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError401Count = 155,
        /// The number of errors of type 402 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 402 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError402Count = 156,
        /// The number of errors of type 403 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 403 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError403Count = 157,
        /// The number of errors of type 405 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 405 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError405Count = 158,
        /// The number of errors of type 406 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 406 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError406Count = 159,
        /// The number of errors of type 407 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 407 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError407Count = 160,
        /// The number of errors of type 408 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 408 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError408Count = 161,
        /// The number of errors of type 409 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 409 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError409Count = 162,
        /// The number of errors of type 410 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 410 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError410Count = 163,
        /// The number of errors of type 500 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 500 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError500Count = 164,
        /// The number of errors of type 501 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 501 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError501Count = 165,
        /// The number of errors of type 502 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 502 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError502Count = 166,
        /// The number of errors of type 503 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 503 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError503Count = 167,
        /// The number of errors of type 600 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 600 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError600Count = 168,
        /// The number of errors of type 601 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 601 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError601Count = 169,
        /// The number of errors of type 602 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 602 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError602Count = 170,
        /// The number of errors of type 603 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 603 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError603Count = 171,
        /// The number of errors of type 604 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 604 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError604Count = 172,
        /// The number of errors of type 900 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 900 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError900Count = 173,
        /// The number of errors of type 901 in video realtime reporting.
        ///
        /// Corresponds to "VAST error 901 count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeError901Count = 174,
        /// The number of total impressions in video realtime reporting.
        ///
        /// Corresponds to "Total impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeImpressions = 138,
        /// The number of matched queries in video realtime reporting.
        ///
        /// Corresponds to "Total responses served" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeMatchedQueries = 140,
        /// The number of all errors in video realtime reporting.
        ///
        /// Corresponds to "Total error count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeTotalErrorCount = 175,
        /// The number of total queries in video realtime reporting.
        ///
        /// Corresponds to "Total ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeTotalQueries = 142,
        /// The number of unmatched queries in video realtime reporting.
        ///
        /// Corresponds to "Total unmatched ad requests" in the Ad Manager UI.
        ///
        /// Compatible with the following report types:
        ///
        /// Data format: `INTEGER`
        VideoRealTimeUnmatchedQueries = 141,
        /// The total number of breaks completed or fatal errors for the last ad in
        /// the pod.
        ///
        /// Corresponds to "Break end" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalBreakEnd = 279,
        /// The total number of breaks starts or errors for the first ad in a pod
        /// that users made it to.
        ///
        /// Corresponds to "Break start" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalBreakStart = 280,
        /// The number of video ad opportunities reached by a user (rounded down, or
        /// capped based on your max ads setting, whichever is less).
        ///
        /// Corresponds to "Capped opportunities (adbreak)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalCappedOpportunitiesAdbreak = 281,
        /// The total number of seconds available to be filled.
        ///
        /// Corresponds to "Total duration (adbreak)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalDurationAdbreak = 283,
        /// The total number of seconds filled.
        ///
        /// Corresponds to "Matched duration (adbreak)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalMatchedDurationAdbreak = 285,
        /// The total matched opportunities in video true opportunities reporting.
        ///
        /// Corresponds to "Matched opportunities (adbreak)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalMatchedOpportunitiesAdbreak = 287,
        /// The number of video ad opportunities reached by a user (rounded down).
        ///
        /// Corresponds to "Viewed opportunities (adbreak)" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueOpportunitiesTotalViewedOpportunitiesAdbreak = 289,
        /// The number of TrueView ad impressions viewed.
        ///
        /// Corresponds to "True views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoTrueViews = 392,
        /// Measures the percentage of skips.
        ///
        /// Corresponds to "True views skip rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoTrueViewSkipRate = 393,
        /// The view-through rate is the percentage of views divided by number of
        /// impressions
        ///
        /// Corresponds to "True views view-through rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoTrueViewViewThroughRate = 394,
        /// Number of times that the publisher specified a video ad played
        /// automatically.
        ///
        /// Corresponds to "Auto-plays" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipAutoPlays = 103,
        /// Average percentage of the video watched by users.
        ///
        /// Corresponds to "Average view rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoViewershipAverageViewRate = 104,
        /// Average time(seconds) users watched the video.
        ///
        /// Corresponds to "Average view time" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        VideoViewershipAverageViewTime = 105,
        /// Number of times that the publisher specified a video ad was clicked to
        /// play.
        ///
        /// Corresponds to "Click-to-plays" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipClickToPlays = 106,
        /// The number of times the video played to completion.
        ///
        /// Corresponds to "Completes" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipCompletes = 107,
        /// Percentage of times the video played to the end.
        ///
        /// Corresponds to "Completion rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoViewershipCompletionRate = 108,
        /// The number of engaged views: ad is viewed to completion or for 30s,
        /// whichever comes first.
        ///
        /// Corresponds to "Engaged views" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipEngagedViews = 109,
        /// The number of times the video played to 25% of its length.
        ///
        /// Corresponds to "First quartiles" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipFirstQuartiles = 110,
        /// The number of times the video reached its midpoint during play.
        ///
        /// Corresponds to "Midpoints" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipMidpoints = 111,
        /// The number of times a skip button is shown in video.
        ///
        /// Corresponds to "Skip buttons shown" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipSkipButtonsShown = 112,
        /// The number of impressions where the video was played.
        ///
        /// Corresponds to "Starts" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipStarts = 113,
        /// The number of times the video played to 75% of its length.
        ///
        /// Corresponds to "Third quartiles" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipThirdQuartiles = 114,
        /// The number of times an error occurred, such as a VAST redirect error, a
        /// video playback error, or an invalid response error.
        ///
        /// Corresponds to "Total error count" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        VideoViewershipTotalErrorCount = 115,
        /// The percentage of video error count.
        ///
        /// Corresponds to "Total error rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoViewershipTotalErrorRate = 94,
        /// Duration of the video creative.
        ///
        /// Corresponds to "Video length" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        VideoViewershipVideoLength = 116,
        /// View-through rate represented as a percentage.
        ///
        /// Corresponds to "Video view through rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `PERCENT`
        VideoViewershipViewThroughRate = 117,
        /// Number of winning bids received from Open Bidding buyers, even when the
        /// winning bid is placed at the end of a mediation for mobile apps chain.
        ///
        /// Corresponds to "Yield group auctions won" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupAuctionsWon = 80,
        /// Number of bids received from Open Bidding buyers, regardless of whether
        /// the returned bid competes in an auction.
        ///
        /// Corresponds to "Yield group bids" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupBids = 81,
        /// Number of bids received from Open Bidding buyers that competed in
        /// the auction.
        ///
        /// Corresponds to "Yield group bids in auction" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupBidsInAuction = 82,
        /// Number of times a yield partner is asked to return bid to fill
        /// a yield group request.
        ///
        /// Corresponds to "Yield group callouts" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupCallouts = 83,
        /// The estimated net rate for yield groups or individual
        /// yield group partners.
        ///
        /// Corresponds to "Yield group estimated CPM" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        YieldGroupEstimatedCpm = 88,
        /// Total net revenue earned by a yield group, based upon the yield group
        /// estimated CPM and yield group impressions recorded.
        ///
        /// Corresponds to "Yield group estimated revenue" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        YieldGroupEstimatedRevenue = 87,
        /// Number of matched yield group requests where a yield partner delivered
        /// their ad to publisher inventory.
        ///
        /// Corresponds to "Yield group impressions" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupImpressions = 85,
        /// Yield group Mediation fill rate indicating how often a network
        /// fills an ad request.
        ///
        /// Corresponds to "Yield group mediation fill rate" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        YieldGroupMediationFillRate = 89,
        /// Total requests where a Mediation chain was served.
        ///
        /// Corresponds to "Yield group mediation matched queries" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupMediationMatchedQueries = 86,
        /// The number of mediation chain passback across all channels.
        ///
        /// Corresponds to "Yield group mediation passbacks" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupMediationPassbacks = 118,
        /// Revenue per thousand impressions based on data collected by Ad Manager
        /// from third-party ad network reports.
        ///
        /// Corresponds to "Yield group mediation third party ECPM" in the Ad Manager
        /// UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `DOUBLE`
        YieldGroupMediationThirdPartyEcpm = 90,
        /// The yield group revenue accrued in the child network's own account but
        /// paid to their parent network through auto-payment. This metric is only
        /// relevant for a "Manage Account" child network.
        ///
        /// Corresponds to "Yield group revenue paid through MCM auto-payment" in the
        /// Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `MONEY`
        YieldGroupRevenuePaidThroughMcmAutopayment = 215,
        /// Number of times a yield group buyer successfully returned a bid in
        /// response to a yield group callout.
        ///
        /// Corresponds to "Yield group successful responses" in the Ad Manager UI.
        ///
        /// Compatible with the following report types: `HISTORICAL`
        ///
        /// Data format: `INTEGER`
        YieldGroupSuccessfulResponses = 84,
    }
    impl Metric {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "METRIC_UNSPECIFIED",
                Self::ActiveUsers => "ACTIVE_USERS",
                Self::ActiveViewAudibleAtStartPercent => {
                    "ACTIVE_VIEW_AUDIBLE_AT_START_PERCENT"
                }
                Self::ActiveViewAudibleImpressions => "ACTIVE_VIEW_AUDIBLE_IMPRESSIONS",
                Self::ActiveViewAudibleThroughCompletionPercent => {
                    "ACTIVE_VIEW_AUDIBLE_THROUGH_COMPLETION_PERCENT"
                }
                Self::ActiveViewAudibleThroughFirstQuartilePercent => {
                    "ACTIVE_VIEW_AUDIBLE_THROUGH_FIRST_QUARTILE_PERCENT"
                }
                Self::ActiveViewAudibleThroughMidpointPercent => {
                    "ACTIVE_VIEW_AUDIBLE_THROUGH_MIDPOINT_PERCENT"
                }
                Self::ActiveViewAudibleThroughThirdQuartilePercent => {
                    "ACTIVE_VIEW_AUDIBLE_THROUGH_THIRD_QUARTILE_PERCENT"
                }
                Self::ActiveViewAudioEnabledImpressions => {
                    "ACTIVE_VIEW_AUDIO_ENABLED_IMPRESSIONS"
                }
                Self::ActiveViewAudioMeasurableImpressions => {
                    "ACTIVE_VIEW_AUDIO_MEASURABLE_IMPRESSIONS"
                }
                Self::ActiveViewAverageViewableTime => {
                    "ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME"
                }
                Self::ActiveViewEligibleImpressions => "ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS",
                Self::ActiveViewEverAudibleBackgroundedPercent => {
                    "ACTIVE_VIEW_EVER_AUDIBLE_BACKGROUNDED_PERCENT"
                }
                Self::ActiveViewEverAudiblePercent => "ACTIVE_VIEW_EVER_AUDIBLE_PERCENT",
                Self::ActiveViewEverBackgroundedPercent => {
                    "ACTIVE_VIEW_EVER_BACKGROUNDED_PERCENT"
                }
                Self::ActiveViewEverMutedPercent => "ACTIVE_VIEW_EVER_MUTED_PERCENT",
                Self::ActiveViewImpressionsAudibleAndVisiblieAtCompletion => {
                    "ACTIVE_VIEW_IMPRESSIONS_AUDIBLE_AND_VISIBLIE_AT_COMPLETION"
                }
                Self::ActiveViewMeasurableImpressions => {
                    "ACTIVE_VIEW_MEASURABLE_IMPRESSIONS"
                }
                Self::ActiveViewMeasurableImpressionsRate => {
                    "ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE"
                }
                Self::ActiveViewNonMeasurableImpressions => {
                    "ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS"
                }
                Self::ActiveViewNonViewableImpressions => {
                    "ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS"
                }
                Self::ActiveViewNonViewableImpressionsDistribution => {
                    "ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::ActiveViewPercentAudibleImpressions => {
                    "ACTIVE_VIEW_PERCENT_AUDIBLE_IMPRESSIONS"
                }
                Self::ActiveViewPlusMeasurableCount => {
                    "ACTIVE_VIEW_PLUS_MEASURABLE_COUNT"
                }
                Self::ActiveViewRevenue => "ACTIVE_VIEW_REVENUE",
                Self::ActiveViewUndeterminedImpressionsDistribution => {
                    "ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION"
                }
                Self::ActiveViewViewableImpressions => "ACTIVE_VIEW_VIEWABLE_IMPRESSIONS",
                Self::ActiveViewViewableImpressionsDistribution => {
                    "ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::ActiveViewViewableImpressionsRate => {
                    "ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE"
                }
                Self::AdsenseActiveViewAverageViewableTime => {
                    "ADSENSE_ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME"
                }
                Self::AdsenseActiveViewEligibleImpressions => {
                    "ADSENSE_ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS"
                }
                Self::AdsenseActiveViewMeasurableImpressions => {
                    "ADSENSE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS"
                }
                Self::AdsenseActiveViewMeasurableImpressionsRate => {
                    "ADSENSE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE"
                }
                Self::AdsenseActiveViewNonMeasurableImpressions => {
                    "ADSENSE_ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS"
                }
                Self::AdsenseActiveViewNonViewableImpressions => {
                    "ADSENSE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS"
                }
                Self::AdsenseActiveViewNonViewableImpressionsDistribution => {
                    "ADSENSE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdsenseActiveViewUndeterminedImpressionsDistribution => {
                    "ADSENSE_ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdsenseActiveViewViewableImpressions => {
                    "ADSENSE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS"
                }
                Self::AdsenseActiveViewViewableImpressionsDistribution => {
                    "ADSENSE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdsenseActiveViewViewableImpressionsRate => {
                    "ADSENSE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE"
                }
                Self::AdsenseAverageEcpm => "ADSENSE_AVERAGE_ECPM",
                Self::AdsenseClicks => "ADSENSE_CLICKS",
                Self::AdsenseCtr => "ADSENSE_CTR",
                Self::AdsenseImpressions => "ADSENSE_IMPRESSIONS",
                Self::AdsensePercentClicks => "ADSENSE_PERCENT_CLICKS",
                Self::AdsensePercentImpressions => "ADSENSE_PERCENT_IMPRESSIONS",
                Self::AdsensePercentRevenue => "ADSENSE_PERCENT_REVENUE",
                Self::AdsensePercentRevenueWithoutCpd => {
                    "ADSENSE_PERCENT_REVENUE_WITHOUT_CPD"
                }
                Self::AdsenseResponsesServed => "ADSENSE_RESPONSES_SERVED",
                Self::AdsenseRevenue => "ADSENSE_REVENUE",
                Self::AdExchangeActiveViewAverageViewableTime => {
                    "AD_EXCHANGE_ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME"
                }
                Self::AdExchangeActiveViewEligibleImpressions => {
                    "AD_EXCHANGE_ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS"
                }
                Self::AdExchangeActiveViewMeasurableImpressions => {
                    "AD_EXCHANGE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS"
                }
                Self::AdExchangeActiveViewMeasurableImpressionsRate => {
                    "AD_EXCHANGE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE"
                }
                Self::AdExchangeActiveViewNonMeasurableImpressions => {
                    "AD_EXCHANGE_ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS"
                }
                Self::AdExchangeActiveViewNonViewableImpressions => {
                    "AD_EXCHANGE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS"
                }
                Self::AdExchangeActiveViewNonViewableImpressionsDistribution => {
                    "AD_EXCHANGE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdExchangeActiveViewUndeterminedImpressionsDistribution => {
                    "AD_EXCHANGE_ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdExchangeActiveViewViewableImpressions => {
                    "AD_EXCHANGE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS"
                }
                Self::AdExchangeActiveViewViewableImpressionsDistribution => {
                    "AD_EXCHANGE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdExchangeActiveViewViewableImpressionsRate => {
                    "AD_EXCHANGE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE"
                }
                Self::AdExchangeAverageEcpm => "AD_EXCHANGE_AVERAGE_ECPM",
                Self::AdExchangeClicks => "AD_EXCHANGE_CLICKS",
                Self::AdExchangeCpc => "AD_EXCHANGE_CPC",
                Self::AdExchangeCtr => "AD_EXCHANGE_CTR",
                Self::AdExchangeDeliveryRate => "AD_EXCHANGE_DELIVERY_RATE",
                Self::AdExchangeImpressions => "AD_EXCHANGE_IMPRESSIONS",
                Self::AdExchangeImpressionsPerAdViewer => {
                    "AD_EXCHANGE_IMPRESSIONS_PER_AD_VIEWER"
                }
                Self::AdExchangeImpressionsPerSession => {
                    "AD_EXCHANGE_IMPRESSIONS_PER_SESSION"
                }
                Self::AdExchangeLift => "AD_EXCHANGE_LIFT",
                Self::AdExchangeMatchedRequestCtr => "AD_EXCHANGE_MATCHED_REQUEST_CTR",
                Self::AdExchangeMatchedRequestEcpm => "AD_EXCHANGE_MATCHED_REQUEST_ECPM",
                Self::AdExchangeMatchRate => "AD_EXCHANGE_MATCH_RATE",
                Self::AdExchangeOpportunitiesFromErrors => {
                    "AD_EXCHANGE_OPPORTUNITIES_FROM_ERRORS"
                }
                Self::AdExchangeOpportunitiesFromImpressions => {
                    "AD_EXCHANGE_OPPORTUNITIES_FROM_IMPRESSIONS"
                }
                Self::AdExchangePercentClicks => "AD_EXCHANGE_PERCENT_CLICKS",
                Self::AdExchangePercentImpressions => "AD_EXCHANGE_PERCENT_IMPRESSIONS",
                Self::AdExchangePercentRevenue => "AD_EXCHANGE_PERCENT_REVENUE",
                Self::AdExchangePercentRevenueWithoutCpd => {
                    "AD_EXCHANGE_PERCENT_REVENUE_WITHOUT_CPD"
                }
                Self::AdExchangePlusYieldGroupEcpm => "AD_EXCHANGE_PLUS_YIELD_GROUP_ECPM",
                Self::AdExchangePlusYieldGroupImpressions => {
                    "AD_EXCHANGE_PLUS_YIELD_GROUP_IMPRESSIONS"
                }
                Self::AdExchangePlusYieldGroupRevenue => {
                    "AD_EXCHANGE_PLUS_YIELD_GROUP_REVENUE"
                }
                Self::AdExchangeResponsesServed => "AD_EXCHANGE_RESPONSES_SERVED",
                Self::AdExchangeRevenue => "AD_EXCHANGE_REVENUE",
                Self::AdExchangeRevenuePaidThroughMcmAutopayment => {
                    "AD_EXCHANGE_REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT"
                }
                Self::AdExchangeRevenuePerAdViewer => "AD_EXCHANGE_REVENUE_PER_AD_VIEWER",
                Self::AdExchangeTotalRequests => "AD_EXCHANGE_TOTAL_REQUESTS",
                Self::AdExchangeTotalRequestCtr => "AD_EXCHANGE_TOTAL_REQUEST_CTR",
                Self::AdExchangeTotalRequestEcpm => "AD_EXCHANGE_TOTAL_REQUEST_ECPM",
                Self::AdExposureSeconds => "AD_EXPOSURE_SECONDS",
                Self::AdRequests => "AD_REQUESTS",
                Self::AdServerActiveViewAverageViewableTime => {
                    "AD_SERVER_ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME"
                }
                Self::AdServerActiveViewEligibleImpressions => {
                    "AD_SERVER_ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS"
                }
                Self::AdServerActiveViewMeasurableImpressions => {
                    "AD_SERVER_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS"
                }
                Self::AdServerActiveViewMeasurableImpressionsRate => {
                    "AD_SERVER_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE"
                }
                Self::AdServerActiveViewNonMeasurableImpressions => {
                    "AD_SERVER_ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS"
                }
                Self::AdServerActiveViewNonViewableImpressions => {
                    "AD_SERVER_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS"
                }
                Self::AdServerActiveViewNonViewableImpressionsDistribution => {
                    "AD_SERVER_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdServerActiveViewUndeterminedImpressionsDistribution => {
                    "AD_SERVER_ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdServerActiveViewViewableImpressions => {
                    "AD_SERVER_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS"
                }
                Self::AdServerActiveViewViewableImpressionsDistribution => {
                    "AD_SERVER_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION"
                }
                Self::AdServerActiveViewViewableImpressionsRate => {
                    "AD_SERVER_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE"
                }
                Self::AdServerAverageEcpm => "AD_SERVER_AVERAGE_ECPM",
                Self::AdServerAverageEcpmWithoutCpd => {
                    "AD_SERVER_AVERAGE_ECPM_WITHOUT_CPD"
                }
                Self::AdServerBeginToRenderImpressions => {
                    "AD_SERVER_BEGIN_TO_RENDER_IMPRESSIONS"
                }
                Self::AdServerClicks => "AD_SERVER_CLICKS",
                Self::AdServerCompletedViews => "AD_SERVER_COMPLETED_VIEWS",
                Self::AdServerCoviewedImpressions => "AD_SERVER_COVIEWED_IMPRESSIONS",
                Self::AdServerCpdRevenue => "AD_SERVER_CPD_REVENUE",
                Self::AdServerCtr => "AD_SERVER_CTR",
                Self::AdServerGrossRevenue => "AD_SERVER_GROSS_REVENUE",
                Self::AdServerGrossRevenueWithoutCpd => {
                    "AD_SERVER_GROSS_REVENUE_WITHOUT_CPD"
                }
                Self::AdServerImpressions => "AD_SERVER_IMPRESSIONS",
                Self::AdServerImpressionsWithCompanion => {
                    "AD_SERVER_IMPRESSIONS_WITH_COMPANION"
                }
                Self::AdServerInactiveBeginToRenderImpressions => {
                    "AD_SERVER_INACTIVE_BEGIN_TO_RENDER_IMPRESSIONS"
                }
                Self::AdServerOpportunitiesFromErrors => {
                    "AD_SERVER_OPPORTUNITIES_FROM_ERRORS"
                }
                Self::AdServerOpportunitiesFromImpressions => {
                    "AD_SERVER_OPPORTUNITIES_FROM_IMPRESSIONS"
                }
                Self::AdServerPercentClicks => "AD_SERVER_PERCENT_CLICKS",
                Self::AdServerPercentImpressions => "AD_SERVER_PERCENT_IMPRESSIONS",
                Self::AdServerPercentRevenue => "AD_SERVER_PERCENT_REVENUE",
                Self::AdServerPercentRevenueWithoutCpd => {
                    "AD_SERVER_PERCENT_REVENUE_WITHOUT_CPD"
                }
                Self::AdServerResponsesServed => "AD_SERVER_RESPONSES_SERVED",
                Self::AdServerRevenue => "AD_SERVER_REVENUE",
                Self::AdServerRevenuePaidThroughMcmAutopayment => {
                    "AD_SERVER_REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT"
                }
                Self::AdServerRevenueWithoutCpd => "AD_SERVER_REVENUE_WITHOUT_CPD",
                Self::AdServerTargetedClicks => "AD_SERVER_TARGETED_CLICKS",
                Self::AdServerTargetedImpressions => "AD_SERVER_TARGETED_IMPRESSIONS",
                Self::AdServerTrackedAds => "AD_SERVER_TRACKED_ADS",
                Self::AdServerUnfilteredBeginToRenderImpressions => {
                    "AD_SERVER_UNFILTERED_BEGIN_TO_RENDER_IMPRESSIONS"
                }
                Self::AdServerUnfilteredClicks => "AD_SERVER_UNFILTERED_CLICKS",
                Self::AdServerUnfilteredDownloadedImpressions => {
                    "AD_SERVER_UNFILTERED_DOWNLOADED_IMPRESSIONS"
                }
                Self::AdServerUnfilteredTrackedAds => "AD_SERVER_UNFILTERED_TRACKED_ADS",
                Self::AdUnitExposureSeconds => "AD_UNIT_EXPOSURE_SECONDS",
                Self::AdViewers => "AD_VIEWERS",
                Self::AtnAdsFailedToRender => "ATN_ADS_FAILED_TO_RENDER",
                Self::AtnEligibleLineItems => "ATN_ELIGIBLE_LINE_ITEMS",
                Self::AtnEligibleLineItemsAdRequests => {
                    "ATN_ELIGIBLE_LINE_ITEMS_AD_REQUESTS"
                }
                Self::AtnHbtAllowedAdRequests => "ATN_HBT_ALLOWED_AD_REQUESTS",
                Self::AtnHbtBidsInAuction => "ATN_HBT_BIDS_IN_AUCTION",
                Self::AtnHbtBidsInAuctionAdRequests => {
                    "ATN_HBT_BIDS_IN_AUCTION_AD_REQUESTS"
                }
                Self::AtnHbtCandidateBids => "ATN_HBT_CANDIDATE_BIDS",
                Self::AtnHbtInvalidAdRequests => "ATN_HBT_INVALID_AD_REQUESTS",
                Self::AtnHbtNoBidsAdRequests => "ATN_HBT_NO_BIDS_AD_REQUESTS",
                Self::AtnHbtRejectedBids => "ATN_HBT_REJECTED_BIDS",
                Self::AtnHbtValidAdRequests => "ATN_HBT_VALID_AD_REQUESTS",
                Self::AtnHbtWithBidsAdRequests => "ATN_HBT_WITH_BIDS_AD_REQUESTS",
                Self::AtnInvalidAdRequests => "ATN_INVALID_AD_REQUESTS",
                Self::AtnLineItemsCreativeNotRetrieved => {
                    "ATN_LINE_ITEMS_CREATIVE_NOT_RETRIEVED"
                }
                Self::AtnLineItemsInAuction => "ATN_LINE_ITEMS_IN_AUCTION",
                Self::AtnLineItemsNotCompeting => "ATN_LINE_ITEMS_NOT_COMPETING",
                Self::AtnLineItemsNotSelected => "ATN_LINE_ITEMS_NOT_SELECTED",
                Self::AtnLineItemInAuctionAdRequests => {
                    "ATN_LINE_ITEM_IN_AUCTION_AD_REQUESTS"
                }
                Self::AtnLineItemTargetedAdRequests => {
                    "ATN_LINE_ITEM_TARGETED_AD_REQUESTS"
                }
                Self::AtnMediationAllowedAdRequests => {
                    "ATN_MEDIATION_ALLOWED_AD_REQUESTS"
                }
                Self::AtnMediationInvalidAdRequests => {
                    "ATN_MEDIATION_INVALID_AD_REQUESTS"
                }
                Self::AtnMediationLoadedAdsFromChains => {
                    "ATN_MEDIATION_LOADED_ADS_FROM_CHAINS"
                }
                Self::AtnMediationNoPartnerAdRequests => {
                    "ATN_MEDIATION_NO_PARTNER_AD_REQUESTS"
                }
                Self::AtnMediationPartnersInAuction => {
                    "ATN_MEDIATION_PARTNERS_IN_AUCTION"
                }
                Self::AtnMediationPartnersInAuctionAdRequests => {
                    "ATN_MEDIATION_PARTNERS_IN_AUCTION_AD_REQUESTS"
                }
                Self::AtnMediationRejectedPartners => "ATN_MEDIATION_REJECTED_PARTNERS",
                Self::AtnMediationTargetedPartners => "ATN_MEDIATION_TARGETED_PARTNERS",
                Self::AtnMediationTotalYieldPartners => {
                    "ATN_MEDIATION_TOTAL_YIELD_PARTNERS"
                }
                Self::AtnMediationUnloadedAdsFromChains => {
                    "ATN_MEDIATION_UNLOADED_ADS_FROM_CHAINS"
                }
                Self::AtnMediationUnusedBidsOrPartners => {
                    "ATN_MEDIATION_UNUSED_BIDS_OR_PARTNERS"
                }
                Self::AtnMediationValidAdRequests => "ATN_MEDIATION_VALID_AD_REQUESTS",
                Self::AtnMediationWithPartnersAdRequests => {
                    "ATN_MEDIATION_WITH_PARTNERS_AD_REQUESTS"
                }
                Self::AtnProgrammaticAdRequestsWithBids => {
                    "ATN_PROGRAMMATIC_AD_REQUESTS_WITH_BIDS"
                }
                Self::AtnProgrammaticAdRequestsWithBidRequestsSent => {
                    "ATN_PROGRAMMATIC_AD_REQUESTS_WITH_BID_REQUESTS_SENT"
                }
                Self::AtnProgrammaticAllowedAdRequests => {
                    "ATN_PROGRAMMATIC_ALLOWED_AD_REQUESTS"
                }
                Self::AtnProgrammaticBidsInAuction => "ATN_PROGRAMMATIC_BIDS_IN_AUCTION",
                Self::AtnProgrammaticBidInAuctionAdRequests => {
                    "ATN_PROGRAMMATIC_BID_IN_AUCTION_AD_REQUESTS"
                }
                Self::AtnProgrammaticBidRequestsSent => {
                    "ATN_PROGRAMMATIC_BID_REQUESTS_SENT"
                }
                Self::AtnProgrammaticBidRequestsWithResponse => {
                    "ATN_PROGRAMMATIC_BID_REQUESTS_WITH_RESPONSE"
                }
                Self::AtnProgrammaticBidRequestCandidates => {
                    "ATN_PROGRAMMATIC_BID_REQUEST_CANDIDATES"
                }
                Self::AtnProgrammaticBidRequestErrors => {
                    "ATN_PROGRAMMATIC_BID_REQUEST_ERRORS"
                }
                Self::AtnProgrammaticIneligibleAdRequests => {
                    "ATN_PROGRAMMATIC_INELIGIBLE_AD_REQUESTS"
                }
                Self::AtnProgrammaticRejectedBids => "ATN_PROGRAMMATIC_REJECTED_BIDS",
                Self::AtnProgrammaticSkippedBidRequests => {
                    "ATN_PROGRAMMATIC_SKIPPED_BID_REQUESTS"
                }
                Self::AtnProgrammaticTotalBids => "ATN_PROGRAMMATIC_TOTAL_BIDS",
                Self::AtnProgrammaticValidAdRequests => {
                    "ATN_PROGRAMMATIC_VALID_AD_REQUESTS"
                }
                Self::AtnRejectedLineItems => "ATN_REJECTED_LINE_ITEMS",
                Self::AtnServedMediationChains => "ATN_SERVED_MEDIATION_CHAINS",
                Self::AtnServedSingleAds => "ATN_SERVED_SINGLE_ADS",
                Self::AtnTargetedLineItems => "ATN_TARGETED_LINE_ITEMS",
                Self::AtnTotalAdRequests => "ATN_TOTAL_AD_REQUESTS",
                Self::AtnTotalCompetingAdsInAuction => {
                    "ATN_TOTAL_COMPETING_ADS_IN_AUCTION"
                }
                Self::AtnTotalLoadedAds => "ATN_TOTAL_LOADED_ADS",
                Self::AtnValidAdRequests => "ATN_VALID_AD_REQUESTS",
                Self::AtnYieldGroupMediationPassbacks => {
                    "ATN_YIELD_GROUP_MEDIATION_PASSBACKS"
                }
                Self::AudienceSegmentCost => "AUDIENCE_SEGMENT_COST",
                Self::AverageEcpm => "AVERAGE_ECPM",
                Self::AverageEcpmWithoutCpd => "AVERAGE_ECPM_WITHOUT_CPD",
                Self::AverageEngagementSecondsPerSession => {
                    "AVERAGE_ENGAGEMENT_SECONDS_PER_SESSION"
                }
                Self::AverageEngagementSecondsPerUser => {
                    "AVERAGE_ENGAGEMENT_SECONDS_PER_USER"
                }
                Self::AverageImpressionsPerUniqueVisitor => {
                    "AVERAGE_IMPRESSIONS_PER_UNIQUE_VISITOR"
                }
                Self::AveragePurchaseRevenuePerPayingUser => {
                    "AVERAGE_PURCHASE_REVENUE_PER_PAYING_USER"
                }
                Self::AverageRevenuePerUser => "AVERAGE_REVENUE_PER_USER",
                Self::AverageSessionSeconds => "AVERAGE_SESSION_SECONDS",
                Self::Bids => "BIDS",
                Self::BidAverageCpm => "BID_AVERAGE_CPM",
                Self::BounceRate => "BOUNCE_RATE",
                Self::Clicks => "CLICKS",
                Self::CodeServedCount => "CODE_SERVED_COUNT",
                Self::CpcRevenue => "CPC_REVENUE",
                Self::CpmRevenue => "CPM_REVENUE",
                Self::CreativeLoadTime0500Percent => "CREATIVE_LOAD_TIME_0_500_PERCENT",
                Self::CreativeLoadTime10002000Percent => {
                    "CREATIVE_LOAD_TIME_1000_2000_PERCENT"
                }
                Self::CreativeLoadTime20004000Percent => {
                    "CREATIVE_LOAD_TIME_2000_4000_PERCENT"
                }
                Self::CreativeLoadTime40008000Percent => {
                    "CREATIVE_LOAD_TIME_4000_8000_PERCENT"
                }
                Self::CreativeLoadTime5001000Percent => {
                    "CREATIVE_LOAD_TIME_500_1000_PERCENT"
                }
                Self::CreativeLoadTimeGt8000Percent => {
                    "CREATIVE_LOAD_TIME_GT_8000_PERCENT"
                }
                Self::Ctr => "CTR",
                Self::DealsBids => "DEALS_BIDS",
                Self::DealsBidRate => "DEALS_BID_RATE",
                Self::DealsBidRequests => "DEALS_BID_REQUESTS",
                Self::DealsWinningBids => "DEALS_WINNING_BIDS",
                Self::DealsWinRate => "DEALS_WIN_RATE",
                Self::DomLoadToFirstAdRequest0500Percent => {
                    "DOM_LOAD_TO_FIRST_AD_REQUEST_0_500_PERCENT"
                }
                Self::DomLoadToFirstAdRequest10002000Percent => {
                    "DOM_LOAD_TO_FIRST_AD_REQUEST_1000_2000_PERCENT"
                }
                Self::DomLoadToFirstAdRequest20004000Percent => {
                    "DOM_LOAD_TO_FIRST_AD_REQUEST_2000_4000_PERCENT"
                }
                Self::DomLoadToFirstAdRequest40008000Percent => {
                    "DOM_LOAD_TO_FIRST_AD_REQUEST_4000_8000_PERCENT"
                }
                Self::DomLoadToFirstAdRequest5001000Percent => {
                    "DOM_LOAD_TO_FIRST_AD_REQUEST_500_1000_PERCENT"
                }
                Self::DomLoadToFirstAdRequestGt8000Percent => {
                    "DOM_LOAD_TO_FIRST_AD_REQUEST_GT_8000_PERCENT"
                }
                Self::DomLoadToTagLoadTime0500Percent => {
                    "DOM_LOAD_TO_TAG_LOAD_TIME_0_500_PERCENT"
                }
                Self::DomLoadToTagLoadTime10002000Percent => {
                    "DOM_LOAD_TO_TAG_LOAD_TIME_1000_2000_PERCENT"
                }
                Self::DomLoadToTagLoadTime20004000Percent => {
                    "DOM_LOAD_TO_TAG_LOAD_TIME_2000_4000_PERCENT"
                }
                Self::DomLoadToTagLoadTime40008000Percent => {
                    "DOM_LOAD_TO_TAG_LOAD_TIME_4000_8000_PERCENT"
                }
                Self::DomLoadToTagLoadTime5001000Percent => {
                    "DOM_LOAD_TO_TAG_LOAD_TIME_500_1000_PERCENT"
                }
                Self::DomLoadToTagLoadTimeGt8000Percent => {
                    "DOM_LOAD_TO_TAG_LOAD_TIME_GT_8000_PERCENT"
                }
                Self::DropoffRate => "DROPOFF_RATE",
                Self::EngagedSessions => "ENGAGED_SESSIONS",
                Self::EngagedSessionsPerUser => "ENGAGED_SESSIONS_PER_USER",
                Self::EngagementRate => "ENGAGEMENT_RATE",
                Self::EuropeanRegulationsConsentRate => {
                    "EUROPEAN_REGULATIONS_CONSENT_RATE"
                }
                Self::EuropeanRegulationsCustomConsentRate => {
                    "EUROPEAN_REGULATIONS_CUSTOM_CONSENT_RATE"
                }
                Self::EuropeanRegulationsMessagesShown => {
                    "EUROPEAN_REGULATIONS_MESSAGES_SHOWN"
                }
                Self::EuropeanRegulationsNoConsentRate => {
                    "EUROPEAN_REGULATIONS_NO_CONSENT_RATE"
                }
                Self::FillRate => "FILL_RATE",
                Self::GoogleAnalyticsClicks => "GOOGLE_ANALYTICS_CLICKS",
                Self::GoogleAnalyticsCtr => "GOOGLE_ANALYTICS_CTR",
                Self::GoogleAnalyticsEcpm => "GOOGLE_ANALYTICS_ECPM",
                Self::GoogleAnalyticsImpressions => "GOOGLE_ANALYTICS_IMPRESSIONS",
                Self::GoogleAnalyticsRevenue => "GOOGLE_ANALYTICS_REVENUE",
                Self::GoogleAnalyticsViews => "GOOGLE_ANALYTICS_VIEWS",
                Self::GoogleAnalyticsViewsPerUser => "GOOGLE_ANALYTICS_VIEWS_PER_USER",
                Self::GoogleSoldAuctionCoviewedImpressions => {
                    "GOOGLE_SOLD_AUCTION_COVIEWED_IMPRESSIONS"
                }
                Self::GoogleSoldAuctionImpressions => "GOOGLE_SOLD_AUCTION_IMPRESSIONS",
                Self::GoogleSoldCoviewedImpressions => "GOOGLE_SOLD_COVIEWED_IMPRESSIONS",
                Self::GoogleSoldImpressions => "GOOGLE_SOLD_IMPRESSIONS",
                Self::GoogleSoldReservationCoviewedImpressions => {
                    "GOOGLE_SOLD_RESERVATION_COVIEWED_IMPRESSIONS"
                }
                Self::GoogleSoldReservationImpressions => {
                    "GOOGLE_SOLD_RESERVATION_IMPRESSIONS"
                }
                Self::Impressions => "IMPRESSIONS",
                Self::InactiveBeginToRenderImpressions => {
                    "INACTIVE_BEGIN_TO_RENDER_IMPRESSIONS"
                }
                Self::InventoryShares => "INVENTORY_SHARES",
                Self::InventorySharePartnerUnfilledOpportunities => {
                    "INVENTORY_SHARE_PARTNER_UNFILLED_OPPORTUNITIES"
                }
                Self::InvoicedImpressions => "INVOICED_IMPRESSIONS",
                Self::InvoicedUnfilledImpressions => "INVOICED_UNFILLED_IMPRESSIONS",
                Self::MediationChainsFilled => "MEDIATION_CHAINS_FILLED",
                Self::MutedImpressions => "MUTED_IMPRESSIONS",
                Self::MuteEligibleImpressions => "MUTE_ELIGIBLE_IMPRESSIONS",
                Self::Opportunities => "OPPORTUNITIES",
                Self::OverdeliveredImpressions => "OVERDELIVERED_IMPRESSIONS",
                Self::PartnerFinanceGrossRevenue => "PARTNER_FINANCE_GROSS_REVENUE",
                Self::PartnerFinanceHostEcpm => "PARTNER_FINANCE_HOST_ECPM",
                Self::PartnerFinanceHostImpressions => "PARTNER_FINANCE_HOST_IMPRESSIONS",
                Self::PartnerFinanceHostRevenue => "PARTNER_FINANCE_HOST_REVENUE",
                Self::PartnerFinancePartnerEcpm => "PARTNER_FINANCE_PARTNER_ECPM",
                Self::PartnerFinancePartnerRevenue => "PARTNER_FINANCE_PARTNER_REVENUE",
                Self::PartnerManagementGrossRevenue => "PARTNER_MANAGEMENT_GROSS_REVENUE",
                Self::PartnerManagementHostClicks => "PARTNER_MANAGEMENT_HOST_CLICKS",
                Self::PartnerManagementHostCtr => "PARTNER_MANAGEMENT_HOST_CTR",
                Self::PartnerManagementHostImpressions => {
                    "PARTNER_MANAGEMENT_HOST_IMPRESSIONS"
                }
                Self::PartnerManagementPartnerClicks => {
                    "PARTNER_MANAGEMENT_PARTNER_CLICKS"
                }
                Self::PartnerManagementPartnerCtr => "PARTNER_MANAGEMENT_PARTNER_CTR",
                Self::PartnerManagementPartnerImpressions => {
                    "PARTNER_MANAGEMENT_PARTNER_IMPRESSIONS"
                }
                Self::PartnerManagementTotalContentViews => {
                    "PARTNER_MANAGEMENT_TOTAL_CONTENT_VIEWS"
                }
                Self::PartnerManagementUnfilledImpressions => {
                    "PARTNER_MANAGEMENT_UNFILLED_IMPRESSIONS"
                }
                Self::PartnerSalesFilledPodRequests => {
                    "PARTNER_SALES_FILLED_POD_REQUESTS"
                }
                Self::PartnerSalesFillRate => "PARTNER_SALES_FILL_RATE",
                Self::PartnerSalesPartnerMatchRate => "PARTNER_SALES_PARTNER_MATCH_RATE",
                Self::PartnerSalesQueries => "PARTNER_SALES_QUERIES",
                Self::PartnerSalesUnfilledImpressions => {
                    "PARTNER_SALES_UNFILLED_IMPRESSIONS"
                }
                Self::PartnerSalesUnmatchedQueries => "PARTNER_SALES_UNMATCHED_QUERIES",
                Self::PartnerSoldCodeServed => "PARTNER_SOLD_CODE_SERVED",
                Self::PartnerSoldCoviewedImpressions => {
                    "PARTNER_SOLD_COVIEWED_IMPRESSIONS"
                }
                Self::PartnerSoldImpressions => "PARTNER_SOLD_IMPRESSIONS",
                Self::ProgrammaticEligibleAdRequests => {
                    "PROGRAMMATIC_ELIGIBLE_AD_REQUESTS"
                }
                Self::ProgrammaticMatchRate => "PROGRAMMATIC_MATCH_RATE",
                Self::ProgrammaticResponsesServed => "PROGRAMMATIC_RESPONSES_SERVED",
                Self::ReachImpressions => "REACH_IMPRESSIONS",
                Self::ResponsesServed => "RESPONSES_SERVED",
                Self::Retention => "RETENTION",
                Self::Revenue => "REVENUE",
                Self::RevenuePaidThroughMcmAutopayment => {
                    "REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT"
                }
                Self::RevenueVerificationCpdRevenue => "REVENUE_VERIFICATION_CPD_REVENUE",
                Self::RevenueVerificationGrossCpdRevenue => {
                    "REVENUE_VERIFICATION_GROSS_CPD_REVENUE"
                }
                Self::RevenueVerificationGrossRevenueWithoutCpd => {
                    "REVENUE_VERIFICATION_GROSS_REVENUE_WITHOUT_CPD"
                }
                Self::RevenueVerificationImpressions => {
                    "REVENUE_VERIFICATION_IMPRESSIONS"
                }
                Self::RevenueVerificationRevenueWithoutCpd => {
                    "REVENUE_VERIFICATION_REVENUE_WITHOUT_CPD"
                }
                Self::RevenueWithoutCpd => "REVENUE_WITHOUT_CPD",
                Self::RewardsGranted => "REWARDS_GRANTED",
                Self::RichMediaAverageDisplayTime => "RICH_MEDIA_AVERAGE_DISPLAY_TIME",
                Self::RichMediaAverageInteractionTime => {
                    "RICH_MEDIA_AVERAGE_INTERACTION_TIME"
                }
                Self::RichMediaBackupImages => "RICH_MEDIA_BACKUP_IMAGES",
                Self::RichMediaCustomEventCount => "RICH_MEDIA_CUSTOM_EVENT_COUNT",
                Self::RichMediaCustomEventTime => "RICH_MEDIA_CUSTOM_EVENT_TIME",
                Self::RichMediaDisplayTime => "RICH_MEDIA_DISPLAY_TIME",
                Self::RichMediaExpandingTime => "RICH_MEDIA_EXPANDING_TIME",
                Self::RichMediaExpansions => "RICH_MEDIA_EXPANSIONS",
                Self::RichMediaFullScreenImpressions => {
                    "RICH_MEDIA_FULL_SCREEN_IMPRESSIONS"
                }
                Self::RichMediaInteractionCount => "RICH_MEDIA_INTERACTION_COUNT",
                Self::RichMediaInteractionRate => "RICH_MEDIA_INTERACTION_RATE",
                Self::RichMediaInteractionTime => "RICH_MEDIA_INTERACTION_TIME",
                Self::RichMediaInteractiveImpressions => {
                    "RICH_MEDIA_INTERACTIVE_IMPRESSIONS"
                }
                Self::RichMediaManualCloses => "RICH_MEDIA_MANUAL_CLOSES",
                Self::RichMediaVideoCompletes => "RICH_MEDIA_VIDEO_COMPLETES",
                Self::RichMediaVideoInteractions => "RICH_MEDIA_VIDEO_INTERACTIONS",
                Self::RichMediaVideoInteractionRate => {
                    "RICH_MEDIA_VIDEO_INTERACTION_RATE"
                }
                Self::RichMediaVideoMidpoints => "RICH_MEDIA_VIDEO_MIDPOINTS",
                Self::RichMediaVideoMutes => "RICH_MEDIA_VIDEO_MUTES",
                Self::RichMediaVideoPauses => "RICH_MEDIA_VIDEO_PAUSES",
                Self::RichMediaVideoPlays => "RICH_MEDIA_VIDEO_PLAYS",
                Self::RichMediaVideoReplays => "RICH_MEDIA_VIDEO_REPLAYS",
                Self::RichMediaVideoStops => "RICH_MEDIA_VIDEO_STOPS",
                Self::RichMediaVideoUnmutes => "RICH_MEDIA_VIDEO_UNMUTES",
                Self::RichMediaVideoViewRate => "RICH_MEDIA_VIDEO_VIEW_RATE",
                Self::RichMediaVideoViewTime => "RICH_MEDIA_VIDEO_VIEW_TIME",
                Self::SellThroughAvailableImpressions => {
                    "SELL_THROUGH_AVAILABLE_IMPRESSIONS"
                }
                Self::SellThroughForecastedImpressions => {
                    "SELL_THROUGH_FORECASTED_IMPRESSIONS"
                }
                Self::SellThroughReservedImpressions => {
                    "SELL_THROUGH_RESERVED_IMPRESSIONS"
                }
                Self::SellThroughSellThroughRate => "SELL_THROUGH_SELL_THROUGH_RATE",
                Self::ServerSideUnwrappingAverageLatencyMs => {
                    "SERVER_SIDE_UNWRAPPING_AVERAGE_LATENCY_MS"
                }
                Self::ServerSideUnwrappingCallouts => "SERVER_SIDE_UNWRAPPING_CALLOUTS",
                Self::ServerSideUnwrappingEmptyResponses => {
                    "SERVER_SIDE_UNWRAPPING_EMPTY_RESPONSES"
                }
                Self::ServerSideUnwrappingErrorResponses => {
                    "SERVER_SIDE_UNWRAPPING_ERROR_RESPONSES"
                }
                Self::ServerSideUnwrappingSuccessfulResponses => {
                    "SERVER_SIDE_UNWRAPPING_SUCCESSFUL_RESPONSES"
                }
                Self::ServerSideUnwrappingTimeouts => "SERVER_SIDE_UNWRAPPING_TIMEOUTS",
                Self::Sessions => "SESSIONS",
                Self::TagLoadToFirstAdRequest0500Percent => {
                    "TAG_LOAD_TO_FIRST_AD_REQUEST_0_500_PERCENT"
                }
                Self::TagLoadToFirstAdRequest10002000Percent => {
                    "TAG_LOAD_TO_FIRST_AD_REQUEST_1000_2000_PERCENT"
                }
                Self::TagLoadToFirstAdRequest20004000Percent => {
                    "TAG_LOAD_TO_FIRST_AD_REQUEST_2000_4000_PERCENT"
                }
                Self::TagLoadToFirstAdRequest40008000Percent => {
                    "TAG_LOAD_TO_FIRST_AD_REQUEST_4000_8000_PERCENT"
                }
                Self::TagLoadToFirstAdRequest5001000Percent => {
                    "TAG_LOAD_TO_FIRST_AD_REQUEST_500_1000_PERCENT"
                }
                Self::TagLoadToFirstAdRequestGt8000Percent => {
                    "TAG_LOAD_TO_FIRST_AD_REQUEST_GT_8000_PERCENT"
                }
                Self::TargetedClicks => "TARGETED_CLICKS",
                Self::TargetedImpressions => "TARGETED_IMPRESSIONS",
                Self::UnfilledImpressions => "UNFILLED_IMPRESSIONS",
                Self::UniqueVisitors => "UNIQUE_VISITORS",
                Self::UnloadedImpressionsDueToCpu => "UNLOADED_IMPRESSIONS_DUE_TO_CPU",
                Self::UnloadedImpressionsDueToNetwork => {
                    "UNLOADED_IMPRESSIONS_DUE_TO_NETWORK"
                }
                Self::UnmatchedAdRequests => "UNMATCHED_AD_REQUESTS",
                Self::UnviewedReasonOtherPercent => "UNVIEWED_REASON_OTHER_PERCENT",
                Self::UnviewedReasonSlotNeverEnteredViewportPercent => {
                    "UNVIEWED_REASON_SLOT_NEVER_ENTERED_VIEWPORT_PERCENT"
                }
                Self::UnviewedReasonUserScrolledBeforeAdFilledPercent => {
                    "UNVIEWED_REASON_USER_SCROLLED_BEFORE_AD_FILLED_PERCENT"
                }
                Self::UnviewedReasonUserScrolledBeforeAdLoadedPercent => {
                    "UNVIEWED_REASON_USER_SCROLLED_BEFORE_AD_LOADED_PERCENT"
                }
                Self::UnviewedReasonUserScrolledBeforeOneSecondPercent => {
                    "UNVIEWED_REASON_USER_SCROLLED_BEFORE_ONE_SECOND_PERCENT"
                }
                Self::UserEngagementDurationInSeconds => {
                    "USER_ENGAGEMENT_DURATION_IN_SECONDS"
                }
                Self::UserMessagesAdBlockingExtensionRate => {
                    "USER_MESSAGES_AD_BLOCKING_EXTENSION_RATE"
                }
                Self::UserMessagesAdBlockingRecoveryAllowlistedCount => {
                    "USER_MESSAGES_AD_BLOCKING_RECOVERY_ALLOWLISTED_COUNT"
                }
                Self::UserMessagesAdBlockingRecoveryMessagesShown => {
                    "USER_MESSAGES_AD_BLOCKING_RECOVERY_MESSAGES_SHOWN"
                }
                Self::UserMessagesAllowAdsPageviews => {
                    "USER_MESSAGES_ALLOW_ADS_PAGEVIEWS"
                }
                Self::UserMessagesIdfaAttAlertsShown => {
                    "USER_MESSAGES_IDFA_ATT_ALERTS_SHOWN"
                }
                Self::UserMessagesIdfaAttConsent => "USER_MESSAGES_IDFA_ATT_CONSENT",
                Self::UserMessagesIdfaAttConsentRate => {
                    "USER_MESSAGES_IDFA_ATT_CONSENT_RATE"
                }
                Self::UserMessagesIdfaAttDeclineConsent => {
                    "USER_MESSAGES_IDFA_ATT_DECLINE_CONSENT"
                }
                Self::UserMessagesIdfaAttDeclineRate => {
                    "USER_MESSAGES_IDFA_ATT_DECLINE_RATE"
                }
                Self::UserMessagesIdfaExplainersShown => {
                    "USER_MESSAGES_IDFA_EXPLAINERS_SHOWN"
                }
                Self::UserMessagesIdfaIabMessagesShown => {
                    "USER_MESSAGES_IDFA_IAB_MESSAGES_SHOWN"
                }
                Self::UserMessagesIdfaNoDecision => "USER_MESSAGES_IDFA_NO_DECISION",
                Self::UserMessagesOfferwallMessagesShown => {
                    "USER_MESSAGES_OFFERWALL_MESSAGES_SHOWN"
                }
                Self::UserMessagesOfferwallSuccessfulEngagements => {
                    "USER_MESSAGES_OFFERWALL_SUCCESSFUL_ENGAGEMENTS"
                }
                Self::UserMessagesPostOfferwallPageviews => {
                    "USER_MESSAGES_POST_OFFERWALL_PAGEVIEWS"
                }
                Self::UserMessagesTotalEstimatedRevenue => {
                    "USER_MESSAGES_TOTAL_ESTIMATED_REVENUE"
                }
                Self::UserMessagesUptcMessagesShown => {
                    "USER_MESSAGES_UPTC_MESSAGES_SHOWN"
                }
                Self::UserMessagesUptcPersonalizationOptOutRatio => {
                    "USER_MESSAGES_UPTC_PERSONALIZATION_OPT_OUT_RATIO"
                }
                Self::UserMessagesUsStatesMessagesShown => {
                    "USER_MESSAGES_US_STATES_MESSAGES_SHOWN"
                }
                Self::UserMessagesUsStatesOptOutSelections => {
                    "USER_MESSAGES_US_STATES_OPT_OUT_SELECTIONS"
                }
                Self::VideoError100Count => "VIDEO_ERROR_100_COUNT",
                Self::VideoError101Count => "VIDEO_ERROR_101_COUNT",
                Self::VideoError102Count => "VIDEO_ERROR_102_COUNT",
                Self::VideoError200Count => "VIDEO_ERROR_200_COUNT",
                Self::VideoError201Count => "VIDEO_ERROR_201_COUNT",
                Self::VideoError202Count => "VIDEO_ERROR_202_COUNT",
                Self::VideoError203Count => "VIDEO_ERROR_203_COUNT",
                Self::VideoError300Count => "VIDEO_ERROR_300_COUNT",
                Self::VideoError301Count => "VIDEO_ERROR_301_COUNT",
                Self::VideoError302Count => "VIDEO_ERROR_302_COUNT",
                Self::VideoError303Count => "VIDEO_ERROR_303_COUNT",
                Self::VideoError400Count => "VIDEO_ERROR_400_COUNT",
                Self::VideoError401Count => "VIDEO_ERROR_401_COUNT",
                Self::VideoError402Count => "VIDEO_ERROR_402_COUNT",
                Self::VideoError403Count => "VIDEO_ERROR_403_COUNT",
                Self::VideoError405Count => "VIDEO_ERROR_405_COUNT",
                Self::VideoError406Count => "VIDEO_ERROR_406_COUNT",
                Self::VideoError407Count => "VIDEO_ERROR_407_COUNT",
                Self::VideoError408Count => "VIDEO_ERROR_408_COUNT",
                Self::VideoError409Count => "VIDEO_ERROR_409_COUNT",
                Self::VideoError410Count => "VIDEO_ERROR_410_COUNT",
                Self::VideoError500Count => "VIDEO_ERROR_500_COUNT",
                Self::VideoError501Count => "VIDEO_ERROR_501_COUNT",
                Self::VideoError502Count => "VIDEO_ERROR_502_COUNT",
                Self::VideoError503Count => "VIDEO_ERROR_503_COUNT",
                Self::VideoError600Count => "VIDEO_ERROR_600_COUNT",
                Self::VideoError601Count => "VIDEO_ERROR_601_COUNT",
                Self::VideoError602Count => "VIDEO_ERROR_602_COUNT",
                Self::VideoError603Count => "VIDEO_ERROR_603_COUNT",
                Self::VideoError604Count => "VIDEO_ERROR_604_COUNT",
                Self::VideoError900Count => "VIDEO_ERROR_900_COUNT",
                Self::VideoError901Count => "VIDEO_ERROR_901_COUNT",
                Self::VideoInteractionAverageInteractionRate => {
                    "VIDEO_INTERACTION_AVERAGE_INTERACTION_RATE"
                }
                Self::VideoInteractionCollapses => "VIDEO_INTERACTION_COLLAPSES",
                Self::VideoInteractionExpands => "VIDEO_INTERACTION_EXPANDS",
                Self::VideoInteractionFullScreens => "VIDEO_INTERACTION_FULL_SCREENS",
                Self::VideoInteractionMutes => "VIDEO_INTERACTION_MUTES",
                Self::VideoInteractionPauses => "VIDEO_INTERACTION_PAUSES",
                Self::VideoInteractionResumes => "VIDEO_INTERACTION_RESUMES",
                Self::VideoInteractionRewinds => "VIDEO_INTERACTION_REWINDS",
                Self::VideoInteractionUnmutes => "VIDEO_INTERACTION_UNMUTES",
                Self::VideoInteractionVideoSkips => "VIDEO_INTERACTION_VIDEO_SKIPS",
                Self::VideoMonetizableContentViews => "VIDEO_MONETIZABLE_CONTENT_VIEWS",
                Self::VideoRealTimeCreativeServes => "VIDEO_REAL_TIME_CREATIVE_SERVES",
                Self::VideoRealTimeError100Count => "VIDEO_REAL_TIME_ERROR_100_COUNT",
                Self::VideoRealTimeError101Count => "VIDEO_REAL_TIME_ERROR_101_COUNT",
                Self::VideoRealTimeError102Count => "VIDEO_REAL_TIME_ERROR_102_COUNT",
                Self::VideoRealTimeError200Count => "VIDEO_REAL_TIME_ERROR_200_COUNT",
                Self::VideoRealTimeError201Count => "VIDEO_REAL_TIME_ERROR_201_COUNT",
                Self::VideoRealTimeError202Count => "VIDEO_REAL_TIME_ERROR_202_COUNT",
                Self::VideoRealTimeError203Count => "VIDEO_REAL_TIME_ERROR_203_COUNT",
                Self::VideoRealTimeError300Count => "VIDEO_REAL_TIME_ERROR_300_COUNT",
                Self::VideoRealTimeError301Count => "VIDEO_REAL_TIME_ERROR_301_COUNT",
                Self::VideoRealTimeError302Count => "VIDEO_REAL_TIME_ERROR_302_COUNT",
                Self::VideoRealTimeError303Count => "VIDEO_REAL_TIME_ERROR_303_COUNT",
                Self::VideoRealTimeError400Count => "VIDEO_REAL_TIME_ERROR_400_COUNT",
                Self::VideoRealTimeError401Count => "VIDEO_REAL_TIME_ERROR_401_COUNT",
                Self::VideoRealTimeError402Count => "VIDEO_REAL_TIME_ERROR_402_COUNT",
                Self::VideoRealTimeError403Count => "VIDEO_REAL_TIME_ERROR_403_COUNT",
                Self::VideoRealTimeError405Count => "VIDEO_REAL_TIME_ERROR_405_COUNT",
                Self::VideoRealTimeError406Count => "VIDEO_REAL_TIME_ERROR_406_COUNT",
                Self::VideoRealTimeError407Count => "VIDEO_REAL_TIME_ERROR_407_COUNT",
                Self::VideoRealTimeError408Count => "VIDEO_REAL_TIME_ERROR_408_COUNT",
                Self::VideoRealTimeError409Count => "VIDEO_REAL_TIME_ERROR_409_COUNT",
                Self::VideoRealTimeError410Count => "VIDEO_REAL_TIME_ERROR_410_COUNT",
                Self::VideoRealTimeError500Count => "VIDEO_REAL_TIME_ERROR_500_COUNT",
                Self::VideoRealTimeError501Count => "VIDEO_REAL_TIME_ERROR_501_COUNT",
                Self::VideoRealTimeError502Count => "VIDEO_REAL_TIME_ERROR_502_COUNT",
                Self::VideoRealTimeError503Count => "VIDEO_REAL_TIME_ERROR_503_COUNT",
                Self::VideoRealTimeError600Count => "VIDEO_REAL_TIME_ERROR_600_COUNT",
                Self::VideoRealTimeError601Count => "VIDEO_REAL_TIME_ERROR_601_COUNT",
                Self::VideoRealTimeError602Count => "VIDEO_REAL_TIME_ERROR_602_COUNT",
                Self::VideoRealTimeError603Count => "VIDEO_REAL_TIME_ERROR_603_COUNT",
                Self::VideoRealTimeError604Count => "VIDEO_REAL_TIME_ERROR_604_COUNT",
                Self::VideoRealTimeError900Count => "VIDEO_REAL_TIME_ERROR_900_COUNT",
                Self::VideoRealTimeError901Count => "VIDEO_REAL_TIME_ERROR_901_COUNT",
                Self::VideoRealTimeImpressions => "VIDEO_REAL_TIME_IMPRESSIONS",
                Self::VideoRealTimeMatchedQueries => "VIDEO_REAL_TIME_MATCHED_QUERIES",
                Self::VideoRealTimeTotalErrorCount => "VIDEO_REAL_TIME_TOTAL_ERROR_COUNT",
                Self::VideoRealTimeTotalQueries => "VIDEO_REAL_TIME_TOTAL_QUERIES",
                Self::VideoRealTimeUnmatchedQueries => {
                    "VIDEO_REAL_TIME_UNMATCHED_QUERIES"
                }
                Self::VideoTrueOpportunitiesTotalBreakEnd => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_BREAK_END"
                }
                Self::VideoTrueOpportunitiesTotalBreakStart => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_BREAK_START"
                }
                Self::VideoTrueOpportunitiesTotalCappedOpportunitiesAdbreak => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_CAPPED_OPPORTUNITIES_ADBREAK"
                }
                Self::VideoTrueOpportunitiesTotalDurationAdbreak => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_DURATION_ADBREAK"
                }
                Self::VideoTrueOpportunitiesTotalMatchedDurationAdbreak => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_MATCHED_DURATION_ADBREAK"
                }
                Self::VideoTrueOpportunitiesTotalMatchedOpportunitiesAdbreak => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_MATCHED_OPPORTUNITIES_ADBREAK"
                }
                Self::VideoTrueOpportunitiesTotalViewedOpportunitiesAdbreak => {
                    "VIDEO_TRUE_OPPORTUNITIES_TOTAL_VIEWED_OPPORTUNITIES_ADBREAK"
                }
                Self::VideoTrueViews => "VIDEO_TRUE_VIEWS",
                Self::VideoTrueViewSkipRate => "VIDEO_TRUE_VIEW_SKIP_RATE",
                Self::VideoTrueViewViewThroughRate => "VIDEO_TRUE_VIEW_VIEW_THROUGH_RATE",
                Self::VideoViewershipAutoPlays => "VIDEO_VIEWERSHIP_AUTO_PLAYS",
                Self::VideoViewershipAverageViewRate => {
                    "VIDEO_VIEWERSHIP_AVERAGE_VIEW_RATE"
                }
                Self::VideoViewershipAverageViewTime => {
                    "VIDEO_VIEWERSHIP_AVERAGE_VIEW_TIME"
                }
                Self::VideoViewershipClickToPlays => "VIDEO_VIEWERSHIP_CLICK_TO_PLAYS",
                Self::VideoViewershipCompletes => "VIDEO_VIEWERSHIP_COMPLETES",
                Self::VideoViewershipCompletionRate => "VIDEO_VIEWERSHIP_COMPLETION_RATE",
                Self::VideoViewershipEngagedViews => "VIDEO_VIEWERSHIP_ENGAGED_VIEWS",
                Self::VideoViewershipFirstQuartiles => "VIDEO_VIEWERSHIP_FIRST_QUARTILES",
                Self::VideoViewershipMidpoints => "VIDEO_VIEWERSHIP_MIDPOINTS",
                Self::VideoViewershipSkipButtonsShown => {
                    "VIDEO_VIEWERSHIP_SKIP_BUTTONS_SHOWN"
                }
                Self::VideoViewershipStarts => "VIDEO_VIEWERSHIP_STARTS",
                Self::VideoViewershipThirdQuartiles => "VIDEO_VIEWERSHIP_THIRD_QUARTILES",
                Self::VideoViewershipTotalErrorCount => {
                    "VIDEO_VIEWERSHIP_TOTAL_ERROR_COUNT"
                }
                Self::VideoViewershipTotalErrorRate => {
                    "VIDEO_VIEWERSHIP_TOTAL_ERROR_RATE"
                }
                Self::VideoViewershipVideoLength => "VIDEO_VIEWERSHIP_VIDEO_LENGTH",
                Self::VideoViewershipViewThroughRate => {
                    "VIDEO_VIEWERSHIP_VIEW_THROUGH_RATE"
                }
                Self::YieldGroupAuctionsWon => "YIELD_GROUP_AUCTIONS_WON",
                Self::YieldGroupBids => "YIELD_GROUP_BIDS",
                Self::YieldGroupBidsInAuction => "YIELD_GROUP_BIDS_IN_AUCTION",
                Self::YieldGroupCallouts => "YIELD_GROUP_CALLOUTS",
                Self::YieldGroupEstimatedCpm => "YIELD_GROUP_ESTIMATED_CPM",
                Self::YieldGroupEstimatedRevenue => "YIELD_GROUP_ESTIMATED_REVENUE",
                Self::YieldGroupImpressions => "YIELD_GROUP_IMPRESSIONS",
                Self::YieldGroupMediationFillRate => "YIELD_GROUP_MEDIATION_FILL_RATE",
                Self::YieldGroupMediationMatchedQueries => {
                    "YIELD_GROUP_MEDIATION_MATCHED_QUERIES"
                }
                Self::YieldGroupMediationPassbacks => "YIELD_GROUP_MEDIATION_PASSBACKS",
                Self::YieldGroupMediationThirdPartyEcpm => {
                    "YIELD_GROUP_MEDIATION_THIRD_PARTY_ECPM"
                }
                Self::YieldGroupRevenuePaidThroughMcmAutopayment => {
                    "YIELD_GROUP_REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT"
                }
                Self::YieldGroupSuccessfulResponses => "YIELD_GROUP_SUCCESSFUL_RESPONSES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METRIC_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE_USERS" => Some(Self::ActiveUsers),
                "ACTIVE_VIEW_AUDIBLE_AT_START_PERCENT" => {
                    Some(Self::ActiveViewAudibleAtStartPercent)
                }
                "ACTIVE_VIEW_AUDIBLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewAudibleImpressions)
                }
                "ACTIVE_VIEW_AUDIBLE_THROUGH_COMPLETION_PERCENT" => {
                    Some(Self::ActiveViewAudibleThroughCompletionPercent)
                }
                "ACTIVE_VIEW_AUDIBLE_THROUGH_FIRST_QUARTILE_PERCENT" => {
                    Some(Self::ActiveViewAudibleThroughFirstQuartilePercent)
                }
                "ACTIVE_VIEW_AUDIBLE_THROUGH_MIDPOINT_PERCENT" => {
                    Some(Self::ActiveViewAudibleThroughMidpointPercent)
                }
                "ACTIVE_VIEW_AUDIBLE_THROUGH_THIRD_QUARTILE_PERCENT" => {
                    Some(Self::ActiveViewAudibleThroughThirdQuartilePercent)
                }
                "ACTIVE_VIEW_AUDIO_ENABLED_IMPRESSIONS" => {
                    Some(Self::ActiveViewAudioEnabledImpressions)
                }
                "ACTIVE_VIEW_AUDIO_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewAudioMeasurableImpressions)
                }
                "ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME" => {
                    Some(Self::ActiveViewAverageViewableTime)
                }
                "ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewEligibleImpressions)
                }
                "ACTIVE_VIEW_EVER_AUDIBLE_BACKGROUNDED_PERCENT" => {
                    Some(Self::ActiveViewEverAudibleBackgroundedPercent)
                }
                "ACTIVE_VIEW_EVER_AUDIBLE_PERCENT" => {
                    Some(Self::ActiveViewEverAudiblePercent)
                }
                "ACTIVE_VIEW_EVER_BACKGROUNDED_PERCENT" => {
                    Some(Self::ActiveViewEverBackgroundedPercent)
                }
                "ACTIVE_VIEW_EVER_MUTED_PERCENT" => {
                    Some(Self::ActiveViewEverMutedPercent)
                }
                "ACTIVE_VIEW_IMPRESSIONS_AUDIBLE_AND_VISIBLIE_AT_COMPLETION" => {
                    Some(Self::ActiveViewImpressionsAudibleAndVisiblieAtCompletion)
                }
                "ACTIVE_VIEW_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewMeasurableImpressions)
                }
                "ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE" => {
                    Some(Self::ActiveViewMeasurableImpressionsRate)
                }
                "ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewNonMeasurableImpressions)
                }
                "ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewNonViewableImpressions)
                }
                "ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::ActiveViewNonViewableImpressionsDistribution)
                }
                "ACTIVE_VIEW_PERCENT_AUDIBLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewPercentAudibleImpressions)
                }
                "ACTIVE_VIEW_PLUS_MEASURABLE_COUNT" => {
                    Some(Self::ActiveViewPlusMeasurableCount)
                }
                "ACTIVE_VIEW_REVENUE" => Some(Self::ActiveViewRevenue),
                "ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::ActiveViewUndeterminedImpressionsDistribution)
                }
                "ACTIVE_VIEW_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::ActiveViewViewableImpressions)
                }
                "ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::ActiveViewViewableImpressionsDistribution)
                }
                "ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE" => {
                    Some(Self::ActiveViewViewableImpressionsRate)
                }
                "ADSENSE_ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME" => {
                    Some(Self::AdsenseActiveViewAverageViewableTime)
                }
                "ADSENSE_ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS" => {
                    Some(Self::AdsenseActiveViewEligibleImpressions)
                }
                "ADSENSE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::AdsenseActiveViewMeasurableImpressions)
                }
                "ADSENSE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE" => {
                    Some(Self::AdsenseActiveViewMeasurableImpressionsRate)
                }
                "ADSENSE_ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::AdsenseActiveViewNonMeasurableImpressions)
                }
                "ADSENSE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::AdsenseActiveViewNonViewableImpressions)
                }
                "ADSENSE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdsenseActiveViewNonViewableImpressionsDistribution)
                }
                "ADSENSE_ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdsenseActiveViewUndeterminedImpressionsDistribution)
                }
                "ADSENSE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::AdsenseActiveViewViewableImpressions)
                }
                "ADSENSE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdsenseActiveViewViewableImpressionsDistribution)
                }
                "ADSENSE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE" => {
                    Some(Self::AdsenseActiveViewViewableImpressionsRate)
                }
                "ADSENSE_AVERAGE_ECPM" => Some(Self::AdsenseAverageEcpm),
                "ADSENSE_CLICKS" => Some(Self::AdsenseClicks),
                "ADSENSE_CTR" => Some(Self::AdsenseCtr),
                "ADSENSE_IMPRESSIONS" => Some(Self::AdsenseImpressions),
                "ADSENSE_PERCENT_CLICKS" => Some(Self::AdsensePercentClicks),
                "ADSENSE_PERCENT_IMPRESSIONS" => Some(Self::AdsensePercentImpressions),
                "ADSENSE_PERCENT_REVENUE" => Some(Self::AdsensePercentRevenue),
                "ADSENSE_PERCENT_REVENUE_WITHOUT_CPD" => {
                    Some(Self::AdsensePercentRevenueWithoutCpd)
                }
                "ADSENSE_RESPONSES_SERVED" => Some(Self::AdsenseResponsesServed),
                "ADSENSE_REVENUE" => Some(Self::AdsenseRevenue),
                "AD_EXCHANGE_ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME" => {
                    Some(Self::AdExchangeActiveViewAverageViewableTime)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS" => {
                    Some(Self::AdExchangeActiveViewEligibleImpressions)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::AdExchangeActiveViewMeasurableImpressions)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE" => {
                    Some(Self::AdExchangeActiveViewMeasurableImpressionsRate)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::AdExchangeActiveViewNonMeasurableImpressions)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::AdExchangeActiveViewNonViewableImpressions)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdExchangeActiveViewNonViewableImpressionsDistribution)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdExchangeActiveViewUndeterminedImpressionsDistribution)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::AdExchangeActiveViewViewableImpressions)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdExchangeActiveViewViewableImpressionsDistribution)
                }
                "AD_EXCHANGE_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE" => {
                    Some(Self::AdExchangeActiveViewViewableImpressionsRate)
                }
                "AD_EXCHANGE_AVERAGE_ECPM" => Some(Self::AdExchangeAverageEcpm),
                "AD_EXCHANGE_CLICKS" => Some(Self::AdExchangeClicks),
                "AD_EXCHANGE_CPC" => Some(Self::AdExchangeCpc),
                "AD_EXCHANGE_CTR" => Some(Self::AdExchangeCtr),
                "AD_EXCHANGE_DELIVERY_RATE" => Some(Self::AdExchangeDeliveryRate),
                "AD_EXCHANGE_IMPRESSIONS" => Some(Self::AdExchangeImpressions),
                "AD_EXCHANGE_IMPRESSIONS_PER_AD_VIEWER" => {
                    Some(Self::AdExchangeImpressionsPerAdViewer)
                }
                "AD_EXCHANGE_IMPRESSIONS_PER_SESSION" => {
                    Some(Self::AdExchangeImpressionsPerSession)
                }
                "AD_EXCHANGE_LIFT" => Some(Self::AdExchangeLift),
                "AD_EXCHANGE_MATCHED_REQUEST_CTR" => {
                    Some(Self::AdExchangeMatchedRequestCtr)
                }
                "AD_EXCHANGE_MATCHED_REQUEST_ECPM" => {
                    Some(Self::AdExchangeMatchedRequestEcpm)
                }
                "AD_EXCHANGE_MATCH_RATE" => Some(Self::AdExchangeMatchRate),
                "AD_EXCHANGE_OPPORTUNITIES_FROM_ERRORS" => {
                    Some(Self::AdExchangeOpportunitiesFromErrors)
                }
                "AD_EXCHANGE_OPPORTUNITIES_FROM_IMPRESSIONS" => {
                    Some(Self::AdExchangeOpportunitiesFromImpressions)
                }
                "AD_EXCHANGE_PERCENT_CLICKS" => Some(Self::AdExchangePercentClicks),
                "AD_EXCHANGE_PERCENT_IMPRESSIONS" => {
                    Some(Self::AdExchangePercentImpressions)
                }
                "AD_EXCHANGE_PERCENT_REVENUE" => Some(Self::AdExchangePercentRevenue),
                "AD_EXCHANGE_PERCENT_REVENUE_WITHOUT_CPD" => {
                    Some(Self::AdExchangePercentRevenueWithoutCpd)
                }
                "AD_EXCHANGE_PLUS_YIELD_GROUP_ECPM" => {
                    Some(Self::AdExchangePlusYieldGroupEcpm)
                }
                "AD_EXCHANGE_PLUS_YIELD_GROUP_IMPRESSIONS" => {
                    Some(Self::AdExchangePlusYieldGroupImpressions)
                }
                "AD_EXCHANGE_PLUS_YIELD_GROUP_REVENUE" => {
                    Some(Self::AdExchangePlusYieldGroupRevenue)
                }
                "AD_EXCHANGE_RESPONSES_SERVED" => Some(Self::AdExchangeResponsesServed),
                "AD_EXCHANGE_REVENUE" => Some(Self::AdExchangeRevenue),
                "AD_EXCHANGE_REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT" => {
                    Some(Self::AdExchangeRevenuePaidThroughMcmAutopayment)
                }
                "AD_EXCHANGE_REVENUE_PER_AD_VIEWER" => {
                    Some(Self::AdExchangeRevenuePerAdViewer)
                }
                "AD_EXCHANGE_TOTAL_REQUESTS" => Some(Self::AdExchangeTotalRequests),
                "AD_EXCHANGE_TOTAL_REQUEST_CTR" => Some(Self::AdExchangeTotalRequestCtr),
                "AD_EXCHANGE_TOTAL_REQUEST_ECPM" => {
                    Some(Self::AdExchangeTotalRequestEcpm)
                }
                "AD_EXPOSURE_SECONDS" => Some(Self::AdExposureSeconds),
                "AD_REQUESTS" => Some(Self::AdRequests),
                "AD_SERVER_ACTIVE_VIEW_AVERAGE_VIEWABLE_TIME" => {
                    Some(Self::AdServerActiveViewAverageViewableTime)
                }
                "AD_SERVER_ACTIVE_VIEW_ELIGIBLE_IMPRESSIONS" => {
                    Some(Self::AdServerActiveViewEligibleImpressions)
                }
                "AD_SERVER_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::AdServerActiveViewMeasurableImpressions)
                }
                "AD_SERVER_ACTIVE_VIEW_MEASURABLE_IMPRESSIONS_RATE" => {
                    Some(Self::AdServerActiveViewMeasurableImpressionsRate)
                }
                "AD_SERVER_ACTIVE_VIEW_NON_MEASURABLE_IMPRESSIONS" => {
                    Some(Self::AdServerActiveViewNonMeasurableImpressions)
                }
                "AD_SERVER_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::AdServerActiveViewNonViewableImpressions)
                }
                "AD_SERVER_ACTIVE_VIEW_NON_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdServerActiveViewNonViewableImpressionsDistribution)
                }
                "AD_SERVER_ACTIVE_VIEW_UNDETERMINED_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdServerActiveViewUndeterminedImpressionsDistribution)
                }
                "AD_SERVER_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS" => {
                    Some(Self::AdServerActiveViewViewableImpressions)
                }
                "AD_SERVER_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_DISTRIBUTION" => {
                    Some(Self::AdServerActiveViewViewableImpressionsDistribution)
                }
                "AD_SERVER_ACTIVE_VIEW_VIEWABLE_IMPRESSIONS_RATE" => {
                    Some(Self::AdServerActiveViewViewableImpressionsRate)
                }
                "AD_SERVER_AVERAGE_ECPM" => Some(Self::AdServerAverageEcpm),
                "AD_SERVER_AVERAGE_ECPM_WITHOUT_CPD" => {
                    Some(Self::AdServerAverageEcpmWithoutCpd)
                }
                "AD_SERVER_BEGIN_TO_RENDER_IMPRESSIONS" => {
                    Some(Self::AdServerBeginToRenderImpressions)
                }
                "AD_SERVER_CLICKS" => Some(Self::AdServerClicks),
                "AD_SERVER_COMPLETED_VIEWS" => Some(Self::AdServerCompletedViews),
                "AD_SERVER_COVIEWED_IMPRESSIONS" => {
                    Some(Self::AdServerCoviewedImpressions)
                }
                "AD_SERVER_CPD_REVENUE" => Some(Self::AdServerCpdRevenue),
                "AD_SERVER_CTR" => Some(Self::AdServerCtr),
                "AD_SERVER_GROSS_REVENUE" => Some(Self::AdServerGrossRevenue),
                "AD_SERVER_GROSS_REVENUE_WITHOUT_CPD" => {
                    Some(Self::AdServerGrossRevenueWithoutCpd)
                }
                "AD_SERVER_IMPRESSIONS" => Some(Self::AdServerImpressions),
                "AD_SERVER_IMPRESSIONS_WITH_COMPANION" => {
                    Some(Self::AdServerImpressionsWithCompanion)
                }
                "AD_SERVER_INACTIVE_BEGIN_TO_RENDER_IMPRESSIONS" => {
                    Some(Self::AdServerInactiveBeginToRenderImpressions)
                }
                "AD_SERVER_OPPORTUNITIES_FROM_ERRORS" => {
                    Some(Self::AdServerOpportunitiesFromErrors)
                }
                "AD_SERVER_OPPORTUNITIES_FROM_IMPRESSIONS" => {
                    Some(Self::AdServerOpportunitiesFromImpressions)
                }
                "AD_SERVER_PERCENT_CLICKS" => Some(Self::AdServerPercentClicks),
                "AD_SERVER_PERCENT_IMPRESSIONS" => Some(Self::AdServerPercentImpressions),
                "AD_SERVER_PERCENT_REVENUE" => Some(Self::AdServerPercentRevenue),
                "AD_SERVER_PERCENT_REVENUE_WITHOUT_CPD" => {
                    Some(Self::AdServerPercentRevenueWithoutCpd)
                }
                "AD_SERVER_RESPONSES_SERVED" => Some(Self::AdServerResponsesServed),
                "AD_SERVER_REVENUE" => Some(Self::AdServerRevenue),
                "AD_SERVER_REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT" => {
                    Some(Self::AdServerRevenuePaidThroughMcmAutopayment)
                }
                "AD_SERVER_REVENUE_WITHOUT_CPD" => Some(Self::AdServerRevenueWithoutCpd),
                "AD_SERVER_TARGETED_CLICKS" => Some(Self::AdServerTargetedClicks),
                "AD_SERVER_TARGETED_IMPRESSIONS" => {
                    Some(Self::AdServerTargetedImpressions)
                }
                "AD_SERVER_TRACKED_ADS" => Some(Self::AdServerTrackedAds),
                "AD_SERVER_UNFILTERED_BEGIN_TO_RENDER_IMPRESSIONS" => {
                    Some(Self::AdServerUnfilteredBeginToRenderImpressions)
                }
                "AD_SERVER_UNFILTERED_CLICKS" => Some(Self::AdServerUnfilteredClicks),
                "AD_SERVER_UNFILTERED_DOWNLOADED_IMPRESSIONS" => {
                    Some(Self::AdServerUnfilteredDownloadedImpressions)
                }
                "AD_SERVER_UNFILTERED_TRACKED_ADS" => {
                    Some(Self::AdServerUnfilteredTrackedAds)
                }
                "AD_UNIT_EXPOSURE_SECONDS" => Some(Self::AdUnitExposureSeconds),
                "AD_VIEWERS" => Some(Self::AdViewers),
                "ATN_ADS_FAILED_TO_RENDER" => Some(Self::AtnAdsFailedToRender),
                "ATN_ELIGIBLE_LINE_ITEMS" => Some(Self::AtnEligibleLineItems),
                "ATN_ELIGIBLE_LINE_ITEMS_AD_REQUESTS" => {
                    Some(Self::AtnEligibleLineItemsAdRequests)
                }
                "ATN_HBT_ALLOWED_AD_REQUESTS" => Some(Self::AtnHbtAllowedAdRequests),
                "ATN_HBT_BIDS_IN_AUCTION" => Some(Self::AtnHbtBidsInAuction),
                "ATN_HBT_BIDS_IN_AUCTION_AD_REQUESTS" => {
                    Some(Self::AtnHbtBidsInAuctionAdRequests)
                }
                "ATN_HBT_CANDIDATE_BIDS" => Some(Self::AtnHbtCandidateBids),
                "ATN_HBT_INVALID_AD_REQUESTS" => Some(Self::AtnHbtInvalidAdRequests),
                "ATN_HBT_NO_BIDS_AD_REQUESTS" => Some(Self::AtnHbtNoBidsAdRequests),
                "ATN_HBT_REJECTED_BIDS" => Some(Self::AtnHbtRejectedBids),
                "ATN_HBT_VALID_AD_REQUESTS" => Some(Self::AtnHbtValidAdRequests),
                "ATN_HBT_WITH_BIDS_AD_REQUESTS" => Some(Self::AtnHbtWithBidsAdRequests),
                "ATN_INVALID_AD_REQUESTS" => Some(Self::AtnInvalidAdRequests),
                "ATN_LINE_ITEMS_CREATIVE_NOT_RETRIEVED" => {
                    Some(Self::AtnLineItemsCreativeNotRetrieved)
                }
                "ATN_LINE_ITEMS_IN_AUCTION" => Some(Self::AtnLineItemsInAuction),
                "ATN_LINE_ITEMS_NOT_COMPETING" => Some(Self::AtnLineItemsNotCompeting),
                "ATN_LINE_ITEMS_NOT_SELECTED" => Some(Self::AtnLineItemsNotSelected),
                "ATN_LINE_ITEM_IN_AUCTION_AD_REQUESTS" => {
                    Some(Self::AtnLineItemInAuctionAdRequests)
                }
                "ATN_LINE_ITEM_TARGETED_AD_REQUESTS" => {
                    Some(Self::AtnLineItemTargetedAdRequests)
                }
                "ATN_MEDIATION_ALLOWED_AD_REQUESTS" => {
                    Some(Self::AtnMediationAllowedAdRequests)
                }
                "ATN_MEDIATION_INVALID_AD_REQUESTS" => {
                    Some(Self::AtnMediationInvalidAdRequests)
                }
                "ATN_MEDIATION_LOADED_ADS_FROM_CHAINS" => {
                    Some(Self::AtnMediationLoadedAdsFromChains)
                }
                "ATN_MEDIATION_NO_PARTNER_AD_REQUESTS" => {
                    Some(Self::AtnMediationNoPartnerAdRequests)
                }
                "ATN_MEDIATION_PARTNERS_IN_AUCTION" => {
                    Some(Self::AtnMediationPartnersInAuction)
                }
                "ATN_MEDIATION_PARTNERS_IN_AUCTION_AD_REQUESTS" => {
                    Some(Self::AtnMediationPartnersInAuctionAdRequests)
                }
                "ATN_MEDIATION_REJECTED_PARTNERS" => {
                    Some(Self::AtnMediationRejectedPartners)
                }
                "ATN_MEDIATION_TARGETED_PARTNERS" => {
                    Some(Self::AtnMediationTargetedPartners)
                }
                "ATN_MEDIATION_TOTAL_YIELD_PARTNERS" => {
                    Some(Self::AtnMediationTotalYieldPartners)
                }
                "ATN_MEDIATION_UNLOADED_ADS_FROM_CHAINS" => {
                    Some(Self::AtnMediationUnloadedAdsFromChains)
                }
                "ATN_MEDIATION_UNUSED_BIDS_OR_PARTNERS" => {
                    Some(Self::AtnMediationUnusedBidsOrPartners)
                }
                "ATN_MEDIATION_VALID_AD_REQUESTS" => {
                    Some(Self::AtnMediationValidAdRequests)
                }
                "ATN_MEDIATION_WITH_PARTNERS_AD_REQUESTS" => {
                    Some(Self::AtnMediationWithPartnersAdRequests)
                }
                "ATN_PROGRAMMATIC_AD_REQUESTS_WITH_BIDS" => {
                    Some(Self::AtnProgrammaticAdRequestsWithBids)
                }
                "ATN_PROGRAMMATIC_AD_REQUESTS_WITH_BID_REQUESTS_SENT" => {
                    Some(Self::AtnProgrammaticAdRequestsWithBidRequestsSent)
                }
                "ATN_PROGRAMMATIC_ALLOWED_AD_REQUESTS" => {
                    Some(Self::AtnProgrammaticAllowedAdRequests)
                }
                "ATN_PROGRAMMATIC_BIDS_IN_AUCTION" => {
                    Some(Self::AtnProgrammaticBidsInAuction)
                }
                "ATN_PROGRAMMATIC_BID_IN_AUCTION_AD_REQUESTS" => {
                    Some(Self::AtnProgrammaticBidInAuctionAdRequests)
                }
                "ATN_PROGRAMMATIC_BID_REQUESTS_SENT" => {
                    Some(Self::AtnProgrammaticBidRequestsSent)
                }
                "ATN_PROGRAMMATIC_BID_REQUESTS_WITH_RESPONSE" => {
                    Some(Self::AtnProgrammaticBidRequestsWithResponse)
                }
                "ATN_PROGRAMMATIC_BID_REQUEST_CANDIDATES" => {
                    Some(Self::AtnProgrammaticBidRequestCandidates)
                }
                "ATN_PROGRAMMATIC_BID_REQUEST_ERRORS" => {
                    Some(Self::AtnProgrammaticBidRequestErrors)
                }
                "ATN_PROGRAMMATIC_INELIGIBLE_AD_REQUESTS" => {
                    Some(Self::AtnProgrammaticIneligibleAdRequests)
                }
                "ATN_PROGRAMMATIC_REJECTED_BIDS" => {
                    Some(Self::AtnProgrammaticRejectedBids)
                }
                "ATN_PROGRAMMATIC_SKIPPED_BID_REQUESTS" => {
                    Some(Self::AtnProgrammaticSkippedBidRequests)
                }
                "ATN_PROGRAMMATIC_TOTAL_BIDS" => Some(Self::AtnProgrammaticTotalBids),
                "ATN_PROGRAMMATIC_VALID_AD_REQUESTS" => {
                    Some(Self::AtnProgrammaticValidAdRequests)
                }
                "ATN_REJECTED_LINE_ITEMS" => Some(Self::AtnRejectedLineItems),
                "ATN_SERVED_MEDIATION_CHAINS" => Some(Self::AtnServedMediationChains),
                "ATN_SERVED_SINGLE_ADS" => Some(Self::AtnServedSingleAds),
                "ATN_TARGETED_LINE_ITEMS" => Some(Self::AtnTargetedLineItems),
                "ATN_TOTAL_AD_REQUESTS" => Some(Self::AtnTotalAdRequests),
                "ATN_TOTAL_COMPETING_ADS_IN_AUCTION" => {
                    Some(Self::AtnTotalCompetingAdsInAuction)
                }
                "ATN_TOTAL_LOADED_ADS" => Some(Self::AtnTotalLoadedAds),
                "ATN_VALID_AD_REQUESTS" => Some(Self::AtnValidAdRequests),
                "ATN_YIELD_GROUP_MEDIATION_PASSBACKS" => {
                    Some(Self::AtnYieldGroupMediationPassbacks)
                }
                "AUDIENCE_SEGMENT_COST" => Some(Self::AudienceSegmentCost),
                "AVERAGE_ECPM" => Some(Self::AverageEcpm),
                "AVERAGE_ECPM_WITHOUT_CPD" => Some(Self::AverageEcpmWithoutCpd),
                "AVERAGE_ENGAGEMENT_SECONDS_PER_SESSION" => {
                    Some(Self::AverageEngagementSecondsPerSession)
                }
                "AVERAGE_ENGAGEMENT_SECONDS_PER_USER" => {
                    Some(Self::AverageEngagementSecondsPerUser)
                }
                "AVERAGE_IMPRESSIONS_PER_UNIQUE_VISITOR" => {
                    Some(Self::AverageImpressionsPerUniqueVisitor)
                }
                "AVERAGE_PURCHASE_REVENUE_PER_PAYING_USER" => {
                    Some(Self::AveragePurchaseRevenuePerPayingUser)
                }
                "AVERAGE_REVENUE_PER_USER" => Some(Self::AverageRevenuePerUser),
                "AVERAGE_SESSION_SECONDS" => Some(Self::AverageSessionSeconds),
                "BIDS" => Some(Self::Bids),
                "BID_AVERAGE_CPM" => Some(Self::BidAverageCpm),
                "BOUNCE_RATE" => Some(Self::BounceRate),
                "CLICKS" => Some(Self::Clicks),
                "CODE_SERVED_COUNT" => Some(Self::CodeServedCount),
                "CPC_REVENUE" => Some(Self::CpcRevenue),
                "CPM_REVENUE" => Some(Self::CpmRevenue),
                "CREATIVE_LOAD_TIME_0_500_PERCENT" => {
                    Some(Self::CreativeLoadTime0500Percent)
                }
                "CREATIVE_LOAD_TIME_1000_2000_PERCENT" => {
                    Some(Self::CreativeLoadTime10002000Percent)
                }
                "CREATIVE_LOAD_TIME_2000_4000_PERCENT" => {
                    Some(Self::CreativeLoadTime20004000Percent)
                }
                "CREATIVE_LOAD_TIME_4000_8000_PERCENT" => {
                    Some(Self::CreativeLoadTime40008000Percent)
                }
                "CREATIVE_LOAD_TIME_500_1000_PERCENT" => {
                    Some(Self::CreativeLoadTime5001000Percent)
                }
                "CREATIVE_LOAD_TIME_GT_8000_PERCENT" => {
                    Some(Self::CreativeLoadTimeGt8000Percent)
                }
                "CTR" => Some(Self::Ctr),
                "DEALS_BIDS" => Some(Self::DealsBids),
                "DEALS_BID_RATE" => Some(Self::DealsBidRate),
                "DEALS_BID_REQUESTS" => Some(Self::DealsBidRequests),
                "DEALS_WINNING_BIDS" => Some(Self::DealsWinningBids),
                "DEALS_WIN_RATE" => Some(Self::DealsWinRate),
                "DOM_LOAD_TO_FIRST_AD_REQUEST_0_500_PERCENT" => {
                    Some(Self::DomLoadToFirstAdRequest0500Percent)
                }
                "DOM_LOAD_TO_FIRST_AD_REQUEST_1000_2000_PERCENT" => {
                    Some(Self::DomLoadToFirstAdRequest10002000Percent)
                }
                "DOM_LOAD_TO_FIRST_AD_REQUEST_2000_4000_PERCENT" => {
                    Some(Self::DomLoadToFirstAdRequest20004000Percent)
                }
                "DOM_LOAD_TO_FIRST_AD_REQUEST_4000_8000_PERCENT" => {
                    Some(Self::DomLoadToFirstAdRequest40008000Percent)
                }
                "DOM_LOAD_TO_FIRST_AD_REQUEST_500_1000_PERCENT" => {
                    Some(Self::DomLoadToFirstAdRequest5001000Percent)
                }
                "DOM_LOAD_TO_FIRST_AD_REQUEST_GT_8000_PERCENT" => {
                    Some(Self::DomLoadToFirstAdRequestGt8000Percent)
                }
                "DOM_LOAD_TO_TAG_LOAD_TIME_0_500_PERCENT" => {
                    Some(Self::DomLoadToTagLoadTime0500Percent)
                }
                "DOM_LOAD_TO_TAG_LOAD_TIME_1000_2000_PERCENT" => {
                    Some(Self::DomLoadToTagLoadTime10002000Percent)
                }
                "DOM_LOAD_TO_TAG_LOAD_TIME_2000_4000_PERCENT" => {
                    Some(Self::DomLoadToTagLoadTime20004000Percent)
                }
                "DOM_LOAD_TO_TAG_LOAD_TIME_4000_8000_PERCENT" => {
                    Some(Self::DomLoadToTagLoadTime40008000Percent)
                }
                "DOM_LOAD_TO_TAG_LOAD_TIME_500_1000_PERCENT" => {
                    Some(Self::DomLoadToTagLoadTime5001000Percent)
                }
                "DOM_LOAD_TO_TAG_LOAD_TIME_GT_8000_PERCENT" => {
                    Some(Self::DomLoadToTagLoadTimeGt8000Percent)
                }
                "DROPOFF_RATE" => Some(Self::DropoffRate),
                "ENGAGED_SESSIONS" => Some(Self::EngagedSessions),
                "ENGAGED_SESSIONS_PER_USER" => Some(Self::EngagedSessionsPerUser),
                "ENGAGEMENT_RATE" => Some(Self::EngagementRate),
                "EUROPEAN_REGULATIONS_CONSENT_RATE" => {
                    Some(Self::EuropeanRegulationsConsentRate)
                }
                "EUROPEAN_REGULATIONS_CUSTOM_CONSENT_RATE" => {
                    Some(Self::EuropeanRegulationsCustomConsentRate)
                }
                "EUROPEAN_REGULATIONS_MESSAGES_SHOWN" => {
                    Some(Self::EuropeanRegulationsMessagesShown)
                }
                "EUROPEAN_REGULATIONS_NO_CONSENT_RATE" => {
                    Some(Self::EuropeanRegulationsNoConsentRate)
                }
                "FILL_RATE" => Some(Self::FillRate),
                "GOOGLE_ANALYTICS_CLICKS" => Some(Self::GoogleAnalyticsClicks),
                "GOOGLE_ANALYTICS_CTR" => Some(Self::GoogleAnalyticsCtr),
                "GOOGLE_ANALYTICS_ECPM" => Some(Self::GoogleAnalyticsEcpm),
                "GOOGLE_ANALYTICS_IMPRESSIONS" => Some(Self::GoogleAnalyticsImpressions),
                "GOOGLE_ANALYTICS_REVENUE" => Some(Self::GoogleAnalyticsRevenue),
                "GOOGLE_ANALYTICS_VIEWS" => Some(Self::GoogleAnalyticsViews),
                "GOOGLE_ANALYTICS_VIEWS_PER_USER" => {
                    Some(Self::GoogleAnalyticsViewsPerUser)
                }
                "GOOGLE_SOLD_AUCTION_COVIEWED_IMPRESSIONS" => {
                    Some(Self::GoogleSoldAuctionCoviewedImpressions)
                }
                "GOOGLE_SOLD_AUCTION_IMPRESSIONS" => {
                    Some(Self::GoogleSoldAuctionImpressions)
                }
                "GOOGLE_SOLD_COVIEWED_IMPRESSIONS" => {
                    Some(Self::GoogleSoldCoviewedImpressions)
                }
                "GOOGLE_SOLD_IMPRESSIONS" => Some(Self::GoogleSoldImpressions),
                "GOOGLE_SOLD_RESERVATION_COVIEWED_IMPRESSIONS" => {
                    Some(Self::GoogleSoldReservationCoviewedImpressions)
                }
                "GOOGLE_SOLD_RESERVATION_IMPRESSIONS" => {
                    Some(Self::GoogleSoldReservationImpressions)
                }
                "IMPRESSIONS" => Some(Self::Impressions),
                "INACTIVE_BEGIN_TO_RENDER_IMPRESSIONS" => {
                    Some(Self::InactiveBeginToRenderImpressions)
                }
                "INVENTORY_SHARES" => Some(Self::InventoryShares),
                "INVENTORY_SHARE_PARTNER_UNFILLED_OPPORTUNITIES" => {
                    Some(Self::InventorySharePartnerUnfilledOpportunities)
                }
                "INVOICED_IMPRESSIONS" => Some(Self::InvoicedImpressions),
                "INVOICED_UNFILLED_IMPRESSIONS" => {
                    Some(Self::InvoicedUnfilledImpressions)
                }
                "MEDIATION_CHAINS_FILLED" => Some(Self::MediationChainsFilled),
                "MUTED_IMPRESSIONS" => Some(Self::MutedImpressions),
                "MUTE_ELIGIBLE_IMPRESSIONS" => Some(Self::MuteEligibleImpressions),
                "OPPORTUNITIES" => Some(Self::Opportunities),
                "OVERDELIVERED_IMPRESSIONS" => Some(Self::OverdeliveredImpressions),
                "PARTNER_FINANCE_GROSS_REVENUE" => Some(Self::PartnerFinanceGrossRevenue),
                "PARTNER_FINANCE_HOST_ECPM" => Some(Self::PartnerFinanceHostEcpm),
                "PARTNER_FINANCE_HOST_IMPRESSIONS" => {
                    Some(Self::PartnerFinanceHostImpressions)
                }
                "PARTNER_FINANCE_HOST_REVENUE" => Some(Self::PartnerFinanceHostRevenue),
                "PARTNER_FINANCE_PARTNER_ECPM" => Some(Self::PartnerFinancePartnerEcpm),
                "PARTNER_FINANCE_PARTNER_REVENUE" => {
                    Some(Self::PartnerFinancePartnerRevenue)
                }
                "PARTNER_MANAGEMENT_GROSS_REVENUE" => {
                    Some(Self::PartnerManagementGrossRevenue)
                }
                "PARTNER_MANAGEMENT_HOST_CLICKS" => {
                    Some(Self::PartnerManagementHostClicks)
                }
                "PARTNER_MANAGEMENT_HOST_CTR" => Some(Self::PartnerManagementHostCtr),
                "PARTNER_MANAGEMENT_HOST_IMPRESSIONS" => {
                    Some(Self::PartnerManagementHostImpressions)
                }
                "PARTNER_MANAGEMENT_PARTNER_CLICKS" => {
                    Some(Self::PartnerManagementPartnerClicks)
                }
                "PARTNER_MANAGEMENT_PARTNER_CTR" => {
                    Some(Self::PartnerManagementPartnerCtr)
                }
                "PARTNER_MANAGEMENT_PARTNER_IMPRESSIONS" => {
                    Some(Self::PartnerManagementPartnerImpressions)
                }
                "PARTNER_MANAGEMENT_TOTAL_CONTENT_VIEWS" => {
                    Some(Self::PartnerManagementTotalContentViews)
                }
                "PARTNER_MANAGEMENT_UNFILLED_IMPRESSIONS" => {
                    Some(Self::PartnerManagementUnfilledImpressions)
                }
                "PARTNER_SALES_FILLED_POD_REQUESTS" => {
                    Some(Self::PartnerSalesFilledPodRequests)
                }
                "PARTNER_SALES_FILL_RATE" => Some(Self::PartnerSalesFillRate),
                "PARTNER_SALES_PARTNER_MATCH_RATE" => {
                    Some(Self::PartnerSalesPartnerMatchRate)
                }
                "PARTNER_SALES_QUERIES" => Some(Self::PartnerSalesQueries),
                "PARTNER_SALES_UNFILLED_IMPRESSIONS" => {
                    Some(Self::PartnerSalesUnfilledImpressions)
                }
                "PARTNER_SALES_UNMATCHED_QUERIES" => {
                    Some(Self::PartnerSalesUnmatchedQueries)
                }
                "PARTNER_SOLD_CODE_SERVED" => Some(Self::PartnerSoldCodeServed),
                "PARTNER_SOLD_COVIEWED_IMPRESSIONS" => {
                    Some(Self::PartnerSoldCoviewedImpressions)
                }
                "PARTNER_SOLD_IMPRESSIONS" => Some(Self::PartnerSoldImpressions),
                "PROGRAMMATIC_ELIGIBLE_AD_REQUESTS" => {
                    Some(Self::ProgrammaticEligibleAdRequests)
                }
                "PROGRAMMATIC_MATCH_RATE" => Some(Self::ProgrammaticMatchRate),
                "PROGRAMMATIC_RESPONSES_SERVED" => {
                    Some(Self::ProgrammaticResponsesServed)
                }
                "REACH_IMPRESSIONS" => Some(Self::ReachImpressions),
                "RESPONSES_SERVED" => Some(Self::ResponsesServed),
                "RETENTION" => Some(Self::Retention),
                "REVENUE" => Some(Self::Revenue),
                "REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT" => {
                    Some(Self::RevenuePaidThroughMcmAutopayment)
                }
                "REVENUE_VERIFICATION_CPD_REVENUE" => {
                    Some(Self::RevenueVerificationCpdRevenue)
                }
                "REVENUE_VERIFICATION_GROSS_CPD_REVENUE" => {
                    Some(Self::RevenueVerificationGrossCpdRevenue)
                }
                "REVENUE_VERIFICATION_GROSS_REVENUE_WITHOUT_CPD" => {
                    Some(Self::RevenueVerificationGrossRevenueWithoutCpd)
                }
                "REVENUE_VERIFICATION_IMPRESSIONS" => {
                    Some(Self::RevenueVerificationImpressions)
                }
                "REVENUE_VERIFICATION_REVENUE_WITHOUT_CPD" => {
                    Some(Self::RevenueVerificationRevenueWithoutCpd)
                }
                "REVENUE_WITHOUT_CPD" => Some(Self::RevenueWithoutCpd),
                "REWARDS_GRANTED" => Some(Self::RewardsGranted),
                "RICH_MEDIA_AVERAGE_DISPLAY_TIME" => {
                    Some(Self::RichMediaAverageDisplayTime)
                }
                "RICH_MEDIA_AVERAGE_INTERACTION_TIME" => {
                    Some(Self::RichMediaAverageInteractionTime)
                }
                "RICH_MEDIA_BACKUP_IMAGES" => Some(Self::RichMediaBackupImages),
                "RICH_MEDIA_CUSTOM_EVENT_COUNT" => Some(Self::RichMediaCustomEventCount),
                "RICH_MEDIA_CUSTOM_EVENT_TIME" => Some(Self::RichMediaCustomEventTime),
                "RICH_MEDIA_DISPLAY_TIME" => Some(Self::RichMediaDisplayTime),
                "RICH_MEDIA_EXPANDING_TIME" => Some(Self::RichMediaExpandingTime),
                "RICH_MEDIA_EXPANSIONS" => Some(Self::RichMediaExpansions),
                "RICH_MEDIA_FULL_SCREEN_IMPRESSIONS" => {
                    Some(Self::RichMediaFullScreenImpressions)
                }
                "RICH_MEDIA_INTERACTION_COUNT" => Some(Self::RichMediaInteractionCount),
                "RICH_MEDIA_INTERACTION_RATE" => Some(Self::RichMediaInteractionRate),
                "RICH_MEDIA_INTERACTION_TIME" => Some(Self::RichMediaInteractionTime),
                "RICH_MEDIA_INTERACTIVE_IMPRESSIONS" => {
                    Some(Self::RichMediaInteractiveImpressions)
                }
                "RICH_MEDIA_MANUAL_CLOSES" => Some(Self::RichMediaManualCloses),
                "RICH_MEDIA_VIDEO_COMPLETES" => Some(Self::RichMediaVideoCompletes),
                "RICH_MEDIA_VIDEO_INTERACTIONS" => Some(Self::RichMediaVideoInteractions),
                "RICH_MEDIA_VIDEO_INTERACTION_RATE" => {
                    Some(Self::RichMediaVideoInteractionRate)
                }
                "RICH_MEDIA_VIDEO_MIDPOINTS" => Some(Self::RichMediaVideoMidpoints),
                "RICH_MEDIA_VIDEO_MUTES" => Some(Self::RichMediaVideoMutes),
                "RICH_MEDIA_VIDEO_PAUSES" => Some(Self::RichMediaVideoPauses),
                "RICH_MEDIA_VIDEO_PLAYS" => Some(Self::RichMediaVideoPlays),
                "RICH_MEDIA_VIDEO_REPLAYS" => Some(Self::RichMediaVideoReplays),
                "RICH_MEDIA_VIDEO_STOPS" => Some(Self::RichMediaVideoStops),
                "RICH_MEDIA_VIDEO_UNMUTES" => Some(Self::RichMediaVideoUnmutes),
                "RICH_MEDIA_VIDEO_VIEW_RATE" => Some(Self::RichMediaVideoViewRate),
                "RICH_MEDIA_VIDEO_VIEW_TIME" => Some(Self::RichMediaVideoViewTime),
                "SELL_THROUGH_AVAILABLE_IMPRESSIONS" => {
                    Some(Self::SellThroughAvailableImpressions)
                }
                "SELL_THROUGH_FORECASTED_IMPRESSIONS" => {
                    Some(Self::SellThroughForecastedImpressions)
                }
                "SELL_THROUGH_RESERVED_IMPRESSIONS" => {
                    Some(Self::SellThroughReservedImpressions)
                }
                "SELL_THROUGH_SELL_THROUGH_RATE" => {
                    Some(Self::SellThroughSellThroughRate)
                }
                "SERVER_SIDE_UNWRAPPING_AVERAGE_LATENCY_MS" => {
                    Some(Self::ServerSideUnwrappingAverageLatencyMs)
                }
                "SERVER_SIDE_UNWRAPPING_CALLOUTS" => {
                    Some(Self::ServerSideUnwrappingCallouts)
                }
                "SERVER_SIDE_UNWRAPPING_EMPTY_RESPONSES" => {
                    Some(Self::ServerSideUnwrappingEmptyResponses)
                }
                "SERVER_SIDE_UNWRAPPING_ERROR_RESPONSES" => {
                    Some(Self::ServerSideUnwrappingErrorResponses)
                }
                "SERVER_SIDE_UNWRAPPING_SUCCESSFUL_RESPONSES" => {
                    Some(Self::ServerSideUnwrappingSuccessfulResponses)
                }
                "SERVER_SIDE_UNWRAPPING_TIMEOUTS" => {
                    Some(Self::ServerSideUnwrappingTimeouts)
                }
                "SESSIONS" => Some(Self::Sessions),
                "TAG_LOAD_TO_FIRST_AD_REQUEST_0_500_PERCENT" => {
                    Some(Self::TagLoadToFirstAdRequest0500Percent)
                }
                "TAG_LOAD_TO_FIRST_AD_REQUEST_1000_2000_PERCENT" => {
                    Some(Self::TagLoadToFirstAdRequest10002000Percent)
                }
                "TAG_LOAD_TO_FIRST_AD_REQUEST_2000_4000_PERCENT" => {
                    Some(Self::TagLoadToFirstAdRequest20004000Percent)
                }
                "TAG_LOAD_TO_FIRST_AD_REQUEST_4000_8000_PERCENT" => {
                    Some(Self::TagLoadToFirstAdRequest40008000Percent)
                }
                "TAG_LOAD_TO_FIRST_AD_REQUEST_500_1000_PERCENT" => {
                    Some(Self::TagLoadToFirstAdRequest5001000Percent)
                }
                "TAG_LOAD_TO_FIRST_AD_REQUEST_GT_8000_PERCENT" => {
                    Some(Self::TagLoadToFirstAdRequestGt8000Percent)
                }
                "TARGETED_CLICKS" => Some(Self::TargetedClicks),
                "TARGETED_IMPRESSIONS" => Some(Self::TargetedImpressions),
                "UNFILLED_IMPRESSIONS" => Some(Self::UnfilledImpressions),
                "UNIQUE_VISITORS" => Some(Self::UniqueVisitors),
                "UNLOADED_IMPRESSIONS_DUE_TO_CPU" => {
                    Some(Self::UnloadedImpressionsDueToCpu)
                }
                "UNLOADED_IMPRESSIONS_DUE_TO_NETWORK" => {
                    Some(Self::UnloadedImpressionsDueToNetwork)
                }
                "UNMATCHED_AD_REQUESTS" => Some(Self::UnmatchedAdRequests),
                "UNVIEWED_REASON_OTHER_PERCENT" => Some(Self::UnviewedReasonOtherPercent),
                "UNVIEWED_REASON_SLOT_NEVER_ENTERED_VIEWPORT_PERCENT" => {
                    Some(Self::UnviewedReasonSlotNeverEnteredViewportPercent)
                }
                "UNVIEWED_REASON_USER_SCROLLED_BEFORE_AD_FILLED_PERCENT" => {
                    Some(Self::UnviewedReasonUserScrolledBeforeAdFilledPercent)
                }
                "UNVIEWED_REASON_USER_SCROLLED_BEFORE_AD_LOADED_PERCENT" => {
                    Some(Self::UnviewedReasonUserScrolledBeforeAdLoadedPercent)
                }
                "UNVIEWED_REASON_USER_SCROLLED_BEFORE_ONE_SECOND_PERCENT" => {
                    Some(Self::UnviewedReasonUserScrolledBeforeOneSecondPercent)
                }
                "USER_ENGAGEMENT_DURATION_IN_SECONDS" => {
                    Some(Self::UserEngagementDurationInSeconds)
                }
                "USER_MESSAGES_AD_BLOCKING_EXTENSION_RATE" => {
                    Some(Self::UserMessagesAdBlockingExtensionRate)
                }
                "USER_MESSAGES_AD_BLOCKING_RECOVERY_ALLOWLISTED_COUNT" => {
                    Some(Self::UserMessagesAdBlockingRecoveryAllowlistedCount)
                }
                "USER_MESSAGES_AD_BLOCKING_RECOVERY_MESSAGES_SHOWN" => {
                    Some(Self::UserMessagesAdBlockingRecoveryMessagesShown)
                }
                "USER_MESSAGES_ALLOW_ADS_PAGEVIEWS" => {
                    Some(Self::UserMessagesAllowAdsPageviews)
                }
                "USER_MESSAGES_IDFA_ATT_ALERTS_SHOWN" => {
                    Some(Self::UserMessagesIdfaAttAlertsShown)
                }
                "USER_MESSAGES_IDFA_ATT_CONSENT" => {
                    Some(Self::UserMessagesIdfaAttConsent)
                }
                "USER_MESSAGES_IDFA_ATT_CONSENT_RATE" => {
                    Some(Self::UserMessagesIdfaAttConsentRate)
                }
                "USER_MESSAGES_IDFA_ATT_DECLINE_CONSENT" => {
                    Some(Self::UserMessagesIdfaAttDeclineConsent)
                }
                "USER_MESSAGES_IDFA_ATT_DECLINE_RATE" => {
                    Some(Self::UserMessagesIdfaAttDeclineRate)
                }
                "USER_MESSAGES_IDFA_EXPLAINERS_SHOWN" => {
                    Some(Self::UserMessagesIdfaExplainersShown)
                }
                "USER_MESSAGES_IDFA_IAB_MESSAGES_SHOWN" => {
                    Some(Self::UserMessagesIdfaIabMessagesShown)
                }
                "USER_MESSAGES_IDFA_NO_DECISION" => {
                    Some(Self::UserMessagesIdfaNoDecision)
                }
                "USER_MESSAGES_OFFERWALL_MESSAGES_SHOWN" => {
                    Some(Self::UserMessagesOfferwallMessagesShown)
                }
                "USER_MESSAGES_OFFERWALL_SUCCESSFUL_ENGAGEMENTS" => {
                    Some(Self::UserMessagesOfferwallSuccessfulEngagements)
                }
                "USER_MESSAGES_POST_OFFERWALL_PAGEVIEWS" => {
                    Some(Self::UserMessagesPostOfferwallPageviews)
                }
                "USER_MESSAGES_TOTAL_ESTIMATED_REVENUE" => {
                    Some(Self::UserMessagesTotalEstimatedRevenue)
                }
                "USER_MESSAGES_UPTC_MESSAGES_SHOWN" => {
                    Some(Self::UserMessagesUptcMessagesShown)
                }
                "USER_MESSAGES_UPTC_PERSONALIZATION_OPT_OUT_RATIO" => {
                    Some(Self::UserMessagesUptcPersonalizationOptOutRatio)
                }
                "USER_MESSAGES_US_STATES_MESSAGES_SHOWN" => {
                    Some(Self::UserMessagesUsStatesMessagesShown)
                }
                "USER_MESSAGES_US_STATES_OPT_OUT_SELECTIONS" => {
                    Some(Self::UserMessagesUsStatesOptOutSelections)
                }
                "VIDEO_ERROR_100_COUNT" => Some(Self::VideoError100Count),
                "VIDEO_ERROR_101_COUNT" => Some(Self::VideoError101Count),
                "VIDEO_ERROR_102_COUNT" => Some(Self::VideoError102Count),
                "VIDEO_ERROR_200_COUNT" => Some(Self::VideoError200Count),
                "VIDEO_ERROR_201_COUNT" => Some(Self::VideoError201Count),
                "VIDEO_ERROR_202_COUNT" => Some(Self::VideoError202Count),
                "VIDEO_ERROR_203_COUNT" => Some(Self::VideoError203Count),
                "VIDEO_ERROR_300_COUNT" => Some(Self::VideoError300Count),
                "VIDEO_ERROR_301_COUNT" => Some(Self::VideoError301Count),
                "VIDEO_ERROR_302_COUNT" => Some(Self::VideoError302Count),
                "VIDEO_ERROR_303_COUNT" => Some(Self::VideoError303Count),
                "VIDEO_ERROR_400_COUNT" => Some(Self::VideoError400Count),
                "VIDEO_ERROR_401_COUNT" => Some(Self::VideoError401Count),
                "VIDEO_ERROR_402_COUNT" => Some(Self::VideoError402Count),
                "VIDEO_ERROR_403_COUNT" => Some(Self::VideoError403Count),
                "VIDEO_ERROR_405_COUNT" => Some(Self::VideoError405Count),
                "VIDEO_ERROR_406_COUNT" => Some(Self::VideoError406Count),
                "VIDEO_ERROR_407_COUNT" => Some(Self::VideoError407Count),
                "VIDEO_ERROR_408_COUNT" => Some(Self::VideoError408Count),
                "VIDEO_ERROR_409_COUNT" => Some(Self::VideoError409Count),
                "VIDEO_ERROR_410_COUNT" => Some(Self::VideoError410Count),
                "VIDEO_ERROR_500_COUNT" => Some(Self::VideoError500Count),
                "VIDEO_ERROR_501_COUNT" => Some(Self::VideoError501Count),
                "VIDEO_ERROR_502_COUNT" => Some(Self::VideoError502Count),
                "VIDEO_ERROR_503_COUNT" => Some(Self::VideoError503Count),
                "VIDEO_ERROR_600_COUNT" => Some(Self::VideoError600Count),
                "VIDEO_ERROR_601_COUNT" => Some(Self::VideoError601Count),
                "VIDEO_ERROR_602_COUNT" => Some(Self::VideoError602Count),
                "VIDEO_ERROR_603_COUNT" => Some(Self::VideoError603Count),
                "VIDEO_ERROR_604_COUNT" => Some(Self::VideoError604Count),
                "VIDEO_ERROR_900_COUNT" => Some(Self::VideoError900Count),
                "VIDEO_ERROR_901_COUNT" => Some(Self::VideoError901Count),
                "VIDEO_INTERACTION_AVERAGE_INTERACTION_RATE" => {
                    Some(Self::VideoInteractionAverageInteractionRate)
                }
                "VIDEO_INTERACTION_COLLAPSES" => Some(Self::VideoInteractionCollapses),
                "VIDEO_INTERACTION_EXPANDS" => Some(Self::VideoInteractionExpands),
                "VIDEO_INTERACTION_FULL_SCREENS" => {
                    Some(Self::VideoInteractionFullScreens)
                }
                "VIDEO_INTERACTION_MUTES" => Some(Self::VideoInteractionMutes),
                "VIDEO_INTERACTION_PAUSES" => Some(Self::VideoInteractionPauses),
                "VIDEO_INTERACTION_RESUMES" => Some(Self::VideoInteractionResumes),
                "VIDEO_INTERACTION_REWINDS" => Some(Self::VideoInteractionRewinds),
                "VIDEO_INTERACTION_UNMUTES" => Some(Self::VideoInteractionUnmutes),
                "VIDEO_INTERACTION_VIDEO_SKIPS" => Some(Self::VideoInteractionVideoSkips),
                "VIDEO_MONETIZABLE_CONTENT_VIEWS" => {
                    Some(Self::VideoMonetizableContentViews)
                }
                "VIDEO_REAL_TIME_CREATIVE_SERVES" => {
                    Some(Self::VideoRealTimeCreativeServes)
                }
                "VIDEO_REAL_TIME_ERROR_100_COUNT" => {
                    Some(Self::VideoRealTimeError100Count)
                }
                "VIDEO_REAL_TIME_ERROR_101_COUNT" => {
                    Some(Self::VideoRealTimeError101Count)
                }
                "VIDEO_REAL_TIME_ERROR_102_COUNT" => {
                    Some(Self::VideoRealTimeError102Count)
                }
                "VIDEO_REAL_TIME_ERROR_200_COUNT" => {
                    Some(Self::VideoRealTimeError200Count)
                }
                "VIDEO_REAL_TIME_ERROR_201_COUNT" => {
                    Some(Self::VideoRealTimeError201Count)
                }
                "VIDEO_REAL_TIME_ERROR_202_COUNT" => {
                    Some(Self::VideoRealTimeError202Count)
                }
                "VIDEO_REAL_TIME_ERROR_203_COUNT" => {
                    Some(Self::VideoRealTimeError203Count)
                }
                "VIDEO_REAL_TIME_ERROR_300_COUNT" => {
                    Some(Self::VideoRealTimeError300Count)
                }
                "VIDEO_REAL_TIME_ERROR_301_COUNT" => {
                    Some(Self::VideoRealTimeError301Count)
                }
                "VIDEO_REAL_TIME_ERROR_302_COUNT" => {
                    Some(Self::VideoRealTimeError302Count)
                }
                "VIDEO_REAL_TIME_ERROR_303_COUNT" => {
                    Some(Self::VideoRealTimeError303Count)
                }
                "VIDEO_REAL_TIME_ERROR_400_COUNT" => {
                    Some(Self::VideoRealTimeError400Count)
                }
                "VIDEO_REAL_TIME_ERROR_401_COUNT" => {
                    Some(Self::VideoRealTimeError401Count)
                }
                "VIDEO_REAL_TIME_ERROR_402_COUNT" => {
                    Some(Self::VideoRealTimeError402Count)
                }
                "VIDEO_REAL_TIME_ERROR_403_COUNT" => {
                    Some(Self::VideoRealTimeError403Count)
                }
                "VIDEO_REAL_TIME_ERROR_405_COUNT" => {
                    Some(Self::VideoRealTimeError405Count)
                }
                "VIDEO_REAL_TIME_ERROR_406_COUNT" => {
                    Some(Self::VideoRealTimeError406Count)
                }
                "VIDEO_REAL_TIME_ERROR_407_COUNT" => {
                    Some(Self::VideoRealTimeError407Count)
                }
                "VIDEO_REAL_TIME_ERROR_408_COUNT" => {
                    Some(Self::VideoRealTimeError408Count)
                }
                "VIDEO_REAL_TIME_ERROR_409_COUNT" => {
                    Some(Self::VideoRealTimeError409Count)
                }
                "VIDEO_REAL_TIME_ERROR_410_COUNT" => {
                    Some(Self::VideoRealTimeError410Count)
                }
                "VIDEO_REAL_TIME_ERROR_500_COUNT" => {
                    Some(Self::VideoRealTimeError500Count)
                }
                "VIDEO_REAL_TIME_ERROR_501_COUNT" => {
                    Some(Self::VideoRealTimeError501Count)
                }
                "VIDEO_REAL_TIME_ERROR_502_COUNT" => {
                    Some(Self::VideoRealTimeError502Count)
                }
                "VIDEO_REAL_TIME_ERROR_503_COUNT" => {
                    Some(Self::VideoRealTimeError503Count)
                }
                "VIDEO_REAL_TIME_ERROR_600_COUNT" => {
                    Some(Self::VideoRealTimeError600Count)
                }
                "VIDEO_REAL_TIME_ERROR_601_COUNT" => {
                    Some(Self::VideoRealTimeError601Count)
                }
                "VIDEO_REAL_TIME_ERROR_602_COUNT" => {
                    Some(Self::VideoRealTimeError602Count)
                }
                "VIDEO_REAL_TIME_ERROR_603_COUNT" => {
                    Some(Self::VideoRealTimeError603Count)
                }
                "VIDEO_REAL_TIME_ERROR_604_COUNT" => {
                    Some(Self::VideoRealTimeError604Count)
                }
                "VIDEO_REAL_TIME_ERROR_900_COUNT" => {
                    Some(Self::VideoRealTimeError900Count)
                }
                "VIDEO_REAL_TIME_ERROR_901_COUNT" => {
                    Some(Self::VideoRealTimeError901Count)
                }
                "VIDEO_REAL_TIME_IMPRESSIONS" => Some(Self::VideoRealTimeImpressions),
                "VIDEO_REAL_TIME_MATCHED_QUERIES" => {
                    Some(Self::VideoRealTimeMatchedQueries)
                }
                "VIDEO_REAL_TIME_TOTAL_ERROR_COUNT" => {
                    Some(Self::VideoRealTimeTotalErrorCount)
                }
                "VIDEO_REAL_TIME_TOTAL_QUERIES" => Some(Self::VideoRealTimeTotalQueries),
                "VIDEO_REAL_TIME_UNMATCHED_QUERIES" => {
                    Some(Self::VideoRealTimeUnmatchedQueries)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_BREAK_END" => {
                    Some(Self::VideoTrueOpportunitiesTotalBreakEnd)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_BREAK_START" => {
                    Some(Self::VideoTrueOpportunitiesTotalBreakStart)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_CAPPED_OPPORTUNITIES_ADBREAK" => {
                    Some(Self::VideoTrueOpportunitiesTotalCappedOpportunitiesAdbreak)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_DURATION_ADBREAK" => {
                    Some(Self::VideoTrueOpportunitiesTotalDurationAdbreak)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_MATCHED_DURATION_ADBREAK" => {
                    Some(Self::VideoTrueOpportunitiesTotalMatchedDurationAdbreak)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_MATCHED_OPPORTUNITIES_ADBREAK" => {
                    Some(Self::VideoTrueOpportunitiesTotalMatchedOpportunitiesAdbreak)
                }
                "VIDEO_TRUE_OPPORTUNITIES_TOTAL_VIEWED_OPPORTUNITIES_ADBREAK" => {
                    Some(Self::VideoTrueOpportunitiesTotalViewedOpportunitiesAdbreak)
                }
                "VIDEO_TRUE_VIEWS" => Some(Self::VideoTrueViews),
                "VIDEO_TRUE_VIEW_SKIP_RATE" => Some(Self::VideoTrueViewSkipRate),
                "VIDEO_TRUE_VIEW_VIEW_THROUGH_RATE" => {
                    Some(Self::VideoTrueViewViewThroughRate)
                }
                "VIDEO_VIEWERSHIP_AUTO_PLAYS" => Some(Self::VideoViewershipAutoPlays),
                "VIDEO_VIEWERSHIP_AVERAGE_VIEW_RATE" => {
                    Some(Self::VideoViewershipAverageViewRate)
                }
                "VIDEO_VIEWERSHIP_AVERAGE_VIEW_TIME" => {
                    Some(Self::VideoViewershipAverageViewTime)
                }
                "VIDEO_VIEWERSHIP_CLICK_TO_PLAYS" => {
                    Some(Self::VideoViewershipClickToPlays)
                }
                "VIDEO_VIEWERSHIP_COMPLETES" => Some(Self::VideoViewershipCompletes),
                "VIDEO_VIEWERSHIP_COMPLETION_RATE" => {
                    Some(Self::VideoViewershipCompletionRate)
                }
                "VIDEO_VIEWERSHIP_ENGAGED_VIEWS" => {
                    Some(Self::VideoViewershipEngagedViews)
                }
                "VIDEO_VIEWERSHIP_FIRST_QUARTILES" => {
                    Some(Self::VideoViewershipFirstQuartiles)
                }
                "VIDEO_VIEWERSHIP_MIDPOINTS" => Some(Self::VideoViewershipMidpoints),
                "VIDEO_VIEWERSHIP_SKIP_BUTTONS_SHOWN" => {
                    Some(Self::VideoViewershipSkipButtonsShown)
                }
                "VIDEO_VIEWERSHIP_STARTS" => Some(Self::VideoViewershipStarts),
                "VIDEO_VIEWERSHIP_THIRD_QUARTILES" => {
                    Some(Self::VideoViewershipThirdQuartiles)
                }
                "VIDEO_VIEWERSHIP_TOTAL_ERROR_COUNT" => {
                    Some(Self::VideoViewershipTotalErrorCount)
                }
                "VIDEO_VIEWERSHIP_TOTAL_ERROR_RATE" => {
                    Some(Self::VideoViewershipTotalErrorRate)
                }
                "VIDEO_VIEWERSHIP_VIDEO_LENGTH" => Some(Self::VideoViewershipVideoLength),
                "VIDEO_VIEWERSHIP_VIEW_THROUGH_RATE" => {
                    Some(Self::VideoViewershipViewThroughRate)
                }
                "YIELD_GROUP_AUCTIONS_WON" => Some(Self::YieldGroupAuctionsWon),
                "YIELD_GROUP_BIDS" => Some(Self::YieldGroupBids),
                "YIELD_GROUP_BIDS_IN_AUCTION" => Some(Self::YieldGroupBidsInAuction),
                "YIELD_GROUP_CALLOUTS" => Some(Self::YieldGroupCallouts),
                "YIELD_GROUP_ESTIMATED_CPM" => Some(Self::YieldGroupEstimatedCpm),
                "YIELD_GROUP_ESTIMATED_REVENUE" => Some(Self::YieldGroupEstimatedRevenue),
                "YIELD_GROUP_IMPRESSIONS" => Some(Self::YieldGroupImpressions),
                "YIELD_GROUP_MEDIATION_FILL_RATE" => {
                    Some(Self::YieldGroupMediationFillRate)
                }
                "YIELD_GROUP_MEDIATION_MATCHED_QUERIES" => {
                    Some(Self::YieldGroupMediationMatchedQueries)
                }
                "YIELD_GROUP_MEDIATION_PASSBACKS" => {
                    Some(Self::YieldGroupMediationPassbacks)
                }
                "YIELD_GROUP_MEDIATION_THIRD_PARTY_ECPM" => {
                    Some(Self::YieldGroupMediationThirdPartyEcpm)
                }
                "YIELD_GROUP_REVENUE_PAID_THROUGH_MCM_AUTOPAYMENT" => {
                    Some(Self::YieldGroupRevenuePaidThroughMcmAutopayment)
                }
                "YIELD_GROUP_SUCCESSFUL_RESPONSES" => {
                    Some(Self::YieldGroupSuccessfulResponses)
                }
                _ => None,
            }
        }
    }
    /// Valid time period columns.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimePeriodColumn {
        /// Default value. Report will have no time period column.
        Unspecified = 0,
        /// A column for each date in the report.
        Date = 1,
        /// A column for each week in the report.
        Week = 2,
        /// A column for each month in the report.
        Month = 3,
        /// A column for each quarter in the report.
        Quarter = 4,
    }
    impl TimePeriodColumn {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_PERIOD_COLUMN_UNSPECIFIED",
                Self::Date => "TIME_PERIOD_COLUMN_DATE",
                Self::Week => "TIME_PERIOD_COLUMN_WEEK",
                Self::Month => "TIME_PERIOD_COLUMN_MONTH",
                Self::Quarter => "TIME_PERIOD_COLUMN_QUARTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_PERIOD_COLUMN_UNSPECIFIED" => Some(Self::Unspecified),
                "TIME_PERIOD_COLUMN_DATE" => Some(Self::Date),
                "TIME_PERIOD_COLUMN_WEEK" => Some(Self::Week),
                "TIME_PERIOD_COLUMN_MONTH" => Some(Self::Month),
                "TIME_PERIOD_COLUMN_QUARTER" => Some(Self::Quarter),
                _ => None,
            }
        }
    }
    /// Possible metric value types to add.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricValueType {
        /// The values for the primary date_range.
        Primary = 0,
        /// Each metrics' percent of the total for the primary date_range.
        PrimaryPercentOfTotal = 1,
        /// The values for the comparison_date_range.
        Comparison = 2,
        /// Each metrics' percent of the total for the comparison_date_range.
        ComparisonPercentOfTotal = 3,
        /// The absolute change between the primary and comparison date ranges.
        AbsoluteChange = 4,
        /// The relative change between the primary and comparison date ranges.
        RelativeChange = 5,
    }
    impl MetricValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Primary => "PRIMARY",
                Self::PrimaryPercentOfTotal => "PRIMARY_PERCENT_OF_TOTAL",
                Self::Comparison => "COMPARISON",
                Self::ComparisonPercentOfTotal => "COMPARISON_PERCENT_OF_TOTAL",
                Self::AbsoluteChange => "ABSOLUTE_CHANGE",
                Self::RelativeChange => "RELATIVE_CHANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIMARY" => Some(Self::Primary),
                "PRIMARY_PERCENT_OF_TOTAL" => Some(Self::PrimaryPercentOfTotal),
                "COMPARISON" => Some(Self::Comparison),
                "COMPARISON_PERCENT_OF_TOTAL" => Some(Self::ComparisonPercentOfTotal),
                "ABSOLUTE_CHANGE" => Some(Self::AbsoluteChange),
                "RELATIVE_CHANGE" => Some(Self::RelativeChange),
                _ => None,
            }
        }
    }
    /// The source to determine the time zone for the report.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeZoneSource {
        /// Unspecified default value.
        Unspecified = 0,
        /// Use the publisher's time zone in network settings.
        Publisher = 1,
        /// Use the time zone of the ad exchange.
        /// Only compatible with Ad Exchange dimensions and metrics.
        AdExchange = 2,
        /// Use UTC time zone.
        /// Only compatible with Revenue Verification reports.
        Utc = 3,
        /// Use the time zone provided in the ReportDefinition.time_zone field.
        /// Has limited dimension and metric compatibility compared with PUBLISHER,
        /// and reports may take longer to run since the dates are dynamically
        /// calculated at request time.
        Provided = 4,
    }
    impl TimeZoneSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIME_ZONE_SOURCE_UNSPECIFIED",
                Self::Publisher => "PUBLISHER",
                Self::AdExchange => "AD_EXCHANGE",
                Self::Utc => "UTC",
                Self::Provided => "PROVIDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_ZONE_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
                "PUBLISHER" => Some(Self::Publisher),
                "AD_EXCHANGE" => Some(Self::AdExchange),
                "UTC" => Some(Self::Utc),
                "PROVIDED" => Some(Self::Provided),
                _ => None,
            }
        }
    }
}
/// The `Report` resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Report {
    /// Identifier. The resource name of the report.
    /// Report resource name have the form:
    /// `networks/{network_code}/reports/{report_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Report ID.
    #[prost(int64, tag = "3")]
    pub report_id: i64,
    /// Optional. The visibility of a report.
    #[prost(enumeration = "report::Visibility", tag = "2")]
    pub visibility: i32,
    /// Required. The report definition of the report.
    #[prost(message, optional, tag = "4")]
    pub report_definition: ::core::option::Option<ReportDefinition>,
    /// Optional. Display name for the report.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The instant this report was last modified.
    #[prost(message, optional, tag = "6")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The instant this report was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The locale of this report. Locale is set from the user's
    /// locale at the time of the request. Locale can't be modified.
    #[prost(string, tag = "8")]
    pub locale: ::prost::alloc::string::String,
    /// Optional. The schedule options of this report.
    #[prost(message, optional, tag = "9")]
    pub schedule_options: ::core::option::Option<ScheduleOptions>,
}
/// Nested message and enum types in `Report`.
pub mod report {
    /// The visibility of a report.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Visibility {
        /// Default value. Reports with hidden visibility won't appear in the Ad
        /// Manager UI.
        Hidden = 0,
        /// Reports with draft visibility will appear in the Ad Manager UI only if
        /// the user has configured the UI to show them.
        Draft = 1,
        /// Reports with saved visibility will appear in the Ad Manager UI by
        /// default. Alias for VISIBLE and will be replaced in the future.
        Saved = 2,
    }
    impl Visibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Hidden => "HIDDEN",
                Self::Draft => "DRAFT",
                Self::Saved => "SAVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HIDDEN" => Some(Self::Hidden),
                "DRAFT" => Some(Self::Draft),
                "SAVED" => Some(Self::Saved),
                _ => None,
            }
        }
    }
}
/// A table containing report data including dimension and metric values.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReportDataTable {}
/// Nested message and enum types in `ReportDataTable`.
pub mod report_data_table {
    /// A row of report data.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Row {
        /// The order of the dimension values is the same as the order of the
        /// dimensions specified in the request.
        #[prost(message, repeated, tag = "1")]
        pub dimension_values: ::prost::alloc::vec::Vec<super::ReportValue>,
        /// The length of the metric_value_groups
        /// field will be equal to the length of the date_ranges field in the
        /// fetch response. The metric_value_groups field is
        /// ordered such that each index corresponds to the date_range at the same
        /// index. For example, given date_ranges \[x, y\], metric_value_groups will
        /// have a length of two. The first entry in metric_value_groups represents
        /// the metrics for date x and the second entry in metric_value_groups
        /// represents the metrics for date y.
        #[prost(message, repeated, tag = "2")]
        pub metric_value_groups: ::prost::alloc::vec::Vec<MetricValueGroup>,
    }
    /// Contains all metric values requested for a single date range and set of
    /// column dimension values (returned in the columns field of the response).
    /// The order of the metrics in each field corresponds to the order of the
    /// metrics specified in the request.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetricValueGroup {
        /// Data for the PRIMARY MetricValueType.
        #[prost(message, repeated, tag = "1")]
        pub primary_values: ::prost::alloc::vec::Vec<super::ReportValue>,
        /// Data for the PRIMARY_PERCENT_OF_TOTAL MetricValueType.
        #[prost(message, repeated, tag = "2")]
        pub primary_percent_of_total_values: ::prost::alloc::vec::Vec<
            super::ReportValue,
        >,
        /// Data for the COMPARISON MetricValueType.
        #[prost(message, repeated, tag = "3")]
        pub comparison_values: ::prost::alloc::vec::Vec<super::ReportValue>,
        /// Data for the COMPARISON_PERCENT_OF_TOTAL MetricValueType.
        #[prost(message, repeated, tag = "4")]
        pub comparison_percent_of_total_values: ::prost::alloc::vec::Vec<
            super::ReportValue,
        >,
        /// Data for the ABSOLUTE_CHANGE MetricValueType.
        #[prost(message, repeated, tag = "5")]
        pub absolute_change_values: ::prost::alloc::vec::Vec<super::ReportValue>,
        /// Data for the RELATIVE_CHANGE MetricValueType.
        #[prost(message, repeated, tag = "6")]
        pub relative_change_values: ::prost::alloc::vec::Vec<super::ReportValue>,
        /// If true, the flag's conditions are met. If false, the flag's
        /// conditions are not met. flag_values has the same length as
        /// flags and index i of flag_values represents the flag at index i
        /// of flags.
        #[prost(bool, repeated, tag = "7")]
        pub flag_values: ::prost::alloc::vec::Vec<bool>,
    }
}
/// The options for a scheduled report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleOptions {
    /// Information pertaining to schedule itself.
    #[prost(message, optional, tag = "1")]
    pub schedule: ::core::option::Option<schedule_options::Schedule>,
    /// Option for when to deliver the scheduled report.
    #[prost(enumeration = "schedule_options::DeliveryCondition", tag = "2")]
    pub delivery_condition: i32,
    /// Optional. The flags evaluated when ReportDeliveryOption.WHEN_FLAG_PRESENT
    /// is specified.
    #[prost(message, repeated, tag = "3")]
    pub flags: ::prost::alloc::vec::Vec<report_definition::Flag>,
}
/// Nested message and enum types in `ScheduleOptions`.
pub mod schedule_options {
    /// The schedule for the report
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Schedule {
        /// Date for the first run of the report.
        #[prost(message, optional, tag = "1")]
        pub start_date: ::core::option::Option<super::super::super::super::r#type::Date>,
        /// Date for the final run of the report.
        #[prost(message, optional, tag = "2")]
        pub end_date: ::core::option::Option<super::super::super::super::r#type::Date>,
        /// Frequency to run report.
        #[prost(enumeration = "schedule::Frequency", tag = "3")]
        pub frequency: i32,
        /// Indicates start time for schedule to run
        /// Will use the time_zone from `ReportDefinition`. Defaults
        /// to the publisher's time zone if not specified.
        ///
        /// For HOURLY, TWO_TIMES_DAILY, THREE_TIMES_DAILY, or FOUR_TIMES_DAILY, this
        /// will be the time of day that the first report will run on the first day.
        /// For example, if the start time is 2:00 PM, and the frequency is
        /// THREE_TIMES_DAILY, the first day will have reports scheduled at 2:00 PM,
        /// 10:00 PM. Each subsequent day will have reports scheduled at 6:00 AM,
        /// 2:00 PM, 10:00 PM.
        #[prost(message, optional, tag = "4")]
        pub start_time: ::core::option::Option<
            super::super::super::super::r#type::TimeOfDay,
        >,
        /// The scheduled values based on the frequency selected.
        /// WEEKLY - uses WeeklySchedule
        /// MONTHLY - uses MonthlySchedule
        #[prost(oneof = "schedule::FrequencySchedule", tags = "6, 7")]
        pub frequency_schedule: ::core::option::Option<schedule::FrequencySchedule>,
    }
    /// Nested message and enum types in `Schedule`.
    pub mod schedule {
        /// Days of week to schedule report run.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct WeeklySchedule {
            /// Specifies days of the week on which to run report.
            #[prost(
                enumeration = "super::super::super::super::super::r#type::DayOfWeek",
                repeated,
                tag = "1"
            )]
            pub weekly_scheduled_days: ::prost::alloc::vec::Vec<i32>,
        }
        /// Days of Month to schedule report run.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct MonthlySchedule {
            /// Specifies days of the month to run report. Range is from 1-31.
            /// Will ignore days that are not valid for the given month.
            #[prost(int32, repeated, tag = "1")]
            pub monthly_scheduled_days: ::prost::alloc::vec::Vec<i32>,
        }
        /// Frequency to run report.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Frequency {
            /// No Frequency specified.
            Unspecified = 0,
            /// Schedule report to run every hour.
            Hourly = 1,
            /// Schedule report to run twice a day (every 12 hours).
            TwoTimesDaily = 2,
            /// Schedule report to run three times a day (every 8 hours).
            ThreeTimesDaily = 3,
            /// Schedule report to run four times a day (every 6 hours).
            FourTimesDaily = 4,
            /// Schedule report to run on a daily basis.
            Daily = 5,
            /// Schedule report to run on a weekly basis.
            Weekly = 6,
            /// Schedule report to run on a monthly basis.
            Monthly = 7,
        }
        impl Frequency {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "FREQUENCY_UNSPECIFIED",
                    Self::Hourly => "HOURLY",
                    Self::TwoTimesDaily => "TWO_TIMES_DAILY",
                    Self::ThreeTimesDaily => "THREE_TIMES_DAILY",
                    Self::FourTimesDaily => "FOUR_TIMES_DAILY",
                    Self::Daily => "DAILY",
                    Self::Weekly => "WEEKLY",
                    Self::Monthly => "MONTHLY",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "FREQUENCY_UNSPECIFIED" => Some(Self::Unspecified),
                    "HOURLY" => Some(Self::Hourly),
                    "TWO_TIMES_DAILY" => Some(Self::TwoTimesDaily),
                    "THREE_TIMES_DAILY" => Some(Self::ThreeTimesDaily),
                    "FOUR_TIMES_DAILY" => Some(Self::FourTimesDaily),
                    "DAILY" => Some(Self::Daily),
                    "WEEKLY" => Some(Self::Weekly),
                    "MONTHLY" => Some(Self::Monthly),
                    _ => None,
                }
            }
        }
        /// The scheduled values based on the frequency selected.
        /// WEEKLY - uses WeeklySchedule
        /// MONTHLY - uses MonthlySchedule
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum FrequencySchedule {
            /// Days of week to schedule report run.
            #[prost(message, tag = "6")]
            WeeklySchedule(WeeklySchedule),
            /// Days of month to schedule report run.
            #[prost(message, tag = "7")]
            MonthlySchedule(MonthlySchedule),
        }
    }
    /// Condition for when to email the scheduled report.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeliveryCondition {
        /// Never deliver report.
        Never = 0,
        /// Always deliver report.
        Always = 1,
        /// Deliver report when flag's conditions are met.
        WhenFlagConditionsMet = 2,
    }
    impl DeliveryCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Never => "NEVER",
                Self::Always => "ALWAYS",
                Self::WhenFlagConditionsMet => "WHEN_FLAG_CONDITIONS_MET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NEVER" => Some(Self::Never),
                "ALWAYS" => Some(Self::Always),
                "WHEN_FLAG_CONDITIONS_MET" => Some(Self::WhenFlagConditionsMet),
                _ => None,
            }
        }
    }
}
/// Request message for a running a report.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RunReportRequest {
    /// Required. The report to run.
    /// Format: `networks/{network_code}/reports/{report_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// `RunReport` operation metadata.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RunReportMetadata {
    /// An estimate of how close this report is to being completed. Will always be
    /// 100 for failed and completed reports.
    #[prost(int32, tag = "2")]
    pub percent_complete: i32,
    /// The result's parent report.
    #[prost(string, tag = "4")]
    pub report: ::prost::alloc::string::String,
}
/// Response message for a completed `RunReport` operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RunReportResponse {
    /// The unique name of the generated result. Use with `FetchReportResultRows`
    /// to retrieve data.
    #[prost(string, tag = "1")]
    pub report_result: ::prost::alloc::string::String,
}
/// Request object for `GetReport` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetReportRequest {
    /// Required. The resource name of the report.
    /// Format: `networks/{network_code}/reports/{report_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListReports` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListReportsRequest {
    /// Required. The parent, which owns this collection of reports.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Reports` to return. The service may return
    /// fewer than this value. If unspecified, at most 50 `Reports` will be
    /// returned. The maximum value is 1000; values greater than 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListReports` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReports` must
    /// match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListReportsResponse` containing matching `Report`
/// objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReportsResponse {
    /// The `Report` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub reports: ::prost::alloc::vec::Vec<Report>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Report` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateReport` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReportRequest {
    /// Required. The parent resource where this `Report` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Report` to create.
    #[prost(message, optional, tag = "2")]
    pub report: ::core::option::Option<Report>,
}
/// Request object for `UpdateReport` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReportRequest {
    /// Required. The `Report` to update.
    #[prost(message, optional, tag = "1")]
    pub report: ::core::option::Option<Report>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request message for the fetch report result rows endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FetchReportResultRowsRequest {
    /// The report result being fetched.
    /// Format:
    /// `networks/{network_code}/reports/{report_id}/results/{report_result_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The maximum number of rows to return. The service may return
    /// fewer than this value. If unspecified, at most 1,000 rows will be returned.
    /// The maximum value is 10,000; values greater than 10,000 will be reduced to
    /// 10,000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `FetchReportResultRows`
    /// call. Provide this to retrieve the second and subsequent batches of rows.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message for the fetch report result rows endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchReportResultRowsResponse {
    /// Up to `page_size` rows of report data.
    #[prost(message, repeated, tag = "1")]
    pub rows: ::prost::alloc::vec::Vec<report_data_table::Row>,
    /// The time at which the report was scheduled to run. For non-scheduled
    /// reports, this is the time at which the report was requested to be run.
    #[prost(message, optional, tag = "2")]
    pub run_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The computed fixed date ranges this report includes.
    /// Only returned with the first page of results (when page_token is not
    /// included in the request).
    #[prost(message, repeated, tag = "3")]
    pub date_ranges: ::prost::alloc::vec::Vec<
        report_definition::date_range::FixedDateRange,
    >,
    /// The computed comparison fixed date ranges this report includes.
    /// Only returned with the first page of results (when page_token is not
    /// included in the request).
    #[prost(message, repeated, tag = "4")]
    pub comparison_date_ranges: ::prost::alloc::vec::Vec<
        report_definition::date_range::FixedDateRange,
    >,
    /// The total number of rows available from this report. Useful for
    /// pagination.
    /// Only returned with the first page of results (when page_token is not
    /// included in the request).
    #[prost(int32, tag = "5")]
    pub total_row_count: i32,
    /// A token that can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "6")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod report_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for interacting with reports.
    #[derive(Debug, Clone)]
    pub struct ReportServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ReportServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ReportServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReportServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ReportServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Report` object.
        pub async fn get_report(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReportRequest>,
        ) -> std::result::Result<tonic::Response<super::Report>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/GetReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.ReportService", "GetReport"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Report` objects.
        pub async fn list_reports(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReportsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReportsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/ListReports",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ReportService",
                        "ListReports",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `Report` object.
        pub async fn create_report(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReportRequest>,
        ) -> std::result::Result<tonic::Response<super::Report>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/CreateReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ReportService",
                        "CreateReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `Report` object.
        pub async fn update_report(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReportRequest>,
        ) -> std::result::Result<tonic::Response<super::Report>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/UpdateReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ReportService",
                        "UpdateReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates the execution of an existing report asynchronously. Users can
        /// get the report by polling this operation using
        /// `OperationsService.GetOperation`.
        /// Poll every 5 seconds initially, with an exponential
        /// backoff. Once a report is complete, the operation will contain a
        /// `RunReportResponse` in its response field containing a report_result that
        /// can be passed to the `FetchReportResultRows` method to retrieve the report
        /// data.
        pub async fn run_report(
            &mut self,
            request: impl tonic::IntoRequest<super::RunReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/RunReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.ReportService", "RunReport"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the result rows from a completed report.
        /// The caller must have previously called `RunReport` and waited for that
        /// operation to complete. The rows will be returned according to the order
        /// specified by the `sorts` member of the report definition.
        pub async fn fetch_report_result_rows(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchReportResultRowsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchReportResultRowsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.ReportService/FetchReportResultRows",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.ReportService",
                        "FetchReportResultRows",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[RoleStatus\]\[google.ads.admanager.v1.RoleStatusEnum.RoleStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RoleStatusEnum {}
/// Nested message and enum types in `RoleStatusEnum`.
pub mod role_status_enum {
    /// The status of the role.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RoleStatus {
        /// No value specified.
        Unspecified = 0,
        /// Role is active.
        Active = 1,
        /// Role is inactive.
        Inactive = 2,
    }
    impl RoleStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ROLE_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROLE_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// The `Role` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Role {
    /// Identifier. The resource name of the `Role`.
    /// Format: `networks/{network_code}/roles/{role_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `Role` ID.
    #[prost(int64, optional, tag = "2")]
    pub role_id: ::core::option::Option<i64>,
    /// Required. The display name of the `Role`.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The description of the `Role`.
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether the `Role` is a built-in or custom user role.
    #[prost(bool, optional, tag = "5")]
    pub built_in: ::core::option::Option<bool>,
    /// Output only. The status of the `Role`.
    #[prost(enumeration = "role_status_enum::RoleStatus", optional, tag = "6")]
    pub status: ::core::option::Option<i32>,
}
/// Request object for `GetRole` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetRoleRequest {
    /// Required. The resource name of the Role.
    /// Format: `networks/{network_code}/roles/{role_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListRoles` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRolesRequest {
    /// Required. The parent, which owns this collection of Roles.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Roles` to return. The service may return
    /// fewer than this value. If unspecified, at most 50 `Roles` will be returned.
    /// The maximum value is 1000; values greater than 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListRoles` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListRoles` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListRolesRequest` containing matching `Role` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRolesResponse {
    /// The `Role` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub roles: ::prost::alloc::vec::Vec<Role>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Role` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod role_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Role` objects.
    #[derive(Debug, Clone)]
    pub struct RoleServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl RoleServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> RoleServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RoleServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            RoleServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Role` object.
        pub async fn get_role(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoleRequest>,
        ) -> std::result::Result<tonic::Response<super::Role>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.RoleService/GetRole",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.RoleService", "GetRole"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Role` objects.
        pub async fn list_roles(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRolesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRolesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.RoleService/ListRoles",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.RoleService", "ListRoles"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[SiteDisapprovalReason\]\[google.ads.admanager.v1.SiteDisapprovalReasonEnum.SiteDisapprovalReason\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SiteDisapprovalReasonEnum {}
/// Nested message and enum types in `SiteDisapprovalReasonEnum`.
pub mod site_disapproval_reason_enum {
    /// The list of possible policy violation types for a Site.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SiteDisapprovalReason {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The site has content that violates policy.
        Content = 1,
        /// Generic error type.
        Other = 2,
        /// The parent must be an authorized seller of the child network's inventory.
        Ownership = 3,
    }
    impl SiteDisapprovalReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SITE_DISAPPROVAL_REASON_UNSPECIFIED",
                Self::Content => "CONTENT",
                Self::Other => "OTHER",
                Self::Ownership => "OWNERSHIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SITE_DISAPPROVAL_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "CONTENT" => Some(Self::Content),
                "OTHER" => Some(Self::Other),
                "OWNERSHIP" => Some(Self::Ownership),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[SiteApprovalStatus\]\[google.ads.admanager.v1.SiteApprovalStatusEnum.SiteApprovalStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SiteApprovalStatusEnum {}
/// Nested message and enum types in `SiteApprovalStatusEnum`.
pub mod site_approval_status_enum {
    /// Represents the approval status of a site.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SiteApprovalStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The site has been approved to serve ads.
        Approved = 1,
        /// The site has been disapproved from serving ads.
        Disapproved = 2,
        /// The default status with which a site is created.
        Draft = 3,
        /// The site has been deactivated and is not serving ads due to dormancy. It
        /// must be resubmitted for approval.
        RequiresReview = 4,
        /// Once the site is submitted for approval, its status changes from draft to
        /// unchecked. It will be reviwed with an estimated turn-around time of 24h.
        /// Such a site cannot serve ads.
        Unchecked = 5,
    }
    impl SiteApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SITE_APPROVAL_STATUS_UNSPECIFIED",
                Self::Approved => "APPROVED",
                Self::Disapproved => "DISAPPROVED",
                Self::Draft => "DRAFT",
                Self::RequiresReview => "REQUIRES_REVIEW",
                Self::Unchecked => "UNCHECKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SITE_APPROVAL_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                "DRAFT" => Some(Self::Draft),
                "REQUIRES_REVIEW" => Some(Self::RequiresReview),
                "UNCHECKED" => Some(Self::Unchecked),
                _ => None,
            }
        }
    }
}
/// A Site represents a domain owned or represented by a network. For a parent
/// network managing other networks as part of Multiple Customer Management
/// "Manage Inventory" model, it could be the child's domain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Site {
    /// Identifier. The resource name of the `Site`.
    /// Format: `networks/{network_code}/sites/{site_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The URL of the Site.
    #[prost(string, optional, tag = "3")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The network code of the child if the Site is being managed for an
    /// MCM child network, or null if owned by this network.
    #[prost(string, optional, tag = "4")]
    pub child_network_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Status of the review performed on the Site by Google.
    #[prost(
        enumeration = "site_approval_status_enum::SiteApprovalStatus",
        optional,
        tag = "5"
    )]
    pub approval_status: ::core::option::Option<i32>,
    /// Output only. The latest Site approval status change time.
    #[prost(message, optional, tag = "6")]
    pub approval_status_update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Provides reasons for disapproving the Site. It is null when
    /// the Site is not disapproved.
    #[prost(message, repeated, tag = "7")]
    pub disapproval_reasons: ::prost::alloc::vec::Vec<DisapprovalReason>,
}
/// Represents the reason for which Google disapproved the Site.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DisapprovalReason {
    /// Output only. The type of policy violation found for the Site.
    #[prost(
        enumeration = "site_disapproval_reason_enum::SiteDisapprovalReason",
        optional,
        tag = "1"
    )]
    pub r#type: ::core::option::Option<i32>,
    /// Output only. Additional details for the disapproval of the Site.
    #[prost(string, optional, tag = "2")]
    pub details: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request object for `GetSite` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetSiteRequest {
    /// Required. The resource name of the Site.
    /// Format: `networks/{network_code}/sites/{site_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListSites` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSitesRequest {
    /// Required. The parent, which owns this collection of Sites.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Sites` to return. The service may return
    /// fewer than this value. If unspecified, at most 50 `Sites` will be returned.
    /// The maximum value is 1000; values greater than 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListSites` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSites` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListSitesRequest` containing matching `Site` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSitesResponse {
    /// The `Site` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Site` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateSite` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSiteRequest {
    /// Required. The parent resource where this `Site` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Site` to create.
    #[prost(message, optional, tag = "2")]
    pub site: ::core::option::Option<Site>,
}
/// Request object for `BatchCreateSites` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateSitesRequest {
    /// Required. The parent resource where `Sites` will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreateSiteRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Site` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateSiteRequest>,
}
/// Response object for `BatchCreateSites` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateSitesResponse {
    /// The `Site` objects created.
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
}
/// Request object for `UpdateSite` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSiteRequest {
    /// Required. The `Site` to update.
    ///
    /// The `Site`'s `name` is used to identify the `Site` to update.
    #[prost(message, optional, tag = "1")]
    pub site: ::core::option::Option<Site>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchUpdateSites` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateSitesRequest {
    /// Required. The parent resource where `Sites` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdateSiteRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Site` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateSiteRequest>,
}
/// Response object for `BatchUpdateSites` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateSitesResponse {
    /// The `Site` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub sites: ::prost::alloc::vec::Vec<Site>,
}
/// Request message for `BatchDeactivateSites` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateSitesRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `Site` objects to deactivate.
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchDeactivateSites` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateSitesResponse {}
/// Request message for `BatchSubmitSitesForApproval` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchSubmitSitesForApprovalRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `Site` objects to submit for approval.
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchSubmitSitesForApproval` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchSubmitSitesForApprovalResponse {}
/// Generated client implementations.
pub mod site_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Site` objects.
    #[derive(Debug, Clone)]
    pub struct SiteServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SiteServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SiteServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SiteServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SiteServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Site` object.
        pub async fn get_site(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/GetSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.SiteService", "GetSite"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Site` objects.
        pub async fn list_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/ListSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.SiteService", "ListSites"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `Site` object.
        pub async fn create_site(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/CreateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.SiteService", "CreateSite"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `Site` objects.
        pub async fn batch_create_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/BatchCreateSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.SiteService",
                        "BatchCreateSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `Site` object.
        pub async fn update_site(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSiteRequest>,
        ) -> std::result::Result<tonic::Response<super::Site>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/UpdateSite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.SiteService", "UpdateSite"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `Site` objects.
        pub async fn batch_update_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/BatchUpdateSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.SiteService",
                        "BatchUpdateSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deactivates a list of `Site` objects.
        pub async fn batch_deactivate_sites(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeactivateSitesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchDeactivateSitesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/BatchDeactivateSites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.SiteService",
                        "BatchDeactivateSites",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits a list of `Site` objects for approval.
        pub async fn batch_submit_sites_for_approval(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchSubmitSitesForApprovalRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchSubmitSitesForApprovalResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.SiteService/BatchSubmitSitesForApproval",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.SiteService",
                        "BatchSubmitSitesForApproval",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper for
/// \[TaxonomyType\]\[google.ads.admanager.v1.TaxonomyTypeEnum.TaxonomyType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TaxonomyTypeEnum {}
/// Nested message and enum types in `TaxonomyTypeEnum`.
pub mod taxonomy_type_enum {
    /// The taxonomy type of the IAB defined taxonomies.
    /// Used for Publisher provided signals.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TaxonomyType {
        /// Unspecified/not present
        Unspecified = 0,
        /// The IAB Audience Taxonomy v1.1.
        TaxonomyIabAudience11 = 3,
        /// The IAB Content Taxonomy v1.0.
        TaxonomyIabContent10 = 8,
        /// The IAB Content Taxonomy v2.1.
        TaxonomyIabContent21 = 4,
        /// The IAB Content Taxonomy v2.2.
        TaxonomyIabContent22 = 6,
        /// The IAB Content Taxonomy v3.0.
        TaxonomyIabContent30 = 5,
        /// The PPS structured video signals taxonomy.
        TaxonomyGoogleStructuredVideo10 = 7,
    }
    impl TaxonomyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TAXONOMY_TYPE_UNSPECIFIED",
                Self::TaxonomyIabAudience11 => "TAXONOMY_IAB_AUDIENCE_1_1",
                Self::TaxonomyIabContent10 => "TAXONOMY_IAB_CONTENT_1_0",
                Self::TaxonomyIabContent21 => "TAXONOMY_IAB_CONTENT_2_1",
                Self::TaxonomyIabContent22 => "TAXONOMY_IAB_CONTENT_2_2",
                Self::TaxonomyIabContent30 => "TAXONOMY_IAB_CONTENT_3_0",
                Self::TaxonomyGoogleStructuredVideo10 => {
                    "TAXONOMY_GOOGLE_STRUCTURED_VIDEO_1_0"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TAXONOMY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TAXONOMY_IAB_AUDIENCE_1_1" => Some(Self::TaxonomyIabAudience11),
                "TAXONOMY_IAB_CONTENT_1_0" => Some(Self::TaxonomyIabContent10),
                "TAXONOMY_IAB_CONTENT_2_1" => Some(Self::TaxonomyIabContent21),
                "TAXONOMY_IAB_CONTENT_2_2" => Some(Self::TaxonomyIabContent22),
                "TAXONOMY_IAB_CONTENT_3_0" => Some(Self::TaxonomyIabContent30),
                "TAXONOMY_GOOGLE_STRUCTURED_VIDEO_1_0" => {
                    Some(Self::TaxonomyGoogleStructuredVideo10)
                }
                _ => None,
            }
        }
    }
}
/// The `TaxonomyCategory` resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TaxonomyCategory {
    /// Identifier. The resource name of the `TaxonomyCategory`.
    /// Format: `networks/{network_code}/taxonomyCategories/{taxonomy_category_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `TaxonomyCategory` ID.
    #[prost(int64, optional, tag = "2")]
    pub taxonomy_category_id: ::core::option::Option<i64>,
    /// Output only. Display name of the `TaxonomyCategory`.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether this `TaxonomyCategory` only serves to group its
    /// children.
    #[prost(bool, optional, tag = "5")]
    pub grouping_only: ::core::option::Option<bool>,
    /// Output only. The ID of the parent category this `TaxonomyCategory` descends
    /// from.
    #[prost(int64, optional, tag = "6")]
    pub parent_taxonomy_category_id: ::core::option::Option<i64>,
    /// Output only. The taxonomy that this `TaxonomyCategory` belongs to.
    #[prost(enumeration = "taxonomy_type_enum::TaxonomyType", optional, tag = "9")]
    pub taxonomy_type: ::core::option::Option<i32>,
    /// Output only. The list of names of the ancestors of this `TaxonomyCategory`.
    #[prost(string, repeated, tag = "7")]
    pub ancestor_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The list of IDs of the ancestors of this `TaxonomyCategory`.
    #[prost(int64, repeated, packed = "false", tag = "8")]
    pub ancestor_taxonomy_category_ids: ::prost::alloc::vec::Vec<i64>,
}
/// Request object for `GetTaxonomyCategory` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTaxonomyCategoryRequest {
    /// Required. The resource name of the TaxonomyCategory.
    /// Format: `networks/{network_code}/taxonomyCategories/{taxonomy_category_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListTaxonomyCategories` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTaxonomyCategoriesRequest {
    /// Required. The parent, which owns this collection of TaxonomyCategories.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `TaxonomyCategories` to return. The service
    /// may return fewer than this value. If unspecified, at most 50
    /// `TaxonomyCategories` will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListTaxonomyCategories`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTaxonomyCategories`
    /// must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListTaxonomyCategoriesRequest` containing matching
/// `TaxonomyCategory` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTaxonomyCategoriesResponse {
    /// The `TaxonomyCategory` objects.
    #[prost(message, repeated, tag = "1")]
    pub taxonomy_categories: ::prost::alloc::vec::Vec<TaxonomyCategory>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `TaxonomyCategory` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Generated client implementations.
pub mod taxonomy_category_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `TaxonomyCategory` objects.
    #[derive(Debug, Clone)]
    pub struct TaxonomyCategoryServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TaxonomyCategoryServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TaxonomyCategoryServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaxonomyCategoryServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TaxonomyCategoryServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `TaxonomyCategory` object.
        pub async fn get_taxonomy_category(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTaxonomyCategoryRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TaxonomyCategory>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TaxonomyCategoryService/GetTaxonomyCategory",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.TaxonomyCategoryService",
                        "GetTaxonomyCategory",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `TaxonomyCategory` objects.
        pub async fn list_taxonomy_categories(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTaxonomyCategoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTaxonomyCategoriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TaxonomyCategoryService/ListTaxonomyCategories",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.TaxonomyCategoryService",
                        "ListTaxonomyCategories",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Wrapper message for
/// \[TeamStatus\]\[google.ads.admanager.v1.TeamStatusEnum.TeamStatus\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TeamStatusEnum {}
/// Nested message and enum types in `TeamStatusEnum`.
pub mod team_status_enum {
    /// Represents the status of a team, whether it is active or inactive.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TeamStatus {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The status of an active team.
        Active = 1,
        /// The status of an inactive team.
        Inactive = 2,
    }
    impl TeamStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TEAM_STATUS_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TEAM_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
/// Wrapper message for
/// \[TeamAccessType\]\[google.ads.admanager.v1.TeamAccessTypeEnum.TeamAccessType\]
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TeamAccessTypeEnum {}
/// Nested message and enum types in `TeamAccessTypeEnum`.
pub mod team_access_type_enum {
    /// Represents the types of team access supported for orders.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TeamAccessType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The level of access in which team members can't view or edit a team's
        /// orders.
        None = 1,
        /// The level of access in which team members can only view a team's orders.
        ReadOnly = 2,
        /// The level of access in which team members can view and edit a team's
        /// orders.
        ReadWrite = 3,
    }
    impl TeamAccessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TEAM_ACCESS_TYPE_UNSPECIFIED",
                Self::None => "NONE",
                Self::ReadOnly => "READ_ONLY",
                Self::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TEAM_ACCESS_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
}
/// A Team defines a grouping of users and what entities they have access to.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Team {
    /// Identifier. The resource name of the `Team`.
    /// Format: `networks/{network_code}/teams/{team_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The name of the Team. This value has a maximum length of 127
    /// characters.
    #[prost(string, optional, tag = "3")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. The description of the Team. This value has a maximum length of
    /// 255 characters.
    #[prost(string, optional, tag = "4")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. The status of the Team. This value determines the visibility
    /// of the team in the UI.
    #[prost(enumeration = "team_status_enum::TeamStatus", optional, tag = "5")]
    pub status: ::core::option::Option<i32>,
    /// Optional. Whether or not users on this team have access to all companies.
    /// If this value is true, then an error will be thrown if an attempt is made
    /// to associate this team with a Company.
    #[prost(bool, optional, tag = "6")]
    pub all_companies_access: ::core::option::Option<bool>,
    /// Optional. Whether or not users on this team have access to all inventory.
    /// If this value is true, then an error will be thrown if an attempt is made
    /// to associate this team with an AdUnit.
    #[prost(bool, optional, tag = "7")]
    pub all_inventory_access: ::core::option::Option<bool>,
    /// Optional. The default access to orders for users on this team.
    #[prost(enumeration = "team_access_type_enum::TeamAccessType", optional, tag = "8")]
    pub access_type: ::core::option::Option<i32>,
}
/// Request object for `GetTeam` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetTeamRequest {
    /// Required. The resource name of the Team.
    /// Format: `networks/{network_code}/teams/{team_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request object for `ListTeams` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListTeamsRequest {
    /// Required. The parent, which owns this collection of Teams.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of `Teams` to return. The service may return
    /// fewer than this value. If unspecified, at most 50 `Teams` will be returned.
    /// The maximum value is 1000; values greater than 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListTeams` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTeams` must match
    /// the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Expression to filter the response.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Expression to specify sorting order.
    /// See syntax details at
    /// <https://developers.google.com/ad-manager/api/beta/filters#order>
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. Number of individual resources to skip while paginating.
    #[prost(int32, tag = "6")]
    pub skip: i32,
}
/// Response object for `ListTeamsRequest` containing matching `Team` objects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTeamsResponse {
    /// The `Team` objects from the specified network.
    #[prost(message, repeated, tag = "1")]
    pub teams: ::prost::alloc::vec::Vec<Team>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Total number of `Team` objects.
    /// If a filter was included in the request, this reflects the total number
    /// after the filtering is applied.
    ///
    /// `total_size` won't be calculated in the response unless it has been
    /// included in a response field mask. The response field mask can be provided
    /// to the method by using the URL parameter `$fields` or `fields`, or by using
    /// the HTTP/gRPC header `X-Goog-FieldMask`.
    ///
    /// For more information, see
    /// <https://developers.google.com/ad-manager/api/beta/field-masks>
    #[prost(int32, tag = "3")]
    pub total_size: i32,
}
/// Request object for `CreateTeam` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTeamRequest {
    /// Required. The parent resource where this `Team` will be created.
    /// Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Team` to create.
    #[prost(message, optional, tag = "2")]
    pub team: ::core::option::Option<Team>,
}
/// Request object for `BatchCreateTeams` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTeamsRequest {
    /// Required. The parent resource where `Teams` will be created.
    /// Format: `networks/{network_code}`
    /// The parent field in the CreateTeamRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Team` objects to create.
    /// A maximum of 100 objects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateTeamRequest>,
}
/// Response object for `BatchCreateTeams` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateTeamsResponse {
    /// The `Team` objects created.
    #[prost(message, repeated, tag = "1")]
    pub teams: ::prost::alloc::vec::Vec<Team>,
}
/// Request object for `UpdateTeam` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateTeamRequest {
    /// Required. The `Team` to update.
    ///
    /// The `Team`'s `name` is used to identify the `Team` to update.
    #[prost(message, optional, tag = "1")]
    pub team: ::core::option::Option<Team>,
    /// Required. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request object for `BatchUpdateTeams` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateTeamsRequest {
    /// Required. The parent resource where `Teams` will be updated.
    /// Format: `networks/{network_code}`
    /// The parent field in the UpdateTeamRequest must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The `Team` objects to update.
    /// A maximum of 100 objects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateTeamRequest>,
}
/// Response object for `BatchUpdateTeams` method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateTeamsResponse {
    /// The `Team` objects updated.
    #[prost(message, repeated, tag = "1")]
    pub teams: ::prost::alloc::vec::Vec<Team>,
}
/// Request message for `BatchActivateTeams` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateTeamsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `Team`s to activate.
    /// Format: `networks/{network_code}/teams/{team_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchActivateTeams` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchActivateTeamsResponse {}
/// Request message for `BatchDeactivateTeams` method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateTeamsRequest {
    /// Required. Format: `networks/{network_code}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource names of the `Team`s to deactivate.
    /// Format: `networks/{network_code}/teams/{team_id}`
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Response object for `BatchDeactivateTeams` method.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchDeactivateTeamsResponse {}
/// Generated client implementations.
pub mod team_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling `Team` objects.
    #[derive(Debug, Clone)]
    pub struct TeamServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TeamServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TeamServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TeamServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TeamServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a `Team` object.
        pub async fn get_team(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTeamRequest>,
        ) -> std::result::Result<tonic::Response<super::Team>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/GetTeam",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.TeamService", "GetTeam"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to retrieve a list of `Team` objects.
        pub async fn list_teams(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTeamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTeamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/ListTeams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.TeamService", "ListTeams"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to create a `Team` object.
        pub async fn create_team(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateTeamRequest>,
        ) -> std::result::Result<tonic::Response<super::Team>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/CreateTeam",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.TeamService", "CreateTeam"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch create `Team` objects.
        pub async fn batch_create_teams(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateTeamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateTeamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/BatchCreateTeams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.TeamService",
                        "BatchCreateTeams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to update a `Team` object.
        pub async fn update_team(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateTeamRequest>,
        ) -> std::result::Result<tonic::Response<super::Team>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/UpdateTeam",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.TeamService", "UpdateTeam"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch update `Team` objects.
        pub async fn batch_update_teams(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateTeamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateTeamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/BatchUpdateTeams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.TeamService",
                        "BatchUpdateTeams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch activate `Team` objects.
        pub async fn batch_activate_teams(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchActivateTeamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchActivateTeamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/BatchActivateTeams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.TeamService",
                        "BatchActivateTeams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// API to batch deactivate `Team` objects.
        pub async fn batch_deactivate_teams(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeactivateTeamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchDeactivateTeamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.TeamService/BatchDeactivateTeams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.ads.admanager.v1.TeamService",
                        "BatchDeactivateTeams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The User resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    /// Identifier. The resource name of the User.
    /// Format: `networks/{network_code}/users/{user_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. `User` ID.
    #[prost(int64, optional, tag = "10")]
    pub user_id: ::core::option::Option<i64>,
    /// Required. The name of the User. It has a maximum length of 128 characters.
    #[prost(string, optional, tag = "2")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The email or login of the User. In order to create a new user,
    /// you must already have a Google Account.
    #[prost(string, optional, tag = "3")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    /// Required. The unique Role ID of the User. Roles that are created by Google
    /// will have negative IDs.
    #[prost(string, optional, tag = "4")]
    pub role: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Specifies whether or not the User is active. An inactive user
    /// cannot log in to the system or perform any operations.
    #[prost(bool, optional, tag = "6")]
    pub active: ::core::option::Option<bool>,
    /// Optional. An identifier for the User that is meaningful to the publisher.
    /// This attribute has a maximum length of 255 characters.
    #[prost(string, optional, tag = "7")]
    pub external_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Output only. Whether the user is an OAuth2 service account user.
    /// Service account users can only be added through the UI.
    #[prost(bool, optional, tag = "8")]
    pub service_account: ::core::option::Option<bool>,
    /// Optional. The IANA Time Zone Database time zone, e.g. "America/New_York",
    /// used in the orders and line items UI for this User. If not provided, the UI
    /// then defaults to using the Network's timezone. This setting only affects
    /// the UI for this user and does not affect the timezone of any dates and
    /// times returned in API responses.
    #[prost(string, optional, tag = "9")]
    pub orders_ui_local_time_zone: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Request object for GetUser method.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetUserRequest {
    /// Required. The resource name of the User.
    /// Format: `networks/{network_code}/users/{user_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod user_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides methods for handling User objects.
    #[derive(Debug, Clone)]
    pub struct UserServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UserServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UserServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UserServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UserServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// API to retrieve a User object.
        ///
        /// To get the current user, the resource name
        /// `networks/{networkCode}/users/me` can be used.
        pub async fn get_user(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUserRequest>,
        ) -> std::result::Result<tonic::Response<super::User>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.ads.admanager.v1.UserService/GetUser",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.ads.admanager.v1.UserService", "GetUser"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Represents a web property.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WebProperty {
    /// Identifier. The resource name of the WebProperty.
    /// Format:
    /// `networks/{network_code}/webProperties/{web_property_code}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The `WebProperty` code.
    #[prost(string, tag = "2")]
    pub web_property_code: ::prost::alloc::string::String,
    /// Required. The ExchangeSyndicationProduct associated with this WebProperty.
    #[prost(
        enumeration = "exchange_syndication_product_enum::ExchangeSyndicationProduct",
        tag = "3"
    )]
    pub product_type: i32,
    /// Optional. The `WebProperty` ID.
    #[prost(int64, tag = "4")]
    pub web_property_id: i64,
}
