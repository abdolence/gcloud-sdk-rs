// This file is @generated by prost-build.
/// Distance metric for vector search.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DistanceMetric {
    /// Default value, distance metric is not specified.
    Unspecified = 0,
    /// Dot product distance metric.
    DotProduct = 1,
    /// Cosine distance metric.
    CosineDistance = 2,
}
impl DistanceMetric {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DISTANCE_METRIC_UNSPECIFIED",
            Self::DotProduct => "DOT_PRODUCT",
            Self::CosineDistance => "COSINE_DISTANCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DISTANCE_METRIC_UNSPECIFIED" => Some(Self::Unspecified),
            "DOT_PRODUCT" => Some(Self::DotProduct),
            "COSINE_DISTANCE" => Some(Self::CosineDistance),
            _ => None,
        }
    }
}
/// A dataObject resource in Vector Search.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataObject {
    /// Immutable. The fully qualified resource name of the dataObject.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataObjects/{data_object_id}`
    /// The data_object_id must be 1-63 characters
    /// long, and comply with
    /// <a href="<https://www.ietf.org/rfc/rfc1035.txt"> target="_blank">RFC1035</a>.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The id of the dataObject.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub data_object_id: ::prost::alloc::string::String,
    /// Output only. Timestamp the dataObject was created at.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp the dataObject was last updated.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The data of the dataObject.
    #[prost(message, optional, tag = "6")]
    pub data: ::core::option::Option<::prost_types::Struct>,
    /// Optional. The vectors of the dataObject.
    #[prost(map = "string, message", tag = "7")]
    pub vectors: ::std::collections::HashMap<::prost::alloc::string::String, Vector>,
}
/// A vector which can be either dense or sparse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vector {
    /// The values of the vector.
    #[deprecated]
    #[prost(float, repeated, packed = "false", tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
    /// The type of the vector.
    #[prost(oneof = "vector::VectorType", tags = "2, 3")]
    pub vector_type: ::core::option::Option<vector::VectorType>,
}
/// Nested message and enum types in `Vector`.
pub mod vector {
    /// The type of the vector.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VectorType {
        /// A dense vector.
        #[prost(message, tag = "2")]
        Dense(super::DenseVector),
        /// A sparse vector.
        #[prost(message, tag = "3")]
        Sparse(super::SparseVector),
    }
}
/// A dense vector.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DenseVector {
    /// Required. The values of the vector.
    #[prost(float, repeated, packed = "false", tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
/// A sparse vector.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseVector {
    /// Required. The values of the vector.
    #[prost(float, repeated, packed = "false", tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
    /// Required. The corresponding indices for the values.
    #[prost(int32, repeated, packed = "false", tag = "2")]
    pub indices: ::prost::alloc::vec::Vec<i32>,
}
/// Message describing the configuration for generating embeddings for a vector
/// field using Vertex AI embeddings API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VertexEmbeddingConfig {
    /// Required. Required: ID of the embedding model to use. See
    /// <https://cloud.google.com/vertex-ai/generative-ai/docs/learn/models#embeddings-models>
    /// for the list of supported models.
    #[prost(string, tag = "1")]
    pub model_id: ::prost::alloc::string::String,
    /// Required. Required: Text template for the input to the model. The template
    /// must contain one or more references to fields in the DataObject, e.g.:
    /// "Movie Title: {title} ---- Movie Plot: {plot}"".
    #[prost(string, tag = "2")]
    pub text_template: ::prost::alloc::string::String,
    /// Required. Required: Task type for the embeddings.
    #[prost(enumeration = "EmbeddingTaskType", tag = "3")]
    pub task_type: i32,
}
/// Represents the task the embeddings will be used for.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EmbeddingTaskType {
    /// Unspecified task type.
    Unspecified = 0,
    /// Specifies the given text is a query in a search/retrieval setting.
    RetrievalQuery = 1,
    /// Specifies the given text is a document from the corpus being searched.
    RetrievalDocument = 2,
    /// Specifies the given text will be used for STS.
    SemanticSimilarity = 3,
    /// Specifies that the given text will be classified.
    Classification = 4,
    /// Specifies that the embeddings will be used for clustering.
    Clustering = 5,
    /// Specifies that the embeddings will be used for question answering.
    QuestionAnswering = 6,
    /// Specifies that the embeddings will be used for fact verification.
    FactVerification = 7,
    /// Specifies that the embeddings will be used for code retrieval.
    CodeRetrievalQuery = 8,
}
impl EmbeddingTaskType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EMBEDDING_TASK_TYPE_UNSPECIFIED",
            Self::RetrievalQuery => "RETRIEVAL_QUERY",
            Self::RetrievalDocument => "RETRIEVAL_DOCUMENT",
            Self::SemanticSimilarity => "SEMANTIC_SIMILARITY",
            Self::Classification => "CLASSIFICATION",
            Self::Clustering => "CLUSTERING",
            Self::QuestionAnswering => "QUESTION_ANSWERING",
            Self::FactVerification => "FACT_VERIFICATION",
            Self::CodeRetrievalQuery => "CODE_RETRIEVAL_QUERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EMBEDDING_TASK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RETRIEVAL_QUERY" => Some(Self::RetrievalQuery),
            "RETRIEVAL_DOCUMENT" => Some(Self::RetrievalDocument),
            "SEMANTIC_SIMILARITY" => Some(Self::SemanticSimilarity),
            "CLASSIFICATION" => Some(Self::Classification),
            "CLUSTERING" => Some(Self::Clustering),
            "QUESTION_ANSWERING" => Some(Self::QuestionAnswering),
            "FACT_VERIFICATION" => Some(Self::FactVerification),
            "CODE_RETRIEVAL_QUERY" => Some(Self::CodeRetrievalQuery),
            _ => None,
        }
    }
}
/// Defines a output fields struct for data in DataObject.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OutputFields {
    /// Optional. The fields from the data fields to include in the output.
    #[prost(string, repeated, tag = "1")]
    pub data_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The fields from the vector fields to include in the output.
    #[prost(string, repeated, tag = "2")]
    pub vector_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The fields from the DataObject metadata to include in the output.
    #[prost(string, repeated, tag = "3")]
    pub metadata_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Represents a hint to the search index engine.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchHint {
    /// The type of index to use.
    #[prost(oneof = "search_hint::IndexType", tags = "1, 2")]
    pub index_type: ::core::option::Option<search_hint::IndexType>,
}
/// Nested message and enum types in `SearchHint`.
pub mod search_hint {
    /// Message to specify the index to use for the search.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IndexHint {
        /// Required. The resource name of the index to use for the search.
        /// The index must be in the same project, location, and collection.
        /// Format:
        /// `projects/{project}/locations/{location}/collections/{collection}/indexes/{index}`
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// The type of index to use.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum IndexType {
        /// Specifies that the search should use a particular index.
        #[prost(message, tag = "1")]
        UseIndex(IndexHint),
        /// If set to true, the search will use the system's default
        /// K-Nearest Neighbor (KNN) index engine.
        #[prost(bool, tag = "2")]
        UseKnn(bool),
    }
}
/// A single search request within a batch operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Search {
    /// The type of search to perform.
    #[prost(oneof = "search::SearchType", tags = "1, 2, 3")]
    pub search_type: ::core::option::Option<search::SearchType>,
}
/// Nested message and enum types in `Search`.
pub mod search {
    /// The type of search to perform.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SearchType {
        /// A vector-based search.
        #[prost(message, tag = "1")]
        VectorSearch(super::VectorSearch),
        /// A semantic search.
        #[prost(message, tag = "2")]
        SemanticSearch(super::SemanticSearch),
        /// A text search operation.
        #[prost(message, tag = "3")]
        TextSearch(super::TextSearch),
    }
}
/// Defines a search operation using a query vector.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorSearch {
    /// Required. The vector field to search.
    #[prost(string, tag = "8")]
    pub search_field: ::prost::alloc::string::String,
    /// Optional. A JSON filter expression, e.g. {"genre": {"$eq": "sci-fi"}},
    /// represented as a google.protobuf.Struct.
    #[prost(message, optional, tag = "4")]
    pub filter: ::core::option::Option<::prost_types::Struct>,
    /// Optional. The number of nearest neighbors to return.
    #[prost(int32, optional, tag = "5")]
    pub top_k: ::core::option::Option<i32>,
    /// Optional. Mask specifying which fields to return.
    #[prost(message, optional, tag = "7")]
    pub output_fields: ::core::option::Option<OutputFields>,
    /// Optional. Sets the search hint. If no strategy is specified, the service
    /// will use an index if one is available, and fall back to the default KNN
    /// search otherwise.
    #[prost(message, optional, tag = "9")]
    pub search_hint: ::core::option::Option<SearchHint>,
    /// Optional. The distance metric to use for the KNN search. If not specified,
    /// DOT_PRODUCT will be used as the default.
    #[prost(enumeration = "DistanceMetric", tag = "11")]
    pub distance_metric: i32,
    #[prost(oneof = "vector_search::VectorType", tags = "1, 2")]
    pub vector_type: ::core::option::Option<vector_search::VectorType>,
}
/// Nested message and enum types in `VectorSearch`.
pub mod vector_search {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum VectorType {
        /// A dense vector for the query.
        #[prost(message, tag = "1")]
        Vector(super::DenseVector),
        /// A sparse vector for the query.
        #[prost(message, tag = "2")]
        SparseVector(super::SparseVector),
    }
}
/// Defines a semantic search operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SemanticSearch {
    /// Required. The query text, which is used to generate an embedding according
    /// to the embedding model specified in the collection config.
    #[prost(string, tag = "1")]
    pub search_text: ::prost::alloc::string::String,
    /// Required. The vector field to search.
    #[prost(string, tag = "2")]
    pub search_field: ::prost::alloc::string::String,
    /// Optional. The task type of the query embedding.
    #[prost(enumeration = "EmbeddingTaskType", tag = "5")]
    pub task_type: i32,
    /// Optional. The fields to return in the search results.
    #[prost(message, optional, tag = "3")]
    pub output_fields: ::core::option::Option<OutputFields>,
    /// Optional. A JSON filter expression, e.g. {"genre": {"$eq": "sci-fi"}},
    /// represented as a google.protobuf.Struct.
    #[prost(message, optional, tag = "6")]
    pub filter: ::core::option::Option<::prost_types::Struct>,
    /// Optional. The number of data objects to return.
    #[prost(int32, optional, tag = "4")]
    pub top_k: ::core::option::Option<i32>,
}
/// Defines a text search operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TextSearch {
    /// Required. The query text.
    #[prost(string, tag = "1")]
    pub search_text: ::prost::alloc::string::String,
    /// Required. The data field names to search.
    #[prost(string, repeated, tag = "2")]
    pub data_field_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The fields to return in the search results.
    #[prost(message, optional, tag = "3")]
    pub output_fields: ::core::option::Option<OutputFields>,
    /// Optional. The number of results to return.
    #[prost(int32, optional, tag = "4")]
    pub top_k: ::core::option::Option<i32>,
}
/// Request for performing a single search.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDataObjectsRequest {
    /// Required. The resource name of the Collection for which to search.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The standard list page size.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. The standard list page token.
    /// Typically obtained via
    /// \[SearchDataObjectsResponse.next_page_token\]\[google.cloud.vectorsearch.v1beta.SearchDataObjectsResponse.next_page_token\]
    /// of the previous
    /// \[DataObjectSearchService.SearchDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectSearchService.SearchDataObjects\]
    /// call.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    /// The query to search for.
    #[prost(oneof = "search_data_objects_request::SearchType", tags = "2, 4, 7")]
    pub search_type: ::core::option::Option<search_data_objects_request::SearchType>,
}
/// Nested message and enum types in `SearchDataObjectsRequest`.
pub mod search_data_objects_request {
    /// The query to search for.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SearchType {
        /// A vector search operation.
        #[prost(message, tag = "2")]
        VectorSearch(super::VectorSearch),
        /// A semantic search operation.
        #[prost(message, tag = "4")]
        SemanticSearch(super::SemanticSearch),
        /// Optional. A text search operation.
        #[prost(message, tag = "7")]
        TextSearch(super::TextSearch),
    }
}
/// A single search result.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResult {
    /// Output only. The matching data object.
    #[prost(message, optional, tag = "1")]
    pub data_object: ::core::option::Option<DataObject>,
    /// Output only. The similarity distance.
    #[prost(double, optional, tag = "2")]
    pub distance: ::core::option::Option<f64>,
}
/// Metadata about the search execution.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchResponseMetadata {
    /// The type of index used.
    #[prost(oneof = "search_response_metadata::IndexType", tags = "1, 2")]
    pub index_type: ::core::option::Option<search_response_metadata::IndexType>,
}
/// Nested message and enum types in `SearchResponseMetadata`.
pub mod search_response_metadata {
    /// Message that indicates the index used for the search.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct IndexInfo {
        /// Output only. The resource name of the index used for the search.
        /// Format:
        /// `projects/{project}/locations/{location}/collections/{collection}/indexes/{index}`
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
    }
    /// The type of index used.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum IndexType {
        /// Indicates that the search used a particular index.
        #[prost(message, tag = "1")]
        UsedIndex(IndexInfo),
        /// Output only. If true, the search used the system's default
        /// K-Nearest Neighbor (KNN) index engine.
        #[prost(bool, tag = "2")]
        UsedKnn(bool),
    }
}
/// Response for a search request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDataObjectsResponse {
    /// Output only. The list of dataObjects that match the search criteria.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<SearchResult>,
    /// Output only. A token to retrieve next page of results.
    /// Pass to \[DataObjectSearchService.SearchDataObjectsRequest.page_token\]\[\] to
    /// obtain that page.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Output only. Metadata about the search execution.
    #[prost(message, optional, tag = "3")]
    pub search_response_metadata: ::core::option::Option<SearchResponseMetadata>,
}
/// Request message for
/// \[DataObjectSearchService.AggregateDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectSearchService.AggregateDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateDataObjectsRequest {
    /// Required. The resource name of the Collection for which to query.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. A JSON filter expression, e.g. {"genre": {"$eq": "sci-fi"}},
    /// represented as a google.protobuf.Struct.
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<::prost_types::Struct>,
    /// Required. The aggregation method to apply to the query.
    #[prost(enumeration = "AggregationMethod", tag = "3")]
    pub aggregate: i32,
}
/// Response message for
/// \[DataObjectSearchService.AggregateDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectSearchService.AggregateDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateDataObjectsResponse {
    /// The aggregated results of the query.
    #[prost(message, repeated, tag = "1")]
    pub aggregate_results: ::prost::alloc::vec::Vec<::prost_types::Struct>,
}
/// Request message for
/// \[DataObjectSearchService.QueryDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectSearchService.QueryDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDataObjectsRequest {
    /// Required. The resource name of the Collection for which to query.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. A JSON filter expression, e.g. {"genre": {"$eq": "sci-fi"}},
    /// represented as a google.protobuf.Struct.
    #[prost(message, optional, tag = "2")]
    pub filter: ::core::option::Option<::prost_types::Struct>,
    /// Optional. Mask specifying which fields to return.
    #[prost(message, optional, tag = "7")]
    pub output_fields: ::core::option::Option<OutputFields>,
    /// Optional. The standard list page size.
    #[prost(int32, tag = "5")]
    pub page_size: i32,
    /// Optional. The standard list page token.
    /// Typically obtained via
    /// \[QueryDataObjectsResponse.next_page_token\]\[google.cloud.vectorsearch.v1beta.QueryDataObjectsResponse.next_page_token\]
    /// of the previous
    /// \[DataObjectSearchService.QueryDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectSearchService.QueryDataObjects\]
    /// call.
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for
/// \[DataObjectSearchService.QueryDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectSearchService.QueryDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDataObjectsResponse {
    /// The list of dataObjects that match the query.
    #[prost(message, repeated, tag = "4")]
    pub data_objects: ::prost::alloc::vec::Vec<DataObject>,
    /// A token to retrieve next page of results.
    /// Pass to \[DataObjectSearchService.QueryDataObjectsRequest.page_token\]\[\] to
    /// obtain that page.
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// A request to perform a batch of search operations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchSearchDataObjectsRequest {
    /// Required. The resource name of the Collection for which to search.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. A list of search requests to execute in parallel.
    #[prost(message, repeated, tag = "2")]
    pub searches: ::prost::alloc::vec::Vec<Search>,
    /// Optional. Options for combining the results of the batch search operations.
    #[prost(message, optional, tag = "3")]
    pub combine: ::core::option::Option<
        batch_search_data_objects_request::CombineResultsOptions,
    >,
}
/// Nested message and enum types in `BatchSearchDataObjectsRequest`.
pub mod batch_search_data_objects_request {
    /// Options for combining the results of the batch search operations.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CombineResultsOptions {
        /// Required. The ranker to use for combining the results.
        #[prost(message, optional, tag = "1")]
        pub ranker: ::core::option::Option<super::Ranker>,
        /// Optional. Mask specifying which fields to return.
        #[prost(message, optional, tag = "2")]
        pub output_fields: ::core::option::Option<super::OutputFields>,
        /// Optional. The number of results to return. If not set, a default value
        /// will be used.
        #[prost(int32, tag = "3")]
        pub top_k: i32,
    }
}
/// Defines a ranker to combine results from multiple searches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ranker {
    /// The ranking method to use.
    #[prost(oneof = "ranker::Ranker", tags = "1, 2")]
    pub ranker: ::core::option::Option<ranker::Ranker>,
}
/// Nested message and enum types in `Ranker`.
pub mod ranker {
    /// The ranking method to use.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Ranker {
        /// Reciprocal Rank Fusion ranking.
        #[prost(message, tag = "1")]
        Rrf(super::ReciprocalRankFusion),
        /// Vertex AI ranking.
        #[prost(message, tag = "2")]
        Vertex(super::VertexRanker),
    }
}
/// Defines the Reciprocal Rank Fusion (RRF) algorithm for result ranking.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReciprocalRankFusion {
    /// Required. The weights to apply to each search result set during fusion.
    #[prost(double, repeated, packed = "false", tag = "1")]
    pub weights: ::prost::alloc::vec::Vec<f64>,
}
/// Defines a ranker using the Vertex AI ranking service.
/// See <https://cloud.google.com/generative-ai-app-builder/docs/ranking> for
/// details.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VertexRanker {
    /// Required. The query against which the records are ranked and scored.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// Optional. The template used to generate the record's title.
    #[prost(string, tag = "2")]
    pub title_template: ::prost::alloc::string::String,
    /// Optional. The template used to generate the record's content.
    #[prost(string, tag = "3")]
    pub content_template: ::prost::alloc::string::String,
    /// Required. The model used for ranking documents. If no model is specified,
    /// then semantic-ranker-default@latest is used.
    #[prost(string, tag = "4")]
    pub model: ::prost::alloc::string::String,
}
/// A response from a batch search operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchSearchDataObjectsResponse {
    /// Output only. A list of search responses, one for each request in the batch.
    /// If a ranker is used, a single ranked list of results is returned.
    #[prost(message, repeated, tag = "1")]
    pub results: ::prost::alloc::vec::Vec<SearchDataObjectsResponse>,
}
/// Aggregation methods.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AggregationMethod {
    /// Should not be used.
    Unspecified = 0,
    /// Count the number of data objects that match the filter.
    Count = 1,
}
impl AggregationMethod {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AGGREGATION_METHOD_UNSPECIFIED",
            Self::Count => "COUNT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGGREGATION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
            "COUNT" => Some(Self::Count),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod data_object_search_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for searching data objects.
    #[derive(Debug, Clone)]
    pub struct DataObjectSearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataObjectSearchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataObjectSearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataObjectSearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataObjectSearchServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Searches data objects.
        pub async fn search_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchDataObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectSearchService/SearchDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectSearchService",
                        "SearchDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries data objects.
        pub async fn query_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryDataObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectSearchService/QueryDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectSearchService",
                        "QueryDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Aggregates data objects.
        pub async fn aggregate_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregateDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AggregateDataObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectSearchService/AggregateDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectSearchService",
                        "AggregateDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Batch searches data objects.
        pub async fn batch_search_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchSearchDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchSearchDataObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectSearchService/BatchSearchDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectSearchService",
                        "BatchSearchDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for
/// \[DataObjectService.CreateDataObject\]\[google.cloud.vectorsearch.v1beta.DataObjectService.CreateDataObject\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataObjectRequest {
    /// Required. The resource name of the Collection to create the DataObject in.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The id of the dataObject to create.
    /// The id must be 1-63 characters long, and comply with
    /// <a href="<https://www.ietf.org/rfc/rfc1035.txt"> target="_blank">RFC1035</a>.
    /// Specifically, it must be 1-63 characters long and match the regular
    /// expression `[a-z](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
    #[prost(string, tag = "2")]
    pub data_object_id: ::prost::alloc::string::String,
    /// Required. The DataObject to create.
    #[prost(message, optional, tag = "3")]
    pub data_object: ::core::option::Option<DataObject>,
}
/// Request message for
/// \[DataObjectService.BatchCreateDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectService.BatchCreateDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateDataObjectsRequest {
    /// Required. The resource name of the Collection to create the DataObjects in.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`.
    /// The parent field in the CreateDataObjectRequest messages must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request message specifying the resources to create.
    /// A maximum of 1000 DataObjects can be created in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateDataObjectRequest>,
}
/// Response message for
/// \[DataObjectService.BatchCreateDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectService.BatchCreateDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateDataObjectsResponse {
    /// DataObjects created.
    #[prost(message, repeated, tag = "1")]
    pub data_objects: ::prost::alloc::vec::Vec<DataObject>,
}
/// Request message for
/// \[DataObjectService.GetDataObject\]\[google.cloud.vectorsearch.v1beta.DataObjectService.GetDataObject\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetDataObjectRequest {
    /// Required. The name of the DataObject resource.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataObjects/{dataObject}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[DataObjectService.UpdateDataObject\]\[google.cloud.vectorsearch.v1beta.DataObjectService.UpdateDataObject\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataObjectRequest {
    /// Required. The DataObject which replaces the resource on the server.
    #[prost(message, optional, tag = "1")]
    pub data_object: ::core::option::Option<DataObject>,
    /// Optional. The update mask applies to the resource. See
    /// \[google.protobuf.FieldMask\]\[google.protobuf.FieldMask\].
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for
/// \[DataObjectService.BatchUpdateDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectService.BatchUpdateDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateDataObjectsRequest {
    /// Required. The resource name of the Collection to update the DataObjects in.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`.
    /// The parent field in the UpdateDataObjectRequest messages must match this
    /// field.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request message specifying the resources to update.
    /// A maximum of 1000 DataObjects can be updated in a batch.
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateDataObjectRequest>,
}
/// Response message for
/// \[DataObjectService.BatchUpdateDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectService.BatchUpdateDataObjects\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatchUpdateDataObjectsResponse {}
/// Request message for
/// \[DataObjectService.DeleteDataObject\]\[google.cloud.vectorsearch.v1beta.DataObjectService.DeleteDataObject\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteDataObjectRequest {
    /// Required. The name of the DataObject resource to be deleted.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/dataObjects/{dataObject}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[DataObjectService.BatchDeleteDataObjects\]\[google.cloud.vectorsearch.v1beta.DataObjectService.BatchDeleteDataObjects\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteDataObjectsRequest {
    /// Required. The resource name of the Collection to delete the DataObjects in.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request message specifying the resources to delete.
    /// A maximum of 1000 DataObjects can be deleted in a batch.
    #[prost(message, repeated, tag = "3")]
    pub requests: ::prost::alloc::vec::Vec<DeleteDataObjectRequest>,
}
/// Generated client implementations.
pub mod data_object_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for creating and managing data objects.
    #[derive(Debug, Clone)]
    pub struct DataObjectServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataObjectServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataObjectServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataObjectServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataObjectServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a dataObject.
        pub async fn create_data_object(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataObjectRequest>,
        ) -> std::result::Result<tonic::Response<super::DataObject>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/CreateDataObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "CreateDataObject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a batch of dataObjects.
        pub async fn batch_create_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateDataObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/BatchCreateDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "BatchCreateDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a data object.
        pub async fn get_data_object(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataObjectRequest>,
        ) -> std::result::Result<tonic::Response<super::DataObject>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/GetDataObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "GetDataObject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a dataObject.
        pub async fn update_data_object(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataObjectRequest>,
        ) -> std::result::Result<tonic::Response<super::DataObject>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/UpdateDataObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "UpdateDataObject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates dataObjects in a batch.
        pub async fn batch_update_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateDataObjectsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/BatchUpdateDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "BatchUpdateDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a dataObject.
        pub async fn delete_data_object(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataObjectRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/DeleteDataObject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "DeleteDataObject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes dataObjects in a batch.
        pub async fn batch_delete_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteDataObjectsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.DataObjectService/BatchDeleteDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.DataObjectService",
                        "BatchDeleteDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Message describing Collection object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Collection {
    /// Identifier. name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User-specified display name of the collection
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-specified description of the collection
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Output only. \[Output only\] Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Deprecated: JSON Schema for data. Please use data_schema instead.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub schema: ::core::option::Option<::prost_types::Struct>,
    /// Optional. Schema for vector fields. Only vector fields in this schema will
    /// be searchable. Field names must contain only alphanumeric characters,
    /// underscores, and hyphens.
    #[prost(map = "string, message", tag = "7")]
    pub vector_schema: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        VectorField,
    >,
    /// Optional. JSON Schema for data.
    /// Field names must contain only alphanumeric characters,
    /// underscores, and hyphens.
    #[prost(message, optional, tag = "10")]
    pub data_schema: ::core::option::Option<::prost_types::Struct>,
}
/// Message describing a vector field.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct VectorField {
    /// Vector type configuration.
    #[prost(oneof = "vector_field::VectorTypeConfig", tags = "3, 4")]
    pub vector_type_config: ::core::option::Option<vector_field::VectorTypeConfig>,
}
/// Nested message and enum types in `VectorField`.
pub mod vector_field {
    /// Vector type configuration.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum VectorTypeConfig {
        /// Dense vector field.
        #[prost(message, tag = "3")]
        DenseVector(super::DenseVectorField),
        /// Sparse vector field.
        #[prost(message, tag = "4")]
        SparseVector(super::SparseVectorField),
    }
}
/// Message describing a dense vector field.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DenseVectorField {
    /// Dimensionality of the vector field.
    #[prost(int32, tag = "1")]
    pub dimensions: i32,
    /// Optional. Configuration for generating embeddings for the vector field. If
    /// not specified, the embedding field must be populated in the DataObject.
    #[prost(message, optional, tag = "3")]
    pub vertex_embedding_config: ::core::option::Option<VertexEmbeddingConfig>,
}
/// Message describing a sparse vector field.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SparseVectorField {}
/// Message for requesting list of Collections
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCollectionsRequest {
    /// Required. Parent value for ListCollectionsRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Collections
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCollectionsResponse {
    /// The list of Collection
    #[prost(message, repeated, tag = "1")]
    pub collections: ::prost::alloc::vec::Vec<Collection>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a Collection
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCollectionRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a Collection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCollectionRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the Collection to create.
    /// The id must be 1-63 characters long, and comply with
    /// <a href="<https://www.ietf.org/rfc/rfc1035.txt"> target="_blank">RFC1035</a>.
    /// Specifically, it must be 1-63 characters long and match the regular
    /// expression `[a-z](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub collection: ::core::option::Option<Collection>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a Collection
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCollectionRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Collection resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten.
    ///
    /// The following fields support update: `display_name`, `description`,
    /// `labels`, `data_schema`, `vector_schema`.
    /// For `data_schema` and `vector_schema`, fields can only be added, not
    /// modified or deleted.
    /// Partial updates for `data_schema` and `vector_schema` are also supported
    /// by using sub-field paths in `update_mask`, e.g.
    /// `data_schema.properties.foo` or `vector_schema.my_vector_field`.
    ///
    /// If `*` is provided in the update_mask, full replacement will be performed.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub collection: ::core::option::Option<Collection>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a Collection
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCollectionRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message describing Index object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
    /// Identifier. name of resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User-specified display name of the index
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. User-specified description of the index
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Labels as key value pairs.
    #[prost(map = "string, string", tag = "10")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. \[Output only\] Create time stamp
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] Update time stamp
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Distance metric used for indexing. If not specified, will default
    /// to DOT_PRODUCT.
    #[prost(enumeration = "DistanceMetric", tag = "4")]
    pub distance_metric: i32,
    /// Required. The collection schema field to index.
    #[prost(string, tag = "5")]
    pub index_field: ::prost::alloc::string::String,
    /// Optional. The fields to push into the index to enable fast ANN inline
    /// filtering.
    #[prost(string, repeated, tag = "6")]
    pub filter_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The fields to push into the index to enable inline data
    /// retrieval.
    #[prost(string, repeated, tag = "7")]
    pub store_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for creating an Index.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIndexRequest {
    /// Required. The resource name of the Collection for which to create the
    /// Index. Format:
    /// `projects/{project}/locations/{location}/collections/{collection}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the Index to create.
    /// The id must be 1-63 characters long, and comply with
    /// <a href="<https://www.ietf.org/rfc/rfc1035.txt"> target="_blank">RFC1035</a>.
    /// Specifically, it must be 1-63 characters long and match the regular
    /// expression `[a-z](?:\[-a-z0-9\]{0,61}\[a-z0-9\])?`.
    #[prost(string, tag = "2")]
    pub index_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub index: ::core::option::Option<Index>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting an Index.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIndexRequest {
    /// Required. The resource name of the Index to delete.
    /// Format:
    /// `projects/{project}/locations/{location}/collections/{collection}/indexes/{index}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for requesting list of Indexes
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIndexesRequest {
    /// Required. Parent value for ListIndexesRequest
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Hint for how to order the results
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing Indexes
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIndexesResponse {
    /// The list of Index
    #[prost(message, repeated, tag = "1")]
    pub indexes: ::prost::alloc::vec::Vec<Index>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Message for getting an Index
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIndexRequest {
    /// Required. Name of the resource
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have
    /// \[google.longrunning.Operation.error\]\[google.longrunning.Operation.error\]
    /// value with a \[google.rpc.Status.code\]\[google.rpc.Status.code\] of `1`,
    /// corresponding to `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Request message for \[DataObjectService.ImportDataObjects\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportDataObjectsRequest {
    /// Required. The resource name of the Collection to import DataObjects into.
    /// Format: `projects/{project}/locations/{location}/collections/{collection}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The configuration for the import data and error results.
    #[prost(oneof = "import_data_objects_request::Config", tags = "2")]
    pub config: ::core::option::Option<import_data_objects_request::Config>,
}
/// Nested message and enum types in `ImportDataObjectsRequest`.
pub mod import_data_objects_request {
    /// Google Cloud Storage configuration for the import.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GcsImportConfig {
        /// Required. URI prefix of the Cloud Storage DataObjects to import.
        #[prost(string, tag = "1")]
        pub contents_uri: ::prost::alloc::string::String,
        /// Required. URI prefix of the Cloud Storage location to write any errors
        /// encountered during the import.
        #[prost(string, tag = "2")]
        pub error_uri: ::prost::alloc::string::String,
    }
    /// The configuration for the import data and error results.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Config {
        /// The Cloud Storage location of the input content.
        #[prost(message, tag = "2")]
        GcsImport(GcsImportConfig),
    }
}
/// Metadata for \[DataObjectService.ImportDataObjects\]\[\].
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImportDataObjectsMetadata {
    /// The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The time the operation was last updated.
    #[prost(message, optional, tag = "2")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Number of DataObjects that were processed successfully.
    #[prost(int64, tag = "3")]
    pub success_count: i64,
    /// Number of DataObjects that failed during processing.
    #[prost(int64, tag = "4")]
    pub failure_count: i64,
}
/// Response for \[DataObjectService.ImportDataObjects\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportDataObjectsResponse {
    /// Status of the LRO
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<super::super::super::rpc::Status>,
}
/// Generated client implementations.
pub mod vector_search_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// VectorSearchService provides methods for managing Collection resources, and
    /// Collection Index resources. The primary resources offered by this service are
    /// Collections which are a container for a set of related JSON data objects, and
    /// Collection Indexes which enable efficient ANN search across data objects
    /// within a Collection.
    #[derive(Debug, Clone)]
    pub struct VectorSearchServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl VectorSearchServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> VectorSearchServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VectorSearchServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            VectorSearchServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Collections in a given project and location.
        pub async fn list_collections(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCollectionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCollectionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/ListCollections",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "ListCollections",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Collection.
        pub async fn get_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCollectionRequest>,
        ) -> std::result::Result<tonic::Response<super::Collection>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/GetCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "GetCollection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Collection in a given project and location.
        pub async fn create_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/CreateCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "CreateCollection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Collection.
        pub async fn update_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/UpdateCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "UpdateCollection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Collection.
        pub async fn delete_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/DeleteCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "DeleteCollection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Indexes in a given project and location.
        pub async fn list_indexes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIndexesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIndexesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/ListIndexes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "ListIndexes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Index.
        pub async fn get_index(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIndexRequest>,
        ) -> std::result::Result<tonic::Response<super::Index>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/GetIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "GetIndex",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Index in a given project and location.
        pub async fn create_index(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/CreateIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "CreateIndex",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Index.
        pub async fn delete_index(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIndexRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/DeleteIndex",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "DeleteIndex",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a Long-Running Operation to import DataObjects into a Collection.
        pub async fn import_data_objects(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportDataObjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.vectorsearch.v1beta.VectorSearchService/ImportDataObjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.vectorsearch.v1beta.VectorSearchService",
                        "ImportDataObjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
