// This file is @generated by prost-build.
/// An Actor represents an entity that performed an action. For example, an actor
/// could be a user who posted a comment on a support case, a user who
/// uploaded an attachment, or a service account that created a support case.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Actor {
    /// The name to display for the actor. If not provided, it is inferred from
    /// credentials supplied during case creation. When an email is provided, a
    /// display name must also be provided. This will be obfuscated if the user
    /// is a Google Support agent.
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    /// The email address of the actor. If not provided, it is inferred from the
    /// credentials supplied during case creation. When a name is provided, an
    /// email must also be provided. If the user is a Google Support agent, this is
    /// obfuscated.
    ///
    /// This field is deprecated. Use `username` instead.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub email: ::prost::alloc::string::String,
    /// Output only. Whether the actor is a Google support actor.
    #[prost(bool, tag = "4")]
    pub google_support: bool,
    /// Output only. The username of the actor. It may look like an email or other
    /// format provided by the identity provider. If not provided, it is inferred
    /// from the credentials supplied. When a name is provided, a username must
    /// also be provided. If the user is a Google Support agent, this will not be
    /// set.
    #[prost(string, tag = "5")]
    pub username: ::prost::alloc::string::String,
}
/// An Attachment contains metadata about a file that was uploaded to a
/// case - it is NOT a file itself. That being said, the name of an Attachment
/// object can be used to download its accompanying file through the
/// `media.download` endpoint.
///
/// While attachments can be uploaded in the console at the
/// same time as a comment, they're associated on a "case" level, not a
/// "comment" level.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Attachment {
    /// Output only. Identifier. The resource name of the attachment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time at which the attachment was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The user who uploaded the attachment. Note, the name and email
    /// will be obfuscated if the attachment was uploaded by Google support.
    #[prost(message, optional, tag = "3")]
    pub creator: ::core::option::Option<Actor>,
    /// The filename of the attachment (e.g. `"graph.jpg"`).
    #[prost(string, tag = "4")]
    pub filename: ::prost::alloc::string::String,
    /// Output only. The MIME type of the attachment (e.g. text/plain).
    #[prost(string, tag = "5")]
    pub mime_type: ::prost::alloc::string::String,
    /// Output only. The size of the attachment in bytes.
    #[prost(int64, tag = "6")]
    pub size_bytes: i64,
}
/// The request message for the ListAttachments endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAttachmentsRequest {
    /// Required. The name of the case for which attachments should be listed.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of attachments fetched with each request.
    ///
    /// If not provided, the default is 10. The maximum page size that will be
    /// returned is 100.
    ///
    /// The size of each page can be smaller than the requested page size and can
    /// include zero. For example, you could request 100 attachments on one page,
    /// receive 0, and then on the next page, receive 90.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Request for getting an attachment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAttachmentRequest {
    /// Required. The name of the attachment to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The response message for the ListAttachments endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAttachmentsResponse {
    /// The list of attachments associated with a case.
    #[prost(message, repeated, tag = "1")]
    pub attachments: ::prost::alloc::vec::Vec<Attachment>,
    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `cases.attachments.list` requests. If unspecified,
    /// there are no more results to retrieve.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod case_attachment_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service to manage file attachments for Google Cloud support cases.
    #[derive(Debug, Clone)]
    pub struct CaseAttachmentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CaseAttachmentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CaseAttachmentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CaseAttachmentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CaseAttachmentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List all the attachments associated with a support case.
        pub async fn list_attachments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAttachmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseAttachmentService/ListAttachments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseAttachmentService",
                        "ListAttachments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve an attachment.
        pub async fn get_attachment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Attachment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseAttachmentService/GetAttachment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseAttachmentService",
                        "GetAttachment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A Case is an object that contains the details of a support case. It
/// contains fields for the time it was created, its priority, its
/// classification, and more. Cases can also have comments and attachments that
/// get added over time.
///
/// A case is parented by a Google Cloud organization or project.
///
/// Organizations are identified by a number, so the name of a case parented by
/// an organization would look like this:
///
/// ```text,
/// organizations/123/cases/456
/// ```
///
/// Projects have two unique identifiers, an ID and a number, and they look like
/// this:
///
/// ```text,
/// projects/abc/cases/456
/// ```
///
/// ```text,
/// projects/123/cases/456
/// ```
///
/// You can use either of them when calling the API. To learn more
/// about project identifiers, see [AIP-2510](<https://google.aip.dev/cloud/2510>).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Case {
    /// Identifier. The resource name for the case.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The short summary of the issue reported in this case.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// A broad description of the issue.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// The issue classification applicable to this case.
    #[prost(message, optional, tag = "4")]
    pub classification: ::core::option::Option<CaseClassification>,
    /// The timezone of the user who created the support case.
    /// It should be in a format IANA recognizes: <https://www.iana.org/time-zones.>
    /// There is no additional validation done by the API.
    #[prost(string, tag = "8")]
    pub time_zone: ::prost::alloc::string::String,
    /// The email addresses to receive updates on this case.
    #[prost(string, repeated, tag = "9")]
    pub subscriber_email_addresses: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. The current status of the support case.
    #[prost(enumeration = "case::State", tag = "12")]
    pub state: i32,
    /// Output only. The time this case was created.
    #[prost(message, optional, tag = "13")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time this case was last updated.
    #[prost(message, optional, tag = "14")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The user who created the case.
    ///
    /// Note: The name and email will be obfuscated if the case was created by
    /// Google Support.
    #[prost(message, optional, tag = "15")]
    pub creator: ::core::option::Option<Actor>,
    /// A user-supplied email address to send case update notifications for. This
    /// should only be used in BYOID flows, where we cannot infer the user's email
    /// address directly from their EUCs.
    #[prost(string, tag = "35")]
    pub contact_email: ::prost::alloc::string::String,
    /// Whether the case is currently escalated.
    #[prost(bool, tag = "17")]
    pub escalated: bool,
    /// Whether this case was created for internal API testing and should not be
    /// acted on by the support team.
    #[prost(bool, tag = "19")]
    pub test_case: bool,
    /// The language the user has requested to receive support in. This should be a
    /// BCP 47 language code (e.g., `"en"`, `"zh-CN"`, `"zh-TW"`, `"ja"`, `"ko"`).
    /// If no language or an unsupported language is specified, this field defaults
    /// to English (en).
    ///
    /// Language selection during case creation may affect your available support
    /// options. For a list of supported languages and their support working hours,
    /// see: <https://cloud.google.com/support/docs/language-working-hours>
    #[prost(string, tag = "23")]
    pub language_code: ::prost::alloc::string::String,
    /// The priority of this case.
    #[prost(enumeration = "case::Priority", tag = "32")]
    pub priority: i32,
}
/// Nested message and enum types in `Case`.
pub mod case {
    /// The status of a support case.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Case is in an unknown state.
        Unspecified = 0,
        /// The case has been created but no one is assigned to work on it yet.
        New = 1,
        /// The case is currently being handled by Google support.
        InProgressGoogleSupport = 2,
        /// Google is waiting for a response.
        ActionRequired = 3,
        /// A solution has been offered for the case, but it isn't yet closed.
        SolutionProvided = 4,
        /// The case has been resolved.
        Closed = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::New => "NEW",
                Self::InProgressGoogleSupport => "IN_PROGRESS_GOOGLE_SUPPORT",
                Self::ActionRequired => "ACTION_REQUIRED",
                Self::SolutionProvided => "SOLUTION_PROVIDED",
                Self::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEW" => Some(Self::New),
                "IN_PROGRESS_GOOGLE_SUPPORT" => Some(Self::InProgressGoogleSupport),
                "ACTION_REQUIRED" => Some(Self::ActionRequired),
                "SOLUTION_PROVIDED" => Some(Self::SolutionProvided),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
    /// The case Priority. P0 is most urgent and P4 the least.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Priority {
        /// Priority is undefined or has not been set yet.
        Unspecified = 0,
        /// Extreme impact on a production service. Service is hard down.
        P0 = 1,
        /// Critical impact on a production service. Service is currently unusable.
        P1 = 2,
        /// Severe impact on a production service. Service is usable but greatly
        /// impaired.
        P2 = 3,
        /// Medium impact on a production service.  Service is available, but
        /// moderately impaired.
        P3 = 4,
        /// General questions or minor issues.  Production service is fully
        /// available.
        P4 = 5,
    }
    impl Priority {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PRIORITY_UNSPECIFIED",
                Self::P0 => "P0",
                Self::P1 => "P1",
                Self::P2 => "P2",
                Self::P3 => "P3",
                Self::P4 => "P4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRIORITY_UNSPECIFIED" => Some(Self::Unspecified),
                "P0" => Some(Self::P0),
                "P1" => Some(Self::P1),
                "P2" => Some(Self::P2),
                "P3" => Some(Self::P3),
                "P4" => Some(Self::P4),
                _ => None,
            }
        }
    }
}
/// A Case Classification represents the topic that a case is about. It's very
/// important to use accurate classifications, because they're
/// used to route your cases to specialists who can help you.
///
/// A classification always has an ID that is its unique identifier.
/// A valid ID is required when creating a case.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CaseClassification {
    /// The unique ID for a classification. Must be specified for case creation.
    ///
    /// To retrieve valid classification IDs for case creation, use
    /// `caseClassifications.search`.
    ///
    /// Classification IDs returned by `caseClassifications.search` are guaranteed
    /// to be valid for at least 6 months. If a given classification is
    /// deactiveated, it will immediately stop being returned. After 6 months,
    /// `case.create` requests using the classification ID will fail.
    #[prost(string, tag = "3")]
    pub id: ::prost::alloc::string::String,
    /// A display name for the classification.
    ///
    /// The display name is not static and can change. To uniquely and consistently
    /// identify classifications, use the `CaseClassification.id` field.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// The full product the classification corresponds to.
    #[prost(message, optional, tag = "10")]
    pub product: ::core::option::Option<Product>,
}
/// The product a case may be associated with.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Product {
    /// The product line of the Product.
    #[prost(enumeration = "ProductLine", tag = "1")]
    pub product_line: i32,
}
/// The product line a support case may be associated with.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProductLine {
    /// Unknown product type.
    Unspecified = 0,
    /// Google Cloud
    GoogleCloud = 1,
    /// Google Maps
    GoogleMaps = 2,
}
impl ProductLine {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRODUCT_LINE_UNSPECIFIED",
            Self::GoogleCloud => "GOOGLE_CLOUD",
            Self::GoogleMaps => "GOOGLE_MAPS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRODUCT_LINE_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_CLOUD" => Some(Self::GoogleCloud),
            "GOOGLE_MAPS" => Some(Self::GoogleMaps),
            _ => None,
        }
    }
}
/// An escalation of a support case.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Escalation {
    /// Required. The reason why the Case is being escalated.
    #[prost(enumeration = "escalation::Reason", tag = "4")]
    pub reason: i32,
    /// Required. A free text description to accompany the `reason` field above.
    /// Provides additional context on why the case is being escalated.
    #[prost(string, tag = "5")]
    pub justification: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Escalation`.
pub mod escalation {
    /// An enum detailing the possible reasons a case may be escalated.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        /// The escalation reason is in an unknown state or has not been specified.
        Unspecified = 0,
        /// The case is taking too long to resolve.
        ResolutionTime = 1,
        /// The support agent does not have the expertise required to successfully
        /// resolve the issue.
        TechnicalExpertise = 2,
        /// The issue is having a significant business impact.
        BusinessImpact = 3,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REASON_UNSPECIFIED",
                Self::ResolutionTime => "RESOLUTION_TIME",
                Self::TechnicalExpertise => "TECHNICAL_EXPERTISE",
                Self::BusinessImpact => "BUSINESS_IMPACT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_UNSPECIFIED" => Some(Self::Unspecified),
                "RESOLUTION_TIME" => Some(Self::ResolutionTime),
                "TECHNICAL_EXPERTISE" => Some(Self::TechnicalExpertise),
                "BUSINESS_IMPACT" => Some(Self::BusinessImpact),
                _ => None,
            }
        }
    }
}
/// The request message for the GetCase endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCaseRequest {
    /// Required. The full name of a case to be retrieved.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for the CreateCase endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateCaseRequest {
    /// Required. The name of the parent under which the case should be created.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The case to be created.
    #[prost(message, optional, tag = "2")]
    pub case: ::core::option::Option<Case>,
}
/// The request message for the ListCases endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCasesRequest {
    /// Required. The name of a parent to list cases under.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// An expression used to filter cases.
    ///
    /// If it's an empty string, then no filtering happens. Otherwise, the endpoint
    /// returns the cases that match the filter.
    ///
    /// Expressions use the following fields separated by `AND` and specified with
    /// `=`:
    ///
    /// * `state`: Can be `OPEN` or `CLOSED`.
    /// * `priority`: Can be `P0`, `P1`, `P2`, `P3`, or `P4`. You
    ///   can specify multiple values for priority using the `OR` operator. For
    ///   example, `priority=P1 OR priority=P2`.
    /// * `creator.email`: The email address of the case creator.
    ///
    /// EXAMPLES:
    ///
    /// * `state=CLOSED`
    /// * `state=OPEN AND creator.email="tester@example.com"`
    /// * `state=OPEN AND (priority=P0 OR priority=P1)`
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
    /// The maximum number of cases fetched with each request. Defaults to 10.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
    /// The product line to request cases for. If unspecified, only
    /// Google Cloud cases will be returned.
    #[prost(enumeration = "ProductLine", optional, tag = "8")]
    pub product_line: ::core::option::Option<i32>,
}
/// The response message for the ListCases endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCasesResponse {
    /// The list of cases associated with the parent after any
    /// filters have been applied.
    #[prost(message, repeated, tag = "1")]
    pub cases: ::prost::alloc::vec::Vec<Case>,
    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `cases.list` requests. If unspecified, there are no
    /// more results to retrieve.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for the SearchCases endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchCasesRequest {
    /// The name of the parent resource to search for cases under.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
    /// An expression used to filter cases.
    ///
    /// Expressions use the following fields separated by `AND` and specified with
    /// `=`:
    ///
    /// * `organization`: An organization name in the form
    ///   `organizations/<organization_id>`.
    /// * `project`: A project name in the form `projects/<project_id>`.
    /// * `state`: Can be `OPEN` or `CLOSED`.
    /// * `priority`: Can be `P0`, `P1`, `P2`, `P3`, or `P4`. You
    ///   can specify multiple values for priority using the `OR` operator. For
    ///   example, `priority=P1 OR priority=P2`.
    /// * `creator.email`: The email address of the case creator.
    ///
    /// You must specify either `organization` or `project`.
    ///
    /// To search across `displayName`, `description`, and comments, use a global
    /// restriction with no keyword or operator. For example, `"my search"`.
    ///
    /// To search only cases updated after a certain date, use `update_time`
    /// restricted with that particular date, time, and timezone in ISO datetime
    /// format. For example, `update_time>"2020-01-01T00:00:00-05:00"`.
    /// `update_time` only supports the greater than operator (`>`).
    ///
    /// Examples:
    ///
    /// * `organization="organizations/123456789"`
    /// * `project="projects/my-project-id"`
    /// * `project="projects/123456789"`
    /// * `organization="organizations/123456789" AND state=CLOSED`
    /// * `project="projects/my-project-id" AND creator.email="tester@example.com"`
    /// * `project="projects/my-project-id" AND (priority=P0 OR priority=P1)`
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// The maximum number of cases fetched with each request. The default page
    /// size is 10.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message for the SearchCases endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCasesResponse {
    /// The list of cases associated with the parent after any
    /// filters have been applied.
    #[prost(message, repeated, tag = "1")]
    pub cases: ::prost::alloc::vec::Vec<Case>,
    /// A token to retrieve the next page of results. Set this in the
    /// `page_token` field of subsequent `cases.search` requests. If unspecified,
    /// there are no more results to retrieve.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for the EscalateCase endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EscalateCaseRequest {
    /// Required. The name of the case to be escalated.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The escalation information to be sent with the escalation request.
    #[prost(message, optional, tag = "2")]
    pub escalation: ::core::option::Option<Escalation>,
}
/// The request message for the UpdateCase endpoint
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateCaseRequest {
    /// Required. The case to update.
    #[prost(message, optional, tag = "1")]
    pub case: ::core::option::Option<Case>,
    /// A list of attributes of the case that should be updated. Supported values
    /// are `priority`, `display_name`, and `subscriber_email_addresses`. If no
    /// fields are specified, all supported fields are updated.
    ///
    /// Be careful - if you do not provide a field mask, then you might
    /// accidentally clear some fields. For example, if you leave the field mask
    /// empty and do not provide a value for `subscriber_email_addresses`, then
    /// `subscriber_email_addresses` is updated to empty.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request message for the CloseCase endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloseCaseRequest {
    /// Required. The name of the case to close.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for the SearchCaseClassifications endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchCaseClassificationsRequest {
    /// An expression used to filter case classifications.
    ///
    /// If it's an empty string, then no filtering happens. Otherwise, case
    /// classifications will be returned that match the filter.
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    /// The maximum number of classifications fetched with each request.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// A token identifying the page of results to return. If unspecified, the
    /// first page is retrieved.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The product to return case classifications for.
    #[prost(message, optional, tag = "7")]
    pub product: ::core::option::Option<Product>,
}
/// The response message for SearchCaseClassifications endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCaseClassificationsResponse {
    /// The classifications retrieved.
    #[prost(message, repeated, tag = "1")]
    pub case_classifications: ::prost::alloc::vec::Vec<CaseClassification>,
    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `caseClassifications.list` requests. If unspecified,
    /// there are no more results to retrieve.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod case_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service to manage Google Cloud support cases.
    #[derive(Debug, Clone)]
    pub struct CaseServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CaseServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CaseServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CaseServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CaseServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieve a case.
        pub async fn get_case(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Case>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/GetCase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.support.v2beta.CaseService", "GetCase"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve all cases under a parent, but not its children.
        ///
        /// For example, listing cases under an organization only returns the cases
        /// that are directly parented by that organization. To retrieve cases
        /// under an organization and its projects, use `cases.search`.
        pub async fn list_cases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/ListCases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "ListCases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Search for cases using a query.
        pub async fn search_cases(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchCasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchCasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/SearchCases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "SearchCases",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a new case and associate it with a parent.
        ///
        /// It must have the following fields set: `display_name`, `description`,
        /// `classification`, and `priority`. If you're just testing the API and don't
        /// want to route your case to an agent, set `testCase=true`.
        pub async fn create_case(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Case>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/CreateCase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "CreateCase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update a case. Only some fields can be updated.
        pub async fn update_case(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Case>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/UpdateCase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "UpdateCase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Escalate a case, starting the Google Cloud Support escalation management
        /// process.
        ///
        /// This operation is only available for some support services. Go to
        /// https://cloud.google.com/support and look for 'Technical support
        /// escalations' in the feature list to find out which ones let you
        /// do that.
        pub async fn escalate_case(
            &mut self,
            request: impl tonic::IntoRequest<super::EscalateCaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Case>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/EscalateCase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "EscalateCase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Close a case.
        pub async fn close_case(
            &mut self,
            request: impl tonic::IntoRequest<super::CloseCaseRequest>,
        ) -> std::result::Result<tonic::Response<super::Case>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/CloseCase",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "CloseCase",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve valid classifications to use when creating a support case.
        ///
        /// Classifications are hierarchical. Each classification is a string
        /// containing all levels of the hierarchy separated by `" > "`. For example,
        /// `"Technical Issue > Compute > Compute Engine"`.
        ///
        /// Classification IDs returned by this endpoint are valid for at least six
        /// months. When a classification is deactivated, this endpoint immediately
        /// stops returning it. After six months, `case.create` requests using the
        /// classification will fail.
        pub async fn search_case_classifications(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchCaseClassificationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchCaseClassificationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CaseService/SearchCaseClassifications",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CaseService",
                        "SearchCaseClassifications",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A comment associated with a support case.
///
/// Case comments are the primary way for Google Support to communicate with a
/// user who has opened a case. When a user responds to Google Support, the
/// user's responses also appear as comments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Comment {
    /// Output only. Identifier. The resource name of the comment.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The time when the comment was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The user or Google Support agent who created the comment.
    #[prost(message, optional, tag = "3")]
    pub creator: ::core::option::Option<Actor>,
    /// The full comment body.
    ///
    /// Maximum of 12800 characters.
    #[prost(string, tag = "4")]
    pub body: ::prost::alloc::string::String,
    /// Output only. DEPRECATED. DO NOT USE.
    ///
    /// A duplicate of the `body` field.
    ///
    /// This field is only present for legacy reasons.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub plain_text_body: ::prost::alloc::string::String,
}
/// The request message for the ListComments endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCommentsRequest {
    /// Required. The name of the case for which to list comments.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of comments to fetch. Defaults to 10.
    #[prost(int32, tag = "4")]
    pub page_size: i32,
    /// A token identifying the page of results to return. If unspecified, the
    /// first page is returned.
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message for the ListComments endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCommentsResponse {
    /// List of the comments associated with the case.
    #[prost(message, repeated, tag = "1")]
    pub comments: ::prost::alloc::vec::Vec<Comment>,
    /// A token to retrieve the next page of results. Set this in the `page_token`
    /// field of subsequent `cases.comments.list` requests. If unspecified, there
    /// are no more results to retrieve.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for the CreateComment endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateCommentRequest {
    /// Required. The name of the case to which the comment should be added.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The comment to be added.
    #[prost(message, optional, tag = "2")]
    pub comment: ::core::option::Option<Comment>,
}
/// The request message for the GetComment endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCommentRequest {
    /// Required. The name of the comment to retrieve.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod comment_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service to manage comments on cases.
    #[derive(Debug, Clone)]
    pub struct CommentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CommentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CommentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CommentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CommentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List all the comments associated with a case.
        pub async fn list_comments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCommentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCommentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CommentService/ListComments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CommentService",
                        "ListComments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add a new comment to a case.
        ///
        /// The comment must have the following fields set: `body`.
        pub async fn create_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CommentService/CreateComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CommentService",
                        "CreateComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a comment.
        pub async fn get_comment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommentRequest>,
        ) -> std::result::Result<tonic::Response<super::Comment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.CommentService/GetComment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.CommentService",
                        "GetComment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Stores text attached to a support object.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TextContent {
    /// Content in this field should be rendered and interpreted as-is.
    #[prost(string, tag = "1")]
    pub plain_text: ::prost::alloc::string::String,
}
/// An email associated with a support case.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EmailMessage {
    /// Identifier. Resource name for the email message.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Time when this email message object was created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The user or Google Support agent that created this email
    /// message. This is inferred from the headers on the email message.
    #[prost(message, optional, tag = "3")]
    pub actor: ::core::option::Option<Actor>,
    /// Output only. Subject of the email.
    #[prost(string, tag = "4")]
    pub subject: ::prost::alloc::string::String,
    /// Output only. Email addresses the email was sent to.
    #[prost(string, repeated, tag = "5")]
    pub recipient_email_addresses: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Output only. Email addresses CCed on the email.
    #[prost(string, repeated, tag = "6")]
    pub cc_email_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. The full email message body. A best-effort attempt is made to
    /// remove extraneous reply threads.
    #[prost(message, optional, tag = "8")]
    pub body_content: ::core::option::Option<TextContent>,
}
/// A feed item associated with a support case.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FeedItem {
    /// Output only. Time corresponding to the event of this item.
    #[prost(message, optional, tag = "1")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The object corresponding to the event.
    #[prost(oneof = "feed_item::EventObject", tags = "100, 101, 102, 103")]
    pub event_object: ::core::option::Option<feed_item::EventObject>,
}
/// Nested message and enum types in `FeedItem`.
pub mod feed_item {
    /// The object corresponding to the event.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum EventObject {
        /// Output only. A comment added to the case.
        #[prost(message, tag = "100")]
        Comment(super::Comment),
        /// Output only. An attachment attached to the case.
        #[prost(message, tag = "101")]
        Attachment(super::Attachment),
        /// Output only. An email message received in reply to the case.
        #[prost(message, tag = "102")]
        EmailMessage(super::EmailMessage),
        /// Output only. A deleted attachment that used to be associated with the
        /// support case.
        #[prost(message, tag = "103")]
        DeletedAttachment(super::Attachment),
    }
}
/// The request message for the ShowFeed endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ShowFeedRequest {
    /// Required. The resource name of the case for which feed items should be
    /// listed.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Field to order feed items by, followed by `asc` or `desc`
    /// postfix. The only valid field is
    /// `creation_time`. This list is case-insensitive, default sorting order is
    /// ascending, and the redundant space characters are insignificant.
    ///
    /// Example: `creation_time desc`
    #[prost(string, tag = "2")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. The maximum number of feed items fetched with each request.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A token identifying the page of results to return. If
    /// unspecified, it retrieves the first page.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message for the ShowFeed endpoint.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShowFeedResponse {
    /// The list of feed items associated with the given Case.
    #[prost(message, repeated, tag = "1")]
    pub feed_items: ::prost::alloc::vec::Vec<FeedItem>,
    /// A token to retrieve the next page of results. This should be set in the
    /// `page_token` field of subsequent `ShowFeedRequests`.
    /// If unspecified, there are no more results to retrieve.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod feed_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service to view case feed items.
    #[derive(Debug, Clone)]
    pub struct FeedServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl FeedServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> FeedServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FeedServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            FeedServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Show items in the feed of this case, including case emails,
        /// attachments, and comments.
        pub async fn show_feed(
            &mut self,
            request: impl tonic::IntoRequest<super::ShowFeedRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ShowFeedResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.support.v2beta.FeedService/ShowFeed",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.support.v2beta.FeedService",
                        "ShowFeed",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
