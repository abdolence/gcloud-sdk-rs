// This file is @generated by prost-build.
/// SchemaRegistry is a schema registry instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaRegistry {
    /// Identifier. The name of the schema registry instance. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    /// The instance name {schema_registry} can contain the following:
    /// * Up to 255 characters.
    /// * Letters (uppercase or lowercase), numbers, and underscores.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The contexts of the schema registry instance.
    #[prost(string, repeated, tag = "2")]
    pub contexts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Context represents an independent schema grouping in a schema registry
/// instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Context {
    /// Identifier. The name of the context. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    /// The context name {context} can contain the following:
    /// * Up to 255 characters.
    /// * Allowed characters: letters (uppercase or lowercase), numbers, and the
    /// following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The subjects of the context.
    #[prost(string, repeated, tag = "2")]
    pub subjects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Schema for a Kafka message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// Optional. The schema type of the schema.
    #[prost(enumeration = "schema::SchemaType", tag = "1")]
    pub schema_type: i32,
    /// The schema payload.
    #[prost(string, tag = "2")]
    pub schema_payload: ::prost::alloc::string::String,
    /// Optional. The schema references used by the schema.
    #[prost(message, repeated, tag = "3")]
    pub references: ::prost::alloc::vec::Vec<schema::SchemaReference>,
}
/// Nested message and enum types in `Schema`.
pub mod schema {
    /// SchemaReference is a reference to a schema.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SchemaReference {
        /// Required. The name of the reference.
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        /// Required. The subject of the reference.
        #[prost(string, tag = "2")]
        pub subject: ::prost::alloc::string::String,
        /// Required. The version of the reference.
        #[prost(int32, tag = "3")]
        pub version: i32,
    }
    /// Schema types.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SchemaType {
        /// No schema type. The default will be AVRO.
        Unspecified = 0,
        /// Avro schema type.
        Avro = 1,
        /// JSON schema type.
        Json = 2,
        /// Protobuf schema type.
        Protobuf = 3,
    }
    impl SchemaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCHEMA_TYPE_UNSPECIFIED",
                Self::Avro => "AVRO",
                Self::Json => "JSON",
                Self::Protobuf => "PROTOBUF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCHEMA_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AVRO" => Some(Self::Avro),
                "JSON" => Some(Self::Json),
                "PROTOBUF" => Some(Self::Protobuf),
                _ => None,
            }
        }
    }
}
/// Subject defines the evolution scope of schemas as a holder of schema
/// versions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaSubject {
    /// The name of the subject. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    ///
    /// Subject name {subject} can contain the following:
    /// * Up to 255 UTF-8 bytes.
    /// * Allowed characters: letters (uppercase or lowercase), numbers, and the
    /// following special characters: `.`, `-`, `_`, `+`, `%`, and `~`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The versions of the subject.
    #[prost(string, repeated, tag = "3")]
    pub versions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Version of a schema.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaVersion {
    /// Required. The subject of the version.
    #[prost(string, tag = "1")]
    pub subject: ::prost::alloc::string::String,
    /// Required. The version ID
    #[prost(int32, tag = "2")]
    pub version_id: i32,
    /// Required. The schema ID.
    #[prost(int32, tag = "3")]
    pub schema_id: i32,
    /// Optional. The schema type of the schema.
    #[prost(enumeration = "schema::SchemaType", tag = "4")]
    pub schema_type: i32,
    /// Required. The schema payload.
    #[prost(string, tag = "5")]
    pub schema_payload: ::prost::alloc::string::String,
    /// Optional. The schema references used by the schema.
    #[prost(message, repeated, tag = "6")]
    pub references: ::prost::alloc::vec::Vec<schema::SchemaReference>,
}
/// SchemaConfig represents configuration for a schema registry or a specific
/// subject.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaConfig {
    /// Required. The compatibility type of the schema.
    /// The default value is BACKWARD.
    /// If unset in a SchemaSubject-level SchemaConfig, defaults to the global
    /// value. If unset in a SchemaRegistry-level SchemaConfig, reverts to the
    /// default value.
    #[prost(enumeration = "schema_config::CompatibilityType", optional, tag = "1")]
    pub compatibility: ::core::option::Option<i32>,
    /// Optional. If true, the schema will be normalized before being stored or
    /// looked up. The default is false. If unset in a SchemaSubject-level
    /// SchemaConfig, the global value will be used. If unset in a
    /// SchemaRegistry-level SchemaConfig, reverts to the default value.
    #[prost(bool, optional, tag = "2")]
    pub normalize: ::core::option::Option<bool>,
    /// Optional. The subject to which this subject is an alias of. Only applicable
    /// for subject config.
    #[prost(string, tag = "3")]
    pub alias: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SchemaConfig`.
pub mod schema_config {
    /// Compatibility type of the schemas.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompatibilityType {
        /// No compatibility check.
        None = 0,
        /// Backwards compatible with the most recent version.
        Backward = 1,
        /// Backwards compatible with all previous versions.
        BackwardTransitive = 2,
        /// Forwards compatible with the most recent version.
        Forward = 3,
        /// Forwards compatible with all previous versions.
        ForwardTransitive = 4,
        /// Backwards and forwards compatible with the most recent version.
        Full = 5,
        /// Backwards and forwards compatible with all previous versions.
        FullTransitive = 6,
    }
    impl CompatibilityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Backward => "BACKWARD",
                Self::BackwardTransitive => "BACKWARD_TRANSITIVE",
                Self::Forward => "FORWARD",
                Self::ForwardTransitive => "FORWARD_TRANSITIVE",
                Self::Full => "FULL",
                Self::FullTransitive => "FULL_TRANSITIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "BACKWARD" => Some(Self::Backward),
                "BACKWARD_TRANSITIVE" => Some(Self::BackwardTransitive),
                "FORWARD" => Some(Self::Forward),
                "FORWARD_TRANSITIVE" => Some(Self::ForwardTransitive),
                "FULL" => Some(Self::Full),
                "FULL_TRANSITIVE" => Some(Self::FullTransitive),
                _ => None,
            }
        }
    }
}
/// SchemaMode represents the mode of a schema registry or a specific subject.
/// Four modes are supported:
/// * NONE: deprecated. This was the default mode for a subject, but now the
/// default is unset (which means use the global schema registry setting)
/// * READONLY: The schema registry is in read-only mode.
/// * READWRITE: The schema registry is in read-write mode, which allows limited
/// write operations on the schema.
/// * IMPORT: The schema registry is in import mode, which allows more editing
/// operations on the schema for data importing purposes.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SchemaMode {
    /// Required. The mode type of a schema registry (READWRITE by default) or of a
    /// subject (unset by default, which means use the global schema registry
    /// setting).
    #[prost(enumeration = "schema_mode::ModeType", tag = "1")]
    pub mode: i32,
}
/// Nested message and enum types in `SchemaMode`.
pub mod schema_mode {
    /// Mode type of the schemas or subjects.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ModeType {
        /// The default / unset value.
        /// The subject mode is NONE/unset by default, which means use the global
        /// schema registry mode. This should not be used for setting the mode.
        None = 0,
        /// READONLY mode.
        Readonly = 1,
        /// READWRITE mode.
        Readwrite = 2,
        /// IMPORT mode.
        Import = 3,
    }
    impl ModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "NONE",
                Self::Readonly => "READONLY",
                Self::Readwrite => "READWRITE",
                Self::Import => "IMPORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NONE" => Some(Self::None),
                "READONLY" => Some(Self::Readonly),
                "READWRITE" => Some(Self::Readwrite),
                "IMPORT" => Some(Self::Import),
                _ => None,
            }
        }
    }
}
/// Request for GetSchemaRegistry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRegistryRequest {
    /// Required. The name of the schema registry instance to return. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListSchemaRegistries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaRegistriesRequest {
    /// Required. The parent whose schema registry instances are to be listed.
    /// Structured like: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Request for ListSchemaRegistries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaRegistriesResponse {
    /// The schema registry instances.
    #[prost(message, repeated, tag = "1")]
    pub schema_registries: ::prost::alloc::vec::Vec<SchemaRegistry>,
}
/// Request to create a schema registry instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSchemaRegistryRequest {
    /// Required. The parent whose schema registry instance is to be created.
    /// Structured like: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The schema registry instance ID to use for this schema registry.
    /// The ID must contain only letters (a-z, A-Z), numbers (0-9), and underscores
    /// (-). The maximum length is 63 characters.
    /// The ID must not start with a number.
    #[prost(string, tag = "2")]
    pub schema_registry_id: ::prost::alloc::string::String,
    /// Required. The schema registry instance to create.
    /// The name field is ignored.
    #[prost(message, optional, tag = "3")]
    pub schema_registry: ::core::option::Option<SchemaRegistry>,
}
/// Request for DeleteSchemaRegistry.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaRegistryRequest {
    /// Required. The name of the schema registry instance to delete. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for GetContext
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetContextRequest {
    /// Required. The name of the context to return. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for ListContexts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListContextsRequest {
    /// Required. The parent of the contexts. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Request for GetSchema.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaRequest {
    /// Required. The name of the schema to return. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Used to limit the search for the schema ID to a specific subject,
    /// otherwise the schema ID will be searched for in all subjects in the given
    /// specified context.
    #[prost(string, optional, tag = "2")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
}
/// Request for ListSchemaTypes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaTypesRequest {
    /// Required. The parent schema registry whose schema types are to be listed.
    /// Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Request for ListSchemaVersions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSchemaVersionsRequest {
    /// Required. The schema whose schema versions are to be listed. Structured
    /// like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The subject to filter the subjects by.
    #[prost(string, optional, tag = "2")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. If true, the response will include soft-deleted versions of the
    /// schema, even if the subject is soft-deleted. The default is false.
    #[prost(bool, optional, tag = "3")]
    pub deleted: ::core::option::Option<bool>,
}
/// Request for listing subjects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubjectsRequest {
    /// Required. The parent schema registry/context whose subjects are to be
    /// listed. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The context to filter the subjects by, in the format of
    /// `:.{context}:`. If unset, all subjects in the registry are returned. Set to
    /// empty string or add as
    /// '?subjectPrefix=' at the end of this request to list subjects in the
    /// default context.
    #[prost(string, optional, tag = "2")]
    pub subject_prefix: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. If true, the response will include soft-deleted subjects. The
    /// default is false.
    #[prost(bool, optional, tag = "3")]
    pub deleted: ::core::option::Option<bool>,
}
/// Request for listing subjects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubjectsBySchemaIdRequest {
    /// Required. The schema resource whose associated subjects are to be listed.
    /// Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/schemas/ids/{schema}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/schemas/ids/{schema}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The subject to filter the subjects by.
    #[prost(string, optional, tag = "2")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional. If true, the response will include soft-deleted subjects. The
    /// default is false.
    #[prost(bool, optional, tag = "3")]
    pub deleted: ::core::option::Option<bool>,
}
/// Request for GetVersions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVersionsRequest {
    /// Required. The subject whose versions are to be listed. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. If true, the response will include soft-deleted versions of an
    /// active or soft-deleted subject. The default is false.
    #[prost(bool, optional, tag = "2")]
    pub deleted: ::core::option::Option<bool>,
}
/// Request for DeleteSubject.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubjectRequest {
    /// Required. The name of the subject to delete. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If true, the subject and all associated metadata including the
    /// schema ID will be deleted permanently. Otherwise, only the subject is
    /// soft-deleted. The default is false. Soft-deleted subjects can still be
    /// searched in ListSubjects API call with deleted=true query parameter. A
    /// soft-delete of a subject must be performed before a hard-delete.
    #[prost(bool, optional, tag = "2")]
    pub permanent: ::core::option::Option<bool>,
}
/// Request for GetVersion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVersionRequest {
    /// Required. The name of the subject to return versions. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If true, no matter if the subject/version is soft-deleted or not,
    /// it returns the version details. If false, it returns NOT_FOUND error if the
    /// subject/version is soft-deleted. The default is false.
    #[prost(bool, optional, tag = "2")]
    pub deleted: ::core::option::Option<bool>,
}
/// Request for CreateVersion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVersionRequest {
    /// Required. The subject to create the version for. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The version to create. It is optional. If not specified, the
    /// version will be created with the max version ID of the subject increased
    /// by 1. If the version ID is specified, it will be used as the new version ID
    /// and must not be used by an existing version of the subject.
    #[prost(int32, optional, tag = "2")]
    pub version: ::core::option::Option<i32>,
    /// Optional. The schema ID of the schema. If not specified, the schema ID will
    /// be generated by the server. If the schema ID is specified, it must not be
    /// used by an existing schema that is different from the schema to be created.
    #[prost(int32, optional, tag = "3")]
    pub id: ::core::option::Option<i32>,
    /// Optional. The type of the schema. It is optional. If not specified, the
    /// schema type will be AVRO.
    #[prost(enumeration = "schema::SchemaType", optional, tag = "4")]
    pub schema_type: ::core::option::Option<i32>,
    /// Required. The schema payload
    #[prost(string, tag = "5")]
    pub schema: ::prost::alloc::string::String,
    /// Optional. The schema references used by the schema.
    #[prost(message, repeated, tag = "6")]
    pub references: ::prost::alloc::vec::Vec<schema::SchemaReference>,
    /// Optional. If true, the schema will be normalized before being stored. The
    /// default is false.
    #[prost(bool, optional, tag = "7")]
    pub normalize: ::core::option::Option<bool>,
}
/// Response for CreateVersion.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateVersionResponse {
    /// The unique identifier of the schema created.
    #[prost(int32, tag = "1")]
    pub id: i32,
}
/// Request for LookupVersion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookupVersionRequest {
    /// Required. The subject to lookup the schema in. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The schema type of the schema.
    #[prost(enumeration = "schema::SchemaType", optional, tag = "2")]
    pub schema_type: ::core::option::Option<i32>,
    /// Required. The schema payload
    #[prost(string, tag = "3")]
    pub schema: ::prost::alloc::string::String,
    /// Optional. The schema references used by the schema.
    #[prost(message, repeated, tag = "4")]
    pub references: ::prost::alloc::vec::Vec<schema::SchemaReference>,
    /// Optional. If true, the schema will be normalized before being looked up.
    /// The default is false.
    #[prost(bool, optional, tag = "5")]
    pub normalize: ::core::option::Option<bool>,
    /// Optional. If true, soft-deleted versions will be included in lookup, no
    /// matter if the subject is active or soft-deleted. If false, soft-deleted
    /// versions will be excluded. The default is false.
    #[prost(bool, optional, tag = "6")]
    pub deleted: ::core::option::Option<bool>,
}
/// Request for DeleteVersion.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVersionRequest {
    /// Required. The name of the subject version to delete. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If true, both the version and the referenced schema ID will be
    /// permanently deleted. The default is false. If false, the version will be
    /// deleted but the schema ID will be retained. Soft-deleted versions can still
    /// be searched in ListVersions API call with deleted=true query parameter. A
    /// soft-delete of a version must be performed before a hard-delete.
    #[prost(bool, optional, tag = "2")]
    pub permanent: ::core::option::Option<bool>,
}
/// Request for ListReferencedSchemas.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReferencedSchemasRequest {
    /// Required. The version to list referenced by. Structured like:
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/subjects/{subject}/versions/{version}`
    /// or
    /// `projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/subjects/{subject}/versions/{version}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
}
/// Request for CheckCompatibility.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckCompatibilityRequest {
    /// Required. The name of the resource to check compatibility for. The format
    /// is either of following:
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/*/versions: Check compatibility with one or
    ///    more versions of the specified subject.
    /// * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/compatibility/subjects/{subject}/versions/{version}: Check
    ///    compatibility with a specific version of the subject.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The schema type of the schema.
    #[prost(enumeration = "schema::SchemaType", optional, tag = "2")]
    pub schema_type: ::core::option::Option<i32>,
    /// Required. The schema payload
    #[prost(string, tag = "3")]
    pub schema: ::prost::alloc::string::String,
    /// Optional. The schema references used by the schema.
    #[prost(message, repeated, tag = "4")]
    pub references: ::prost::alloc::vec::Vec<schema::SchemaReference>,
    /// Optional. If true, the response will contain the compatibility check result
    /// with reasons for failed checks. The default is false.
    #[prost(bool, optional, tag = "5")]
    pub verbose: ::core::option::Option<bool>,
}
/// Response for CheckCompatibility.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CheckCompatibilityResponse {
    /// The compatibility check result. If true, the schema is compatible with the
    /// resource.
    #[prost(bool, tag = "1")]
    pub is_compatible: bool,
    /// Failure reasons if verbose = true.
    #[prost(string, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for getting config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaConfigRequest {
    /// Required. The resource name to get the config for. It can be either of
    /// following:
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Get config at global level.
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Get config for a specific subject.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If true, the config will fall back to the config at the global
    /// level if no subject level config is found.
    #[prost(bool, optional, tag = "2")]
    pub default_to_global: ::core::option::Option<bool>,
}
/// Request for updating schema config.
/// On a SchemaSubject-level SchemaConfig, an unset field will be removed from
/// the SchemaConfig.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSchemaConfigRequest {
    /// Required. The resource name to update the config for. It can be either of
    /// following:
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config: Update config at global level.
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}: Update config for a specific subject.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The compatibility type of the schemas.
    /// Cannot be unset for a SchemaRegistry-level SchemaConfig.
    /// If unset on a SchemaSubject-level SchemaConfig, removes the compatibility
    /// field for the SchemaConfig.
    #[prost(enumeration = "schema_config::CompatibilityType", optional, tag = "2")]
    pub compatibility: ::core::option::Option<i32>,
    /// Optional. If true, the schema will be normalized before being stored or
    /// looked up. The default is false. Cannot be unset for a SchemaRegistry-level
    /// SchemaConfig. If unset on a SchemaSubject-level SchemaConfig, removes the
    /// normalize field for the SchemaConfig.
    #[prost(bool, optional, tag = "3")]
    pub normalize: ::core::option::Option<bool>,
}
/// Request for deleting schema config.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaConfigRequest {
    /// Required. The resource name of subject to delete the config for. The format
    /// is
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/config/{subject}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for getting schema registry or subject mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSchemaModeRequest {
    /// Required. The resource name of the mode. The format is
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for updating schema registry or subject mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSchemaModeRequest {
    /// Required. The resource name of the mode. The format is
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}: mode for a schema registry, or
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}: mode for a specific subject in a specific context
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The mode type.
    #[prost(enumeration = "schema_mode::ModeType", tag = "2")]
    pub mode: i32,
}
/// Request for deleting schema mode.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSchemaModeRequest {
    /// Required. The resource name of subject to delete the mode for. The format
    /// is
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/mode/{subject}
    ///    * projects/{project}/locations/{location}/schemaRegistries/{schema_registry}/contexts/{context}/mode/{subject}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod managed_schema_registry_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// SchemaRegistry is a service that allows users to manage schemas for their
    /// Kafka clusters. It provides APIs to register, list, and delete schemas, as
    /// well as to get the schema for a given schema id or a given version id under a
    /// subject, to update the global or subject-specific compatibility mode, and to
    /// check the compatibility of a schema against a subject or a version. The main
    /// resource hierarchy is as follows:
    ///
    /// * SchemaRegistry
    /// * SchemaRegistry/Context
    /// * SchemaRegistry/Context/Schema
    /// * SchemaRegistry/Context/Subject
    /// * SchemaRegistry/Context/Subject/Version
    /// * SchemaRegistry/Config
    /// * SchemaRegistry/Mode
    ///
    /// **SchemaRegistry** is the root resource to represent a schema registry
    /// instance. A customer can have multiple schema registry instances in a
    /// project.
    ///
    /// **Context** is a context resource that represents a group of
    /// schemas, subjects and versions. A schema registry instance can have multiple
    /// contexts and always has a 'default' context. Contexts are independent of each
    /// other. Context is optional and if not specified, it falls back to the
    /// 'default' context.
    ///
    /// **Schema** is a schema resource that represents a unique schema in a context
    /// of a schema registry instance. Each schema has a unique schema id, and can be
    /// referenced by a version of a subject.
    ///
    /// **Subject** refers to the name under which the schema is registered. A
    /// typical subject is the Kafka topic name. A schema registry instance can have
    /// multiple subjects.
    ///
    /// **Version** represents a version of a subject. A subject can have multiple
    /// versions. Creation of new version of a subject is guarded by the
    /// compatibility mode configured globally or for the subject specifically.
    ///
    /// **Config** represents a config at global level cross all registry
    /// instances or at subject level. Currently, only compatibility is supported in
    /// config.
    ///
    /// **Mode** represents the mode of a schema registry or a specific subject.
    /// Three modes are supported:
    /// * READONLY: The schema registry is in read-only mode, no write operations
    /// allowed..
    /// * READWRITE: The schema registry is in read-write mode, which allows limited
    /// write operations on the schema.
    /// * IMPORT: The schema registry is in import mode, which allows more editing
    /// operations on the schema for data importing purposes.
    #[derive(Debug, Clone)]
    pub struct ManagedSchemaRegistryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ManagedSchemaRegistryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ManagedSchemaRegistryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ManagedSchemaRegistryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ManagedSchemaRegistryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get the schema registry instance.
        pub async fn get_schema_registry(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRegistryRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaRegistry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetSchemaRegistry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetSchemaRegistry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List schema registries.
        pub async fn list_schema_registries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemaRegistriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSchemaRegistriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListSchemaRegistries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListSchemaRegistries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a schema registry instance.
        pub async fn create_schema_registry(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSchemaRegistryRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaRegistry>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/CreateSchemaRegistry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "CreateSchemaRegistry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a schema registry instance.
        pub async fn delete_schema_registry(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaRegistryRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/DeleteSchemaRegistry",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "DeleteSchemaRegistry",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the context.
        pub async fn get_context(
            &mut self,
            request: impl tonic::IntoRequest<super::GetContextRequest>,
        ) -> std::result::Result<tonic::Response<super::Context>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetContext",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetContext",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List contexts for a schema registry.
        pub async fn list_contexts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListContextsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListContexts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListContexts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the schema for the given schema id.
        pub async fn get_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::Schema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the schema string for the given schema id.
        /// The response will be the schema string.
        pub async fn get_raw_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetRawSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetRawSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List the schema versions for the given schema id.
        /// The response will be an array of subject-version pairs as:
        /// [{"subject":"subject1", "version":1}, {"subject":"subject2", "version":2}].
        pub async fn list_schema_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemaVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListSchemaVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListSchemaVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List the supported schema types.
        /// The response will be an array of schema types.
        pub async fn list_schema_types(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSchemaTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListSchemaTypes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListSchemaTypes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List subjects in the schema registry.
        /// The response will be an array of subject names.
        pub async fn list_subjects(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListSubjects",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListSubjects",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List subjects which reference a particular schema id.
        /// The response will be an array of subject names.
        pub async fn list_subjects_by_schema_id(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubjectsBySchemaIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListSubjectsBySchemaId",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListSubjectsBySchemaId",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a subject.
        /// The response will be an array of versions of the deleted subject.
        pub async fn delete_subject(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSubjectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/DeleteSubject",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "DeleteSubject",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup a schema under the specified subject.
        pub async fn lookup_version(
            &mut self,
            request: impl tonic::IntoRequest<super::LookupVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaVersion>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/LookupVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "LookupVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a versioned schema (schema with subject/version) of a subject.
        pub async fn get_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaVersion>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the schema string only for a version of a subject.
        /// The response will be the schema string.
        pub async fn get_raw_schema_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetRawSchemaVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetRawSchemaVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get all versions of a subject.
        /// The response will be an array of versions of the subject.
        pub async fn list_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register a new version under a given subject with the given schema.
        pub async fn create_version(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateVersionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/CreateVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "CreateVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete a version of a subject.
        /// The response will be the deleted version id.
        pub async fn delete_version(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVersionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/DeleteVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "DeleteVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a list of IDs of schemas that reference the schema with the given
        /// subject and version.
        pub async fn list_referenced_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReferencedSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/ListReferencedSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "ListReferencedSchemas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Check compatibility of a schema with all versions or a specific version of
        /// a subject.
        pub async fn check_compatibility(
            &mut self,
            request: impl tonic::IntoRequest<super::CheckCompatibilityRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CheckCompatibilityResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/CheckCompatibility",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "CheckCompatibility",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get schema config at global level or for a subject.
        pub async fn get_schema_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetSchemaConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetSchemaConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update config at global level or for a subject.
        /// Creates a SchemaSubject-level SchemaConfig if it does not exist.
        pub async fn update_schema_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSchemaConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/UpdateSchemaConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "UpdateSchemaConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete schema config for a subject.
        pub async fn delete_schema_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/DeleteSchemaConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "DeleteSchemaConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get mode at global level or for a subject.
        pub async fn get_schema_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSchemaModeRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaMode>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/GetSchemaMode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "GetSchemaMode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update mode at global level or for a subject.
        pub async fn update_schema_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSchemaModeRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaMode>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/UpdateSchemaMode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "UpdateSchemaMode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete schema mode for a subject.
        pub async fn delete_schema_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSchemaModeRequest>,
        ) -> std::result::Result<tonic::Response<super::SchemaMode>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry/DeleteSchemaMode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.managedkafka.schemaregistry.v1.ManagedSchemaRegistry",
                        "DeleteSchemaMode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
