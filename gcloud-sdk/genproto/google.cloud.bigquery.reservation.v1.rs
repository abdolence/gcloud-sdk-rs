// This file is @generated by prost-build.
/// A reservation is a mechanism used to guarantee slots to users.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    /// Identifier. The resource name of the reservation, e.g.,
    /// `projects/*/locations/*/reservations/team1-prod`.
    /// The reservation_id must only contain lower case alphanumeric characters or
    /// dashes. It must start with a letter and must not end with a dash. Its
    /// maximum length is 64 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Baseline slots available to this reservation. A slot is a unit of
    /// computational power in BigQuery, and serves as the unit of parallelism.
    ///
    /// Queries using this reservation might use more slots during runtime if
    /// ignore_idle_slots is set to false, or autoscaling is enabled.
    ///
    /// The total slot_capacity of the reservation and its siblings
    /// may exceed the total slot_count of capacity commitments. In that case, the
    /// exceeding slots will be charged with the autoscale SKU. You can increase
    /// the number of baseline slots in a reservation every few minutes. If you
    /// want to decrease your baseline slots, you are limited to once an hour if
    /// you have recently changed your baseline slot capacity and your baseline
    /// slots exceed your committed slots. Otherwise, you can decrease your
    /// baseline slots every few minutes.
    #[prost(int64, tag = "2")]
    pub slot_capacity: i64,
    /// Optional. If false, any query or pipeline job using this reservation will
    /// use idle slots from other reservations within the same admin project. If
    /// true, a query or pipeline job using this reservation will execute with the
    /// slot capacity specified in the slot_capacity field at most.
    #[prost(bool, tag = "4")]
    pub ignore_idle_slots: bool,
    /// Optional. The configuration parameters for the auto scaling feature.
    #[prost(message, optional, tag = "7")]
    pub autoscale: ::core::option::Option<reservation::Autoscale>,
    /// Optional. Job concurrency target which sets a soft upper bound on the
    /// number of jobs that can run concurrently in this reservation. This is a
    /// soft target due to asynchronous nature of the system and various
    /// optimizations for small queries. Default value is 0 which means that
    /// concurrency target will be automatically computed by the system. NOTE: this
    /// field is exposed as target job concurrency in the Information Schema, DDL
    /// and BigQuery CLI.
    #[prost(int64, tag = "16")]
    pub concurrency: i64,
    /// Output only. Creation time of the reservation.
    #[prost(message, optional, tag = "8")]
    pub creation_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Last update time of the reservation.
    #[prost(message, optional, tag = "9")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Applicable only for reservations located within one of the BigQuery
    /// multi-regions (US or EU).
    ///
    /// If set to true, this reservation is placed in the organization's
    /// secondary region which is designated for disaster recovery purposes.
    /// If false, this reservation is placed in the organization's default region.
    ///
    /// NOTE: this is a preview feature. Project must be allow-listed in order to
    /// set this field.
    #[deprecated]
    #[prost(bool, tag = "14")]
    pub multi_region_auxiliary: bool,
    /// Optional. Edition of the reservation.
    #[prost(enumeration = "Edition", tag = "17")]
    pub edition: i32,
    /// Output only. The current location of the reservation's primary replica.
    /// This field is only set for reservations using the managed disaster recovery
    /// feature.
    #[prost(string, tag = "18")]
    pub primary_location: ::prost::alloc::string::String,
    /// Optional. The current location of the reservation's secondary replica. This
    /// field is only set for reservations using the managed disaster recovery
    /// feature. Users can set this in create reservation calls
    /// to create a failover reservation or in update reservation calls to convert
    /// a non-failover reservation to a failover reservation(or vice versa).
    #[prost(string, tag = "19")]
    pub secondary_location: ::prost::alloc::string::String,
    /// Output only. The location where the reservation was originally created.
    /// This is set only during the failover reservation's creation. All billing
    /// charges for the failover reservation will be applied to this location.
    #[prost(string, tag = "20")]
    pub original_primary_location: ::prost::alloc::string::String,
    /// Optional. The overall max slots for the reservation, covering slot_capacity
    /// (baseline), idle slots (if ignore_idle_slots is false) and scaled slots.
    /// If present, the reservation won't use more than the specified number of
    /// slots, even if there is demand and supply (from idle slots).
    /// NOTE: capping a reservation's idle slot usage is best effort and its
    /// usage may exceed the max_slots value. However, in terms of
    /// autoscale.current_slots (which accounts for the additional added slots), it
    /// will never exceed the max_slots - baseline.
    ///
    /// This field must be set together with the scaling_mode enum value,
    /// otherwise the request will be rejected with error code
    /// `google.rpc.Code.INVALID_ARGUMENT`.
    ///
    /// If the max_slots and scaling_mode are set, the autoscale or
    /// autoscale.max_slots field must be unset. Otherwise the request will be
    /// rejected with error code `google.rpc.Code.INVALID_ARGUMENT`. However, the
    /// autoscale field may still be in the output. The autopscale.max_slots will
    /// always show as 0 and the autoscaler.current_slots will represent the
    /// current slots from autoscaler excluding idle slots.
    /// For example, if the max_slots is 1000 and scaling_mode is AUTOSCALE_ONLY,
    /// then in the output, the autoscaler.max_slots will be 0 and the
    /// autoscaler.current_slots may be any value between 0 and 1000.
    ///
    /// If the max_slots is 1000, scaling_mode is ALL_SLOTS, the baseline is 100
    /// and idle slots usage is 200, then in the output, the autoscaler.max_slots
    /// will be 0 and the autoscaler.current_slots will not be higher than 700.
    ///
    /// If the max_slots is 1000, scaling_mode is IDLE_SLOTS_ONLY, then in the
    /// output, the autoscaler field will be null.
    ///
    /// If the max_slots and scaling_mode are set, then the ignore_idle_slots field
    /// must be aligned with the scaling_mode enum value.(See details in
    /// ScalingMode comments). Otherwise the request will be rejected with
    /// error code `google.rpc.Code.INVALID_ARGUMENT`.
    ///
    /// Please note,  the max_slots is for user to manage the part of slots greater
    /// than the baseline. Therefore, we don't allow users to set max_slots smaller
    /// or equal to the baseline as it will not be meaningful. If the field is
    /// present and slot_capacity>=max_slots, requests will be rejected with error
    /// code `google.rpc.Code.INVALID_ARGUMENT`.
    ///
    /// Please note that if max_slots is set to 0, we will treat it as unset.
    /// Customers can set max_slots to 0 and set scaling_mode to
    /// SCALING_MODE_UNSPECIFIED to disable the max_slots feature.
    #[prost(int64, optional, tag = "21")]
    pub max_slots: ::core::option::Option<i64>,
    /// Optional. The scaling mode for the reservation.
    /// If the field is present but max_slots is not present, requests will be
    /// rejected with error code `google.rpc.Code.INVALID_ARGUMENT`.
    #[prost(enumeration = "reservation::ScalingMode", tag = "22")]
    pub scaling_mode: i32,
    /// Optional. The labels associated with this reservation. You can use these
    /// to organize and group your reservations.
    /// You can set this property when you create or update a reservation.
    #[prost(map = "string, string", tag = "23")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. The reservation group that this reservation belongs to.
    /// You can set this property when you create or update a reservation.
    /// Reservations do not need to belong to a reservation group.
    /// Format:
    /// projects/{project}/locations/{location}/reservationGroups/{reservation_group}
    /// or just {reservation_group}
    #[prost(string, tag = "25")]
    pub reservation_group: ::prost::alloc::string::String,
    /// Output only. The Disaster Recovery(DR) replication status of the
    /// reservation. This is only available for the primary replicas of DR/failover
    /// reservations and provides information about the both the staleness of the
    /// secondary and the last error encountered while trying to replicate changes
    /// from the primary to the secondary. If this field is blank, it means that
    /// the reservation is either not a DR reservation or the reservation is a DR
    /// secondary or that any replication operations on the reservation have
    /// succeeded.
    #[prost(message, optional, tag = "24")]
    pub replication_status: ::core::option::Option<reservation::ReplicationStatus>,
    /// Optional. The scheduling policy to use for jobs and queries running under
    /// this reservation. The scheduling policy controls how the reservation's
    /// resources are distributed.
    ///
    /// This feature is not yet generally available.
    #[prost(message, optional, tag = "27")]
    pub scheduling_policy: ::core::option::Option<SchedulingPolicy>,
}
/// Nested message and enum types in `Reservation`.
pub mod reservation {
    /// Auto scaling settings.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Autoscale {
        /// Output only. The slot capacity added to this reservation when autoscale
        /// happens. Will be between \[0, max_slots\]. Note: after users reduce
        /// max_slots, it may take a while before it can be propagated, so
        /// current_slots may stay in the original value and could be larger than
        /// max_slots for that brief period (less than one minute)
        #[prost(int64, tag = "1")]
        pub current_slots: i64,
        /// Optional. Number of slots to be scaled when needed.
        #[prost(int64, tag = "2")]
        pub max_slots: i64,
    }
    /// Disaster Recovery(DR) replication status of the reservation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReplicationStatus {
        /// Output only. The last error encountered while trying to replicate changes
        /// from the primary to the secondary. This field is only available if the
        /// replication has not succeeded since.
        #[prost(message, optional, tag = "1")]
        pub error: ::core::option::Option<
            super::super::super::super::super::rpc::Status,
        >,
        /// Output only. The time at which the last error was encountered while
        /// trying to replicate changes from the primary to the secondary. This field
        /// is only available if the replication has not succeeded since.
        #[prost(message, optional, tag = "2")]
        pub last_error_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Output only. A timestamp corresponding to the last change on the primary
        /// that was successfully replicated to the secondary.
        #[prost(message, optional, tag = "3")]
        pub last_replication_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Output only. The time at which a soft failover for the reservation and
        /// its associated datasets was initiated. After this field is set, all
        /// subsequent changes to the reservation will be rejected unless a hard
        /// failover overrides this operation. This field will be cleared once the
        /// failover is complete.
        #[prost(message, optional, tag = "4")]
        pub soft_failover_start_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// The scaling mode for the reservation. This enum determines how the
    /// reservation scales up and down.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ScalingMode {
        /// Default value of ScalingMode.
        Unspecified = 0,
        /// The reservation will scale up only using slots from autoscaling. It will
        /// not use any idle slots even if there may be some available. The upper
        /// limit that autoscaling can scale up to will be max_slots - baseline.
        /// For example, if max_slots is 1000, baseline is 200 and customer sets
        /// ScalingMode to AUTOSCALE_ONLY, then autoscalerg will scale up to 800
        /// slots and no idle slots will be used.
        ///
        /// Please note, in this mode, the ignore_idle_slots field must be set to
        /// true. Otherwise the request will be rejected with error code
        /// `google.rpc.Code.INVALID_ARGUMENT`.
        AutoscaleOnly = 1,
        /// The reservation will scale up using only idle slots contributed by
        /// other reservations or from unassigned commitments. If no idle slots are
        /// available it will not scale up further. If the idle slots which it is
        /// using are reclaimed by the contributing reservation(s) it may be forced
        /// to scale down. The max idle slots the reservation can be max_slots -
        /// baseline capacity. For example, if max_slots is 1000, baseline is 200 and
        /// customer sets ScalingMode to IDLE_SLOTS_ONLY,
        ///
        /// 1. if there are 1000 idle slots available in other reservations, the
        ///    reservation will scale up to 1000 slots with 200 baseline and 800 idle
        ///    slots.
        /// 1. if there are 500 idle slots available in other reservations, the
        ///    reservation will scale up to 700 slots with 200 baseline and 300 idle
        ///    slots.
        ///    Please note, in this mode, the reservation might not be able to scale up
        ///    to max_slots.
        ///
        /// Please note, in this mode, the ignore_idle_slots field must be set to
        /// false. Otherwise the request will be rejected with error code
        /// `google.rpc.Code.INVALID_ARGUMENT`.
        IdleSlotsOnly = 2,
        /// The reservation will scale up using all slots available to it. It will
        /// use idle slots contributed by other reservations or from unassigned
        /// commitments first. If no idle slots are available it will scale up using
        /// autoscaling. For example, if max_slots is 1000, baseline is 200 and
        /// customer sets ScalingMode to ALL_SLOTS,
        ///
        /// 1. if there are 800 idle slots available in other reservations, the
        ///    reservation will scale up to 1000 slots with 200 baseline and 800 idle
        ///    slots.
        /// 1. if there are 500 idle slots available in other reservations, the
        ///    reservation will scale up to 1000 slots with 200 baseline, 500 idle
        ///    slots and 300 autoscaling slots.
        /// 1. if there are no idle slots available in other reservations, it will
        ///    scale up to 1000 slots with 200 baseline and 800 autoscaling slots.
        ///
        /// Please note, in this mode, the ignore_idle_slots field must be set to
        /// false. Otherwise the request will be rejected with error code
        /// `google.rpc.Code.INVALID_ARGUMENT`.
        AllSlots = 3,
    }
    impl ScalingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SCALING_MODE_UNSPECIFIED",
                Self::AutoscaleOnly => "AUTOSCALE_ONLY",
                Self::IdleSlotsOnly => "IDLE_SLOTS_ONLY",
                Self::AllSlots => "ALL_SLOTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCALING_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "AUTOSCALE_ONLY" => Some(Self::AutoscaleOnly),
                "IDLE_SLOTS_ONLY" => Some(Self::IdleSlotsOnly),
                "ALL_SLOTS" => Some(Self::AllSlots),
                _ => None,
            }
        }
    }
}
/// The scheduling policy controls how a reservation's resources are distributed.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SchedulingPolicy {
    /// Optional. If present and > 0, the reservation will attempt to limit the
    /// concurrency of jobs running for any particular project within it to the
    /// given value.
    ///
    /// This feature is not yet generally available.
    #[prost(int64, optional, tag = "1")]
    pub concurrency: ::core::option::Option<i64>,
    /// Optional. If present and > 0, the reservation will attempt to limit the
    /// slot consumption of queries running for any particular project within it to
    /// the given value.
    ///
    /// This feature is not yet generally available.
    #[prost(int64, optional, tag = "2")]
    pub max_slots: ::core::option::Option<i64>,
}
/// A reservation group is a container for reservations.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReservationGroup {
    /// Identifier. The resource name of the reservation group, e.g.,
    /// `projects/*/locations/*/reservationGroups/team1-prod`.
    /// The reservation_group_id must only contain lower case alphanumeric
    /// characters or dashes. It must start with a letter and must not end with a
    /// dash. Its maximum length is 64 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Capacity commitment is a way to purchase compute capacity for BigQuery jobs
/// (in the form of slots) with some committed period of usage. Annual
/// commitments renew by default. Commitments can be removed after their
/// commitment end time passes.
///
/// In order to remove annual commitment, its plan needs to be changed
/// to monthly or flex first.
///
/// A capacity commitment resource exists as a child resource of the admin
/// project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapacityCommitment {
    /// Output only. The resource name of the capacity commitment, e.g.,
    /// `projects/myproject/locations/US/capacityCommitments/123`
    /// The commitment_id must only contain lower case alphanumeric characters or
    /// dashes. It must start with a letter and must not end
    /// with a dash. Its maximum length is 64 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Number of slots in this commitment.
    #[prost(int64, tag = "2")]
    pub slot_count: i64,
    /// Optional. Capacity commitment commitment plan.
    #[prost(enumeration = "capacity_commitment::CommitmentPlan", tag = "3")]
    pub plan: i32,
    /// Output only. State of the commitment.
    #[prost(enumeration = "capacity_commitment::State", tag = "4")]
    pub state: i32,
    /// Output only. The start of the current commitment period. It is applicable
    /// only for ACTIVE capacity commitments. Note after the commitment is renewed,
    /// commitment_start_time won't be changed. It refers to the start time of the
    /// original commitment.
    #[prost(message, optional, tag = "9")]
    pub commitment_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The end of the current commitment period. It is applicable
    /// only for ACTIVE capacity commitments. Note after renewal,
    /// commitment_end_time is the time the renewed commitment expires. So itwould
    /// be at a time after commitment_start_time + committed period, because we
    /// don't change commitment_start_time ,
    #[prost(message, optional, tag = "5")]
    pub commitment_end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. For FAILED commitment plan, provides the reason of failure.
    #[prost(message, optional, tag = "7")]
    pub failure_status: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// Optional. The plan this capacity commitment is converted to after
    /// commitment_end_time passes. Once the plan is changed, committed period is
    /// extended according to commitment plan. Only applicable for ANNUAL and TRIAL
    /// commitments.
    #[prost(enumeration = "capacity_commitment::CommitmentPlan", tag = "8")]
    pub renewal_plan: i32,
    /// Applicable only for commitments located within one of the BigQuery
    /// multi-regions (US or EU).
    ///
    /// If set to true, this commitment is placed in the organization's
    /// secondary region which is designated for disaster recovery purposes.
    /// If false, this commitment is placed in the organization's default region.
    ///
    /// NOTE: this is a preview feature. Project must be allow-listed in order to
    /// set this field.
    #[deprecated]
    #[prost(bool, tag = "10")]
    pub multi_region_auxiliary: bool,
    /// Optional. Edition of the capacity commitment.
    #[prost(enumeration = "Edition", tag = "12")]
    pub edition: i32,
    /// Output only. If true, the commitment is a flat-rate commitment, otherwise,
    /// it's an edition commitment.
    #[prost(bool, tag = "14")]
    pub is_flat_rate: bool,
}
/// Nested message and enum types in `CapacityCommitment`.
pub mod capacity_commitment {
    /// Commitment plan defines the current committed period. Capacity commitment
    /// cannot be deleted during it's committed period.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CommitmentPlan {
        /// Invalid plan value. Requests with this value will be rejected with
        /// error code `google.rpc.Code.INVALID_ARGUMENT`.
        Unspecified = 0,
        /// Flex commitments have committed period of 1 minute after becoming ACTIVE.
        /// After that, they are not in a committed period anymore and can be removed
        /// any time.
        Flex = 3,
        /// Same as FLEX, should only be used if flat-rate commitments are still
        /// available.
        FlexFlatRate = 7,
        /// Trial commitments have a committed period of 182 days after becoming
        /// ACTIVE. After that, they are converted to a new commitment based on the
        /// `renewal_plan`. Default `renewal_plan` for Trial commitment is Flex so
        /// that it can be deleted right after committed period ends.
        Trial = 5,
        /// Monthly commitments have a committed period of 30 days after becoming
        /// ACTIVE. After that, they are not in a committed period anymore and can be
        /// removed any time.
        Monthly = 2,
        /// Same as MONTHLY, should only be used if flat-rate commitments are still
        /// available.
        MonthlyFlatRate = 8,
        /// Annual commitments have a committed period of 365 days after becoming
        /// ACTIVE. After that they are converted to a new commitment based on the
        /// renewal_plan.
        Annual = 4,
        /// Same as ANNUAL, should only be used if flat-rate commitments are still
        /// available.
        AnnualFlatRate = 9,
        /// 3-year commitments have a committed period of 1095(3 * 365) days after
        /// becoming ACTIVE. After that they are converted to a new commitment based
        /// on the renewal_plan.
        ThreeYear = 10,
        /// Should only be used for `renewal_plan` and is only meaningful if
        /// edition is specified to values other than EDITION_UNSPECIFIED. Otherwise
        /// CreateCapacityCommitmentRequest or UpdateCapacityCommitmentRequest will
        /// be rejected with error code `google.rpc.Code.INVALID_ARGUMENT`. If the
        /// renewal_plan is NONE, capacity commitment will be removed at the end of
        /// its commitment period.
        None = 6,
    }
    impl CommitmentPlan {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "COMMITMENT_PLAN_UNSPECIFIED",
                Self::Flex => "FLEX",
                Self::FlexFlatRate => "FLEX_FLAT_RATE",
                Self::Trial => "TRIAL",
                Self::Monthly => "MONTHLY",
                Self::MonthlyFlatRate => "MONTHLY_FLAT_RATE",
                Self::Annual => "ANNUAL",
                Self::AnnualFlatRate => "ANNUAL_FLAT_RATE",
                Self::ThreeYear => "THREE_YEAR",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMMITMENT_PLAN_UNSPECIFIED" => Some(Self::Unspecified),
                "FLEX" => Some(Self::Flex),
                "FLEX_FLAT_RATE" => Some(Self::FlexFlatRate),
                "TRIAL" => Some(Self::Trial),
                "MONTHLY" => Some(Self::Monthly),
                "MONTHLY_FLAT_RATE" => Some(Self::MonthlyFlatRate),
                "ANNUAL" => Some(Self::Annual),
                "ANNUAL_FLAT_RATE" => Some(Self::AnnualFlatRate),
                "THREE_YEAR" => Some(Self::ThreeYear),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    /// Capacity commitment can either become ACTIVE right away or transition
    /// from PENDING to ACTIVE or FAILED.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Invalid state value.
        Unspecified = 0,
        /// Capacity commitment is pending provisioning. Pending capacity commitment
        /// does not contribute to the project's slot_capacity.
        Pending = 1,
        /// Once slots are provisioned, capacity commitment becomes active.
        /// slot_count is added to the project's slot_capacity.
        Active = 2,
        /// Capacity commitment is failed to be activated by the backend.
        Failed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Active => "ACTIVE",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ACTIVE" => Some(Self::Active),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// The request for
/// \[ReservationService.CreateReservation\]\[google.cloud.bigquery.reservation.v1.ReservationService.CreateReservation\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateReservationRequest {
    /// Required. Project, location. E.g.,
    /// `projects/myproject/locations/US`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The reservation ID. It must only contain lower case alphanumeric
    /// characters or dashes. It must start with a letter and must not end
    /// with a dash. Its maximum length is 64 characters.
    #[prost(string, tag = "2")]
    pub reservation_id: ::prost::alloc::string::String,
    /// Definition of the new reservation to create.
    #[prost(message, optional, tag = "3")]
    pub reservation: ::core::option::Option<Reservation>,
}
/// The request for
/// \[ReservationService.ListReservations\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListReservations\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListReservationsRequest {
    /// Required. The parent resource name containing project and location, e.g.:
    /// `projects/myproject/locations/US`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The next_page_token value returned from a previous List request, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for
/// \[ReservationService.ListReservations\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListReservations\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationsResponse {
    /// List of reservations visible to the user.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.GetReservation\]\[google.cloud.bigquery.reservation.v1.ReservationService.GetReservation\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetReservationRequest {
    /// Required. Resource name of the reservation to retrieve. E.g.,
    /// `projects/myproject/locations/US/reservations/team1-prod`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.DeleteReservation\]\[google.cloud.bigquery.reservation.v1.ReservationService.DeleteReservation\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteReservationRequest {
    /// Required. Resource name of the reservation to retrieve. E.g.,
    /// `projects/myproject/locations/US/reservations/team1-prod`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.UpdateReservation\]\[google.cloud.bigquery.reservation.v1.ReservationService.UpdateReservation\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReservationRequest {
    /// Content of the reservation to update.
    #[prost(message, optional, tag = "1")]
    pub reservation: ::core::option::Option<Reservation>,
    /// Standard field mask for the set of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request for ReservationService.FailoverReservation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailoverReservationRequest {
    /// Required. Resource name of the reservation to failover. E.g.,
    /// `projects/myproject/locations/US/reservations/team1-prod`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A parameter that determines how writes that are pending
    /// replication are handled after a failover is initiated. If not specified,
    /// HARD failover mode is used by default.
    #[prost(enumeration = "FailoverMode", tag = "2")]
    pub failover_mode: i32,
}
/// The request for
/// \[ReservationService.CreateReservationGroup\]\[google.cloud.bigquery.reservation.v1.ReservationService.CreateReservationGroup\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateReservationGroupRequest {
    /// Required. Project, location. E.g.,
    /// `projects/myproject/locations/US`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The reservation group ID. It must only contain lower case
    /// alphanumeric characters or dashes. It must start with a letter and must not
    /// end with a dash. Its maximum length is 64 characters.
    #[prost(string, tag = "2")]
    pub reservation_group_id: ::prost::alloc::string::String,
    /// Required. New Reservation Group to create.
    #[prost(message, optional, tag = "3")]
    pub reservation_group: ::core::option::Option<ReservationGroup>,
}
/// The request for
/// \[ReservationService.GetReservationGroup\]\[google.cloud.bigquery.reservation.v1.ReservationService.GetReservationGroup\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetReservationGroupRequest {
    /// Required. Resource name of the reservation group to retrieve. E.g.,
    /// `projects/myproject/locations/US/reservationGroups/team1-prod`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.ListReservationGroups\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListReservationGroups\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListReservationGroupsRequest {
    /// Required. The parent resource name containing project and location, e.g.:
    /// `projects/myproject/locations/US`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The next_page_token value returned from a previous List request, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for
/// \[ReservationService.ListReservationGroups\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListReservationGroups\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationGroupsResponse {
    /// List of reservations visible to the user.
    #[prost(message, repeated, tag = "1")]
    pub reservation_groups: ::prost::alloc::vec::Vec<ReservationGroup>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.DeleteReservationGroup\]\[google.cloud.bigquery.reservation.v1.ReservationService.DeleteReservationGroup\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteReservationGroupRequest {
    /// Required. Resource name of the reservation group to retrieve. E.g.,
    /// `projects/myproject/locations/US/reservationGroups/team1-prod`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.CreateCapacityCommitment\]\[google.cloud.bigquery.reservation.v1.ReservationService.CreateCapacityCommitment\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCapacityCommitmentRequest {
    /// Required. Resource name of the parent reservation. E.g.,
    /// `projects/myproject/locations/US`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Content of the capacity commitment to create.
    #[prost(message, optional, tag = "2")]
    pub capacity_commitment: ::core::option::Option<CapacityCommitment>,
    /// If true, fail the request if another project in the organization has a
    /// capacity commitment.
    #[prost(bool, tag = "4")]
    pub enforce_single_admin_project_per_org: bool,
    /// The optional capacity commitment ID. Capacity commitment name will be
    /// generated automatically if this field is empty.
    /// This field must only contain lower case alphanumeric characters or dashes.
    /// The first and last character cannot be a dash. Max length is 64 characters.
    /// NOTE: this ID won't be kept if the capacity commitment is split or merged.
    #[prost(string, tag = "5")]
    pub capacity_commitment_id: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.ListCapacityCommitments\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCapacityCommitmentsRequest {
    /// Required. Resource name of the parent reservation. E.g.,
    /// `projects/myproject/locations/US`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The next_page_token value returned from a previous List request, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for
/// \[ReservationService.ListCapacityCommitments\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListCapacityCommitments\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCapacityCommitmentsResponse {
    /// List of capacity commitments visible to the user.
    #[prost(message, repeated, tag = "1")]
    pub capacity_commitments: ::prost::alloc::vec::Vec<CapacityCommitment>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.GetCapacityCommitment\]\[google.cloud.bigquery.reservation.v1.ReservationService.GetCapacityCommitment\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCapacityCommitmentRequest {
    /// Required. Resource name of the capacity commitment to retrieve. E.g.,
    /// `projects/myproject/locations/US/capacityCommitments/123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.DeleteCapacityCommitment\]\[google.cloud.bigquery.reservation.v1.ReservationService.DeleteCapacityCommitment\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCapacityCommitmentRequest {
    /// Required. Resource name of the capacity commitment to delete. E.g.,
    /// `projects/myproject/locations/US/capacityCommitments/123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Can be used to force delete commitments even if assignments exist. Deleting
    /// commitments with assignments may cause queries to fail if they no longer
    /// have access to slots.
    #[prost(bool, tag = "3")]
    pub force: bool,
}
/// The request for
/// \[ReservationService.UpdateCapacityCommitment\]\[google.cloud.bigquery.reservation.v1.ReservationService.UpdateCapacityCommitment\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCapacityCommitmentRequest {
    /// Content of the capacity commitment to update.
    #[prost(message, optional, tag = "1")]
    pub capacity_commitment: ::core::option::Option<CapacityCommitment>,
    /// Standard field mask for the set of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request for
/// \[ReservationService.SplitCapacityCommitment\]\[google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SplitCapacityCommitmentRequest {
    /// Required. The resource name e.g.,:
    /// `projects/myproject/locations/US/capacityCommitments/123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Number of slots in the capacity commitment after the split.
    #[prost(int64, tag = "2")]
    pub slot_count: i64,
}
/// The response for
/// \[ReservationService.SplitCapacityCommitment\]\[google.cloud.bigquery.reservation.v1.ReservationService.SplitCapacityCommitment\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCapacityCommitmentResponse {
    /// First capacity commitment, result of a split.
    #[prost(message, optional, tag = "1")]
    pub first: ::core::option::Option<CapacityCommitment>,
    /// Second capacity commitment, result of a split.
    #[prost(message, optional, tag = "2")]
    pub second: ::core::option::Option<CapacityCommitment>,
}
/// The request for
/// \[ReservationService.MergeCapacityCommitments\]\[google.cloud.bigquery.reservation.v1.ReservationService.MergeCapacityCommitments\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MergeCapacityCommitmentsRequest {
    /// Parent resource that identifies admin project and location e.g.,
    /// `projects/myproject/locations/us`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Ids of capacity commitments to merge.
    /// These capacity commitments must exist under admin project and location
    /// specified in the parent.
    /// ID is the last portion of capacity commitment name e.g., 'abc' for
    /// projects/myproject/locations/US/capacityCommitments/abc
    #[prost(string, repeated, tag = "2")]
    pub capacity_commitment_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. The optional resulting capacity commitment ID. Capacity
    /// commitment name will be generated automatically if this field is empty.
    /// This field must only contain lower case alphanumeric characters or dashes.
    /// The first and last character cannot be a dash. Max length is 64 characters.
    #[prost(string, tag = "3")]
    pub capacity_commitment_id: ::prost::alloc::string::String,
}
/// An assignment allows a project to submit jobs
/// of a certain type using slots from the specified reservation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Assignment {
    /// Output only. Name of the resource. E.g.:
    /// `projects/myproject/locations/US/reservations/team1-prod/assignments/123`.
    /// The assignment_id must only contain lower case alphanumeric characters or
    /// dashes and the max length is 64 characters.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The resource which will use the reservation. E.g.
    /// `projects/myproject`, `folders/123`, or `organizations/456`.
    #[prost(string, tag = "4")]
    pub assignee: ::prost::alloc::string::String,
    /// Optional. Which type of jobs will use the reservation.
    #[prost(enumeration = "assignment::JobType", tag = "3")]
    pub job_type: i32,
    /// Output only. State of the assignment.
    #[prost(enumeration = "assignment::State", tag = "6")]
    pub state: i32,
    /// Optional. This field controls if "Gemini in BigQuery"
    /// (<https://cloud.google.com/gemini/docs/bigquery/overview>) features should be
    /// enabled for this reservation assignment, which is not on by default.
    /// "Gemini in BigQuery" has a distinct compliance posture from BigQuery.  If
    /// this field is set to true, the assignment job type is QUERY, and
    /// the parent reservation edition is ENTERPRISE_PLUS, then the assignment will
    /// give the grantee project/organization access to "Gemini in BigQuery"
    /// features.
    #[prost(bool, tag = "10")]
    pub enable_gemini_in_bigquery: bool,
    /// Optional. The scheduling policy to use for jobs and queries of this
    /// assignee when running under the associated reservation. The scheduling
    /// policy controls how the reservation's resources are distributed. This
    /// overrides the default scheduling policy specified on the reservation.
    ///
    /// This feature is not yet generally available.
    #[prost(message, optional, tag = "11")]
    pub scheduling_policy: ::core::option::Option<SchedulingPolicy>,
}
/// Nested message and enum types in `Assignment`.
pub mod assignment {
    /// Types of job, which could be specified when using the reservation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JobType {
        /// Invalid type. Requests with this value will be rejected with
        /// error code `google.rpc.Code.INVALID_ARGUMENT`.
        Unspecified = 0,
        /// Pipeline (load/export) jobs from the project will use the reservation.
        Pipeline = 1,
        /// Query jobs from the project will use the reservation.
        Query = 2,
        /// BigQuery ML jobs that use services external to BigQuery for model
        /// training. These jobs will not utilize idle slots from other reservations.
        MlExternal = 3,
        /// Background jobs that BigQuery runs for the customers in the background.
        Background = 4,
        /// Continuous SQL jobs will use this reservation. Reservations with
        /// continuous assignments cannot be mixed with non-continuous assignments.
        Continuous = 6,
        /// Finer granularity background jobs for capturing changes in a source
        /// database and streaming them into BigQuery. Reservations with this job
        /// type take priority over a default BACKGROUND reservation assignment (if
        /// it exists).
        BackgroundChangeDataCapture = 7,
        /// Finer granularity background jobs for refreshing cached metadata for
        /// BigQuery tables. Reservations with this job type take priority over a
        /// default BACKGROUND reservation assignment (if it exists).
        BackgroundColumnMetadataIndex = 8,
        /// Finer granularity background jobs for refreshing search indexes upon
        /// BigQuery table columns. Reservations with this job type
        /// take priority over a default BACKGROUND reservation assignment (if it
        /// exists).
        BackgroundSearchIndexRefresh = 9,
    }
    impl JobType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "JOB_TYPE_UNSPECIFIED",
                Self::Pipeline => "PIPELINE",
                Self::Query => "QUERY",
                Self::MlExternal => "ML_EXTERNAL",
                Self::Background => "BACKGROUND",
                Self::Continuous => "CONTINUOUS",
                Self::BackgroundChangeDataCapture => "BACKGROUND_CHANGE_DATA_CAPTURE",
                Self::BackgroundColumnMetadataIndex => "BACKGROUND_COLUMN_METADATA_INDEX",
                Self::BackgroundSearchIndexRefresh => "BACKGROUND_SEARCH_INDEX_REFRESH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JOB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PIPELINE" => Some(Self::Pipeline),
                "QUERY" => Some(Self::Query),
                "ML_EXTERNAL" => Some(Self::MlExternal),
                "BACKGROUND" => Some(Self::Background),
                "CONTINUOUS" => Some(Self::Continuous),
                "BACKGROUND_CHANGE_DATA_CAPTURE" => {
                    Some(Self::BackgroundChangeDataCapture)
                }
                "BACKGROUND_COLUMN_METADATA_INDEX" => {
                    Some(Self::BackgroundColumnMetadataIndex)
                }
                "BACKGROUND_SEARCH_INDEX_REFRESH" => {
                    Some(Self::BackgroundSearchIndexRefresh)
                }
                _ => None,
            }
        }
    }
    /// Assignment will remain in PENDING state if no active capacity commitment is
    /// present. It will become ACTIVE when some capacity commitment becomes
    /// active.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Invalid state value.
        Unspecified = 0,
        /// Queries from assignee will be executed as on-demand, if related
        /// assignment is pending.
        Pending = 1,
        /// Assignment is ready.
        Active = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Active => "ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "ACTIVE" => Some(Self::Active),
                _ => None,
            }
        }
    }
}
/// The request for
/// \[ReservationService.CreateAssignment\]\[google.cloud.bigquery.reservation.v1.ReservationService.CreateAssignment\].
/// Note: "bigquery.reservationAssignments.create" permission is required on the
/// related assignee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateAssignmentRequest {
    /// Required. The parent resource name of the assignment
    /// E.g. `projects/myproject/locations/US/reservations/team1-prod`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Assignment resource to create.
    #[prost(message, optional, tag = "2")]
    pub assignment: ::core::option::Option<Assignment>,
    /// The optional assignment ID. Assignment name will be generated automatically
    /// if this field is empty.
    /// This field must only contain lower case alphanumeric characters or dashes.
    /// Max length is 64 characters.
    #[prost(string, tag = "4")]
    pub assignment_id: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.ListAssignments\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAssignmentsRequest {
    /// Required. The parent resource name e.g.:
    ///
    /// `projects/myproject/locations/US/reservations/team1-prod`
    ///
    /// Or:
    ///
    /// `projects/myproject/locations/US/reservations/-`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The maximum number of items to return per page.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// The next_page_token value returned from a previous List request, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for
/// \[ReservationService.ListAssignments\]\[google.cloud.bigquery.reservation.v1.ReservationService.ListAssignments\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssignmentsResponse {
    /// List of assignments visible to the user.
    #[prost(message, repeated, tag = "1")]
    pub assignments: ::prost::alloc::vec::Vec<Assignment>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.DeleteAssignment\]\[google.cloud.bigquery.reservation.v1.ReservationService.DeleteAssignment\].
/// Note: "bigquery.reservationAssignments.delete" permission is required on the
/// related assignee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteAssignmentRequest {
    /// Required. Name of the resource, e.g.
    /// `projects/myproject/locations/US/reservations/team1-prod/assignments/123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.SearchAssignments\]\[google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments\].
/// Note: "bigquery.reservationAssignments.search" permission is required on the
/// related assignee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchAssignmentsRequest {
    /// Required. The resource name of the admin project(containing project and
    /// location), e.g.:
    /// `projects/myproject/locations/US`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Please specify resource name as assignee in the query.
    ///
    /// Examples:
    ///
    /// * `assignee=projects/myproject`
    /// * `assignee=folders/123`
    /// * `assignee=organizations/456`
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// The maximum number of items to return per page.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// The next_page_token value returned from a previous List request, if any.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.SearchAllAssignments\]\[google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments\].
/// Note: "bigquery.reservationAssignments.search" permission is required on the
/// related assignee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SearchAllAssignmentsRequest {
    /// Required. The resource name with location (project name could be the
    /// wildcard '-'), e.g.:
    /// `projects/-/locations/US`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Please specify resource name as assignee in the query.
    ///
    /// Examples:
    ///
    /// * `assignee=projects/myproject`
    /// * `assignee=folders/123`
    /// * `assignee=organizations/456`
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// The maximum number of items to return per page.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// The next_page_token value returned from a previous List request, if any.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response for
/// \[ReservationService.SearchAssignments\]\[google.cloud.bigquery.reservation.v1.ReservationService.SearchAssignments\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAssignmentsResponse {
    /// List of assignments visible to the user.
    #[prost(message, repeated, tag = "1")]
    pub assignments: ::prost::alloc::vec::Vec<Assignment>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The response for
/// \[ReservationService.SearchAllAssignments\]\[google.cloud.bigquery.reservation.v1.ReservationService.SearchAllAssignments\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAllAssignmentsResponse {
    /// List of assignments visible to the user.
    #[prost(message, repeated, tag = "1")]
    pub assignments: ::prost::alloc::vec::Vec<Assignment>,
    /// Token to retrieve the next page of results, or empty if there are no
    /// more results in the list.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.MoveAssignment\]\[google.cloud.bigquery.reservation.v1.ReservationService.MoveAssignment\].
///
/// **Note**: "bigquery.reservationAssignments.create" permission is required on
/// the destination_id.
///
/// **Note**: "bigquery.reservationAssignments.create" and
/// "bigquery.reservationAssignments.delete" permission are required on the
/// related assignee.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MoveAssignmentRequest {
    /// Required. The resource name of the assignment,
    /// e.g.
    /// `projects/myproject/locations/US/reservations/team1-prod/assignments/123`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The new reservation ID, e.g.:
    /// `projects/myotherproject/locations/US/reservations/team2-prod`
    #[prost(string, tag = "3")]
    pub destination_id: ::prost::alloc::string::String,
    /// The optional assignment ID. A new assignment name is generated if this
    /// field is empty.
    ///
    /// This field can contain only lowercase alphanumeric characters or dashes.
    /// Max length is 64 characters.
    #[prost(string, tag = "5")]
    pub assignment_id: ::prost::alloc::string::String,
}
/// The request for
/// \[ReservationService.UpdateAssignment\]\[google.cloud.bigquery.reservation.v1.ReservationService.UpdateAssignment\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateAssignmentRequest {
    /// Content of the assignment to update.
    #[prost(message, optional, tag = "1")]
    pub assignment: ::core::option::Option<Assignment>,
    /// Standard field mask for the set of fields to be updated.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Fully qualified reference to BigQuery table.
/// Internally stored as google.cloud.bi.v1.BqTableReference.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TableReference {
    /// Optional. The assigned project ID of the project.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Optional. The ID of the dataset in the above project.
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Optional. The ID of the table in the above dataset.
    #[prost(string, tag = "3")]
    pub table_id: ::prost::alloc::string::String,
}
/// Represents a BI Reservation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BiReservation {
    /// Identifier. The resource name of the singleton BI reservation.
    /// Reservation names have the form
    /// `projects/{project_id}/locations/{location_id}/biReservation`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The last update timestamp of a reservation.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Size of a reservation, in bytes.
    #[prost(int64, tag = "4")]
    pub size: i64,
    /// Optional. Preferred tables to use BI capacity for.
    #[prost(message, repeated, tag = "5")]
    pub preferred_tables: ::prost::alloc::vec::Vec<TableReference>,
}
/// A request to get a singleton BI reservation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetBiReservationRequest {
    /// Required. Name of the requested reservation, for example:
    /// `projects/{project_id}/locations/{location_id}/biReservation`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// A request to update a BI reservation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBiReservationRequest {
    /// A reservation to update.
    #[prost(message, optional, tag = "1")]
    pub bi_reservation: ::core::option::Option<BiReservation>,
    /// A list of fields to be updated in this request.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The type of editions.
/// Different features and behaviors are provided to different editions
/// Capacity commitments and reservations are linked to editions.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Edition {
    /// Default value, which will be treated as ENTERPRISE.
    Unspecified = 0,
    /// Standard edition.
    Standard = 1,
    /// Enterprise edition.
    Enterprise = 2,
    /// Enterprise Plus edition.
    EnterprisePlus = 3,
}
impl Edition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EDITION_UNSPECIFIED",
            Self::Standard => "STANDARD",
            Self::Enterprise => "ENTERPRISE",
            Self::EnterprisePlus => "ENTERPRISE_PLUS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDITION_UNSPECIFIED" => Some(Self::Unspecified),
            "STANDARD" => Some(Self::Standard),
            "ENTERPRISE" => Some(Self::Enterprise),
            "ENTERPRISE_PLUS" => Some(Self::EnterprisePlus),
            _ => None,
        }
    }
}
/// The failover mode when a user initiates a failover on a reservation
/// determines how writes that are pending replication are handled after the
/// failover is initiated.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FailoverMode {
    /// Invalid value.
    Unspecified = 0,
    /// When customers initiate a soft failover, BigQuery will wait until all
    /// committed writes are replicated to the secondary. This mode requires both
    /// regions to be available for the failover to succeed and prevents data loss.
    Soft = 1,
    /// When customers initiate a hard failover, BigQuery will not wait until all
    /// committed writes are replicated to the secondary. There can be data loss
    /// for hard failover.
    Hard = 2,
}
impl FailoverMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FAILOVER_MODE_UNSPECIFIED",
            Self::Soft => "SOFT",
            Self::Hard => "HARD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FAILOVER_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SOFT" => Some(Self::Soft),
            "HARD" => Some(Self::Hard),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod reservation_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This API allows users to manage their BigQuery reservations.
    ///
    /// A reservation provides computational resource guarantees, in the form of
    /// [slots](https://cloud.google.com/bigquery/docs/slots), to users. A slot is a
    /// unit of computational power in BigQuery, and serves as the basic unit of
    /// parallelism. In a scan of a multi-partitioned table, a single slot operates
    /// on a single partition of the table. A reservation resource exists as a child
    /// resource of the admin project and location, e.g.:
    /// `projects/myproject/locations/US/reservations/reservationName`.
    ///
    /// A capacity commitment is a way to purchase compute capacity for BigQuery jobs
    /// (in the form of slots) with some committed period of usage. A capacity
    /// commitment resource exists as a child resource of the admin project and
    /// location, e.g.:
    /// `projects/myproject/locations/US/capacityCommitments/id`.
    #[derive(Debug, Clone)]
    pub struct ReservationServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ReservationServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ReservationServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReservationServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ReservationServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new reservation resource.
        pub async fn create_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/CreateReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "CreateReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the reservations for the project in the specified location.
        pub async fn list_reservations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReservationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/ListReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "ListReservations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns information about the reservation.
        pub async fn get_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/GetReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "GetReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a reservation.
        /// Returns `google.rpc.Code.FAILED_PRECONDITION` when reservation has
        /// assignments.
        pub async fn delete_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReservationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/DeleteReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "DeleteReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing reservation resource.
        pub async fn update_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/UpdateReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "UpdateReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fail over a reservation to the secondary location. The operation should be
        /// done in the current secondary location, which will be promoted to the
        /// new primary location for the reservation.
        /// Attempting to failover a reservation in the current primary location will
        /// fail with the error code `google.rpc.Code.FAILED_PRECONDITION`.
        pub async fn failover_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::FailoverReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/FailoverReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "FailoverReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new capacity commitment resource.
        pub async fn create_capacity_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCapacityCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CapacityCommitment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/CreateCapacityCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "CreateCapacityCommitment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the capacity commitments for the admin project.
        pub async fn list_capacity_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCapacityCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCapacityCommitmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/ListCapacityCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "ListCapacityCommitments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns information about the capacity commitment.
        pub async fn get_capacity_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCapacityCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CapacityCommitment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/GetCapacityCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "GetCapacityCommitment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a capacity commitment. Attempting to delete capacity commitment
        /// before its commitment_end_time will fail with the error code
        /// `google.rpc.Code.FAILED_PRECONDITION`.
        pub async fn delete_capacity_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCapacityCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/DeleteCapacityCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "DeleteCapacityCommitment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing capacity commitment.
        ///
        /// Only `plan` and `renewal_plan` fields can be updated.
        ///
        /// Plan can only be changed to a plan of a longer commitment period.
        /// Attempting to change to a plan with shorter commitment period will fail
        /// with the error code `google.rpc.Code.FAILED_PRECONDITION`.
        pub async fn update_capacity_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCapacityCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CapacityCommitment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/UpdateCapacityCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "UpdateCapacityCommitment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Splits capacity commitment to two commitments of the same plan and
        /// `commitment_end_time`.
        ///
        /// A common use case is to enable downgrading commitments.
        ///
        /// For example, in order to downgrade from 10000 slots to 8000, you might
        /// split a 10000 capacity commitment into commitments of 2000 and 8000. Then,
        /// you delete the first one after the commitment end time passes.
        pub async fn split_capacity_commitment(
            &mut self,
            request: impl tonic::IntoRequest<super::SplitCapacityCommitmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SplitCapacityCommitmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/SplitCapacityCommitment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "SplitCapacityCommitment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Merges capacity commitments of the same plan into a single commitment.
        ///
        /// The resulting capacity commitment has the greater commitment_end_time
        /// out of the to-be-merged capacity commitments.
        ///
        /// Attempting to merge capacity commitments of different plan will fail
        /// with the error code `google.rpc.Code.FAILED_PRECONDITION`.
        pub async fn merge_capacity_commitments(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeCapacityCommitmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CapacityCommitment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/MergeCapacityCommitments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "MergeCapacityCommitments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an assignment object which allows the given project to submit jobs
        /// of a certain type using slots from the specified reservation.
        ///
        /// Currently a
        /// resource (project, folder, organization) can only have one assignment per
        /// each (job_type, location) combination, and that reservation will be used
        /// for all jobs of the matching type.
        ///
        /// Different assignments can be created on different levels of the
        /// projects, folders or organization hierarchy.  During query execution,
        /// the assignment is looked up at the project, folder and organization levels
        /// in that order. The first assignment found is applied to the query.
        ///
        /// When creating assignments, it does not matter if other assignments exist at
        /// higher levels.
        ///
        /// Example:
        ///
        /// * The organization `organizationA` contains two projects, `project1`
        ///  and `project2`.
        /// * Assignments for all three entities (`organizationA`, `project1`, and
        ///  `project2`) could all be created and mapped to the same or different
        ///  reservations.
        ///
        /// "None" assignments represent an absence of the assignment. Projects
        /// assigned to None use on-demand pricing. To create a "None" assignment, use
        /// "none" as a reservation_id in the parent. Example parent:
        /// `projects/myproject/locations/US/reservations/none`.
        ///
        /// Returns `google.rpc.Code.PERMISSION_DENIED` if user does not have
        /// 'bigquery.admin' permissions on the project using the reservation
        /// and the project that owns this reservation.
        ///
        /// Returns `google.rpc.Code.INVALID_ARGUMENT` when location of the assignment
        /// does not match location of the reservation.
        pub async fn create_assignment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAssignmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Assignment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/CreateAssignment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "CreateAssignment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists assignments.
        ///
        /// Only explicitly created assignments will be returned.
        ///
        /// Example:
        ///
        /// * Organization `organizationA` contains two projects, `project1` and
        ///  `project2`.
        /// * Reservation `res1` exists and was created previously.
        /// * CreateAssignment was used previously to define the following
        ///  associations between entities and reservations: `<organizationA, res1>`
        ///  and `<project1, res1>`
        ///
        /// In this example, ListAssignments will just return the above two assignments
        /// for reservation `res1`, and no expansion/merge will happen.
        ///
        /// The wildcard "-" can be used for
        /// reservations in the request. In that case all assignments belongs to the
        /// specified project and location will be listed.
        ///
        /// **Note** "-" cannot be used for projects nor locations.
        pub async fn list_assignments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssignmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssignmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/ListAssignments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "ListAssignments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a assignment. No expansion will happen.
        ///
        /// Example:
        ///
        /// * Organization `organizationA` contains two projects, `project1` and
        ///  `project2`.
        /// * Reservation `res1` exists and was created previously.
        /// * CreateAssignment was used previously to define the following
        ///  associations between entities and reservations: `<organizationA, res1>`
        ///  and `<project1, res1>`
        ///
        /// In this example, deletion of the `<organizationA, res1>` assignment won't
        /// affect the other assignment `<project1, res1>`. After said deletion,
        /// queries from `project1` will still use `res1` while queries from
        /// `project2` will switch to use on-demand mode.
        pub async fn delete_assignment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAssignmentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/DeleteAssignment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "DeleteAssignment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Looks up assignments for a specified resource for a particular
        /// region. If the request is about a project:
        ///
        /// 1. Assignments created on the project will be returned if they exist.
        /// 1. Otherwise assignments created on the closest ancestor will be
        ///   returned.
        /// 1. Assignments for different JobTypes will all be returned.
        ///
        /// The same logic applies if the request is about a folder.
        ///
        /// If the request is about an organization, then assignments created on the
        /// organization will be returned (organization doesn't have ancestors).
        ///
        /// Comparing to ListAssignments, there are some behavior
        /// differences:
        ///
        /// 1. permission on the assignee will be verified in this API.
        /// 1. Hierarchy lookup (project->folder->organization) happens in this API.
        /// 1. Parent here is `projects/*/locations/*`, instead of
        ///   `projects/*/locations/*reservations/*`.
        ///
        /// **Note** "-" cannot be used for projects
        /// nor locations.
        #[deprecated]
        pub async fn search_assignments(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAssignmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAssignmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/SearchAssignments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "SearchAssignments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up assignments for a specified resource for a particular region.
        /// If the request is about a project:
        ///
        /// 1. Assignments created on the project will be returned if they exist.
        /// 1. Otherwise assignments created on the closest ancestor will be
        ///   returned.
        /// 1. Assignments for different JobTypes will all be returned.
        ///
        /// The same logic applies if the request is about a folder.
        ///
        /// If the request is about an organization, then assignments created on the
        /// organization will be returned (organization doesn't have ancestors).
        ///
        /// Comparing to ListAssignments, there are some behavior
        /// differences:
        ///
        /// 1. permission on the assignee will be verified in this API.
        /// 1. Hierarchy lookup (project->folder->organization) happens in this API.
        /// 1. Parent here is `projects/*/locations/*`, instead of
        ///   `projects/*/locations/*reservations/*`.
        pub async fn search_all_assignments(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAllAssignmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAllAssignmentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/SearchAllAssignments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "SearchAllAssignments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Moves an assignment under a new reservation.
        ///
        /// This differs from removing an existing assignment and recreating a new one
        /// by providing a transactional change that ensures an assignee always has an
        /// associated reservation.
        pub async fn move_assignment(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveAssignmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Assignment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/MoveAssignment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "MoveAssignment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing assignment.
        ///
        /// Only the `priority` field can be updated.
        pub async fn update_assignment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAssignmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Assignment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/UpdateAssignment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "UpdateAssignment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a BI reservation.
        pub async fn get_bi_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBiReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::BiReservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/GetBiReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "GetBiReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a BI reservation.
        ///
        /// Only fields specified in the `field_mask` are updated.
        ///
        /// A singleton BI reservation always exists with default size 0.
        /// In order to reserve BI capacity it needs to be updated to an amount
        /// greater than 0. In order to release BI capacity reservation size
        /// must be set to 0.
        pub async fn update_bi_reservation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBiReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::BiReservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/UpdateBiReservation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "UpdateBiReservation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource.
        /// May return:
        ///
        /// * A`NOT_FOUND` error if the resource doesn't exist or you don't have the
        ///  permission to view it.
        /// * An empty policy if the resource exists but doesn't have a set policy.
        ///
        /// Supported resources are:
        ///
        /// * Reservations
        /// * ReservationAssignments
        ///
        /// To call this method, you must have the following Google IAM permissions:
        ///
        /// * `bigqueryreservation.reservations.getIamPolicy` to get policies on
        ///  reservations.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets an access control policy for a resource. Replaces any existing
        /// policy.
        ///
        /// Supported resources are:
        ///
        /// * Reservations
        ///
        /// To call this method, you must have the following Google IAM permissions:
        ///
        /// * `bigqueryreservation.reservations.setIamPolicy` to set policies on
        ///  reservations.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets your permissions on a resource. Returns an empty set of permissions if
        /// the resource doesn't exist.
        ///
        /// Supported resources are:
        ///
        /// * Reservations
        ///
        /// No Google IAM permissions are required to call this method.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::super::super::super::super::iam::v1::TestIamPermissionsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new reservation group.
        pub async fn create_reservation_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateReservationGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReservationGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/CreateReservationGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "CreateReservationGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns information about the reservation group.
        pub async fn get_reservation_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReservationGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReservationGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/GetReservationGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "GetReservationGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a reservation.
        /// Returns `google.rpc.Code.FAILED_PRECONDITION` when reservation has
        /// assignments.
        pub async fn delete_reservation_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReservationGroupRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/DeleteReservationGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "DeleteReservationGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the reservation groups for the project in the specified location.
        pub async fn list_reservation_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReservationGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListReservationGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.bigquery.reservation.v1.ReservationService/ListReservationGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.bigquery.reservation.v1.ReservationService",
                        "ListReservationGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
