// This file is @generated by prost-build.
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have
    /// \[google.longrunning.Operation.error\]\[google.longrunning.Operation.error\]
    /// value with a \[google.rpc.Status.code\]\[google.rpc.Status.code\] of `1`,
    /// corresponding to `Code.CANCELLED`.
    #[prost(bool, tag = "5")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "6")]
    pub api_version: ::prost::alloc::string::String,
}
/// A collection of virtual machines and connected resources forming a
/// high-performance computing cluster capable of running large-scale, tightly
/// coupled workloads. A cluster combines a set a compute resources that perform
/// computations, storage resources that contain inputs and store outputs, an
/// orchestrator that is responsible for assigning jobs to compute resources, and
/// network resources that connect everything together.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Cluster {
    /// Identifier. [Relative resource name](<https://google.aip.dev/122>) of the
    /// cluster, in the format
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User-provided description of the cluster.
    #[prost(string, tag = "9")]
    pub description: ::prost::alloc::string::String,
    /// Optional.
    /// [Labels](<https://cloud.google.com/compute/docs/labeling-resources>) applied
    /// to the cluster. Labels can be used to organize clusters and to filter them
    /// in queries.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Time that the cluster was originally created.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time that the cluster was most recently updated.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Indicates whether changes to the cluster are currently in
    /// flight. If this is `true`, then the current state might not match the
    /// cluster's intended state.
    #[prost(bool, tag = "10")]
    pub reconciling: bool,
    /// Optional. Network resources available to the cluster. Must contain at most
    /// one value. Keys specify the ID of the network resource by which it can be
    /// referenced elsewhere, and must conform to
    /// [RFC-1034](<https://datatracker.ietf.org/doc/html/rfc1034>) (lower-case,
    /// alphanumeric, and at most 63 characters).
    #[prost(map = "string, message", tag = "11")]
    pub network_resources: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NetworkResource,
    >,
    /// Optional. Storage resources available to the cluster. Keys specify the ID
    /// of the storage resource by which it can be referenced elsewhere, and must
    /// conform to [RFC-1034](<https://datatracker.ietf.org/doc/html/rfc1034>)
    /// (lower-case, alphanumeric, and at most 63 characters).
    #[prost(map = "string, message", tag = "12")]
    pub storage_resources: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StorageResource,
    >,
    /// Optional. Compute resources available to the cluster. Keys specify the ID
    /// of the compute resource by which it can be referenced elsewhere, and must
    /// conform to [RFC-1034](<https://datatracker.ietf.org/doc/html/rfc1034>)
    /// (lower-case, alphanumeric, and at most 63 characters).
    #[prost(map = "string, message", tag = "13")]
    pub compute_resources: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ComputeResource,
    >,
    /// Optional. Orchestrator that is responsible for scheduling and running jobs
    /// on the cluster.
    #[prost(message, optional, tag = "8")]
    pub orchestrator: ::core::option::Option<Orchestrator>,
    /// Optional. Deprecated. Use network_resources instead.
    #[deprecated]
    #[prost(message, repeated, tag = "5")]
    pub networks: ::prost::alloc::vec::Vec<Network>,
    /// Optional. Deprecated. Use storage_resources instead.
    #[deprecated]
    #[prost(message, repeated, tag = "6")]
    pub storages: ::prost::alloc::vec::Vec<Storage>,
    /// Optional. Deprecated. Use compute_resources instead.
    #[deprecated]
    #[prost(message, optional, tag = "7")]
    pub compute: ::core::option::Option<Compute>,
}
/// Request message for
/// \[ListClusters\]\[google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster.ListClusters\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListClustersRequest {
    /// Required. Parent location of the clusters to list, in the format
    /// `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Maximum number of clusters to return. The service may return
    /// fewer than this value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token received from a previous `ListClusters` call.
    /// Provide this to retrieve the subsequent page. When paginating, all other
    /// parameters provided to `ListClusters` must match the call that provided the
    /// page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. [Filter](<https://google.aip.dev/160>) to apply to the returned
    /// results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. How to order the resulting clusters. Must be one of the following
    /// strings:
    ///
    /// * `name`
    /// * `name desc`
    /// * `create_time`
    /// * `create_time desc`
    ///
    /// If not specified, clusters will be returned in an arbitrary order.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for
/// \[ListClusters\]\[google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster.ListClusters\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListClustersResponse {
    /// Clusters in the specified location.
    #[prost(message, repeated, tag = "1")]
    pub clusters: ::prost::alloc::vec::Vec<Cluster>,
    /// A token that can be sent as `page_token` to retrieve the next page. If this
    /// field is absent, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for
/// \[GetCluster\]\[google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster.GetCluster\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetClusterRequest {
    /// Required. Name of the cluster to retrieve, in the format
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for
/// \[CreateCluster\]\[google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster.CreateCluster\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateClusterRequest {
    /// Required. Parent location in which the cluster should be created, in the
    /// format `projects/{project}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the cluster to create. Must conform to
    /// [RFC-1034](<https://datatracker.ietf.org/doc/html/rfc1034>) (lower-case,
    /// alphanumeric, and at most 63 characters).
    #[prost(string, tag = "2")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Required. Cluster to create.
    #[prost(message, optional, tag = "3")]
    pub cluster: ::core::option::Option<Cluster>,
    /// Optional. A unique identifier for this request. A random UUID is
    /// recommended. This request is idempotent if and only if `request_id` is
    /// provided.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for
/// \[UpdateCluster\]\[google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster.UpdateCluster\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateClusterRequest {
    /// Required. Cluster to update.
    #[prost(message, optional, tag = "2")]
    pub cluster: ::core::option::Option<Cluster>,
    /// Optional. Mask specifying which fields in the cluster to update. All paths
    /// must be specified explicitly - wildcards are not supported. At least one
    /// path must be provided.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Optional. A unique identifier for this request. A random UUID is
    /// recommended. This request is idempotent if and only if `request_id` is
    /// provided.
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request message for
/// \[DeleteCluster\]\[google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster.DeleteCluster\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteClusterRequest {
    /// Required. Name of the cluster to delete, in the format
    /// `projects/{project}/locations/{location}/clusters/{cluster}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. A unique identifier for this request. A random UUID is
    /// recommended. This request is idempotent if and only if `request_id` is
    /// provided.
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// A resource representing a network that connects the various components of a
/// cluster together.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkResource {
    /// Immutable. Configuration for this network resource, which describes how it
    /// should be created or imported. This field only controls how the network
    /// resource is initially created or imported. Subsequent changes to the
    /// network resource should be made via the resource's API and will not be
    /// reflected in the configuration.
    #[prost(message, optional, tag = "2")]
    pub config: ::core::option::Option<NetworkResourceConfig>,
    /// Reference to the network resource in Google Cloud. Exactly one of these
    /// fields will be populated based on the configured type of network resource.
    #[prost(oneof = "network_resource::Reference", tags = "3, 1")]
    pub reference: ::core::option::Option<network_resource::Reference>,
}
/// Nested message and enum types in `NetworkResource`.
pub mod network_resource {
    /// Reference to the network resource in Google Cloud. Exactly one of these
    /// fields will be populated based on the configured type of network resource.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Reference {
        /// Reference to a network in Google Compute Engine.
        #[prost(message, tag = "3")]
        Network(super::NetworkReference),
        /// Deprecated: Use network instead.
        #[prost(message, tag = "1")]
        ComputeNetwork(super::ComputeNetworkReference),
    }
}
/// A reference to a [VPC network](<https://cloud.google.com/vpc/docs/vpc>) in
/// Google Compute Engine.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkReference {
    /// Output only. Name of the network, in the format
    /// `projects/{project}/global/networks/{network}`.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Output only. Name of the particular subnetwork being used by the cluster,
    /// in the format
    /// `projects/{project}/regions/{region}/subnetworks/{subnetwork}`.
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
}
/// Describes how a network resource should be initialized. Each network resource
/// can either be imported from an existing Google Cloud resource or initialized
/// when the cluster is created.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkResourceConfig {
    /// Particular type of configuration for this network resource.
    #[prost(oneof = "network_resource_config::Config", tags = "3, 4, 1, 2")]
    pub config: ::core::option::Option<network_resource_config::Config>,
}
/// Nested message and enum types in `NetworkResourceConfig`.
pub mod network_resource_config {
    /// Particular type of configuration for this network resource.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Config {
        /// Optional. Immutable. If set, indicates that a new network should be
        /// created.
        #[prost(message, tag = "3")]
        NewNetwork(super::NewNetworkConfig),
        /// Optional. Immutable. If set, indicates that an existing network should be
        /// imported.
        #[prost(message, tag = "4")]
        ExistingNetwork(super::ExistingNetworkConfig),
        /// Immutable. Deprecated: Use new_network instead.
        #[prost(message, tag = "1")]
        NewComputeNetwork(super::NewComputeNetworkConfig),
        /// Immutable. Deprecated: Use existing_network instead.
        #[prost(message, tag = "2")]
        ExistingComputeNetwork(super::ExistingComputeNetworkConfig),
    }
}
/// When set in a
/// \[NetworkResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.NetworkResourceConfig\],
/// indicates that a new network should be created.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewNetworkConfig {
    /// Required. Immutable. Name of the network to create, in the format
    /// `projects/{project}/global/networks/{network}`.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Optional. Immutable. Description of the network. Maximum of 2048
    /// characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
/// When set in a
/// \[NetworkResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.NetworkResourceConfig\],
/// indicates that an existing network should be imported.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExistingNetworkConfig {
    /// Required. Immutable. Name of the network to import, in the format
    /// `projects/{project}/global/networks/{network}`.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Required. Immutable. Particular subnetwork to use, in the format
    /// `projects/{project}/regions/{region}/subnetworks/{subnetwork}`.
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
}
/// A resource representing a form of persistent storage that is accessible to
/// compute resources in the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageResource {
    /// Required. Immutable. Configuration for this storage resource, which
    /// describes how it should be created or imported. This field only controls
    /// how the storage resource is initially created or imported. Subsequent
    /// changes to the storage resource should be made via the resource's API and
    /// will not be reflected in the configuration.
    #[prost(message, optional, tag = "4")]
    pub config: ::core::option::Option<StorageResourceConfig>,
    /// Reference to the storage resource in Google Cloud. Exactly one of these
    /// fields will be populated based on the configured type of storage resource.
    #[prost(oneof = "storage_resource::Reference", tags = "1, 2, 3")]
    pub reference: ::core::option::Option<storage_resource::Reference>,
}
/// Nested message and enum types in `StorageResource`.
pub mod storage_resource {
    /// Reference to the storage resource in Google Cloud. Exactly one of these
    /// fields will be populated based on the configured type of storage resource.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Reference {
        /// Reference to a Filestore instance. Populated if and only if the storage
        /// resource was configured to use Filestore.
        #[prost(message, tag = "1")]
        Filestore(super::FilestoreReference),
        /// Reference to a Google Cloud Storage bucket. Populated if and only if the
        /// storage resource was configured to use Google Cloud Storage.
        #[prost(message, tag = "2")]
        Bucket(super::BucketReference),
        /// Reference to a Managed Lustre instance. Populated if and only if the
        /// storage resource was configured to use Managed Lustre.
        #[prost(message, tag = "3")]
        Lustre(super::LustreReference),
    }
}
/// A reference to a [Filestore](<https://cloud.google.com/filestore>) instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FilestoreReference {
    /// Output only. Name of the Filestore instance, in the format
    /// `projects/{project}/locations/{location}/instances/{instance}`
    #[prost(string, tag = "1")]
    pub filestore: ::prost::alloc::string::String,
}
/// A reference to a [Google Cloud Storage](<https://cloud.google.com/storage>)
/// bucket.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BucketReference {
    /// Output only. Name of the bucket.
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
}
/// A reference to a [Managed
/// Lustre](<https://cloud.google.com/products/managed-lustre>) instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LustreReference {
    /// Output only. Name of the Managed Lustre instance, in the format
    /// `projects/{project}/locations/{location}/instances/{instance}`
    #[prost(string, tag = "1")]
    pub lustre: ::prost::alloc::string::String,
}
/// Describes how a storage resource should be initialized. Each storage resource
/// can either be imported from an existing Google Cloud resource or initialized
/// when the cluster is created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageResourceConfig {
    /// Particular type of configuration for this storage resource.
    #[prost(oneof = "storage_resource_config::Config", tags = "1, 2, 3, 4, 5, 6")]
    pub config: ::core::option::Option<storage_resource_config::Config>,
}
/// Nested message and enum types in `StorageResourceConfig`.
pub mod storage_resource_config {
    /// Particular type of configuration for this storage resource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Optional. Immutable. If set, indicates that a new Filestore instance
        /// should be created.
        #[prost(message, tag = "1")]
        NewFilestore(super::NewFilestoreConfig),
        /// Optional. Immutable. If set, indicates that an existing Filestore
        /// instance should be imported.
        #[prost(message, tag = "2")]
        ExistingFilestore(super::ExistingFilestoreConfig),
        /// Optional. Immutable. If set, indicates that a new Cloud Storage bucket
        /// should be created.
        #[prost(message, tag = "3")]
        NewBucket(super::NewBucketConfig),
        /// Optional. Immutable. If set, indicates that an existing Cloud Storage
        /// bucket should be imported.
        #[prost(message, tag = "4")]
        ExistingBucket(super::ExistingBucketConfig),
        /// Optional. Immutable. If set, indicates that a new Managed Lustre instance
        /// should be created.
        #[prost(message, tag = "5")]
        NewLustre(super::NewLustreConfig),
        /// Optional. Immutable. If set, indicates that an existing Managed Lustre
        /// instance should be imported.
        #[prost(message, tag = "6")]
        ExistingLustre(super::ExistingLustreConfig),
    }
}
/// When set in a
/// \[StorageResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.StorageResourceConfig\],
/// indicates that a new [Filestore](<https://cloud.google.com/filestore>) instance
/// should be created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewFilestoreConfig {
    /// Required. Immutable. Name of the Filestore instance to create, in the
    /// format `projects/{project}/locations/{location}/instances/{instance}`
    #[prost(string, tag = "1")]
    pub filestore: ::prost::alloc::string::String,
    /// Optional. Immutable. Description of the instance. Maximum of 2048
    /// characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Required. Immutable. File system shares on the instance. Exactly one file
    /// share must be specified.
    #[prost(message, repeated, tag = "2")]
    pub file_shares: ::prost::alloc::vec::Vec<FileShareConfig>,
    /// Required. Immutable. Service tier to use for the instance.
    #[prost(enumeration = "new_filestore_config::Tier", tag = "3")]
    pub tier: i32,
    /// Optional. Immutable. Access protocol to use for all file shares in the
    /// instance. Defaults to NFS V3 if not set.
    #[prost(enumeration = "new_filestore_config::Protocol", tag = "5")]
    pub protocol: i32,
}
/// Nested message and enum types in `NewFilestoreConfig`.
pub mod new_filestore_config {
    /// Available [service
    /// tiers](<https://cloud.google.com/filestore/docs/service-tiers>) for Filestore
    /// instances.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tier {
        /// Not set.
        Unspecified = 0,
        /// Offers expanded capacity and performance scaling capabilities suitable
        /// for high-performance computing application requirements.
        Zonal = 4,
        /// Offers features and availability needed for mission-critical,
        /// high-performance computing workloads.
        Regional = 6,
        /// Deprecated: Use a different tier instead.
        BasicHdd = 1,
        /// Deprecated: Use a different tier instead.
        BasicSsd = 2,
        /// Deprecated: Use a different tier instead.
        HighScaleSsd = 3,
        /// Deprecated: Use a different tier instead.
        Enterprise = 5,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIER_UNSPECIFIED",
                Self::Zonal => "ZONAL",
                Self::Regional => "REGIONAL",
                Self::BasicHdd => "BASIC_HDD",
                Self::BasicSsd => "BASIC_SSD",
                Self::HighScaleSsd => "HIGH_SCALE_SSD",
                Self::Enterprise => "ENTERPRISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "ZONAL" => Some(Self::Zonal),
                "REGIONAL" => Some(Self::Regional),
                "BASIC_HDD" => Some(Self::BasicHdd),
                "BASIC_SSD" => Some(Self::BasicSsd),
                "HIGH_SCALE_SSD" => Some(Self::HighScaleSsd),
                "ENTERPRISE" => Some(Self::Enterprise),
                _ => None,
            }
        }
    }
    /// File access protocol for Filestore instances.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        /// Not set.
        Unspecified = 0,
        /// NFS 3.0.
        Nfsv3 = 1,
        /// NFS 4.1.
        Nfsv41 = 2,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROTOCOL_UNSPECIFIED",
                Self::Nfsv3 => "NFSV3",
                Self::Nfsv41 => "NFSV41",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
                "NFSV3" => Some(Self::Nfsv3),
                "NFSV41" => Some(Self::Nfsv41),
                _ => None,
            }
        }
    }
}
/// Message describing filestore configuration
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FileShareConfig {
    /// Required. Size of the filestore in GB
    #[prost(int64, tag = "1")]
    pub capacity_gb: i64,
    /// Required. Filestore share location
    #[prost(string, tag = "2")]
    pub file_share: ::prost::alloc::string::String,
}
/// When set in a
/// \[StorageResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.StorageResourceConfig\],
/// indicates that an existing [Filestore](<https://cloud.google.com/filestore>)
/// instance should be imported.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExistingFilestoreConfig {
    /// Required. Immutable. Name of the Filestore instance to import, in the
    /// format `projects/{project}/locations/{location}/instances/{instance}`
    #[prost(string, tag = "1")]
    pub filestore: ::prost::alloc::string::String,
}
/// When set in a
/// \[StorageResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.StorageResourceConfig\],
/// indicates that a new [Google Cloud Storage](<https://cloud.google.com/storage>)
/// bucket should be created.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewBucketConfig {
    /// Required. Immutable. Name of the Cloud Storage bucket to create.
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    /// Optional. Immutable. If set, indicates that the bucket should use
    /// [hierarchical
    /// namespaces](<https://cloud.google.com/storage/docs/hns-overview>).
    #[prost(message, optional, tag = "4")]
    pub hierarchical_namespace: ::core::option::Option<GcsHierarchicalNamespaceConfig>,
    /// Storage class of the bucket, which can be set automatically or explicitly.
    #[prost(oneof = "new_bucket_config::Option", tags = "2, 3")]
    pub option: ::core::option::Option<new_bucket_config::Option>,
}
/// Nested message and enum types in `NewBucketConfig`.
pub mod new_bucket_config {
    /// [Storage class](<https://cloud.google.com/storage/docs/storage-classes>) for
    /// a Cloud Storage bucket.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageClass {
        /// Not set.
        Unspecified = 0,
        /// Best for data that is frequently accessed.
        Standard = 1,
        /// Low-cost storage for data that is accessed less frequently.
        Nearline = 2,
        /// Very low-cost storage for infrequently accessed data.
        Coldline = 3,
        /// Lowest-cost storage for data archiving, online backup, and disaster
        /// recovery.
        Archive = 4,
    }
    impl StorageClass {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STORAGE_CLASS_UNSPECIFIED",
                Self::Standard => "STANDARD",
                Self::Nearline => "NEARLINE",
                Self::Coldline => "COLDLINE",
                Self::Archive => "ARCHIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STORAGE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "NEARLINE" => Some(Self::Nearline),
                "COLDLINE" => Some(Self::Coldline),
                "ARCHIVE" => Some(Self::Archive),
                _ => None,
            }
        }
    }
    /// Storage class of the bucket, which can be set automatically or explicitly.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Option {
        /// Optional. Immutable. If set, indicates that the bucket should use
        /// [Autoclass](<https://cloud.google.com/storage/docs/autoclass>).
        #[prost(message, tag = "2")]
        Autoclass(super::GcsAutoclassConfig),
        /// Optional. Immutable. If set, uses the provided storage class as the
        /// bucket's default storage class.
        #[prost(enumeration = "StorageClass", tag = "3")]
        StorageClass(i32),
    }
}
/// Message describing Google Cloud Storage autoclass configuration
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcsAutoclassConfig {
    /// Required. Enables Auto-class feature.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    /// Optional. Terminal storage class of the autoclass bucket
    #[prost(enumeration = "gcs_autoclass_config::TerminalStorageClass", tag = "2")]
    pub terminal_storage_class: i32,
}
/// Nested message and enum types in `GcsAutoclassConfig`.
pub mod gcs_autoclass_config {
    /// Terminal storage class types of the autoclass bucket
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TerminalStorageClass {
        /// Unspecified terminal storage class
        Unspecified = 0,
        /// Nearline terminal storage class
        Nearline = 1,
        /// Archive terminal storage class
        Archive = 2,
    }
    impl TerminalStorageClass {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TERMINAL_STORAGE_CLASS_UNSPECIFIED",
                Self::Nearline => "TERMINAL_STORAGE_CLASS_NEARLINE",
                Self::Archive => "TERMINAL_STORAGE_CLASS_ARCHIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TERMINAL_STORAGE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
                "TERMINAL_STORAGE_CLASS_NEARLINE" => Some(Self::Nearline),
                "TERMINAL_STORAGE_CLASS_ARCHIVE" => Some(Self::Archive),
                _ => None,
            }
        }
    }
}
/// Message describing Google Cloud Storage hierarchical namespace configuration
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcsHierarchicalNamespaceConfig {
    /// Required. Enables hierarchical namespace setup for the bucket.
    #[prost(bool, tag = "1")]
    pub enabled: bool,
}
/// When set in a
/// \[StorageResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.StorageResourceConfig\],
/// indicates that an existing [Google Cloud
/// Storage](<https://cloud.google.com/storage>) bucket should be imported.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExistingBucketConfig {
    /// Required. Immutable. Name of the Cloud Storage bucket to import.
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
}
/// When set in a
/// \[StorageResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.StorageResourceConfig\],
/// indicates that a new [Managed
/// Lustre](<https://cloud.google.com/products/managed-lustre>) instance should be
/// created.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewLustreConfig {
    /// Required. Immutable. Name of the Managed Lustre instance to create, in the
    /// format `projects/{project}/locations/{location}/instances/{instance}`
    #[prost(string, tag = "1")]
    pub lustre: ::prost::alloc::string::String,
    /// Optional. Immutable. Description of the Managed Lustre instance. Maximum of
    /// 2048 characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Required. Immutable. Filesystem name for this instance. This name is used
    /// by client-side tools, including when mounting the instance. Must be 8
    /// characters or less and can only contain letters and numbers.
    #[prost(string, tag = "3")]
    pub filesystem: ::prost::alloc::string::String,
    /// Required. Immutable. Storage capacity of the instance in gibibytes (GiB).
    /// Allowed values are between 18000 and 7632000.
    #[prost(int64, tag = "4")]
    pub capacity_gb: i64,
}
/// When set in a
/// \[StorageResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.StorageResourceConfig\],
/// indicates that an existing [Managed
/// Lustre](<https://cloud.google.com/products/managed-lustre>) instance should be
/// imported.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExistingLustreConfig {
    /// Required. Immutable. Name of the Managed Lustre instance to import, in the
    /// format `projects/{project}/locations/{location}/instances/{instance}`
    #[prost(string, tag = "1")]
    pub lustre: ::prost::alloc::string::String,
}
/// A resource defining how virtual machines and accelerators should be
/// provisioned for the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeResource {
    /// Required. Immutable. Configuration for this compute resource, which
    /// describes how it should be created at runtime.
    #[prost(message, optional, tag = "6")]
    pub config: ::core::option::Option<ComputeResourceConfig>,
    /// Deprecated: Use config.
    #[prost(oneof = "compute_resource::ConfigOneof", tags = "2, 3, 4, 5")]
    pub config_oneof: ::core::option::Option<compute_resource::ConfigOneof>,
}
/// Nested message and enum types in `ComputeResource`.
pub mod compute_resource {
    /// Deprecated: Use config.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ConfigOneof {
        /// Deprecated: Use config.
        #[prost(message, tag = "2")]
        NewOnDemandInstances(super::NewOnDemandInstancesConfig),
        /// Deprecated: Use config.
        #[prost(message, tag = "3")]
        NewSpotInstances(super::NewSpotInstancesConfig),
        /// Deprecated: Use config.
        #[prost(message, tag = "4")]
        NewReservedInstances(super::NewReservedInstancesConfig),
        /// Deprecated: Use config.
        #[prost(message, tag = "5")]
        NewDwsFlexInstances(super::NewDwsFlexInstancesConfig),
    }
}
/// Describes how a compute resource should be created at runtime.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeResourceConfig {
    /// Particular type of configuration for this compute resource.
    #[prost(oneof = "compute_resource_config::Config", tags = "1, 2, 3, 4, 5")]
    pub config: ::core::option::Option<compute_resource_config::Config>,
}
/// Nested message and enum types in `ComputeResourceConfig`.
pub mod compute_resource_config {
    /// Particular type of configuration for this compute resource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Config {
        /// Optional. Immutable. If set, indicates that this resource should use
        /// on-demand VMs.
        #[prost(message, tag = "1")]
        NewOnDemandInstances(super::NewOnDemandInstancesConfig),
        /// Optional. Immutable. If set, indicates that this resource should use spot
        /// VMs.
        #[prost(message, tag = "2")]
        NewSpotInstances(super::NewSpotInstancesConfig),
        /// Optional. Immutable. If set, indicates that this resource should use
        /// reserved VMs.
        #[prost(message, tag = "3")]
        NewReservedInstances(super::NewReservedInstancesConfig),
        /// Optional. Immutable. If set, indicates that this resource should use
        /// flex-start VMs.
        #[prost(message, tag = "4")]
        NewDwsFlexInstances(super::NewDwsFlexInstancesConfig),
        /// Optional. Immutable. If set, indicates that this resource should use
        /// flex-start VMs.
        #[prost(message, tag = "5")]
        NewFlexStartInstances(super::NewFlexStartInstancesConfig),
    }
}
/// When set in a
/// \[ComputeResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.ComputeResourceConfig\],
/// indicates that on-demand (i.e., using the standard provisioning model) VM
/// instances should be created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewOnDemandInstancesConfig {
    /// Required. Immutable. Name of the zone in which VM instances should run,
    /// e.g., `us-central1-a`. Must be in the same region as the cluster, and must
    /// match the zone of any other resources specified in the cluster.
    #[prost(string, tag = "1")]
    pub zone: ::prost::alloc::string::String,
    /// Required. Immutable. Name of the Compute Engine [machine
    /// type](<https://cloud.google.com/compute/docs/machine-resource>) to use, e.g.
    /// `n2-standard-2`.
    #[prost(string, tag = "2")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(map = "string, string", tag = "3")]
    pub atm_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. Deprecated: set disks in node config instead.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub boot_disk: ::core::option::Option<Disk>,
}
/// When set in a
/// \[ComputeResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.ComputeResourceConfig\],
/// indicates that [spot
/// VM](<https://cloud.google.com/compute/docs/instances/spot>) instances should be
/// created.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewSpotInstancesConfig {
    /// Required. Immutable. Name of the zone in which VM instances should run,
    /// e.g., `us-central1-a`. Must be in the same region as the cluster, and must
    /// match the zone of any other resources specified in the cluster.
    #[prost(string, tag = "1")]
    pub zone: ::prost::alloc::string::String,
    /// Required. Immutable. Name of the Compute Engine [machine
    /// type](<https://cloud.google.com/compute/docs/machine-resource>) to use, e.g.
    /// `n2-standard-2`.
    #[prost(string, tag = "2")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(map = "string, string", tag = "3")]
    pub atm_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Immutable. Deprecated: set disks in node config instead.
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub boot_disk: ::core::option::Option<Disk>,
    /// Optional. Specifies the termination action of the instance
    #[prost(enumeration = "new_spot_instances_config::TerminationAction", tag = "5")]
    pub termination_action: i32,
}
/// Nested message and enum types in `NewSpotInstancesConfig`.
pub mod new_spot_instances_config {
    /// Specifies the termination action of the instance
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TerminationAction {
        /// Unspecified termination action
        Unspecified = 0,
        /// Stop the instance
        Stop = 1,
        /// Delete the instance
        Delete = 2,
    }
    impl TerminationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TERMINATION_ACTION_UNSPECIFIED",
                Self::Stop => "STOP",
                Self::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TERMINATION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "STOP" => Some(Self::Stop),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
/// When set in a
/// \[ComputeResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.ComputeResourceConfig\],
/// indicates that VM instances should be created from a
/// [reservation](<https://cloud.google.com/compute/docs/instances/reservations-overview>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewReservedInstancesConfig {
    /// Required. Immutable. Name of the reservation from which VM instances should
    /// be created, in the format
    /// `projects/{project}/zones/{zone}/reservations/{reservation}`.
    #[prost(string, tag = "1")]
    pub reservation: ::prost::alloc::string::String,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(map = "string, string", tag = "2")]
    pub atm_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Immutable. Deprecated: Do not use.
    #[deprecated]
    #[prost(string, tag = "3")]
    pub zone: ::prost::alloc::string::String,
    /// Optional. Immutable. Deprecated: Do not use.
    #[deprecated]
    #[prost(string, tag = "4")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. Immutable. Deprecated: Do not use.
    #[deprecated]
    #[prost(enumeration = "new_reserved_instances_config::ReservationType", tag = "5")]
    pub r#type: i32,
    /// Optional. Immutable. Deprecated: set disks in node config instead.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub boot_disk: ::core::option::Option<Disk>,
}
/// Nested message and enum types in `NewReservedInstancesConfig`.
pub mod new_reserved_instances_config {
    /// Deprecated: Do not use.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReservationType {
        /// Deprecated: Do not use.
        Unspecified = 0,
        /// Deprecated: Do not use.
        NoReservation = 1,
        /// Deprecated: Do not use.
        AnyReservation = 2,
        /// Deprecated: Do not use.
        SpecificReservation = 3,
    }
    impl ReservationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESERVATION_TYPE_UNSPECIFIED",
                Self::NoReservation => "NO_RESERVATION",
                Self::AnyReservation => "ANY_RESERVATION",
                Self::SpecificReservation => "SPECIFIC_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NO_RESERVATION" => Some(Self::NoReservation),
                "ANY_RESERVATION" => Some(Self::AnyReservation),
                "SPECIFIC_RESERVATION" => Some(Self::SpecificReservation),
                _ => None,
            }
        }
    }
}
/// When set in a
/// \[ComputeResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.ComputeResourceConfig\],
/// indicates that VM instances should be created using [Flex
/// Start](<https://cloud.google.com/compute/docs/instances/provisioning-models>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewFlexStartInstancesConfig {
    /// Required. Immutable. Name of the zone in which VM instances should run,
    /// e.g., `us-central1-a`. Must be in the same region as the cluster, and must
    /// match the zone of any other resources specified in the cluster.
    #[prost(string, tag = "1")]
    pub zone: ::prost::alloc::string::String,
    /// Required. Immutable. Name of the Compute Engine [machine
    /// type](<https://cloud.google.com/compute/docs/machine-resource>) to use, e.g.
    /// `n2-standard-2`.
    #[prost(string, tag = "2")]
    pub machine_type: ::prost::alloc::string::String,
    /// Required. Immutable. Specifies the time limit for created instances.
    /// Instances will be terminated at the end of this duration.
    #[prost(message, optional, tag = "3")]
    pub max_duration: ::core::option::Option<::prost_types::Duration>,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(map = "string, string", tag = "4")]
    pub atm_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Immutable. Deprecated: Do not use.
    #[deprecated]
    #[prost(
        enumeration = "new_flex_start_instances_config::TerminationAction",
        tag = "5"
    )]
    pub termination_action: i32,
    /// Optional. Immutable. Deprecated: set disks in node config instead.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub boot_disk: ::core::option::Option<Disk>,
}
/// Nested message and enum types in `NewFlexStartInstancesConfig`.
pub mod new_flex_start_instances_config {
    /// Deprecated: Do not use.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TerminationAction {
        /// Deprecated: Do not use.
        Unspecified = 0,
        /// Deprecated: Do not use.
        Stop = 1,
        /// Deprecated: Do not use.
        Delete = 2,
    }
    impl TerminationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TERMINATION_ACTION_UNSPECIFIED",
                Self::Stop => "STOP",
                Self::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TERMINATION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "STOP" => Some(Self::Stop),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
/// Unstable: Contact hypercompute-service-eng@ before using.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Disk {
    /// Required. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Required. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(int64, tag = "2")]
    pub size_gb: i64,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(bool, tag = "3")]
    pub boot: bool,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(string, tag = "4")]
    pub source_image: ::prost::alloc::string::String,
}
/// A [Persistent disk](<https://cloud.google.com/compute/docs/disks>) used as the
/// boot disk for a Compute Engine VM instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BootDisk {
    /// Required. Immutable. [Persistent disk
    /// type](<https://cloud.google.com/compute/docs/disks#disk-types>), in the
    /// format `projects/{project}/zones/{zone}/diskTypes/{disk_type}`.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Required. Immutable. Size of the disk in gigabytes. Must be at least 10GB.
    #[prost(int64, tag = "2")]
    pub size_gb: i64,
    /// Optional. Immutable. Source image used to create this disk. Must be a
    /// \[supported disk family\]\[...\] for the VM instance's machine type. If this is
    /// empty, the system will select a supported image based on the machine type.
    #[prost(string, tag = "3")]
    pub image: ::prost::alloc::string::String,
    /// Output only. The specific image that will be used for new VM instances.
    #[prost(string, tag = "4")]
    pub effective_image: ::prost::alloc::string::String,
}
/// Unstable: Contact hypercompute-service-eng@ before using.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AtmTag {
    /// Required. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Required. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
/// The component responsible for scheduling and running workloads on the
/// cluster as well as providing the user interface for interacting with the
/// cluster at runtime.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Orchestrator {
    /// Particular type of orchestrator to use in this cluster.
    #[prost(oneof = "orchestrator::Option", tags = "1")]
    pub option: ::core::option::Option<orchestrator::Option>,
}
/// Nested message and enum types in `Orchestrator`.
pub mod orchestrator {
    /// Particular type of orchestrator to use in this cluster.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Option {
        /// Optional. If set, indicates that the cluster should use Slurm as the
        /// orchestrator.
        #[prost(message, tag = "1")]
        Slurm(super::SlurmOrchestrator),
    }
}
/// When set in
/// \[Orchestrator\]\[google.cloud.hypercomputecluster.v1alpha.Orchestrator\],
/// indicates that the cluster should use [Slurm](<https://slurm.schedmd.com/>) as
/// the orchestrator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlurmOrchestrator {
    /// Required. Configuration for login nodes, which allow users to access the
    /// cluster over SSH.
    #[prost(message, optional, tag = "6")]
    pub login_nodes: ::core::option::Option<SlurmLoginNodes>,
    /// Required. Configuration of Slurm nodesets, which define groups of compute
    /// resources that can be used by Slurm. At least one compute node is required.
    #[prost(message, repeated, tag = "1")]
    pub node_sets: ::prost::alloc::vec::Vec<SlurmNodeSet>,
    /// Required. Configuration of Slurm partitions, which group one or more
    /// nodesets. Acts as a queue against which jobs can be submitted. At least one
    /// partition is required.
    #[prost(message, repeated, tag = "2")]
    pub partitions: ::prost::alloc::vec::Vec<SlurmPartition>,
    /// Optional. Default partition to use for submitted jobs that do not
    /// explicitly specify a partition. Required if and only if there is more than
    /// one partition, in which case it must match the id of one of the partitions.
    #[prost(string, tag = "3")]
    pub default_partition: ::prost::alloc::string::String,
    /// Optional. Slurm [prolog
    /// scripts](<https://slurm.schedmd.com/prolog_epilog.html>), which will be
    /// executed by compute nodes before a node begins running a new job.
    #[prost(string, repeated, tag = "4")]
    pub prolog_bash_scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Slurm [epilog
    /// scripts](<https://slurm.schedmd.com/prolog_epilog.html>), which will be
    /// executed by compute nodes whenever a node finishes running a job.
    #[prost(string, repeated, tag = "5")]
    pub epilog_bash_scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(message, optional, tag = "7")]
    pub config: ::core::option::Option<slurm_orchestrator::SlurmConfig>,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(string, repeated, tag = "8")]
    pub task_prolog_bash_scripts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(string, repeated, tag = "9")]
    pub task_epilog_bash_scripts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `SlurmOrchestrator`.
pub mod slurm_orchestrator {
    /// Slurm orchestrator configuration. Values correspond to a subset of those
    /// found in <https://slurm.schedmd.com/slurm.conf.html.>
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct SlurmConfig {
        /// Optional. Enables automatic requeue for batch jobs which exit with the
        /// specified values. Default is empty. Corresponds to RequeueExit.
        #[prost(int64, repeated, packed = "false", tag = "1")]
        pub requeue_exit_codes: ::prost::alloc::vec::Vec<i64>,
        /// Optional. Enables automatic requeue for batch jobs which exit with the
        /// specified values, with these jobs being held until released manually by
        /// the user. Default is empty. Corresponds to RequeueExitHold.
        #[prost(int64, repeated, packed = "false", tag = "2")]
        pub requeue_hold_exit_codes: ::prost::alloc::vec::Vec<i64>,
        /// Optional. Flags to control the Prolog behavior. By default no flags are
        /// set. Corresponds to PrologFlags.
        #[prost(
            enumeration = "slurm_config::PrologFlag",
            repeated,
            packed = "false",
            tag = "3"
        )]
        pub prolog_flags: ::prost::alloc::vec::Vec<i32>,
        /// Optional. The interval Slurm waits for Prolog and Epilog before
        /// terminating them. Default is 65534 seconds. Corresponds to
        /// PrologEpilogTimeout.
        #[prost(message, optional, tag = "4")]
        pub prolog_epilog_timeout: ::core::option::Option<::prost_types::Duration>,
        /// Optional. Flags to control the level of association to impose on job
        /// submissions. By default no flags are set. Corresponds to
        /// AccountingStorageEnforce.
        #[prost(
            enumeration = "slurm_config::AccountingStorageEnforceFlag",
            repeated,
            packed = "false",
            tag = "5"
        )]
        pub accounting_storage_enforce_flags: ::prost::alloc::vec::Vec<i32>,
        /// Optional. Specifies the plugin to be used in establishing a job's
        /// scheduling priority. Set this value to "priority/multifactor" to enable
        /// the Multifactor Job Priority Plugin.
        #[prost(enumeration = "slurm_config::PriorityType", tag = "6")]
        pub priority_type: i32,
        /// Optional. An unsigned integer that scales the contribution of the age
        /// factor.
        #[prost(int64, tag = "7")]
        pub priority_weight_age: i64,
        /// Optional. An unsigned integer that scales the contribution of the
        /// association factor.
        #[prost(int64, tag = "8")]
        pub priority_weight_assoc: i64,
        /// Optional. An unsigned integer that scales the contribution of the
        /// fair-share factor.
        #[prost(int64, tag = "9")]
        pub priority_weight_fairshare: i64,
        /// Optional. An unsigned integer that scales the contribution of the job
        /// size factor.
        #[prost(int64, tag = "10")]
        pub priority_weight_job_size: i64,
        /// Optional. An unsigned integer that scales the contribution of the
        /// partition factor.
        #[prost(int64, tag = "11")]
        pub priority_weight_partition: i64,
        /// Optional. An unsigned integer that scales the contribution of the quality
        /// of service factor.
        #[prost(int64, tag = "12")]
        pub priority_weight_qos: i64,
        /// Optional. A comma-separated list of TRES Types and weights that sets the
        /// degree that each TRES Type contributes to the job's priority.
        #[prost(string, tag = "13")]
        pub priority_weight_tres: ::prost::alloc::string::String,
        /// Optional. Specifies the mechanism used to preempt jobs or enable gang
        /// scheduling.
        #[prost(
            enumeration = "slurm_config::PreemptMode",
            repeated,
            packed = "false",
            tag = "14"
        )]
        pub preempt_mode: ::prost::alloc::vec::Vec<i32>,
        /// Optional. Specifies the plugin used to identify which jobs can be
        /// preempted in order to start a pending job.
        #[prost(enumeration = "slurm_config::PreemptType", tag = "15")]
        pub preempt_type: i32,
        /// Optional. Specifies minimum run time of jobs before they are considered
        /// for preemption.
        #[prost(string, tag = "16")]
        pub preempt_exempt_time: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `SlurmConfig`.
    pub mod slurm_config {
        /// Flags to control the Prolog behavior.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PrologFlag {
            /// Unspecified prolog flag.
            Unspecified = 0,
            /// Prolog script will be executed at job allocation. NOTE: increases the
            /// time required to start jobs. Corresponds to Alloc.
            Alloc = 1,
            /// Use the ProcTrack plugin to create a job container on all allocated
            /// compute nodes. Corresponds to Contain.
            Contain = 2,
            /// Slurmctld will wait until the prolog completes on all allocated nodes
            /// before sending the batch job launch request. Corresponds to DeferBatch.
            DeferBatch = 3,
            /// If set, the ALLOC flag should also be set. This will allow for salloc
            /// to not block until the prolog is finished on each node. Corresponds to
            /// NoHold.
            NoHold = 4,
            /// Always requeue it automatically even if the job requested no requeues.
            /// NOTE: Setting this flag implicitly sets the ALLOC flag. Corresponds to
            /// ForceRequeueOnFail.
            ForceRequeueOnFail = 5,
            /// Make the Prolog/Epilog run in the extern slurmstepd. Corresponds to
            /// RunInJob.
            RunInJob = 6,
            /// Force prolog and epilog scripts to run serially within each node. NOTE:
            /// This is incompatible with Serial.
            Serial = 7,
            /// Enable Slurm's built-in X11 forwarding capabilities. Corresponds to
            /// X11.
            X11 = 8,
        }
        impl PrologFlag {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PROLOG_FLAG_UNSPECIFIED",
                    Self::Alloc => "ALLOC",
                    Self::Contain => "CONTAIN",
                    Self::DeferBatch => "DEFER_BATCH",
                    Self::NoHold => "NO_HOLD",
                    Self::ForceRequeueOnFail => "FORCE_REQUEUE_ON_FAIL",
                    Self::RunInJob => "RUN_IN_JOB",
                    Self::Serial => "SERIAL",
                    Self::X11 => "X11",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PROLOG_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                    "ALLOC" => Some(Self::Alloc),
                    "CONTAIN" => Some(Self::Contain),
                    "DEFER_BATCH" => Some(Self::DeferBatch),
                    "NO_HOLD" => Some(Self::NoHold),
                    "FORCE_REQUEUE_ON_FAIL" => Some(Self::ForceRequeueOnFail),
                    "RUN_IN_JOB" => Some(Self::RunInJob),
                    "SERIAL" => Some(Self::Serial),
                    "X11" => Some(Self::X11),
                    _ => None,
                }
            }
        }
        /// Flags to control the level of association to impose on job submissions.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum AccountingStorageEnforceFlag {
            /// Unspecified accounting storage enforce flag.
            Unspecified = 0,
            /// Implies all other available options except nojobs and nosteps.
            All = 1,
            /// No new job will be allowed to run unless a corresponding association
            /// exists in the system.
            Associations = 2,
            /// Users will be limited by association to whatever job size or run time
            /// limits are defined. Implies associations.
            Limits = 3,
            /// Slurm will not account for any jobs or steps on the system. Implies
            /// nosteps.
            Nojobs = 4,
            /// Slurm will not account for any steps that have run.
            Nosteps = 5,
            /// Jobs will not be scheduled unless a valid qos is specified. Implies
            /// associations.
            Qos = 6,
            /// A job will only be launched against an association or qos that has a
            /// TRES-minutes limit set if the job will be able to run to completion.
            /// Without this option set, jobs will be launched as long as their usage
            /// hasn't reached the TRES-minutes limit. This can lead to jobs being
            /// launched but then killed when the limit is reached. With this option, a
            /// job won't be killed due to limits, even if the limits are changed after
            /// the job was started and the association or qos violates the updated
            /// limits. Implies limits and associations.
            Safe = 7,
            /// Jobs will not be scheduled unless a valid workload characterization key
            /// is specified. Implies associations and TrackWCKey (a separate
            /// configuration option).
            Wckeys = 8,
        }
        impl AccountingStorageEnforceFlag {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "ACCOUNTING_STORAGE_ENFORCE_FLAG_UNSPECIFIED",
                    Self::All => "ALL",
                    Self::Associations => "ASSOCIATIONS",
                    Self::Limits => "LIMITS",
                    Self::Nojobs => "NOJOBS",
                    Self::Nosteps => "NOSTEPS",
                    Self::Qos => "QOS",
                    Self::Safe => "SAFE",
                    Self::Wckeys => "WCKEYS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ACCOUNTING_STORAGE_ENFORCE_FLAG_UNSPECIFIED" => {
                        Some(Self::Unspecified)
                    }
                    "ALL" => Some(Self::All),
                    "ASSOCIATIONS" => Some(Self::Associations),
                    "LIMITS" => Some(Self::Limits),
                    "NOJOBS" => Some(Self::Nojobs),
                    "NOSTEPS" => Some(Self::Nosteps),
                    "QOS" => Some(Self::Qos),
                    "SAFE" => Some(Self::Safe),
                    "WCKEYS" => Some(Self::Wckeys),
                    _ => None,
                }
            }
        }
        /// Specifies the plugin to be used in establishing a job's scheduling
        /// priority.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PriorityType {
            /// Unspecified priority type.
            Unspecified = 0,
            /// Jobs are evaluated in a First In, First Out (FIFO) manner.
            PriorityBasic = 1,
            /// Jobs are assigned a priority based upon a variety of factors that
            /// include size, age, Fairshare, etc.
            PriorityMultifactor = 2,
        }
        impl PriorityType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PRIORITY_TYPE_UNSPECIFIED",
                    Self::PriorityBasic => "PRIORITY_BASIC",
                    Self::PriorityMultifactor => "PRIORITY_MULTIFACTOR",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PRIORITY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PRIORITY_BASIC" => Some(Self::PriorityBasic),
                    "PRIORITY_MULTIFACTOR" => Some(Self::PriorityMultifactor),
                    _ => None,
                }
            }
        }
        /// Specifies the mechanism used to preempt jobs or enable gang scheduling.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PreemptMode {
            /// Unspecified preempt mode.
            Unspecified = 0,
            /// Is the default value and disables job preemption and gang scheduling.
            Off = 1,
            /// The preempted job will be cancelled
            Cancel = 2,
            /// Enables gang scheduling (time slicing) of jobs in the same partition,
            /// and allows the resuming of suspended jobs.
            Gang = 3,
            /// Preempts jobs by requeuing them (if possible) or canceling them.
            Requeue = 4,
            /// The preempted jobs will be suspended, and later the Gang scheduler will
            /// resume them.
            Suspend = 5,
            /// Allow preemption only if the preemptor's job priority is higher than
            /// the preemptee's job priority.
            Priority = 6,
            /// Allow jobs within the same qos to preempt one another.
            Within = 7,
        }
        impl PreemptMode {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PREEMPT_MODE_UNSPECIFIED",
                    Self::Off => "OFF",
                    Self::Cancel => "CANCEL",
                    Self::Gang => "GANG",
                    Self::Requeue => "REQUEUE",
                    Self::Suspend => "SUSPEND",
                    Self::Priority => "PRIORITY",
                    Self::Within => "WITHIN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PREEMPT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                    "OFF" => Some(Self::Off),
                    "CANCEL" => Some(Self::Cancel),
                    "GANG" => Some(Self::Gang),
                    "REQUEUE" => Some(Self::Requeue),
                    "SUSPEND" => Some(Self::Suspend),
                    "PRIORITY" => Some(Self::Priority),
                    "WITHIN" => Some(Self::Within),
                    _ => None,
                }
            }
        }
        /// Specifies the plugin used to identify which jobs can be preempted in
        /// order to start a pending job.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PreemptType {
            /// Unspecified preempt type.
            Unspecified = 0,
            /// Job preemption is disabled (default).
            PreemptNone = 1,
            /// Job preemption is based upon partition PriorityTier.
            PreemptPartitionPrio = 2,
            /// Job preemption rules are specified by Quality Of Service (QOS)
            /// specifications in the Slurm database.
            PreemptQos = 3,
        }
        impl PreemptType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PREEMPT_TYPE_UNSPECIFIED",
                    Self::PreemptNone => "PREEMPT_NONE",
                    Self::PreemptPartitionPrio => "PREEMPT_PARTITION_PRIO",
                    Self::PreemptQos => "PREEMPT_QOS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PREEMPT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "PREEMPT_NONE" => Some(Self::PreemptNone),
                    "PREEMPT_PARTITION_PRIO" => Some(Self::PreemptPartitionPrio),
                    "PREEMPT_QOS" => Some(Self::PreemptQos),
                    _ => None,
                }
            }
        }
    }
}
/// Configuration for Slurm nodesets in the cluster. Nodesets are groups of
/// compute nodes used by Slurm that are responsible for running workloads
/// submitted to the cluster.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlurmNodeSet {
    /// Required. Identifier for the nodeset, which allows it to be referenced by
    /// partitions. Must conform to
    /// [RFC-1034](<https://datatracker.ietf.org/doc/html/rfc1034>) (lower-case,
    /// alphanumeric, and at most 63 characters).
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Optional. ID of the compute resource on which this nodeset will run. Must
    /// match a key in the cluster's
    /// [compute_resources](Cluster.compute_resources).
    #[prost(string, tag = "16")]
    pub compute_id: ::prost::alloc::string::String,
    /// Optional. How \[storage
    /// resources\]\[google.cloud.hypercomputecluster.v1alpha.StorageResource\] should
    /// be mounted on each compute node.
    #[prost(message, repeated, tag = "3")]
    pub storage_configs: ::prost::alloc::vec::Vec<StorageConfig>,
    /// Optional. Number of nodes to be statically created for this nodeset. The
    /// cluster will attempt to ensure that at least this many nodes exist at all
    /// times.
    #[prost(int64, tag = "4")]
    pub static_node_count: i64,
    /// Optional. Controls how many additional nodes a cluster can bring online to
    /// handle workloads. Set this value to enable dynamic node creation and limit
    /// the number of additional nodes the cluster can bring online. Leave empty if
    /// you do not want the cluster to create nodes dynamically, and instead rely
    /// only on static nodes.
    #[prost(int64, tag = "5")]
    pub max_dynamic_node_count: i64,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(message, optional, tag = "13")]
    pub service_account: ::core::option::Option<ServiceAccount>,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(message, optional, tag = "15")]
    pub boot_disk: ::core::option::Option<Disk>,
    /// Optional. Deprecated: Use
    /// \[ComputeInstanceSlurmNodeSet.startup_script\]\[google.cloud.hypercomputecluster.v1alpha.ComputeInstanceSlurmNodeSet.startup_script\]
    /// instead.
    #[prost(string, tag = "7")]
    pub startup_script: ::prost::alloc::string::String,
    /// Optional. Deprecated: Use compute_id instead.
    #[prost(string, tag = "2")]
    pub resource_request_id: ::prost::alloc::string::String,
    /// Optional. Deprecated: Do not use.
    #[prost(bool, tag = "9")]
    pub enable_os_login: bool,
    /// Optional. Deprecated: Do not use.
    #[prost(bool, tag = "10")]
    pub can_ip_forward: bool,
    /// Optional. Deprecated: Do not use.
    #[prost(bool, tag = "11")]
    pub enable_public_ips: bool,
    /// Optional. Deprecated: Use
    /// \[ComputeInstanceSlurmNodeSet.labels\]\[google.cloud.hypercomputecluster.v1alpha.ComputeInstanceSlurmNodeSet.labels\]
    /// instead.
    #[prost(map = "string, string", tag = "12")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Additional configuration for the nodeset. If not set, the nodeset will
    /// use
    /// \[ComputeInstanceSlurmNodeSet\]\[google.cloud.hypercomputecluster.v1alpha.ComputeInstanceSlurmNodeSet\]
    /// with default values.
    #[prost(oneof = "slurm_node_set::Type", tags = "17, 18")]
    pub r#type: ::core::option::Option<slurm_node_set::Type>,
}
/// Nested message and enum types in `SlurmNodeSet`.
pub mod slurm_node_set {
    /// Additional configuration for the nodeset. If not set, the nodeset will
    /// use
    /// \[ComputeInstanceSlurmNodeSet\]\[google.cloud.hypercomputecluster.v1alpha.ComputeInstanceSlurmNodeSet\]
    /// with default values.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Optional. If set, indicates that the nodeset should be backed by Compute
        /// Engine instances.
        #[prost(message, tag = "17")]
        ComputeInstance(super::ComputeInstanceSlurmNodeSet),
        /// Optional. If set, indicates that the nodeset should be backed by a
        /// Kubernetes Engine node pool.
        #[prost(message, tag = "18")]
        ContainerNodePool(super::ContainerNodePoolSlurmNodeSet),
    }
}
/// When set in a
/// \[SlurmNodeSet\]\[google.cloud.hypercomputecluster.v1alpha.SlurmNodeSet\],
/// indicates that the nodeset should be backed by Compute Engine VM instances.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComputeInstanceSlurmNodeSet {
    /// Optional. [Startup
    /// script](<https://cloud.google.com/compute/docs/instances/startup-scripts/linux>)
    /// to be run on each VM instance in the nodeset. Max 256KB.
    #[prost(string, tag = "1")]
    pub startup_script: ::prost::alloc::string::String,
    /// Optional.
    /// [Labels](<https://cloud.google.com/compute/docs/labeling-resources>) that
    /// should be applied to each VM instance in the nodeset.
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Boot disk for the compute instance
    #[prost(message, optional, tag = "3")]
    pub boot_disk: ::core::option::Option<BootDisk>,
}
/// When set in a
/// \[SlurmNodeSet\]\[google.cloud.hypercomputecluster.v1alpha.SlurmNodeSet\],
/// indicates that the nodeset should be backed by a Kubernetes Engine node pool.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContainerNodePoolSlurmNodeSet {}
/// Configuration for Slurm partitions in the cluster. Partitions are groups of
/// nodesets, and are how clients specify where their workloads should be run.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SlurmPartition {
    /// Required. ID of the partition, which is how users will identify it. Must
    /// conform to [RFC-1034](<https://datatracker.ietf.org/doc/html/rfc1034>)
    /// (lower-case, alphanumeric, and at most 63 characters).
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Required. IDs of the nodesets that make up this partition. Values must
    /// match
    /// \[SlurmNodeSet.id\]\[google.cloud.hypercomputecluster.v1alpha.SlurmNodeSet.id\].
    #[prost(string, repeated, tag = "2")]
    pub node_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(bool, tag = "3")]
    pub exclusive: bool,
}
/// Configuration for Slurm [login
/// nodes](<https://slurm.schedmd.com/quickstart_admin.html#login>) in the cluster.
/// Login nodes are Compute Engine VM instances that allow users to access the
/// cluster over SSH.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SlurmLoginNodes {
    /// Required. Number of login node instances to create.
    #[prost(int64, tag = "3")]
    pub count: i64,
    /// Required. Name of the zone in which login nodes should run, e.g.,
    /// `us-central1-a`. Must be in the same region as the cluster, and must match
    /// the zone of any other resources specified in the cluster.
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Required. Name of the Compute Engine [machine
    /// type](<https://cloud.google.com/compute/docs/machine-resource>) to use for
    /// login nodes, e.g. `n2-standard-2`.
    #[prost(string, tag = "1")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. [Startup
    /// script](<https://cloud.google.com/compute/docs/instances/startup-scripts/linux>)
    /// to be run on each login node instance. Max 256KB.
    #[prost(string, tag = "5")]
    pub startup_script: ::prost::alloc::string::String,
    /// Optional. Whether [OS Login](<https://cloud.google.com/compute/docs/oslogin>)
    /// should be enabled on login node instances.
    #[prost(bool, tag = "6")]
    pub enable_os_login: bool,
    /// Optional. Whether login node instances should be assigned [external IP
    /// addresses](<https://cloud.google.com/compute/docs/ip-addresses#externaladdresses>).
    #[prost(bool, tag = "7")]
    pub enable_public_ips: bool,
    /// Optional.
    /// [Labels](<https://cloud.google.com/compute/docs/labeling-resources>) that
    /// should be applied to each login node instance.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. How \[storage
    /// resources\]\[google.cloud.hypercomputecluster.v1alpha.StorageResource\] should
    /// be mounted on each login node.
    #[prost(message, repeated, tag = "12")]
    pub storage_configs: ::prost::alloc::vec::Vec<StorageConfig>,
    /// Output only. Information about the login node instances that were created
    /// in Compute Engine.
    #[prost(message, repeated, tag = "10")]
    pub instances: ::prost::alloc::vec::Vec<ComputeInstance>,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(message, repeated, tag = "4")]
    pub disks: ::prost::alloc::vec::Vec<Disk>,
    /// Optional. Unstable: Contact hypercompute-service-eng@ before using.
    #[prost(message, optional, tag = "9")]
    pub service_account: ::core::option::Option<ServiceAccount>,
    /// Optional. Boot disk for the login node
    #[prost(message, optional, tag = "13")]
    pub boot_disk: ::core::option::Option<BootDisk>,
}
/// Service account email and scopes
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ServiceAccount {
    /// Optional. Service account email
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
    /// Optional. Service account scopes
    #[prost(string, repeated, tag = "2")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Description of how a \[storage
/// resource\]\[google.cloud.hypercomputecluster.v1alpha.StorageResource\] should be
/// mounted on a VM instance.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorageConfig {
    /// Required. ID of the storage resource to mount, which must match a key in
    /// the cluster's [storage_resources](Cluster.storage_resources).
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Required. A directory inside the VM instance's file system where the
    /// storage resource should be mounted (e.g., `/mnt/share`).
    #[prost(string, tag = "2")]
    pub local_mount: ::prost::alloc::string::String,
}
/// Details about a Compute Engine
/// [instance](<https://cloud.google.com/compute/docs/instances>).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ComputeInstance {
    /// Output only. Name of the VM instance, in the format
    /// `projects/{project}/zones/{zone}/instances/{instance}`.
    #[prost(string, tag = "1")]
    pub instance: ::prost::alloc::string::String,
}
/// Message describing Network object
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Network {
    /// Output only. Name of the network
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Output only. Name of the subnetwork
    #[prost(string, tag = "4")]
    pub subnetwork: ::prost::alloc::string::String,
    /// Source of the network
    #[prost(oneof = "network::Source", tags = "2, 3")]
    pub source: ::core::option::Option<network::Source>,
}
/// Nested message and enum types in `Network`.
pub mod network {
    /// Source of the network
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Source {
        /// Immutable. Parameters to initialize the network
        #[prost(message, tag = "2")]
        InitializeParams(super::NetworkInitializeParams),
        /// Immutable. Reference of existing network resource name
        #[prost(message, tag = "3")]
        NetworkSource(super::NetworkSource),
    }
}
/// Message describing initialize params for network object
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkInitializeParams {
    /// Required. Name of the network
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Optional. Description of the network
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
/// Message describing network source for network object
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NetworkSource {
    /// Required. Immutable. Name of the network
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Required. Subnetwork of the network
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
}
/// Deprecated: Use NetworkReference instead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ComputeNetworkReference {
    /// Output only. The name of the network.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Output only. Subnetwork of the network.
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
}
/// Deprecated: Use NewNetworkConfig instead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NewComputeNetworkConfig {
    /// Immutable. The name of the network.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Immutable. Description of the network.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
}
/// Deprecated: Use ExistingNetworkConfig instead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExistingComputeNetworkConfig {
    /// Immutable. The name of the network.
    #[prost(string, tag = "1")]
    pub network: ::prost::alloc::string::String,
    /// Immutable. Subnetwork of the network.
    #[prost(string, tag = "2")]
    pub subnetwork: ::prost::alloc::string::String,
}
/// Message describing Storage object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Storage {
    /// Required. Storage id
    #[prost(string, tag = "4")]
    pub id: ::prost::alloc::string::String,
    /// Output only. Storage name
    #[prost(string, tag = "1")]
    pub storage: ::prost::alloc::string::String,
    /// Source of the storage
    #[prost(oneof = "storage::Source", tags = "2, 3")]
    pub source: ::core::option::Option<storage::Source>,
}
/// Nested message and enum types in `Storage`.
pub mod storage {
    /// Source of the storage
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Source {
        /// Immutable. Parameters to initialize the storage
        #[prost(message, tag = "2")]
        InitializeParams(super::StorageInitializeParams),
        /// Immutable. Reference of existing storage
        #[prost(message, tag = "3")]
        StorageSource(super::StorageSource),
    }
}
/// Message describing initialize params for storage object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageInitializeParams {
    /// Storage options
    #[prost(oneof = "storage_initialize_params::Option", tags = "1, 2, 3")]
    pub option: ::core::option::Option<storage_initialize_params::Option>,
}
/// Nested message and enum types in `StorageInitializeParams`.
pub mod storage_initialize_params {
    /// Storage options
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Option {
        /// FileStore initialize params
        #[prost(message, tag = "1")]
        Filestore(super::FilestoreInitializeParams),
        /// Google Cloud Storage initialize params
        #[prost(message, tag = "2")]
        Gcs(super::GcsInitializeParams),
        /// Lustre initialize params
        #[prost(message, tag = "3")]
        Lustre(super::LustreInitializeParams),
    }
}
/// Message describing initialize params for filestore
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FilestoreInitializeParams {
    /// Required. File share configuration
    #[prost(message, repeated, tag = "1")]
    pub file_shares: ::prost::alloc::vec::Vec<FileShareConfig>,
    /// Required. The service tier of the filestore
    #[prost(enumeration = "filestore_initialize_params::Tier", tag = "2")]
    pub tier: i32,
    /// Required. Name of the filestore
    #[prost(string, tag = "3")]
    pub filestore: ::prost::alloc::string::String,
    /// Optional. Description of the filestore
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The protocol of the filestore
    #[prost(enumeration = "filestore_initialize_params::Protocol", tag = "5")]
    pub protocol: i32,
}
/// Nested message and enum types in `FilestoreInitializeParams`.
pub mod filestore_initialize_params {
    /// The service tier types of the filestore
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Tier {
        /// Unspecified filestore tier
        Unspecified = 0,
        /// Basic HDD filestore tier
        BasicHdd = 1,
        /// Basic SSD filestore tier
        BasicSsd = 2,
        /// High scale SSD filestore tier
        HighScaleSsd = 3,
        /// Zonal filestore tier
        Zonal = 4,
        /// Enterprise filestore tier
        Enterprise = 5,
        /// Regional filestore tier
        Regional = 6,
    }
    impl Tier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TIER_UNSPECIFIED",
                Self::BasicHdd => "TIER_BASIC_HDD",
                Self::BasicSsd => "TIER_BASIC_SSD",
                Self::HighScaleSsd => "TIER_HIGH_SCALE_SSD",
                Self::Zonal => "TIER_ZONAL",
                Self::Enterprise => "TIER_ENTERPRISE",
                Self::Regional => "TIER_REGIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIER_UNSPECIFIED" => Some(Self::Unspecified),
                "TIER_BASIC_HDD" => Some(Self::BasicHdd),
                "TIER_BASIC_SSD" => Some(Self::BasicSsd),
                "TIER_HIGH_SCALE_SSD" => Some(Self::HighScaleSsd),
                "TIER_ZONAL" => Some(Self::Zonal),
                "TIER_ENTERPRISE" => Some(Self::Enterprise),
                "TIER_REGIONAL" => Some(Self::Regional),
                _ => None,
            }
        }
    }
    /// The protocol types of the filestore
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        /// Unspecified filestore protocol
        Unspecified = 0,
        /// NFSv3
        Nfsv3 = 1,
        /// NFSv4.1
        Nfsv41 = 2,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROTOCOL_UNSPECIFIED",
                Self::Nfsv3 => "PROTOCOL_NFSV3",
                Self::Nfsv41 => "PROTOCOL_NFSV41",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
                "PROTOCOL_NFSV3" => Some(Self::Nfsv3),
                "PROTOCOL_NFSV41" => Some(Self::Nfsv41),
                _ => None,
            }
        }
    }
}
/// Message describing initialize params for Google Cloud Storage
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcsInitializeParams {
    /// Required. Name of the bucket
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
    /// Optional. The hierarchical namespace configuration of the bucket
    #[prost(message, optional, tag = "4")]
    pub hierarchical_namespace: ::core::option::Option<GcsHierarchicalNamespaceConfig>,
    /// Bucket storage class options
    #[prost(oneof = "gcs_initialize_params::Option", tags = "2, 3")]
    pub option: ::core::option::Option<gcs_initialize_params::Option>,
}
/// Nested message and enum types in `GcsInitializeParams`.
pub mod gcs_initialize_params {
    /// The storage class types of the bucket
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageClass {
        /// Unspecified storage class
        Unspecified = 0,
        /// Standard storage class
        Standard = 1,
        /// Nearline storage class
        Nearline = 2,
        /// Coldline storage class
        Coldline = 3,
        /// Archive storage class
        Archive = 4,
    }
    impl StorageClass {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STORAGE_CLASS_UNSPECIFIED",
                Self::Standard => "STORAGE_CLASS_STANDARD",
                Self::Nearline => "STORAGE_CLASS_NEARLINE",
                Self::Coldline => "STORAGE_CLASS_COLDLINE",
                Self::Archive => "STORAGE_CLASS_ARCHIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STORAGE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
                "STORAGE_CLASS_STANDARD" => Some(Self::Standard),
                "STORAGE_CLASS_NEARLINE" => Some(Self::Nearline),
                "STORAGE_CLASS_COLDLINE" => Some(Self::Coldline),
                "STORAGE_CLASS_ARCHIVE" => Some(Self::Archive),
                _ => None,
            }
        }
    }
    /// Bucket storage class options
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Option {
        /// Autoclass configuration for objects in the bucket.
        #[prost(message, tag = "2")]
        Autoclass(super::GcsAutoclassConfig),
        /// Default storage class for objects in the bucket.
        #[prost(enumeration = "StorageClass", tag = "3")]
        StorageClass(i32),
    }
}
/// Message describing initialize params for lustre
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LustreInitializeParams {
    /// Required. Name of the lustre instance
    #[prost(string, tag = "1")]
    pub lustre: ::prost::alloc::string::String,
    /// Optional. Description of the lustre instance
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Required. Immutable. Filesystem of the lustre instance
    #[prost(string, tag = "3")]
    pub filesystem: ::prost::alloc::string::String,
    /// Required. Size of the lustre instance in GB
    #[prost(int64, tag = "4")]
    pub capacity_gb: i64,
}
/// Message describing source of storage
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StorageSource {
    /// Existing storage options
    #[prost(oneof = "storage_source::Option", tags = "1, 2, 3")]
    pub option: ::core::option::Option<storage_source::Option>,
}
/// Nested message and enum types in `StorageSource`.
pub mod storage_source {
    /// Existing storage options
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Option {
        /// Name of the existing filestore
        #[prost(string, tag = "1")]
        Filestore(::prost::alloc::string::String),
        /// Name of the existing Google Cloud Storage bucket
        #[prost(string, tag = "2")]
        Bucket(::prost::alloc::string::String),
        /// Name of the existing Lustre instance
        #[prost(string, tag = "3")]
        Lustre(::prost::alloc::string::String),
    }
}
/// Message describing Compute object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Compute {
    /// Required. Source of compute resource
    #[prost(message, repeated, tag = "1")]
    pub resource_requests: ::prost::alloc::vec::Vec<ResourceRequest>,
    /// Optional. ATM Tags to attach to compute VM instances
    #[prost(message, repeated, tag = "2")]
    pub atm_tags: ::prost::alloc::vec::Vec<AtmTag>,
}
/// Message describing resource request object
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceRequest {
    /// Required. Id of resource request
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Required. Zone of the selected locations
    #[prost(string, tag = "2")]
    pub zone: ::prost::alloc::string::String,
    /// Required. Type of the machine e.g. c2-standard-60
    #[prost(string, tag = "3")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. Type and count of accelerator cards attached to the instance
    #[prost(message, repeated, tag = "4")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<GuestAccelerator>,
    /// Optional. Array of disks associated with this instance
    #[prost(message, repeated, tag = "5")]
    pub disks: ::prost::alloc::vec::Vec<Disk>,
    /// Optional. Max amount of time instance is allowed to run
    #[prost(int64, tag = "6")]
    pub max_run_duration: i64,
    /// Optional. Specifies the provisioning model of the instance
    #[prost(enumeration = "resource_request::ProvisioningModel", tag = "7")]
    pub provisioning_model: i32,
    /// Optional. Reservations this instance can consume from
    #[prost(message, optional, tag = "8")]
    pub reservation_affinity: ::core::option::Option<ReservationAffinity>,
    /// Optional. Specifies the termination action of the instance
    #[prost(enumeration = "resource_request::TerminationAction", tag = "9")]
    pub termination_action: i32,
}
/// Nested message and enum types in `ResourceRequest`.
pub mod resource_request {
    /// Specifies the provisioning model of the instance
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningModel {
        /// Unspecified provisioning model
        Unspecified = 0,
        /// Standard provisioning model
        Standard = 1,
        /// Spot provisioning model
        Spot = 2,
        /// Flex Start provisioning model
        FlexStart = 3,
        /// Reservation Bound provisioning model
        ReservationBound = 4,
    }
    impl ProvisioningModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PROVISIONING_MODEL_UNSPECIFIED",
                Self::Standard => "PROVISIONING_MODEL_STANDARD",
                Self::Spot => "PROVISIONING_MODEL_SPOT",
                Self::FlexStart => "PROVISIONING_MODEL_FLEX_START",
                Self::ReservationBound => "PROVISIONING_MODEL_RESERVATION_BOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROVISIONING_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "PROVISIONING_MODEL_STANDARD" => Some(Self::Standard),
                "PROVISIONING_MODEL_SPOT" => Some(Self::Spot),
                "PROVISIONING_MODEL_FLEX_START" => Some(Self::FlexStart),
                "PROVISIONING_MODEL_RESERVATION_BOUND" => Some(Self::ReservationBound),
                _ => None,
            }
        }
    }
    /// Specifies the termination action of the instance
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TerminationAction {
        /// Unspecified termination action
        Unspecified = 0,
        /// Stop the instance
        Stop = 1,
        /// Delete the instance
        Delete = 2,
    }
    impl TerminationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TERMINATION_ACTION_UNSPECIFIED",
                Self::Stop => "TERMINATION_ACTION_STOP",
                Self::Delete => "TERMINATION_ACTION_DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TERMINATION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "TERMINATION_ACTION_STOP" => Some(Self::Stop),
                "TERMINATION_ACTION_DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
/// Message describing GuestAccelerator object
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GuestAccelerator {
    /// Optional. Accelerator type resource to attach to this instance
    #[prost(string, tag = "1")]
    pub accelerator_type: ::prost::alloc::string::String,
    /// Optional. Number of the guest accelerator cards exposed to this instance
    #[prost(int64, tag = "2")]
    pub count: i64,
}
/// When set in a
/// \[ComputeResourceConfig\]\[google.cloud.hypercomputecluster.v1alpha.ComputeResourceConfig\],
/// indicates that VM instances should be created using [Flex
/// Start](<https://cloud.google.com/compute/docs/instances/provisioning-models>)
/// with Dynamic Workload Scheduler.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewDwsFlexInstancesConfig {
    /// Required. Immutable. Name of the zone in which VM instances should run,
    /// e.g., `us-central1-a`. Must be in the same region as the cluster, and must
    /// match the zone of any other resources specified in the cluster.
    #[prost(string, tag = "1")]
    pub zone: ::prost::alloc::string::String,
    /// Required. Immutable. Name of the Compute Engine [machine
    /// type](<https://cloud.google.com/compute/docs/machine-resource>) to use, e.g.
    /// `n2-standard-2`.
    #[prost(string, tag = "2")]
    pub machine_type: ::prost::alloc::string::String,
    /// Required. Immutable. Specifies the time limit for created instances.
    /// Instances will be terminated at the end of this duration.
    #[prost(message, optional, tag = "3")]
    pub max_duration: ::core::option::Option<::prost_types::Duration>,
    /// Optional. Immutable. Unstable: Contact hypercompute-service-eng@ before
    /// using.
    #[prost(map = "string, string", tag = "4")]
    pub atm_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Immutable. Deprecated: Do not use.
    #[deprecated]
    #[prost(enumeration = "new_dws_flex_instances_config::TerminationAction", tag = "5")]
    pub termination_action: i32,
    /// Optional. Immutable. Deprecated: set disks in node config instead.
    #[deprecated]
    #[prost(message, optional, tag = "6")]
    pub boot_disk: ::core::option::Option<Disk>,
}
/// Nested message and enum types in `NewDWSFlexInstancesConfig`.
pub mod new_dws_flex_instances_config {
    /// Deprecated: Do not use.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TerminationAction {
        /// Deprecated: Do not use.
        Unspecified = 0,
        /// Deprecated: Do not use.
        Stop = 1,
        /// Deprecated: Do not use.
        Delete = 2,
    }
    impl TerminationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TERMINATION_ACTION_UNSPECIFIED",
                Self::Stop => "STOP",
                Self::Delete => "DELETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TERMINATION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "STOP" => Some(Self::Stop),
                "DELETE" => Some(Self::Delete),
                _ => None,
            }
        }
    }
}
/// Deprecated: Do not use.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReservationAffinity {
    /// Required. Deprecated: Do not use.
    #[deprecated]
    #[prost(enumeration = "reservation_affinity::ReservationType", tag = "1")]
    pub r#type: i32,
    /// Optional. Deprecated: Do not use.
    #[deprecated]
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    /// Optional. Deprecated: Do not use.
    #[deprecated]
    #[prost(string, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ReservationAffinity`.
pub mod reservation_affinity {
    /// Deprecated: Do not use.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReservationType {
        /// Deprecated: Do not use.
        Unspecified = 0,
        /// Deprecated: Do not use.
        NoReservation = 1,
        /// Deprecated: Do not use.
        AnyReservation = 2,
        /// Deprecated: Do not use.
        SpecificReservation = 3,
    }
    impl ReservationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESERVATION_TYPE_UNSPECIFIED",
                Self::NoReservation => "RESERVATION_TYPE_NO_RESERVATION",
                Self::AnyReservation => "RESERVATION_TYPE_ANY_RESERVATION",
                Self::SpecificReservation => "RESERVATION_TYPE_SPECIFIC_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RESERVATION_TYPE_NO_RESERVATION" => Some(Self::NoReservation),
                "RESERVATION_TYPE_ANY_RESERVATION" => Some(Self::AnyReservation),
                "RESERVATION_TYPE_SPECIFIC_RESERVATION" => {
                    Some(Self::SpecificReservation)
                }
                _ => None,
            }
        }
    }
}
/// Generated client implementations.
pub mod hypercompute_cluster_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct HypercomputeClusterClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl HypercomputeClusterClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> HypercomputeClusterClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HypercomputeClusterClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            HypercomputeClusterClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Clusters in a given project and location.
        pub async fn list_clusters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListClustersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListClustersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster/ListClusters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster",
                        "ListClusters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Cluster.
        pub async fn get_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::GetClusterRequest>,
        ) -> std::result::Result<tonic::Response<super::Cluster>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster/GetCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster",
                        "GetCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Cluster in a given project and location.
        pub async fn create_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster/CreateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster",
                        "CreateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Cluster.
        pub async fn update_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster/UpdateCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster",
                        "UpdateCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Cluster.
        pub async fn delete_cluster(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteClusterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster/DeleteCluster",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.HypercomputeCluster",
                        "DeleteCluster",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// A Machine Learning run.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineLearningRun {
    /// Identifier. The name of the Machine Learning run.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Display name for the run.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Required. Allows grouping of similar runs.
    ///
    /// * Helps improving UI rendering performance.
    /// * Allows comparing similar runs via fast filters.
    #[prost(string, tag = "3")]
    pub run_set: ::prost::alloc::string::String,
    /// Optional. ETag for the run.
    /// It must be provided for update/delete operations and must match the
    /// server's etag.
    #[prost(string, tag = "4")]
    pub etag: ::prost::alloc::string::String,
    /// Optional. Tracks configuration for this run,
    /// example: batch_size, jax_version, tpu_generation etc.
    #[prost(message, optional, tag = "5")]
    pub configs: ::core::option::Option<Configs>,
    /// Required. List of tools enabled for this run
    /// example: XProf, NSys
    #[prost(message, repeated, tag = "6")]
    pub tools: ::prost::alloc::vec::Vec<Tool>,
    /// Optional. Metrics for the run.
    #[prost(message, optional, tag = "7")]
    pub metrics: ::core::option::Option<Metrics>,
    /// Optional. Any custom labels for this run
    /// Example: type:workload, type:simulation etc.
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of the run.
    #[prost(enumeration = "State", tag = "9")]
    pub state: i32,
    /// Output only. Time when the run was created.
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Time when the run was last updated.
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Artifacts for the run.
    #[prost(message, optional, tag = "12")]
    pub artifacts: ::core::option::Option<Artifacts>,
    /// Required. The orchestrator used for the run.
    #[prost(enumeration = "machine_learning_run::Orchestrator", tag = "13")]
    pub orchestrator: i32,
    /// Optional. The metadata for the workload associated with the run.
    #[prost(message, optional, tag = "14")]
    pub workload_details: ::core::option::Option<WorkloadDetails>,
    /// Optional. RunPhase defines the phase of the run.
    #[prost(enumeration = "machine_learning_run::RunPhase", tag = "15")]
    pub run_phase: i32,
    /// Optional. Error details for the run.
    /// This field is set when the run is failed.
    #[prost(string, tag = "16")]
    pub error_details: ::prost::alloc::string::String,
    /// Output only. Time when the run was completed.
    /// This field is set when the run is completed or failed.
    #[prost(message, optional, tag = "17")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `MachineLearningRun`.
pub mod machine_learning_run {
    /// Orchestrator for the ML run like Google Compute Engine, Google
    /// Kubernetes Engine, Slurm etc.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Orchestrator {
        /// Orchestrator type is not specified.
        Unspecified = 0,
        /// Google Compute Engine orchestrator.
        Gce = 1,
        /// Google Kubernetes Engine orchestrator.
        Gke = 2,
        /// Slurm cluster orchestrator.
        Slurm = 3,
    }
    impl Orchestrator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "ORCHESTRATOR_UNSPECIFIED",
                Self::Gce => "GCE",
                Self::Gke => "GKE",
                Self::Slurm => "SLURM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ORCHESTRATOR_UNSPECIFIED" => Some(Self::Unspecified),
                "GCE" => Some(Self::Gce),
                "GKE" => Some(Self::Gke),
                "SLURM" => Some(Self::Slurm),
                _ => None,
            }
        }
    }
    /// RunPhase defines the phase of the Machine Learning run.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RunPhase {
        /// State is not specified.
        Unspecified = 0,
        /// Run is active.
        Active = 1,
        /// Run is completed.
        Completed = 2,
        /// Run is failed.
        Failed = 3,
    }
    impl RunPhase {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RUN_PHASE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Completed => "COMPLETED",
                Self::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RUN_PHASE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Request message for MachineLearningRuns.CreateMachineLearningRun.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMachineLearningRunRequest {
    /// Required. Parent format: projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The Machine Learning Run to create.
    #[prost(message, optional, tag = "2")]
    pub machine_learning_run: ::core::option::Option<MachineLearningRun>,
    /// Optional. The ID of the Machine Learning Run to create.
    #[prost(string, tag = "3")]
    pub machine_learning_run_id: ::prost::alloc::string::String,
}
/// Request message for MachineLearningRuns.UpdateMachineLearningRun.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMachineLearningRunRequest {
    /// Required. The Machine Learning Run to update.
    #[prost(message, optional, tag = "1")]
    pub machine_learning_run: ::core::option::Option<MachineLearningRun>,
    /// Optional. Used to identify fields to be updated. Allowed fields is \*, we
    /// don't support partial updates.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// Request message for MachineLearningRuns.DeleteMachineLearningRun.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteMachineLearningRunRequest {
    /// Required.
    /// projects/{project}/locations/{location}/machineLearningRuns/{machineLearningRun}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Etag for the run. Etag gets updated with every update/create
    /// operation. If provided, it must match the server's etag.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Request message for MachineLearningRuns.GetMachineLearningRun.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetMachineLearningRunRequest {
    /// Required.
    /// projects/{project}/locations/{location}/machineLearningRuns/{machineLearningRun}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for MachineLearningRuns.ListMachineLearningRuns.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListMachineLearningRunsRequest {
    /// Required. projects/{project}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of Machine Learning Runs to return. The
    /// service may return fewer than this value. If unspecified, at most 10
    /// Machine Learning Runs will be returned. The maximum value is 1000; values
    /// above 1000 will be coerced to 1000. Please refer to
    /// <https://google.aip.dev/158> for more details.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListMachineLearningRuns`
    /// call. Provide this to retrieve the subsequent page. Please refer to
    /// <https://google.aip.dev/158> for more details.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. An expression for filtering the results of the request.
    ///
    /// Supported filter fields are:
    ///
    /// * run_id (string): The ID of the run (e.g., "run-1").
    /// * run_set (string): The run set (e.g., "run-set-1").
    /// * display_name (string): The display name of the run (e.g.,
    ///   "display-name-1").
    /// * state (enum): The state of the run (e.g., "STATE_COMPLETED").
    /// * region (string): The region of the run (e.g., "us-central1").
    /// * orchestrator (enum): The orchestrator used for the run (e.g.,
    ///   "ORCHESTRATOR_GKE").
    /// * create_time (timestamp): The creation timestamp of the run.
    /// * update_time (timestamp): The last update timestamp of the run.
    /// * etag (string): The ETag of the run.
    ///
    /// Filter expressions can be combined using "AND" and "OR" operators.
    ///
    /// Examples:
    ///
    /// To filter by a single field:
    ///
    /// `run_set = "run-set-1"`
    /// `state = "STATE_ACTIVE"`
    ///
    /// To filter by multiple fields:
    ///
    /// `run_set = "run-set-1" AND state = "STATE_ACTIVE"`
    /// `region = "us-central1" AND orchestrator = "ORCHESTRATOR_GKE"`
    ///
    /// To filter by timestamp:
    ///
    /// `create_time > "2025-05-26T10:00:00Z"`
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. A comma-separated list of fields to order by, sorted in ascending
    /// order. Use "desc" after a field name for descending.
    ///
    /// Supported fields:
    ///
    /// * `run_id`
    /// * `run_set`
    /// * `display_name`
    /// * `region`
    /// * `orchestrator`
    /// * `state`
    /// * `create_time`
    /// * `update_time`
    ///
    /// Example: `update_time desc, create_time`.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for MachineLearningRuns.ListMachineLearningRuns.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMachineLearningRunsResponse {
    /// The Machine Learning Runs.
    #[prost(message, repeated, tag = "1")]
    pub machine_learning_runs: ::prost::alloc::vec::Vec<MachineLearningRun>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for MachineLearningRuns.ListProfileSessions.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListProfileSessionsRequest {
    /// Required. Parent format:
    /// projects/{project}/locations/{location}/machineLearningRuns/{machineLearningRun}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of Profile Sessions to return. The service may
    /// return fewer than this value.
    /// If unspecified, at most 50 Profile Sessions will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListProfileSessions`
    /// call. Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for MachineLearningRuns.ListProfileSessions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProfileSessionsResponse {
    /// A list of profile sessions.
    #[prost(message, repeated, tag = "1")]
    pub profile_sessions: ::prost::alloc::vec::Vec<ProfileSession>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for MachineLearningRuns.GetProfileSession.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetProfileSessionRequest {
    /// Required.
    /// projects/{project}/locations/{location}/machineLearningRuns/{machineLearningRun}/profileSessions/{profileSession}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Represents a single profiling session.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProfileSession {
    /// Identifier. The name of the profile session.
    /// Format:
    /// projects/{project}/locations/{location}/machineLearningRuns/{machine_learning_run}/profileSessions/{profile_session}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The cloud storage path of the session. Example:
    /// `gs://my-bucket/my-run-directory/session-1`.
    #[prost(string, tag = "2")]
    pub gcs_path: ::prost::alloc::string::String,
    /// Output only. The creation time of the session.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The URL to dashboard to see session specific data. Not
    /// specified if URL is not ready yet. Currently represents only Xprof.
    ///
    /// Form <https://<backend>?\<params(gsc_bucket|etc>)>
    /// Could contains user information like bucket name etc.
    #[prost(string, tag = "4")]
    pub dashboard_url: ::prost::alloc::string::String,
}
/// Configuration for a Machine Learning run.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Configs {
    /// Optional. User defined configs.
    #[prost(map = "string, string", tag = "1")]
    pub user_configs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Software configs.
    #[prost(map = "string, string", tag = "2")]
    pub software_configs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Optional. Hardware configs.
    #[prost(map = "string, string", tag = "3")]
    pub hardware_configs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Metrics for a Machine Learning run.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Metrics {
    /// Output only. Average step time.
    #[prost(message, optional, tag = "1")]
    pub avg_step: ::core::option::Option<::prost_types::Duration>,
    /// Output only. Average Model Flops Utilization (MFU).
    #[prost(float, tag = "2")]
    pub avg_mfu: f32,
    /// Output only. Average throughput. Value depends on the kind of workload ran
    /// on TPU.
    #[prost(float, tag = "3")]
    pub avg_throughput: f32,
    /// Output only. Average latency.
    #[prost(message, optional, tag = "4")]
    pub avg_latency: ::core::option::Option<::prost_types::Duration>,
}
/// Represents information about the artifacts of the Machine Learning Run.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Artifacts {
    /// Required. The Cloud Storage path where the artifacts of the run are stored.
    /// Example: `gs://my-bucket/my-run-directory`.
    #[prost(string, tag = "1")]
    pub gcs_path: ::prost::alloc::string::String,
}
/// A tool for a Machine Learning run.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Tool {
    /// tool - one of the diagnostic tool.
    #[prost(oneof = "tool::Tool", tags = "1")]
    pub tool: ::core::option::Option<tool::Tool>,
}
/// Nested message and enum types in `Tool`.
pub mod tool {
    /// tool - one of the diagnostic tool.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Tool {
        /// Required. XProf related metadata
        #[prost(message, tag = "1")]
        Xprof(super::Xprof),
    }
}
/// Workload details associated for the Machine Learning Run.
/// Workload have different metadata based on the orchestrator like
/// GKE cluster, Slurm cluster, Google Compute Engine instance etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkloadDetails {
    /// The metadata for the workload for different orchestrators.
    #[prost(oneof = "workload_details::Metadata", tags = "1")]
    pub metadata: ::core::option::Option<workload_details::Metadata>,
}
/// Nested message and enum types in `WorkloadDetails`.
pub mod workload_details {
    /// The metadata for the workload for different orchestrators.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Metadata {
        /// GKE Workload metadata.
        #[prost(message, tag = "1")]
        Gke(super::GkeWorkloadDetails),
    }
}
/// Workload details for the GKE orchestrator.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GkeWorkloadDetails {
    /// Required. The identifier of the workload. Example - jobset-abcd
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Required. The kind of the workload. Example - JobSet
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// Required. The cluster of the workload.
    /// Example - /projects/<project id>/locations/<location>/clusters/<cluster
    /// name>
    #[prost(string, tag = "3")]
    pub cluster: ::prost::alloc::string::String,
    /// Required. The namespace of the workload. Example - default
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Optional. The parent workload. Example - JobSet for a Job, RayJob,
    /// LeaderWorkerSet etc. If a workload is a part of a RunSet, this field is
    /// populate as `RunSet` and if it was ray job, it will be set to `RayJob` etc.
    /// This will be an additional field to representing a workload.
    #[prost(string, tag = "5")]
    pub parent_workload: ::prost::alloc::string::String,
    /// Optional. labels for the workload.
    /// Example: {"type": "workload", "app": "simulation"}.
    #[prost(map = "string, string", tag = "6")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// XProf related metadata
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Xprof {
    /// Required. XProf session id
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
}
/// State of the Machine Learning run.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// State is not specified.
    Unspecified = 0,
    /// Run is active.
    Active = 1,
    /// Run is completed.
    Completed = 2,
    /// Run is failed.
    Failed = 3,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::Active => "STATE_ACTIVE",
            Self::Completed => "STATE_COMPLETED",
            Self::Failed => "STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "STATE_ACTIVE" => Some(Self::Active),
            "STATE_COMPLETED" => Some(Self::Completed),
            "STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod machine_learning_runs_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service for managing Machine Learning Runs.
    #[derive(Debug, Clone)]
    pub struct MachineLearningRunsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MachineLearningRunsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MachineLearningRunsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MachineLearningRunsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MachineLearningRunsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a Machine Learning Run.
        pub async fn create_machine_learning_run(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateMachineLearningRunRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/CreateMachineLearningRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "CreateMachineLearningRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an Machine Learning Run.
        pub async fn update_machine_learning_run(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMachineLearningRunRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/UpdateMachineLearningRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "UpdateMachineLearningRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Machine Learning Run.
        pub async fn delete_machine_learning_run(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMachineLearningRunRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/DeleteMachineLearningRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "DeleteMachineLearningRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Machine Learning Run.
        pub async fn get_machine_learning_run(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMachineLearningRunRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MachineLearningRun>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/GetMachineLearningRun",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "GetMachineLearningRun",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Machine Learning Runs.
        pub async fn list_machine_learning_runs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMachineLearningRunsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMachineLearningRunsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/ListMachineLearningRuns",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "ListMachineLearningRuns",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a Profile Session.
        pub async fn get_profile_session(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProfileSessionRequest>,
        ) -> std::result::Result<tonic::Response<super::ProfileSession>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/GetProfileSession",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "GetProfileSession",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Profile Sessions for a Machine Learning Run.
        pub async fn list_profile_sessions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListProfileSessionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListProfileSessionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns/ListProfileSessions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.hypercomputecluster.v1alpha.MachineLearningRuns",
                        "ListProfileSessions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
