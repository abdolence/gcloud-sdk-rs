// This file is @generated by prost-build.
/// The status of an account.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AccountStatus {
    /// Invalid status.
    Unspecified = 0,
    /// Active state where the account can conduct the operations allowed by its
    /// roles.
    Active = 1,
    /// Inactive state where all transactions on the account are forbidden.
    /// The manager of the account can still send account management transactions.
    Inactive = 2,
}
impl AccountStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ACCOUNT_STATUS_UNSPECIFIED",
            Self::Active => "ACCOUNT_STATUS_ACTIVE",
            Self::Inactive => "ACCOUNT_STATUS_INACTIVE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACCOUNT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCOUNT_STATUS_ACTIVE" => Some(Self::Active),
            "ACCOUNT_STATUS_INACTIVE" => Some(Self::Inactive),
            _ => None,
        }
    }
}
/// The regular set of roles.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Role {
    /// Invalid role.
    Unspecified = 0,
    /// The role that allows an account to initiate a payment transaction.
    Payer = 5,
    /// The role that allows an account to receive payments.
    Receiver = 6,
    /// The role that allows an account to deploy contracts.
    ContractCreator = 7,
    /// The role that allows an account to interact with deployed contracts.
    ContractParticipant = 8,
}
impl Role {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ROLE_UNSPECIFIED",
            Self::Payer => "ROLE_PAYER",
            Self::Receiver => "ROLE_RECEIVER",
            Self::ContractCreator => "ROLE_CONTRACT_CREATOR",
            Self::ContractParticipant => "ROLE_CONTRACT_PARTICIPANT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "ROLE_PAYER" => Some(Self::Payer),
            "ROLE_RECEIVER" => Some(Self::Receiver),
            "ROLE_CONTRACT_CREATOR" => Some(Self::ContractCreator),
            "ROLE_CONTRACT_PARTICIPANT" => Some(Self::ContractParticipant),
            _ => None,
        }
    }
}
/// The set of permissions that can be granted to a contract.
/// More values are expected to be added in the future.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContractPermission {
    /// Invalid permission.
    Unspecified = 0,
    /// Allows a contract to read and write into storage owned by the account who
    /// granted the permission. The contract can only read and write the properties
    /// that it has previously written.
    ///
    /// Note this does not allow the contract to read or write data managed by
    /// other contracts; nor does it allow the contract to directly update other
    /// account properties (for example, the balance of the account in its native
    /// currency).
    Storage = 1,
}
impl ContractPermission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONTRACT_PERMISSION_UNSPECIFIED",
            Self::Storage => "CONTRACT_PERMISSION_STORAGE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTRACT_PERMISSION_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTRACT_PERMISSION_STORAGE" => Some(Self::Storage),
            _ => None,
        }
    }
}
/// An entity in the Universal Ledger network. All accounts are attached to an
/// entity. The entity ID, also often referred to as the account ID, is unique
/// and immutable across the network.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Entity {
    /// Output only. The ID assigned to the entity. This is assigned by the network
    /// on account creation.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
/// Represents an amount of currency (i.e. money). Note that the denominated
/// currency is not included in this message. The relevant currency is decided by
/// the account that sends the transaction. Each account has a unique immutable
/// currency associated to it.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyValue {
    /// Required. The number of minor units of the currency.
    ///
    /// This smallest valid denomination is referred to as "minor units" and is
    /// specified in [ISO 4217](<https://www.iso.org/iso-4217-currency-codes.html>).
    /// As an example, for USD, the value will be the number of cents and for GBP
    /// it will be the number of pence. For the Japanese Yen which does not have a
    /// minor unit, it will be the number of Yen.
    #[prost(int64, tag = "1")]
    pub value: i64,
}
/// A list of strings.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringList {
    /// Optional. The string values.
    #[prost(string, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A list of int64s.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Int64List {
    /// Optional. The int64 values.
    #[prost(int64, repeated, packed = "false", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<i64>,
}
/// A list of account IDs.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountIdList {
    /// Optional. The account ID values.
    #[prost(string, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A list of booleans.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoolList {
    /// Optional. The boolean values.
    #[prost(bool, repeated, packed = "false", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<bool>,
}
/// A list of dictionaries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictList {
    /// Optional. The DictValue values.
    #[prost(message, repeated, tag = "1")]
    pub value: ::prost::alloc::vec::Vec<DictValue>,
}
/// Indices map key to value. For example, `keys\[0\]` key maps to `values\[0\]`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DictValue {
    /// Each key can be exactly one kind.
    #[prost(oneof = "dict_value::Keys", tags = "1, 2, 3, 8")]
    pub keys: ::core::option::Option<dict_value::Keys>,
    /// Each value can be exactly one kind.
    #[prost(oneof = "dict_value::Values", tags = "4, 5, 6, 7")]
    pub values: ::core::option::Option<dict_value::Values>,
}
/// Nested message and enum types in `DictValue`.
pub mod dict_value {
    /// Each key can be exactly one kind.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Keys {
        /// Optional. A list of boolean keys.
        #[prost(message, tag = "1")]
        BoolKeys(super::BoolList),
        /// Optional. A list of string keys.
        #[prost(message, tag = "2")]
        StringKeys(super::StringList),
        /// Optional. A list of int64 keys.
        #[prost(message, tag = "3")]
        Int64Keys(super::Int64List),
        /// Optional. A list of account ID keys.
        #[prost(message, tag = "8")]
        AccountIdKeys(super::AccountIdList),
    }
    /// Each value can be exactly one kind.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Values {
        /// Optional. A list of boolean values.
        #[prost(message, tag = "4")]
        BoolValues(super::BoolList),
        /// Optional. A list of string values.
        #[prost(message, tag = "5")]
        StringValues(super::StringList),
        /// Optional. A list of int64 values.
        #[prost(message, tag = "6")]
        Int64Values(super::Int64List),
        /// Optional. Values are a list of nested dictionaries.
        #[prost(message, tag = "7")]
        DictValues(super::DictList),
    }
}
/// A concrete value of some type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    /// The actual value.
    #[prost(oneof = "value::Value", tags = "1, 2, 3, 4, 5, 6")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    /// The actual value.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// Optional. Represents a None value.
        #[prost(enumeration = "super::NoneValue", tag = "1")]
        NoneValue(i32),
        /// Optional. A boolean value.
        #[prost(bool, tag = "2")]
        BoolValue(bool),
        /// Optional. An int64 value.
        #[prost(int64, tag = "3")]
        Int64Value(i64),
        /// Optional. A string value.
        #[prost(string, tag = "4")]
        StringValue(::prost::alloc::string::String),
        /// Optional. An account ID.
        #[prost(string, tag = "5")]
        AccountId(::prost::alloc::string::String),
        /// Optional. A dictionary value.
        #[prost(message, tag = "6")]
        DictValue(super::DictValue),
    }
}
/// A singleton enumeration to represent the None value.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NoneValue {
    /// The None value.
    Unspecified = 0,
}
impl NoneValue {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "NONE_VALUE_UNSPECIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
            _ => None,
        }
    }
}
/// Fee structure where the fee is proportional to some reference amount.
/// The reference amount would usually be the payment amount but the specific
/// choice is up to each transaction type that includes this fee stanza.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FractionalFee {
    /// Required. A percentage expressed in multiples of hundredths of a basis
    /// point, where 1 basis point = 0.01%. For example, 1% is expressed as an
    /// amount of 10000, while 0.01% (= 1 bp) is expressed as an amount of 100.
    #[prost(int64, tag = "1")]
    pub amount: i64,
    /// Optional. Indicates who pays the fee. By default, it will be the
    /// transaction sender. If set to `FEE_PAYER_OTHER`, then a valid fee account
    /// must also be supplied in `fee_account_id` (or the deprecated `fee_account`
    /// field).
    #[prost(enumeration = "FeePayer", tag = "2")]
    pub fee_payer: i32,
    /// Optional. Optional fee account in case the fee is to be paid from an
    /// account other than the transaction sender or receiver. If a fee account is
    /// specified, fee payer must be set to `FEE_PAYER_OTHER` and the transaction
    /// must also be signed by the fee account. Deprecated: use `fee_account_id`
    /// instead.
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub fee_account: ::core::option::Option<Entity>,
    /// Optional. The ID of the account from which the fee is paid. This is an
    /// optional field which is only required if the fee is to be paid from an
    /// account other than the transaction sender or receiver. If a fee account ID
    /// is specified, fee payer must be set to `FEE_PAYER_OTHER` and the
    /// transaction must also be signed by the fee account.
    #[prost(string, tag = "4")]
    pub fee_account_id: ::prost::alloc::string::String,
}
/// Initiates a settlement operation between two token managers.
/// The sender must be a clearinghouse account.
///
/// In the deferred
/// \[SettlementMode\]\[google.cloud.universalledger.v1.SettlementMode\] where the
/// clearinghouse has custody of the token manager funds, this is the only
/// transaction that needs to be sent to execute a settlement between the two
/// token managers.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SettlementRequest {
    /// Optional. Immutable. The account ID of the party that needs to make the
    /// fund transfer. Deprecated: use `payer_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub payer: ::core::option::Option<Entity>,
    /// Optional. Immutable. The account ID of the party that needs to make the
    /// fund transfer. One of `payer` or `payer_id` must be specified.
    #[prost(string, tag = "6")]
    pub payer_id: ::prost::alloc::string::String,
    /// Optional. Immutable. The account ID of the party that needs to be paid.
    /// Deprecated: use `beneficiary_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub beneficiary: ::core::option::Option<Entity>,
    /// Optional. Immutable. The account ID of the party that will receive the
    /// funds. One of `beneficiary` or `beneficiary_id` must be specified.
    #[prost(string, tag = "7")]
    pub beneficiary_id: ::prost::alloc::string::String,
    /// Required. Immutable. The balance of issued tokens that need to be
    /// transferred by the `payer` account to the `beneficiary` account on the
    /// ledger.
    #[prost(message, optional, tag = "3")]
    pub balance: ::core::option::Option<CurrencyValue>,
    /// Required. Immutable. The round ID at which this settlement amount was
    /// computed.
    #[prost(int64, tag = "5")]
    pub round_id: i64,
}
/// Creates a new user account. The sender must be an account manager.
///
/// If the transaction is successful, the ID of the newly created account is
/// returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateAccount {
    /// Required. The public key of the account owner. Note that this is *not* the
    /// public key of the sender. This is the public key of the *new* account owner
    /// and it will be stored on the ledger. It will be used to validate the
    /// signature of the transactions emanating from the created account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "6")]
    pub key_format: i32,
    /// Optional. The list of roles to grant to this account.
    #[prost(enumeration = "Role", repeated, packed = "false", tag = "2")]
    pub roles: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The status of the account to be created. By default, the account
    /// status of a newly created account will be `ACCOUNT_STATUS_ACTIVE`.
    #[prost(enumeration = "AccountStatus", tag = "3")]
    pub account_status: i32,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "4")]
    pub account_comment: ::prost::alloc::string::String,
    /// Optional. The token manager for this account. This field is optional and if
    /// not supplied, the default token manager associated to the account manager
    /// (that is, the sender of this transaction) will be used.
    /// Deprecated: use `token_manager_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub token_manager: ::core::option::Option<Entity>,
    /// Optional. The ID of the token manager for this account. This field is
    /// optional and if not supplied, the default token manager associated to the
    /// account manager (that is, the sender of this transaction) will be used. The
    /// value is limited to 60 characters.
    #[prost(string, tag = "7")]
    pub token_manager_id: ::prost::alloc::string::String,
}
/// Marks an account as `ACCOUNT_STATUS_INACTIVE`. The sender must be the account
/// manager of the account to deactivate.
///
/// This implies that the account owner will not be able to make any transactions
/// on the account regardless of the roles.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeactivateAccount {
    /// Optional. The ID of the account to be deactivated.
    /// Deprecated: use `account_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Entity>,
    /// Optional. The ID of the account to be deactivated. One of `account` or
    /// `account_id` must be specified. The value is limited to 60 characters.
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
}
/// Marks an account as `ACCOUNT_STATUS_ACTIVE`. The sender must be the account
/// manager of the account to activate.
///
/// The account owner can resume normal operations permitted by the roles on the
/// account.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ActivateAccount {
    /// Optional. The ID of the account to be activated.
    /// Deprecated: use `account_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Entity>,
    /// Optional. The ID of the account to be activated. One of `account` or
    /// `account_id` must be specified. The value is limited to 60 characters.
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
}
/// Adds the specified roles to the account. The sender must be the account
/// manager of the account to modify.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AddRoles {
    /// Optional. The ID of the account to be modified.
    /// Deprecated: use `account_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Entity>,
    /// Optional. The ID of the account to be modified. One of `account` or
    /// `account_id` must be specified. The value is limited to 60 characters.
    #[prost(string, tag = "3")]
    pub account_id: ::prost::alloc::string::String,
    /// Required. The roles to be added.
    #[prost(enumeration = "Role", repeated, packed = "false", tag = "2")]
    pub roles: ::prost::alloc::vec::Vec<i32>,
}
/// Removes the specified roles from the account. The sender must be the account
/// manager of the account to modify.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RemoveRoles {
    /// Optional. The ID of the account to be modified.
    /// Deprecated: use `account_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Entity>,
    /// Optional. The ID of the account to be modified. One of `account` or
    /// `account_id` must be specified. The value is limited to 60 characters.
    #[prost(string, tag = "3")]
    pub account_id: ::prost::alloc::string::String,
    /// Required. The roles to be removed.
    #[prost(enumeration = "Role", repeated, packed = "false", tag = "2")]
    pub roles: ::prost::alloc::vec::Vec<i32>,
}
/// Transfers the responsibility of managing a particular account to another
/// manager. The sender must be the current account manager of the account and,
/// to provide consent, the new manager must also sign this transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChangeAccountManager {
    /// Optional. The ID of the account whose manager is to be changed.
    /// Deprecated: use `account_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Entity>,
    /// Optional. The ID of the account whose manager is to be changed. One of
    /// `account` or `account_id` must be specified. The value is limited to 60
    /// characters.
    #[prost(string, tag = "3")]
    pub account_id: ::prost::alloc::string::String,
    /// Optional. The ID of the new proposed account manager. Validation requires
    /// that the new manager has also signed this transaction. Deprecated: use
    /// `next_manager_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub next_manager: ::core::option::Option<Entity>,
    /// Optional. The ID of the new proposed account manager. Validation requires
    /// that the new manager has also signed this transaction. One of
    /// `next_manager` or `next_manager_id` must be specified. The value is limited
    /// to 60 characters.
    #[prost(string, tag = "4")]
    pub next_manager_id: ::prost::alloc::string::String,
}
/// Transactions for token issuance and minting.
/// Notifies the network that the target account has deposited reserve funds and
/// increases its token issuance limit. The sender must be a clearinghouse
/// account.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IncreaseTokenIssuanceLimit {
    /// Optional. The ID of the institutional account whose mint limit is to be
    /// raised. This account must be a token manager for the transaction to be
    /// valid. Deprecated: use `token_manager_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub token_manager: ::core::option::Option<Entity>,
    /// Optional. The ID of the institutional account whose mint limit is to be
    /// raised. This account must be a token manager for the transaction to be
    /// valid. One of `token_manager` or `token_manager_id` must be specified.
    #[prost(string, tag = "3")]
    pub token_manager_id: ::prost::alloc::string::String,
    /// Required. The amount by which to raise the limit. The amount must be
    /// positive.
    #[prost(message, optional, tag = "2")]
    pub amount: ::core::option::Option<CurrencyValue>,
}
/// Notifies the network that the target account wishes to withdraw reserve funds
/// and decreases its token issuance limit. The sender must be a clearinghouse
/// account.
///
/// Note that this transaction must be successfully finalized *before* the
/// reserve funds can be withdrawn. This is necessary because it is possible for
/// the transaction to fail (for example, if the minted amount is already above
/// the requested reduced limit).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DecreaseTokenIssuanceLimit {
    /// Optional. The ID of the institutional account whose mint limit is to be
    /// lowered. This account must have the `ADMIN_ROLE_TOKEN_MANAGER` permission
    /// on it for the transaction to be valid. Deprecated: use `token_manager_id`
    /// instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub token_manager: ::core::option::Option<Entity>,
    /// Optional. The ID of the institutional account whose mint limit is to be
    /// lowered. This account must have the `ADMIN_ROLE_TOKEN_MANAGER` permission
    /// on it for the transaction to be valid. One of `token_manager` or
    /// `token_manager_id` must be specified.
    #[prost(string, tag = "3")]
    pub token_manager_id: ::prost::alloc::string::String,
    /// Required. The amount by which to lower the limit. The amount must be
    /// positive. The transaction will fail if the reduced limit will fall below
    /// the currently issued tokens.
    #[prost(message, optional, tag = "2")]
    pub amount: ::core::option::Option<CurrencyValue>,
}
/// Mints currency tokens and transfers them to a specified account. The sender
/// must be a token manager.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Mint {
    /// Required. The amount to mint. The amount must be such that the total tokens
    /// minted by the token manager do not exceed the mint limit. If the amount is
    /// higher than that, the transaction must be rejected
    #[prost(message, optional, tag = "1")]
    pub mint_amount: ::core::option::Option<CurrencyValue>,
    /// Optional. The account to which the minted amount should be transferred.
    /// The beneficiary account must have the `ROLE_RECEIVER` enabled on it.
    /// Deprecated: use `beneficiary_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub beneficiary: ::core::option::Option<Entity>,
    /// Optional. The ID of the account to which the minted amount should be
    /// transferred. The receiving account must have the `ROLE_RECEIVER` enabled on
    /// it. One of `beneficiary` or `beneficiary_id` must be specified.
    #[prost(string, tag = "3")]
    pub beneficiary_id: ::prost::alloc::string::String,
}
/// Burns currency tokens. The sender must be a token manager and the account
/// supplying the tokens to burn must additionally sign the transaction.
///
/// The expected flow is that the token manager will have its designated burn
/// account which customers would transfer the tokens to before they are burnt.
/// Alternatively, the customers could directly sign the transaction in which
/// case it would act as an atomic "transfer-and-burn" transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Burn {
    /// Required. The amount to burn.
    #[prost(message, optional, tag = "1")]
    pub burn_amount: ::core::option::Option<CurrencyValue>,
    /// Optional. The account supplying the tokens to burn. The account must have
    /// the `ROLE_PAYER` enabled on it. Deprecated: use `payer_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub payer: ::core::option::Option<Entity>,
    /// Optional. The ID of the account supplying the tokens to burn. The payer
    /// account must have the `ROLE_PAYER` enabled on it. One of `payer` or
    /// `payer_id` must be specified.
    #[prost(string, tag = "3")]
    pub payer_id: ::prost::alloc::string::String,
}
/// Transfers tokens from one user account to another. The sender must be a
/// regular user account, as opposed to a privileged account like a token manager
/// or an account manager.
///
/// Additionally, the transaction sender must have the `ROLE_PAYER` enabled on
/// it, while the receiver must have the `ROLE_RECEIVER` enabled on it.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Transfer {
    /// Optional. The account that receives the tokens.
    /// Deprecated: use `beneficiary_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub beneficiary: ::core::option::Option<Entity>,
    /// Optional. The ID of the account that receives the tokens. One of
    /// `beneficiary` or `beneficiary_id` must be specified.
    #[prost(string, tag = "4")]
    pub beneficiary_id: ::prost::alloc::string::String,
    /// Required. The amount to transfer. The amount must be positive.
    #[prost(message, optional, tag = "2")]
    pub amount: ::core::option::Option<CurrencyValue>,
    /// Optional. The transaction fee to be paid, as a fraction of the amount to
    /// transfer.
    #[prost(message, optional, tag = "3")]
    pub fractional_fee: ::core::option::Option<FractionalFee>,
}
/// Creates a new token manager associated to the currency of the operator
/// sending the request. The sender must be a currency operator.
///
/// If the transaction is successful, the ID of the newly created account is
/// returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateTokenManager {
    /// Required. The public key of the new token manager. Note that this is *not*
    /// the public key of the operator. This public key will be associated with the
    /// token manager and stored on the ledger. It will be used to validate the
    /// signature of the transactions emanating from the token manager's account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "5")]
    pub key_format: i32,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "4")]
    pub account_comment: ::prost::alloc::string::String,
}
/// Creates a new account manager. The sender must be a currency operator.
///
/// If the transaction is successful, the ID of the newly created account is
/// returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateAccountManager {
    /// Required. The public key of the new account manager. Note that this is
    /// *not* the public key of the operator. This public key will be associated
    /// with the account manager and stored on the ledger. It will be used to
    /// validate the signature of the transactions emanating from the account
    /// manager's account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "5")]
    pub key_format: i32,
    /// Optional. The default token manager for the accounts that will be created
    /// by this manager. Deprecated: use `default_token_manager_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub default_token_manager: ::core::option::Option<Entity>,
    /// Optional. The ID of the default token manager for the accounts that will be
    /// created by this manager. The value is limited to 60 characters.
    #[prost(string, tag = "3")]
    pub default_token_manager_id: ::prost::alloc::string::String,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "4")]
    pub account_comment: ::prost::alloc::string::String,
}
/// Creates a new clearinghouse. The sender must be a currency operator.
///
/// If the transaction is successful, the ID of the newly created account is
/// returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateClearinghouse {
    /// Required. The public key of the new clearinghouse. Note that this is *not*
    /// the public key of the operator. This public key will be associated with the
    /// clearinghouse and stored on the ledger. It will be used to validate
    /// signature of the transactions emanating from the clearinghouse's account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "6")]
    pub key_format: i32,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "4")]
    pub account_comment: ::prost::alloc::string::String,
    /// The settlement mode for this clearinghouse. Required.
    #[prost(enumeration = "SettlementMode", tag = "5")]
    pub settlement_mode: i32,
}
/// Transfers the ownership of the platform operator to a new account. The sender
/// must be the current platform operator.
///
/// If the transaction is successful, deactivates the current platform operator,
/// and the ID of the newly created account is returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransferPlatformOperator {
    /// Required. The public key of the new platform operator. This public key will
    /// be associated with the platform operator and stored on the ledger. It will
    /// be used to validate the signature of the transactions emanating from the
    /// platform operator's account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "3")]
    pub key_format: i32,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "2")]
    pub account_comment: ::prost::alloc::string::String,
}
/// Creates a new currency operator. The sender must be the platform operator.
///
/// If the transaction is successful, the ID of the newly created account is
/// returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
///
/// This transaction must introduce a new currency into the system. If the
/// specified currency already exists, this transaction will fail.
/// If the currency operator has to be replaced, the TransferCurrencyOperator
/// transaction should be sent instead.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateCurrencyOperator {
    /// Required. The public key of the new currency operator. This public key will
    /// be associated with the currency operator and stored on the ledger. It will
    /// be used to validate the signature of the transactions emanating from the
    /// operator's account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "4")]
    pub key_format: i32,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "2")]
    pub account_comment: ::prost::alloc::string::String,
    /// The fiat currency associated with this operator, represented as a
    /// 3-capital-letter ISO 4217 code.
    #[prost(string, tag = "3")]
    pub currency: ::prost::alloc::string::String,
}
/// Transfers the ownership of the given currency operator to a new account. The
/// sender must be the platform operator.
///
/// If the transaction is successful, deactivates the given currency operator,
/// and the ID of the newly created account is returned as an event in the
/// \[TransactionCertificate\]\[google.cloud.universalledger.v1.TransactionCertificate\]
/// of the finalized transaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransferCurrencyOperator {
    /// Required. The public key of the new currency operator. This public key will
    /// be associated with the currency operator and stored on the ledger. It will
    /// be used to validate the signature of the transactions emanating from the
    /// currency operator's account.
    ///
    /// The format of the public key is defined by the `key_format` field.
    #[prost(bytes = "vec", tag = "1")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Optional. Immutable. The key format of the public key. If not
    /// specified, defaults to a binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    #[prost(enumeration = "KeyFormat", tag = "5")]
    pub key_format: i32,
    /// Optional. Immutable. An opaque comment field that is not interpreted by the
    /// system but stored on the ledger in the account. Maximum length is 128
    /// characters. May be left empty. Once created, the field is immutable.
    #[prost(string, tag = "2")]
    pub account_comment: ::prost::alloc::string::String,
    /// Optional. The currency operator to be replaced. Must be active.
    /// Deprecated: use `currency_operator_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "4")]
    pub currency_operator: ::core::option::Option<Entity>,
    /// Optional. The ID of the currency operator to be replaced. Must be active.
    /// One of `currency_operator` or `currency_operator_id` must be specified. The
    /// value is limited to 60 characters.
    #[prost(string, tag = "6")]
    pub currency_operator_id: ::prost::alloc::string::String,
}
/// Triggers the creation of a snapshot of the network. The sender must be
/// the platform operator.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateSnapshot {}
/// Stores a contract on the ledger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContract {
    /// Serialised biter_bytecode.Contract bytes.
    #[prost(bytes = "vec", tag = "1")]
    pub contract_bytes: ::prost::alloc::vec::Vec<u8>,
    /// Arguments for the `__init__` method.
    #[prost(map = "string, message", tag = "2")]
    pub arguments: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
    /// An immutable opaque comment field that is associated with the contract.
    #[prost(string, tag = "3")]
    pub contract_comment: ::prost::alloc::string::String,
}
/// Grants permissions to the contract by the transaction sender.
///
/// Note that, at the moment, there is no support for revoking permissions.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GrantContractPermissions {
    /// Optional. ID of the contract to which permissions are being granted.
    /// Deprecated: use `contract_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub contract: ::core::option::Option<Entity>,
    /// Optional. The ID of the contract to which permissions are being granted.
    /// One of `contract` or `contract_id` must be specified.
    #[prost(string, tag = "3")]
    pub contract_id: ::prost::alloc::string::String,
    /// The permissions to be granted.
    #[prost(enumeration = "ContractPermission", repeated, tag = "2")]
    pub permissions: ::prost::alloc::vec::Vec<i32>,
}
/// Invokes the execution of a contract method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvokeContractMethod {
    /// Optional. ID of the contract to run.
    /// Deprecated: use `contract_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub contract: ::core::option::Option<Entity>,
    /// Optional. The ID of the contract to run. One of `contract` or `contract_id`
    /// must be specified.
    #[prost(string, tag = "5")]
    pub contract_id: ::prost::alloc::string::String,
    /// Name of the method to run.
    #[prost(string, tag = "2")]
    pub method_name: ::prost::alloc::string::String,
    /// Arguments for the method.
    #[prost(map = "string, message", tag = "3")]
    pub arguments: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
    /// The amount to be paid.
    /// Must be greater than zero when invoking payable methods; and zero for
    /// non-payable ones.
    #[prost(message, optional, tag = "4")]
    pub payment: ::core::option::Option<CurrencyValue>,
}
/// Specifies who pays the transaction fees.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FeePayer {
    /// Unspecified fee payer. This value is invalid.
    Unspecified = 0,
    /// Indicates that the sender should be charged the fees in addition to the
    /// transfer amount. For example, if A is sending `$100` to B and the fee is
    /// `$1`, then A's account is debited `$100 + $1 = $101` and B's account is
    /// credited `$100`.
    Sender = 1,
    /// Indicates that the receiver should be charged the fees. For example,
    /// if A is sending `$100` to B and the fee is `$1`, then A's account is
    /// debited `$100` and B's account is credited `$100 - $1 = $99`.
    Receiver = 2,
    /// Indicates that a separate fee account should be charged the fees. For
    /// example, if A is sending `$100` to B and the fee is `$1`, then A's account
    /// is debited `$100` and B's account is credited `$100`. The fee of `$1` will
    /// be debited from a separate fee account specified elsewhere.
    Other = 3,
}
impl FeePayer {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FEE_PAYER_UNSPECIFIED",
            Self::Sender => "FEE_PAYER_SENDER",
            Self::Receiver => "FEE_PAYER_RECEIVER",
            Self::Other => "FEE_PAYER_OTHER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FEE_PAYER_UNSPECIFIED" => Some(Self::Unspecified),
            "FEE_PAYER_SENDER" => Some(Self::Sender),
            "FEE_PAYER_RECEIVER" => Some(Self::Receiver),
            "FEE_PAYER_OTHER" => Some(Self::Other),
            _ => None,
        }
    }
}
/// Specifies the format a public key is provided in.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum KeyFormat {
    /// The key format is unspecified. This value is invalid and should not be
    /// used.
    Unspecified = 0,
    /// A binary serialized keyset in [Tink wire
    /// format](<https://developers.google.com/tink/wire-format#keyset_serialization>).
    TinkWireFormat = 1,
    /// A PEM-encoded elliptic curve signing key using the P-256 curve  with
    /// SHA256 digest. Signatures must be provided in DER format.
    PemEcP256Sha256 = 2,
}
impl KeyFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "KEY_FORMAT_UNSPECIFIED",
            Self::TinkWireFormat => "KEY_FORMAT_TINK_WIRE_FORMAT",
            Self::PemEcP256Sha256 => "KEY_FORMAT_PEM_EC_P256_SHA256",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "KEY_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "KEY_FORMAT_TINK_WIRE_FORMAT" => Some(Self::TinkWireFormat),
            "KEY_FORMAT_PEM_EC_P256_SHA256" => Some(Self::PemEcP256Sha256),
            _ => None,
        }
    }
}
/// The settlement mode for a clearinghouse.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SettlementMode {
    /// The settlement mode is unspecified. This value is invalid and should not
    /// be used.
    Unspecified = 0,
    /// The clearinghouse is responsible for tracking the ownership of the
    /// off-ledger funds, and periodically issuing
    /// \[SettlementRequest\]\[google.cloud.universalledger.v1.SettlementRequest\]
    /// transactions to maintain the corresponding balances on the ledger in sync.
    Deferred = 1,
    /// The clearinghouse maintains a single pool of funds and the ledger acts as
    /// the golden source for the allocation of those funds between the token
    /// managers. This settlement mode can also be described as "instant gross
    /// settlement."
    Instant = 2,
}
impl SettlementMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SETTLEMENT_MODE_UNSPECIFIED",
            Self::Deferred => "SETTLEMENT_MODE_DEFERRED",
            Self::Instant => "SETTLEMENT_MODE_INSTANT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SETTLEMENT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "SETTLEMENT_MODE_DEFERRED" => Some(Self::Deferred),
            "SETTLEMENT_MODE_INSTANT" => Some(Self::Instant),
            _ => None,
        }
    }
}
/// Represents the state of an account on the ledger.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    /// Output only. The sequence number of this account. This number increments
    /// with each transaction sent by this account.
    #[prost(int64, tag = "1")]
    pub sequence_number: i64,
    /// Output only. The primary public key associated with this account, used for
    /// signature verification.
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// Output only. The ID of the execution round (similar to block "height") at
    /// which the account information provided is accurate.
    #[prost(int64, tag = "3")]
    pub round_id: i64,
    /// Output only. The account comment stored when this account was created.
    #[prost(string, tag = "9")]
    pub comment: ::prost::alloc::string::String,
    /// Specific details based on the type of account.
    #[prost(oneof = "account::AccountDetails", tags = "6, 4, 5, 12, 11, 10, 7, 8")]
    pub account_details: ::core::option::Option<account::AccountDetails>,
}
/// Nested message and enum types in `Account`.
pub mod account {
    /// Specific details based on the type of account.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AccountDetails {
        /// Output only. Details for a standard user account.
        #[prost(message, tag = "6")]
        UserDetails(super::UserDetails),
        /// Output only. Details for an account manager account.
        #[prost(message, tag = "4")]
        AccountManagerDetails(super::AccountManagerDetails),
        /// Output only. Details for a token manager account.
        #[prost(message, tag = "5")]
        TokenManagerDetails(super::TokenManagerDetails),
        /// Output only. Details for a contract token manager account.
        #[prost(message, tag = "12")]
        ContractTokenManagerDetails(super::ContractTokenManagerDetails),
        /// Output only. Details for a smart contract account.
        #[prost(message, tag = "11")]
        ContractDetails(super::ContractDetails),
        /// Output only. Details for a clearinghouse account.
        #[prost(message, tag = "10")]
        ClearinghouseDetails(super::ClearingHouseDetails),
        /// Output only. Details for a currency operator account.
        #[prost(message, tag = "7")]
        CurrencyOperatorDetails(super::CurrencyOperatorDetails),
        /// Output only. Details for a platform operator account.
        #[prost(message, tag = "8")]
        PlatformOperatorDetails(super::PlatformOperatorDetails),
    }
}
/// Details specific to an Account Manager.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AccountManagerDetails {
    /// Output only. The default token manager for accounts created by this account
    /// manager.
    #[prost(message, optional, tag = "1")]
    pub token_manager: ::core::option::Option<Entity>,
    /// Output only. The number of accounts created by this account manager.
    #[prost(int32, tag = "2")]
    pub num_accounts: i32,
}
/// Details specific to a Token Manager.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TokenManagerDetails {
    /// Output only. The amount of tokens this token manager is allowed to mint.
    #[prost(message, optional, tag = "1")]
    pub issuance_limit: ::core::option::Option<CurrencyValue>,
    /// Output only. The amount of tokens minted by this token manager.
    /// This number will increase when minting and decrease when burning.
    #[prost(message, optional, tag = "2")]
    pub issued_tokens: ::core::option::Option<CurrencyValue>,
}
/// Details specific to a Contract Token Manager.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ContractTokenManagerDetails {
    /// Output only. The amount of tokens this contract token manager is allowed
    /// to provide backing for.
    ///
    /// Since contract token managers cannot increase or decrease
    /// their issuance limit, this should equal the `issued_tokens`.
    #[prost(message, optional, tag = "1")]
    pub issuance_limit: ::core::option::Option<CurrencyValue>,
    /// Output only. The amount of tokens this contract token manager is
    /// providing backing for (that is, its total liability).
    ///
    /// This equals to the sum of all balances held in contracts for its currency,
    /// plus its net position in the settlement matrix.
    #[prost(message, optional, tag = "2")]
    pub issued_tokens: ::core::option::Option<CurrencyValue>,
    /// Output only. The account ID of the previous contract token manager for this
    /// currency. This forms an audit trail that can be traversed to discover all
    /// previous managers. If this is the first contract token manager for the
    /// currency, this will be empty.
    #[prost(string, tag = "3")]
    pub previous_contract_token_manager_id: ::prost::alloc::string::String,
    /// Output only. The status of this account.
    #[prost(enumeration = "AccountStatus", tag = "4")]
    pub account_status: i32,
}
/// Details specific to a User account.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDetails {
    /// Output only. The account manager for this user.
    #[prost(message, optional, tag = "1")]
    pub account_manager: ::core::option::Option<Entity>,
    /// Output only. The token manager for this user.
    #[prost(message, optional, tag = "2")]
    pub token_manager: ::core::option::Option<Entity>,
    /// Output only. The list of roles granted to this account.
    #[prost(enumeration = "Role", repeated, packed = "false", tag = "3")]
    pub roles: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The status of this account.
    #[prost(enumeration = "AccountStatus", tag = "4")]
    pub account_status: i32,
    /// Output only. The token balance of this user account.
    #[prost(message, optional, tag = "5")]
    pub balance: ::core::option::Option<CurrencyValue>,
    /// Output only. The contract account fields (contract ID -> fields) for this
    /// user.
    #[prost(map = "string, message", tag = "6")]
    pub account_fields: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        Fields,
    >,
}
/// Details specific to a Currency Operator.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrencyOperatorDetails {
    /// Output only. The currency associated with this account, represented by the
    /// 3-letter ISO 4217 code.
    #[prost(string, tag = "1")]
    pub currency: ::prost::alloc::string::String,
    /// Output only. The status of this account.
    #[prost(enumeration = "AccountStatus", tag = "2")]
    pub account_status: i32,
    /// Output only. The previous currency operator which transferred ownership of
    /// the currency operator role to this account. If this is the first currency
    /// operator for the currency, this will be empty.
    #[prost(message, optional, tag = "3")]
    pub previous_entity_id: ::core::option::Option<Entity>,
    /// Output only. The platform operator which created this currency operator.
    #[prost(message, optional, tag = "4")]
    pub platform_operator_entity_id: ::core::option::Option<Entity>,
    /// Output only. The contract token manager associated with this currency
    /// operator.
    #[prost(message, optional, tag = "5")]
    pub contract_token_manager: ::core::option::Option<Entity>,
}
/// Details specific to a Platform Operator.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlatformOperatorDetails {
    /// Output only. The status of this account.
    #[prost(enumeration = "AccountStatus", tag = "1")]
    pub account_status: i32,
    /// Output only. The previous platform operator which transferred ownership of
    /// the platform operator role to this account. If this is the first platform
    /// operator, this will be empty.
    #[prost(message, optional, tag = "2")]
    pub previous_entity_id: ::core::option::Option<Entity>,
}
/// Details specific to a Clearinghouse.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearingHouseDetails {
    /// Output only. The status of this account.
    #[prost(enumeration = "AccountStatus", tag = "1")]
    pub account_status: i32,
    /// Output only. The balances that this clearinghouse is currently tracking for
    /// settlement.
    #[prost(message, repeated, tag = "2")]
    pub balances: ::prost::alloc::vec::Vec<BalanceToSettle>,
    /// Output only. The settlement mode of this clearinghouse.
    #[prost(enumeration = "SettlementMode", tag = "3")]
    pub settlement_mode: i32,
}
/// Details specific to a Smart Contract.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ContractDetails {
    /// Output only. The owner of the contract.
    #[prost(message, optional, tag = "1")]
    pub owner: ::core::option::Option<Entity>,
    /// Output only. The serialized contract code.
    #[prost(bytes = "vec", tag = "2")]
    pub code: ::prost::alloc::vec::Vec<u8>,
    /// Output only. The contract fields (field name -> value) for this contract.
    #[prost(message, optional, tag = "3")]
    pub contract_fields: ::core::option::Option<Fields>,
    /// Output only. The currency balances held by the contract (currency operator
    /// -> balance).
    #[prost(map = "string, message", tag = "4")]
    pub currency_balances: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        CurrencyValue,
    >,
}
/// A balance to settle between two token managers.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BalanceToSettle {
    /// Output only. The account which owes the balance to be settled.
    #[prost(message, optional, tag = "1")]
    pub balance_payer: ::core::option::Option<Entity>,
    /// Output only. The account which is owed the balance to be settled.
    #[prost(message, optional, tag = "2")]
    pub balance_receiver: ::core::option::Option<Entity>,
    /// Output only. The balance to settle. Must be positive.
    #[prost(message, optional, tag = "3")]
    pub balance: ::core::option::Option<CurrencyValue>,
}
/// A map of fields (field name -> value) from a contract used to represent
/// contract fields or account fields.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fields {
    /// Output only. The map of field names to their values.
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// Represents an event in the processing of a transaction as observed by a
/// single validator.
///
/// All values reported are from the perspective of the validator handling the
/// request and may differ from the view of other validators.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StatusEvent {
    /// Output only. The time when the event was recorded by this validator.
    #[prost(message, optional, tag = "1")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The type of the event.
    #[prost(enumeration = "EventType", tag = "2")]
    pub event_type: i32,
    /// Output only. Additional details associated with the event.
    #[prost(message, optional, tag = "3")]
    pub event_details: ::core::option::Option<EventDetails>,
}
/// Represents additional details of a status event.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventDetails {
    /// The details of the event.
    #[prost(oneof = "event_details::EventDetails", tags = "1")]
    pub event_details: ::core::option::Option<event_details::EventDetails>,
}
/// Nested message and enum types in `EventDetails`.
pub mod event_details {
    /// The details of the event.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum EventDetails {
        /// Output only. Additional details for an execution event.
        #[prost(message, tag = "1")]
        ExecutionDetails(super::ExecutionDetails),
    }
}
/// Additional details for an execution event.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExecutionDetails {
    /// Output only. The round ID at which the execution event occurred.
    #[prost(int64, tag = "1")]
    pub round_id: i64,
}
/// Represents the type of an event in the processing of a transaction, as
/// observed by the validator that the request was routed to.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EventType {
    /// Unknown or unspecified event.
    Unspecified = 0,
    /// The transaction was received by this validator directly from a client.
    Received = 1,
    /// The transaction was broadcasted by this to other validators.
    Broadcasted = 2,
    /// The transaction was ordered and scheduled for execution by this validator.
    Ordered = 3,
    /// The execution of the transaction has started.
    ExecutionStarted = 4,
    /// The execution of the transaction has completed.
    ExecutionCompleted = 5,
    /// The transaction has been finalized by this validator.
    Finalized = 6,
}
impl EventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVENT_TYPE_UNSPECIFIED",
            Self::Received => "EVENT_TYPE_RECEIVED",
            Self::Broadcasted => "EVENT_TYPE_BROADCASTED",
            Self::Ordered => "EVENT_TYPE_ORDERED",
            Self::ExecutionStarted => "EVENT_TYPE_EXECUTION_STARTED",
            Self::ExecutionCompleted => "EVENT_TYPE_EXECUTION_COMPLETED",
            Self::Finalized => "EVENT_TYPE_FINALIZED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "EVENT_TYPE_RECEIVED" => Some(Self::Received),
            "EVENT_TYPE_BROADCASTED" => Some(Self::Broadcasted),
            "EVENT_TYPE_ORDERED" => Some(Self::Ordered),
            "EVENT_TYPE_EXECUTION_STARTED" => Some(Self::ExecutionStarted),
            "EVENT_TYPE_EXECUTION_COMPLETED" => Some(Self::ExecutionCompleted),
            "EVENT_TYPE_FINALIZED" => Some(Self::Finalized),
            _ => None,
        }
    }
}
/// Represents a transaction initiated by a client.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientTransaction {
    /// Optional. The transaction sender.
    /// Deprecated: use `sender_id` instead.
    #[deprecated]
    #[prost(message, optional, tag = "1")]
    pub source: ::core::option::Option<Entity>,
    /// Optional. The ID of the account that is sending this transaction.
    /// One of `source` or `sender_id` must be set.
    #[prost(string, tag = "11")]
    pub sender_id: ::prost::alloc::string::String,
    /// Optional. Accounts that, in addition to the sender, have signed this
    /// transaction. Deprecated: Use `other_signatory_ids` instead.
    #[deprecated]
    #[prost(message, repeated, tag = "2")]
    pub signatories: ::prost::alloc::vec::Vec<Entity>,
    /// Optional. The IDs of accounts that, in addition to the sender, have signed
    /// this transaction.
    #[prost(string, repeated, tag = "12")]
    pub other_signatory_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. A unique, monotonically increasing number, starting from 0.
    ///
    /// This number must be increased by one for each transaction previously
    /// submitted to the network by the same transaction sender.
    ///
    /// Note this does not include any transaction units that may have been
    /// submitted as part of a chain, which must not set a sequence number. But it
    /// does include the sender of the transaction chain itself.
    #[prost(int64, tag = "3")]
    pub sequence_number: i64,
    /// Must be set to true if this client transaction is part of a transaction
    /// chain. Otherwise, it must be set to false.
    ///
    /// This is necessary to prevent a signed transaction intended to be part of a
    /// chain from being submitted on its own.
    #[prost(bool, tag = "7")]
    pub chained_unit: bool,
    /// The client transaction-specific message.
    #[prost(oneof = "client_transaction::Kind", tags = "5, 6, 8")]
    pub kind: ::core::option::Option<client_transaction::Kind>,
}
/// Nested message and enum types in `ClientTransaction`.
pub mod client_transaction {
    /// The client transaction-specific message.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Kind {
        /// Optional. A client transaction-specific message. Should be any one of:
        ///
        /// <!--
        /// clang-format off
        /// -->
        ///
        /// * \[TransferPlatformOperator\]\[google.cloud.universalledger.v1.TransferPlatformOperator\]
        /// * \[CreateCurrencyOperator\]\[google.cloud.universalledger.v1.CreateCurrencyOperator\]
        /// * \[TransferCurrencyOperator\]\[google.cloud.universalledger.v1.TransferCurrencyOperator\]
        /// * \[CreateAccountManager\]\[google.cloud.universalledger.v1.CreateAccountManager\]
        /// * \[CreateTokenManager\]\[google.cloud.universalledger.v1.CreateTokenManager\]
        /// * \[CreateClearinghouse\]\[google.cloud.universalledger.v1.CreateClearinghouse\]
        /// * \[IncreaseTokenIssuanceLimit\]\[google.cloud.universalledger.v1.IncreaseTokenIssuanceLimit\]
        /// * \[DecreaseTokenIssuanceLimit\]\[google.cloud.universalledger.v1.DecreaseTokenIssuanceLimit\]
        /// * \[SettlementRequest\]\[google.cloud.universalledger.v1.SettlementRequest\]
        /// * \[Mint\]\[google.cloud.universalledger.v1.Mint\]
        /// * \[Burn\]\[google.cloud.universalledger.v1.Burn\]
        /// * \[CreateAccount\]\[google.cloud.universalledger.v1.CreateAccount\]
        /// * \[DeactivateAccount\]\[google.cloud.universalledger.v1.DeactivateAccount\]
        /// * \[ActivateAccount\]\[google.cloud.universalledger.v1.ActivateAccount\]
        /// * \[AddRoles\]\[google.cloud.universalledger.v1.AddRoles\]
        /// * \[RemoveRoles\]\[google.cloud.universalledger.v1.RemoveRoles\]
        /// * \[ChangeAccountManager\]\[google.cloud.universalledger.v1.ChangeAccountManager\]
        /// * \[Transfer\]\[google.cloud.universalledger.v1.Transfer\]
        /// * \[CreateContract\]\[google.cloud.universalledger.v1.CreateContract\]
        /// * \[GrantContractPermissions\]\[google.cloud.universalledger.v1.GrantContractPermissions\]
        /// * \[InvokeContractMethod\]\[google.cloud.universalledger.v1.InvokeContractMethod\]
        /// * \[CreateContractTokenManager\]\[google.cloud.universalledger.v1.CreateContractTokenManager\]
        /// * \[TransferContractTokenManager\]\[google.cloud.universalledger.v1.TransferContractTokenManager\]
        /// * \[RemoveSigningPublicKey\]\[google.cloud.universalledger.v1.RemoveSigningPublicKey\]
        /// * \[ReplaceSigningPublicKey\]\[google.cloud.universalledger.v1.ReplaceSigningPublicKey\]
        ///
        /// <!--
        /// clang-format on
        /// -->
        #[prost(message, tag = "5")]
        App(::prost_types::Any),
        /// Optional. An operational transaction message. Note this can only be sent
        /// by the platform operator. Should be any one of:
        ///
        /// <!--
        /// clang-format off
        /// -->
        ///
        /// * \[CreateSnapshot\]\[google.cloud.universalledger.v1.CreateSnapshot\]
        ///
        /// <!--
        /// clang-format on
        /// -->
        #[prost(message, tag = "6")]
        Operational(::prost_types::Any),
        /// Optional. Message for a transaction chain including multiple transaction
        /// units to execute in sequence.
        #[prost(message, tag = "8")]
        Chain(super::TransactionChain),
    }
}
/// A transaction with attached signatures. To submit a transaction, this message
/// should be serialized and included in a
/// \[SubmitTransactionRequest\]\[google.cloud.universalledger.v1.SubmitTransactionRequest\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignedTransaction {
    /// Required. A serialized
    /// \[ClientTransaction\]\[google.cloud.universalledger.v1.ClientTransaction\]
    /// with the transaction details.
    #[prost(bytes = "vec", tag = "1")]
    pub serialized_client_transaction: ::prost::alloc::vec::Vec<u8>,
    /// Required. The signature of the transaction sender.
    ///
    /// The signature should be computed by signing the
    /// `serialized_client_transaction` bytes with their own private key.
    ///
    /// For a transaction chain, the bytes to be signed are computed as the
    /// concatenation of:
    ///
    /// * A digest of the serialized client transaction of the entire chain.
    /// * A digest of the serialized signed transaction of each unit in the chain,
    ///   in the order they appear in the chain.
    ///   The digests are computed using SHA-256.
    #[prost(bytes = "vec", tag = "3")]
    pub sender_signature: ::prost::alloc::vec::Vec<u8>,
    /// Optional. The signatures of accounts listed as additional transaction
    /// signatories. The number and order of these signatures must match the
    /// `signatories` field in the
    /// \[ClientTransaction\]\[google.cloud.universalledger.v1.ClientTransaction\].
    ///
    /// The bytes to be signed are the same as those for the `sender_signature`,
    /// which each signatory should sign with their own private key.
    ///
    /// The number and identity of additional signatories depends on the particular
    /// transaction kind. For a transaction chain, one signature is needed for each
    /// account appearing either as the sender or as a signatory of a unit in the
    /// chain.
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub other_signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// A transaction chain including multiple transaction units to execute in
/// sequence.
///
/// The units will be executed sequentially, in the order they are listed. If all
/// of the units succeed, their cumulative effects will be committed atomically
/// to the world state. Otherwise, if any of them fails, the whole chain will be
/// failed and none of its effects will be applied.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransactionChain {
    /// The individual units of the chain. Each unit must be a serialized
    /// \[SignedTransaction\]\[google.cloud.universalledger.v1.SignedTransaction\].
    ///
    /// Note that the serialized bytes are required in order to determine the bytes
    /// to be signed for the chain itself.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub units: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
/// A Merkle tree with a cryptographic digest of the root node.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct MerkleTree {
    /// Output only. The cryptographic digest of the root node.
    #[prost(string, tag = "1")]
    pub root_hash_hex: ::prost::alloc::string::String,
    /// Output only. The number of transactions in the tree.
    #[prost(int64, tag = "2")]
    pub num_transactions: i64,
}
/// Certificate of the execution of a round by a specific validator.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RoundCertificate {
    /// Output only. The ID of the round for which the certificate is for.
    #[prost(int64, tag = "1")]
    pub round_id: i64,
    /// Output only. The human readable validator identifier. This is used to
    /// lookup the public key against which the `validator_signatures` is verified.
    #[prost(string, tag = "2")]
    pub validator_id: ::prost::alloc::string::String,
    /// Output only. The hex representation of the homomorphic digest over the
    /// world state after the effects of this round are applied.
    #[prost(string, tag = "3")]
    pub round_state_checksum_hex: ::prost::alloc::string::String,
    /// Output only. The hex representation of the homomorphic digest over the
    /// aggregated transaction effects of this round.
    #[prost(string, tag = "4")]
    pub round_delta_checksum_hex: ::prost::alloc::string::String,
    /// Output only. Merkle tree having this round as root node and transaction
    /// batches (executed in the round) as the leaves.
    #[prost(message, optional, tag = "6")]
    pub merkle_tree: ::core::option::Option<MerkleTree>,
    /// Optional. The signature of the validator. This is signed over the digest of
    /// the preceding payload of this record.
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub validator_signatures: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Output only. Boolean to indicate if the round is finalized, i.e., whether a
    /// sufficient quorum of validators have certified this round with the same
    /// certificate.
    #[prost(bool, tag = "7")]
    pub is_finalized: bool,
}
/// Represents an update by some transaction to the world state.
///
/// If it has a `delta_val`, it is assumed to be a delta (an integer offset)
/// applied to the previously stored value on a given key. In that case,
/// `new_val` and `old_val` should be empty.
///
/// Otherwise, it is assumed to have at least one of `old_val` or `new_val` (or
/// both). An empty `old_val` indicates the value was inserted. An empty
/// `new_val` indicates the value was deleted.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransactionEffect {
    /// Output only. The key in the world state that was updated.
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
    /// Output only. The value of the key before the transaction was executed.
    #[prost(bytes = "vec", tag = "2")]
    pub old_val: ::prost::alloc::vec::Vec<u8>,
    /// Output only. The value of the key after the transaction was executed.
    #[prost(bytes = "vec", tag = "3")]
    pub new_val: ::prost::alloc::vec::Vec<u8>,
    /// Output only. An integer offset that was applied to the previously stored
    /// value.
    #[prost(int64, tag = "4")]
    pub delta_val: i64,
}
/// Represents the status of a transaction execution.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TransactionStatus {
    /// Output only. The status code, a numeric value whose meaning is defined by
    /// the corresponding [gRPC status
    /// code](<https://github.com/grpc/grpc/blob/master/doc/statuscodes.md>).
    #[prost(int32, tag = "1")]
    pub code: i32,
    /// Output only. The error message, if any. Set only if code is not `OK`. This
    /// is a string encoded as utf-8 bytes. Stored as bytes to prevent any issues
    /// with the determinism of the encoding.
    #[prost(bytes = "vec", tag = "2")]
    pub message: ::prost::alloc::vec::Vec<u8>,
}
/// Effects of the execution of a transaction in the world state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEffects {
    /// Output only. The resulting status of the transaction execution.
    #[prost(message, optional, tag = "1")]
    pub status: ::core::option::Option<TransactionStatus>,
    /// Output only. The effects of the transaction in the world state.
    #[prost(message, repeated, tag = "2")]
    pub effects: ::prost::alloc::vec::Vec<TransactionEffect>,
}
/// An event produced by a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionEvent {
    /// Output only. The type of event. A special event of type
    /// `transaction_output` contains the outputs produced by the transactionfor
    /// example, the account ID of a newly created account.
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Output only. The event attributes as arbitrary key-value pairs.
    #[prost(message, repeated, tag = "2")]
    pub attributes: ::prost::alloc::vec::Vec<transaction_event::EventAttribute>,
}
/// Nested message and enum types in `TransactionEvent`.
pub mod transaction_event {
    /// An individual attribute as a key-value pair.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EventAttribute {
        /// Output only. The key of the attribute.
        #[prost(string, tag = "1")]
        pub key: ::prost::alloc::string::String,
        /// Output only. The value of the attribute.
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
}
/// Certificate of the execution of a specific transaction in a round.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionCertificate {
    /// Output only. Digest of the transaction this certificate is for.
    #[prost(string, tag = "1")]
    pub transaction_digest_hex: ::prost::alloc::string::String,
    /// Output only. The ID of the execution round at which this transaction was
    /// executed in.
    #[prost(int64, tag = "2")]
    pub round_id: i64,
    /// Output only. The effects of the transaction in the world state.
    #[prost(message, optional, tag = "3")]
    pub transaction_effects: ::core::option::Option<TransactionEffects>,
    /// Output only. Events produced by the transaction.
    #[prost(message, repeated, tag = "6")]
    pub events: ::prost::alloc::vec::Vec<TransactionEvent>,
    /// Output only. Homomorphic checksum of the effects. A 2048 byte value encoded
    /// as a hexadecimal string.
    #[prost(string, tag = "4")]
    pub transaction_effects_state_checksum_hex: ::prost::alloc::string::String,
    /// Output only. The cryptographic digest of all the previous fields in
    /// sequence. Used to build a Merkle tree for the proof of inclusion.
    #[prost(string, tag = "5")]
    pub certification_results_digest_hex: ::prost::alloc::string::String,
}
/// Certificate of the inclusion of the effects of a transaction in the world
/// state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofOfInclusion {
    /// Output only. Certificate of the inclusion of the transaction effects in a
    /// specific round.
    #[prost(message, optional, tag = "1")]
    pub transaction_certificate: ::core::option::Option<TransactionCertificate>,
    /// Output only. Certificate of the execution of the round.
    #[prost(message, optional, tag = "2")]
    pub round_certificate: ::core::option::Option<RoundCertificate>,
    /// Output only. Cryptographic proof of inclusion of the transaction effects in
    /// the execution round.
    ///
    /// It is given as a path from a given leaf (a transaction digest) to the root
    /// of the execution round. The path is represented as a list of (left child,
    /// right child) pairs, and the first pair is the left and right children of
    /// the given leaf's parent node. For example, assuming the Merkle tree was
    /// built with eight leaf digests `\[t0, t1, t2, t3, t4, t5, t6, t7\]`, having
    /// the following structure:
    ///
    /// ```text
    ///         _____root_digest____
    ///        |                    |
    ///     __ h20__             __h21__
    ///    |        |           |       |
    ///   h10     h11          h12     h13
    ///   | |     | |          | |     | |
    /// t0 t1   t2 t3        t4 t5   t6 t7
    /// ```
    ///
    /// In here, `path_to_round_root` for `t0` will contain:
    /// `\[(t0, t1), (h10, h11), (h20, h21)\]`.
    ///
    /// One can consecutively compute SHA-256 hashes of each
    /// path node to verify that the path hashes to the same value as the
    /// `round_certificate.merkle_tree.root_digest_hex`. Thus, verifying that the
    /// leaf was included in the round's Merkle tree.
    #[prost(message, repeated, tag = "3")]
    pub path_to_round_root: ::prost::alloc::vec::Vec<proof_of_inclusion::MerkleTreeNode>,
}
/// Nested message and enum types in `ProofOfInclusion`.
pub mod proof_of_inclusion {
    /// Represents a node in a Merkle tree path.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct MerkleTreeNode {
        /// Output only. The hex representation of the hash of the left child of a
        /// node.
        #[prost(string, tag = "1")]
        pub left_child_hash_hex: ::prost::alloc::string::String,
        /// Output only. The hex representation of the hash of the right child of a
        /// node.
        #[prost(string, tag = "2")]
        pub right_child_hash_hex: ::prost::alloc::string::String,
    }
}
/// The state of an attempted transaction submission.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionAttempt {
    /// Output only. The current status of the transaction attempt.
    #[prost(enumeration = "transaction_attempt::TransactionStatus", tag = "1")]
    pub status: i32,
    /// Output only. Certificate of the inclusion of the transaction effects in the
    /// world state. Only provided if status is `FINALIZED`.
    #[prost(message, optional, tag = "2")]
    pub proof_of_inclusion: ::core::option::Option<ProofOfInclusion>,
    /// Output only. The ordered status events recorded for the transaction
    /// attempt.
    #[prost(message, repeated, tag = "3")]
    pub status_events: ::prost::alloc::vec::Vec<StatusEvent>,
}
/// Nested message and enum types in `TransactionAttempt`.
pub mod transaction_attempt {
    /// The status of the transaction attempt.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionStatus {
        /// Unknown or uninitialized state.
        Unspecified = 0,
        /// The transaction is known to this validator, but it is not finalized yet.
        Pending = 1,
        /// The transaction is finalized. Its effects have been persisted on the
        /// blockchain and cannot be reversed.
        Finalized = 2,
    }
    impl TransactionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TRANSACTION_STATUS_UNSPECIFIED",
                Self::Pending => "PENDING",
                Self::Finalized => "FINALIZED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "PENDING" => Some(Self::Pending),
                "FINALIZED" => Some(Self::Finalized),
                _ => None,
            }
        }
    }
}
/// The state of a transaction.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionState {
    /// One entry per each known submission of the transaction to the validator
    /// handling the request.
    #[prost(message, repeated, tag = "1")]
    pub transaction_attempts: ::prost::alloc::vec::Vec<TransactionAttempt>,
}
/// Represents a Universal Ledger endpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Endpoint {
    /// Identifier. The resource name of the endpoint.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for ListEndpoints.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListEndpointsRequest {
    /// Required. The parent, which owns this collection of endpoints.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of endpoints to return. The service may return
    /// fewer than this value. If unspecified, at most 50 endpoints will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListEndpoints` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for ListEndpoints.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEndpointsResponse {
    /// The endpoints for the given project and location.
    #[prost(message, repeated, tag = "1")]
    pub endpoints: ::prost::alloc::vec::Vec<Endpoint>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetEndpoint.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetEndpointRequest {
    /// Required. The name of the endpoint to retrieve.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for QueryAccount.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryAccountRequest {
    /// Required. The endpoint to serve the request.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    /// The location is a region.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Required. The account ID to get information about. The value is limited to
    /// 60 characters.
    #[prost(string, tag = "2")]
    pub account_id: ::prost::alloc::string::String,
    /// Optional. The ID of the execution round (similar to block "height") at
    /// which to request data. The returned account information will be accurate
    /// for the world state at this execution round. If unspecified, uses the
    /// latest finalized round as known by the serving validator. The state at a
    /// given round ID is always consistent and canonical.
    #[prost(int64, tag = "3")]
    pub round_id: i64,
}
/// Response message for QueryAccount.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAccountResponse {
    /// The account information, along with the height at which it was obtained.
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
}
/// Request message for SubmitTransaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitTransactionRequest {
    /// Required. The endpoint to submit the transaction to.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    /// The location is a region.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Required. A protobuf serialized
    /// \[SignedTransaction\]\[google.cloud.universalledger.v1.SignedTransaction\] to
    /// submit to the Universal Ledger network. Using a serialized format ensures
    /// that all validators can compute the same hash for the transaction,
    /// regardless of the machine or environment where the transaction was
    /// serialized.
    #[prost(bytes = "vec", tag = "2")]
    pub serialized_signed_transaction: ::prost::alloc::vec::Vec<u8>,
}
/// Response message for SubmitTransaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitTransactionResponse {
    /// Hex encoded SHA-256 hash of the `serialized_signed_transaction` that
    /// uniquely identifies the submitted transaction.
    /// This ID is provided so that a client can track the transaction without
    /// needing to implement the hashing logic itself. The ID can be directly
    /// used in subsequent API calls, for example to query the transaction state.
    #[prost(string, tag = "1")]
    pub transaction_digest_hex: ::prost::alloc::string::String,
}
/// Request message for SubmitOperationalTransaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitOperationalTransactionRequest {
    /// Required. The endpoint to serve the request.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    /// The location is a region.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Required. A protobuf serialized
    /// \[SignedTransaction\]\[google.cloud.universalledger.v1.SignedTransaction\] to
    /// submit to the network. The enclosed client transaction must be an
    /// operational transaction, and the sender must be the platform operator.
    /// Having the fully serialized transaction allows all validators
    /// to compute the same hash without assuming any format for the serialized
    /// transaction.
    #[prost(bytes = "vec", tag = "2")]
    pub serialized_signed_operational_transaction: ::prost::alloc::vec::Vec<u8>,
}
/// Response message for SubmitOperationalTransaction.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SubmitOperationalTransactionResponse {
    /// Hex encoded SHA-256 hash of the `serialized_signed_operational_transaction`
    /// that uniquely identifies the submitted operational transaction.
    /// This ID is provided so that a client can track the transaction without
    /// needing to implement the hashing logic itself. The ID can be directly
    /// used in subsequent API calls, for example to query the transaction state.
    #[prost(string, tag = "1")]
    pub transaction_digest_hex: ::prost::alloc::string::String,
}
/// Request message for QueryTransactionState.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryTransactionStateRequest {
    /// Required. The endpoint to serve the request.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    /// The location is a region.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Required. The transaction digest to get the state of.
    #[prost(string, tag = "2")]
    pub transaction_digest_hex: ::prost::alloc::string::String,
}
/// Response message for QueryTransactionState.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryTransactionStateResponse {
    /// One entry per each known submission of the transaction to the validator
    /// handling the request.
    #[prost(message, repeated, tag = "1")]
    pub transaction_attempts: ::prost::alloc::vec::Vec<TransactionAttempt>,
}
/// Request message for QueryData.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryDataRequest {
    /// Required. The endpoint to serve the request.
    /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
    /// The location is a region.
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// Required. A protobuf serialized
    /// \[SignedQueryRequest\]\[google.cloud.universalledger.v1.SignedQueryRequest\] to
    /// query the Universal Ledger network.
    #[prost(bytes = "vec", tag = "2")]
    pub serialized_signed_query_request: ::prost::alloc::vec::Vec<u8>,
}
/// Response message for QueryData.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDataResponse {
    /// The Query specific response message. Should be any one of:
    #[prost(oneof = "query_data_response::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<query_data_response::Kind>,
}
/// Nested message and enum types in `QueryDataResponse`.
pub mod query_data_response {
    /// The Query specific response message. Should be any one of:
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// The account information, if the query was for an account.
        #[prost(message, tag = "1")]
        Account(super::Account),
        /// The state of a transaction, if the query was for a transaction.
        #[prost(message, tag = "2")]
        TransactionState(super::TransactionState),
    }
}
/// Generated client implementations.
pub mod universal_ledger_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service for interacting with the Google Cloud Universal Ledger.
    /// Endpoints are pre-created and managed by Google and cannot
    /// be modified by users.
    /// The names of available endpoints will be provided in the public
    /// documentation.
    /// An endpoint is a regional resource within a Universal Ledger network.
    /// Requests sent to an endpoint may be routed to different validators in the
    /// given network within the given region.
    #[derive(Debug, Clone)]
    pub struct UniversalLedgerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UniversalLedgerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UniversalLedgerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UniversalLedgerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UniversalLedgerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submits a transaction to the network.
        /// The request is first validated for basic correctness. If validation fails,
        /// the request will fail immediately.
        /// If validation succeeds, this method returns only after the transaction has
        /// been replicated across a majority of validators in the network, or until
        /// the request fails.
        pub async fn submit_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/SubmitTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "SubmitTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all endpoints for a given project and location.
        pub async fn list_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEndpointsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEndpointsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/ListEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "ListEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a specific endpoint.
        pub async fn get_endpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEndpointRequest>,
        ) -> std::result::Result<tonic::Response<super::Endpoint>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/GetEndpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "GetEndpoint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Submits an operational transaction to the network.
        /// This method returns only after the transaction has been replicated across a
        /// majority of validators in the network, or if the transaction fails.
        pub async fn submit_operational_transaction(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitOperationalTransactionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitOperationalTransactionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/SubmitOperationalTransaction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "SubmitOperationalTransaction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries the state of a transaction. This method can be called for any
        /// transaction submitted to the network. The returned transaction details may
        /// vary between calls, because an endpoint may route requests to different
        /// validators within the network and region, and the validators may not be at
        /// the same round ID at any given time.
        pub async fn query_transaction_state(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryTransactionStateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryTransactionStateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/QueryTransactionState",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "QueryTransactionState",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries all the information stored about an account in the network.
        /// The returned account details may vary between calls, because an
        /// endpoint may route requests to different validators within the network and
        /// region, and the validators may not be at the same round ID at any given
        /// time.
        pub async fn query_account(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/QueryAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "QueryAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Queries the network for information stored on the ledger,
        /// such as accounts and transactions.
        pub async fn query_data(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryDataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.universalledger.v1.UniversalLedger/QueryData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.universalledger.v1.UniversalLedger",
                        "QueryData",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
