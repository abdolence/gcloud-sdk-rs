// This file is @generated by prost-build.
/// The request message for the `RegisterIcebergTable` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegisterIcebergTableRequest {
    /// Required. Table to register in the format:
    /// `projects/{project_id}/catalogs/{catalog_id}/namespaces/{namespace}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The name of the table to register.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Required. The metadata location of the table.
    #[prost(string, tag = "3")]
    pub metadata_location: ::prost::alloc::string::String,
    /// Optional. Whether to overwrite the table if it already exists. Default is
    /// false. Currently this field is ignored and an error is returned if the
    /// table already exists.
    #[prost(string, tag = "4")]
    pub overwrite: ::prost::alloc::string::String,
}
/// The Iceberg REST Catalog information.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IcebergCatalog {
    /// Identifier. The catalog name, `projects/my-project/catalogs/my-catalog`.
    /// This field is immutable.
    /// This field is ignored for CreateIcebergCatalog.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The credential mode for the catalog.
    #[prost(enumeration = "iceberg_catalog::CredentialMode", tag = "2")]
    pub credential_mode: i32,
    /// Output only. The service account used for credential vending, output only.
    /// Might be empty if Credential vending was never enabled for the catalog.
    #[prost(string, tag = "3")]
    pub biglake_service_account: ::prost::alloc::string::String,
    /// Required. The catalog type. Required for CreateIcebergCatalog.
    #[prost(enumeration = "iceberg_catalog::CatalogType", tag = "4")]
    pub catalog_type: i32,
    /// Optional. The default location for the catalog. For the Google Cloud
    /// Storage Bucket catalog this is output only.
    #[prost(string, tag = "5")]
    pub default_location: ::prost::alloc::string::String,
    /// Output only. The GCP region(s) where the catalog metadata is stored.
    /// This will contain one value for all locations, except for the catalogs that
    /// are configured to use custom dual region buckets.
    #[prost(string, repeated, tag = "6")]
    pub catalog_regions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. When the catalog was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. When the catalog was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `IcebergCatalog`.
pub mod iceberg_catalog {
    /// Determines the catalog type.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CatalogType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Catalog type for Google Cloud Storage Buckets.
        GcsBucket = 1,
    }
    impl CatalogType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CATALOG_TYPE_UNSPECIFIED",
                Self::GcsBucket => "CATALOG_TYPE_GCS_BUCKET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CATALOG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CATALOG_TYPE_GCS_BUCKET" => Some(Self::GcsBucket),
                _ => None,
            }
        }
    }
    /// The credential mode used for the catalog.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CredentialMode {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// End user credentials, default. The authenticating user must have access
        /// to the catalog resources and the corresponding Google Cloud Storage
        /// files.
        EndUser = 1,
        /// Use credential vending. The authenticating user must have access to the
        /// catalog resources and the system will provide the caller with downscoped
        /// credentials to access the Google Cloud Storage files. All table
        /// operations in this mode would require `X-Iceberg-Access-Delegation`
        /// header with `vended-credentials` value included. System will generate a
        /// service account and the catalog administrator must grant the service
        /// account appropriate permissions.
        ///
        /// See:
        /// <https://github.com/apache/iceberg/blob/931865ecaf40a827f9081dddb675bf1c95c05461/open-api/rest-catalog-open-api.yaml#L1854>
        /// for more details.
        VendedCredentials = 2,
    }
    impl CredentialMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CREDENTIAL_MODE_UNSPECIFIED",
                Self::EndUser => "CREDENTIAL_MODE_END_USER",
                Self::VendedCredentials => "CREDENTIAL_MODE_VENDED_CREDENTIALS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREDENTIAL_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREDENTIAL_MODE_END_USER" => Some(Self::EndUser),
                "CREDENTIAL_MODE_VENDED_CREDENTIALS" => Some(Self::VendedCredentials),
                _ => None,
            }
        }
    }
}
/// The request message for the `CreateIcebergCatalog` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CreateIcebergCatalogRequest {
    /// Required. The parent resource where this catalog will be created.
    /// Format: projects/{project_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The name of the catalog.
    #[prost(string, tag = "3")]
    pub iceberg_catalog_id: ::prost::alloc::string::String,
    /// Required. The catalog to create.
    /// The required fields for creation are:
    ///
    /// * catalog_type.
    ///   Optionally: credential_mode can be provided, if Credential Vending is
    ///   desired.
    #[prost(message, optional, tag = "2")]
    pub iceberg_catalog: ::core::option::Option<IcebergCatalog>,
}
/// The request message for the `DeleteIcebergCatalog` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIcebergCatalogRequest {
    /// Required. The catalog to delete.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for the `UpdateIcebergCatalog` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateIcebergCatalogRequest {
    /// Required. The catalog to update.
    #[prost(message, optional, tag = "1")]
    pub iceberg_catalog: ::core::option::Option<IcebergCatalog>,
    /// Optional. The list of fields to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request message for the `GetIcebergCatalog` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIcebergCatalogRequest {
    /// Required. The catalog to get.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for the `ListIcebergCatalogs` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIcebergCatalogsRequest {
    /// Required. The parent resource where this catalog will be created.
    /// Format: projects/{project_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The view of the catalog to return.
    #[prost(enumeration = "list_iceberg_catalogs_request::CatalogView", tag = "2")]
    pub view: i32,
    /// Optional. The maximum number of catalogs to return. The service may return
    /// fewer than this value.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. The page token, received from a previous `ListIcebergCatalogs`
    /// call. Provide this to retrieve the subsequent page.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ListIcebergCatalogsRequest`.
pub mod list_iceberg_catalogs_request {
    /// The enumeration of the views that can be returned.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CatalogView {
        /// Default/unset value. Same as BASIC.
        Unspecified = 0,
        /// Include only the name and catalog type.
        Basic = 1,
        /// Include all fields of the catalog.
        Full = 2,
    }
    impl CatalogView {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CATALOG_VIEW_UNSPECIFIED",
                Self::Basic => "CATALOG_VIEW_BASIC",
                Self::Full => "CATALOG_VIEW_FULL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CATALOG_VIEW_UNSPECIFIED" => Some(Self::Unspecified),
                "CATALOG_VIEW_BASIC" => Some(Self::Basic),
                "CATALOG_VIEW_FULL" => Some(Self::Full),
                _ => None,
            }
        }
    }
}
/// The response message for the `ListIcebergCatalogs` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIcebergCatalogsResponse {
    /// Output only. The list of iceberg catalogs.
    #[prost(message, repeated, tag = "1")]
    pub iceberg_catalogs: ::prost::alloc::vec::Vec<IcebergCatalog>,
    /// Output only. The next page token for pagination.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Output only. The list of unreachable cloud regions for router fanout.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request message for FailoverIcebergCatalog.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailoverIcebergCatalogRequest {
    /// Required. The name of the catalog in the form
    /// "projects/{project_id}/catalogs/{catalog_id}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The region being assigned as the new primary replica region. For
    /// example "us-east1". This must be one of the replica regions in the
    /// catalog's list of replicas marked as a "secondary".
    #[prost(string, tag = "2")]
    pub primary_replica: ::prost::alloc::string::String,
    /// Optional. If set, only validate the request, but do not perform the update.
    /// This can be used to inspect the replication_time at any time, including
    /// before performing a fail-over.
    #[prost(bool, tag = "3")]
    pub validate_only: bool,
    /// Optional. If unset, wait for all data from the source region to replicate
    /// to the new primary region before completing the failover, with no data loss
    /// (also called "soft failover"). If set, failover immediately, accepting the
    /// loss of any data committed in the source region after this timestamp, that
    /// has not yet replicated. If any data committed before this time has not
    /// replicated, the failover will not be performed and an error will be
    /// returned (also called "hard failover").
    #[prost(message, optional, tag = "4")]
    pub conditional_failover_replication_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
}
/// Response message for FailoverIcebergCatalog.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FailoverIcebergCatalogResponse {
    /// Output only. The min timestamp for which all namespaces and table metadata
    /// have been replicated in the region specified as the new primary_replica.
    /// Some resources may have been replicated more recently than this timestamp.
    /// If empty, the replica has just been created and has not yet been fully
    /// initialized. NOTE: When the Cloud Storage replication watermark is
    /// available, this will represent both catalog metadata and Cloud Storage
    /// data.
    #[prost(message, optional, tag = "1")]
    pub replication_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The update message for the `UpdateIcebergTable` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIcebergTableRequest {
    /// Required. Table to commit in the format:
    /// `projects/{project_id}/namespaces/{namespace}/tables/{table}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The request body that should be in the format of Apache Iceberg's
    /// `#/components/schemas/CommitTableRequest`. Content type is expected to be
    /// `application/json`. Added this field for easier json parsing.
    #[prost(message, optional, tag = "2")]
    pub http_body: ::core::option::Option<super::super::super::api::HttpBody>,
}
/// The request message for the `GetIcebergTable` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIcebergTableRequest {
    /// Required. Table to get in the format:
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. What snapshot to get. Valid only for GetIcebergTable.
    #[prost(string, tag = "2")]
    pub snapshots: ::prost::alloc::string::String,
}
/// The request message for the `DeleteIcebergTable` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIcebergTableRequest {
    /// Required. Table to delete in the format:
    /// `projects/{project_id}/namespaces/{namespace}/tables/{table}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. If true we'll delete both the table and the data. Currently
    /// purgin data is not supported.
    #[prost(bool, tag = "2")]
    pub purge_requested: bool,
}
/// The request message for the `CreateIcebergTable` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIcebergTableRequest {
    /// Required. The parent resource where this table will be created.
    /// Format: projects/{project_id}/namespaces/{namespace}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The request body that should be in the format of Apache Iceberg's
    /// `#/components/schemas/CreateTableRequest`. Content type is expected to be
    /// `application/json`.
    #[prost(message, optional, tag = "3")]
    pub http_body: ::core::option::Option<super::super::super::api::HttpBody>,
}
/// The request message for the `ListIcebergTableIdentifiers` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIcebergTableIdentifiersRequest {
    /// Optional. PageToken for pagination.
    #[prost(string, tag = "1")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Page size for pagination.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Required. The namespace to list tables from.
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
}
/// The table identifier.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TableIdentifier {
    /// The namespace of the table. This is always 1 element, since we don't
    /// support nested namespaces.
    #[prost(string, repeated, tag = "1")]
    pub namespace: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The table name.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// The response message for the `ListIcebergTableIdentifiers` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIcebergTableIdentifiersResponse {
    /// Output only. The list of table identifiers.
    #[prost(message, repeated, tag = "1")]
    pub identifiers: ::prost::alloc::vec::Vec<TableIdentifier>,
    /// Output only. The next page token for pagination.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for the `UpdateIcebergNamespace` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IcebergNamespaceUpdate {
    /// Optional. Keys of the properties to remove.
    #[prost(string, repeated, tag = "2")]
    pub removals: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. List of properties to update or add.
    #[prost(map = "string, string", tag = "3")]
    pub updates: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// The request message for the `UpdateIcebergNamespace` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIcebergNamespaceRequest {
    /// Required. The namespace to update.
    ///
    /// The namespace's `name` field is used to identify the namespace to update.
    /// Format: projects/{project_id}/namespaces/{namespace}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The update to apply to the namespace.
    #[prost(message, optional, tag = "2")]
    pub iceberg_namespace_update: ::core::option::Option<IcebergNamespaceUpdate>,
}
/// The response message for the `UpdateIcebergNamespace` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UpdateIcebergNamespaceResponse {
    /// Output only. List of properties that were removed.
    #[prost(string, repeated, tag = "1")]
    pub removed: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. List of properties that were added or updated.
    #[prost(string, repeated, tag = "2")]
    pub updated: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. List of properties that were requested to be removed, but were
    /// not found.
    #[prost(string, repeated, tag = "3")]
    pub missing: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request message for the `DeleteIcebergNamespace` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteIcebergNamespaceRequest {
    /// Required. Iceberg namespace to delete in the format:
    /// `projects/{project_id}/namespaces/{namespace}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The namespace object to create.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IcebergNamespace {
    /// Required. The name of the namespace.
    #[prost(string, repeated, tag = "1")]
    pub namespace: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The optional properties of the namespace.
    #[prost(map = "string, string", tag = "2")]
    pub properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// The request message for the `CreateIcebergNamespace` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateIcebergNamespaceRequest {
    /// Required. The parent resource where this namespace will be created.
    /// Format: projects/{project_id}/restcatalog/v1/catalogs/{catalog_id}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The namespace to create.
    #[prost(message, optional, tag = "2")]
    pub iceberg_namespace: ::core::option::Option<IcebergNamespace>,
}
/// The request message for the `GetIcebergCatalogConfig` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIcebergCatalogConfigRequest {
    /// Required. Warehouse location or identifier to request from the service.
    #[prost(string, tag = "1")]
    pub warehouse: ::prost::alloc::string::String,
}
/// The iceberg catalog configuration.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IcebergCatalogConfig {
    /// Output only. Properties that should be used to override client
    /// configuration; applied after defaults and client configuration. Required,
    /// even if empty.
    #[prost(map = "string, string", tag = "1")]
    pub overrides: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Properties that should be used as default configuration;
    /// applied before client configuration. Required, even if empty.
    #[prost(map = "string, string", tag = "2")]
    pub defaults: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. Endpoints, required, must not be empty.
    #[prost(string, repeated, tag = "3")]
    pub endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The request message for the `GetIcebergNamespace` API.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetIcebergNamespaceRequest {
    /// Required. Iceberg namespace to fetch in the format:
    /// `projects/{project_id}/namespaces/{namespace}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// ListIcebergNamespacesRequest
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListIcebergNamespacesRequest {
    /// Optional. PageToken
    #[prost(string, tag = "1")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. For servers that support pagination, this signals an upper bound
    /// of the number of results that a client will receive. For servers that do
    /// not support pagination, clients may receive results larger than the
    /// indicated `pageSize`.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Required. The parent from the resource path.
    #[prost(string, tag = "3")]
    pub api_parent: ::prost::alloc::string::String,
    /// Optional. An optional namespace, underneath which to list namespaces. If
    /// not provided or empty, all top-level namespaces should be listed. If parent
    /// is a multipart namespace, the parts must be separated by the unit separator
    /// (`0x1F`) byte.
    /// Not a real parent, so ST_NOT_REQUIRED.
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
}
/// The response message for the `ListIcebergNamespaces` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListIcebergNamespacesResponse {
    /// The list of namespaces.
    #[prost(message, repeated, tag = "1")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost_types::ListValue>,
    /// The next page token for pagination.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The storage credential for a path in the table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageCredential {
    /// Indicates a storage location prefix where the credential is relevant.
    #[prost(string, tag = "1")]
    pub prefix: ::prost::alloc::string::String,
    /// The credentials for the storage location. The keys that are populated are:
    ///
    /// * `gcs.oauth2.token`
    /// * `gcs.oauth2.token_expires_at`
    /// * `expiration-time` (to support federation from Polaris).
    #[prost(map = "string, string", tag = "2")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// The response message for the `LoadCredentials` API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadIcebergTableCredentialsResponse {
    /// The credentials for the table assigned to the caller.
    #[prost(message, repeated, tag = "1")]
    pub storage_credentials: ::prost::alloc::vec::Vec<StorageCredential>,
}
/// Generated client implementations.
pub mod iceberg_catalog_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Iceberg Catalog Service API: this implements the open-source Iceberg REST
    /// Catalog API.
    /// See the API definition here:
    /// https://github.com/apache/iceberg/blob/main/open-api/rest-catalog-open-api.yaml
    ///
    /// The API is defined as OpenAPI 3.1.1 spec.
    ///
    /// Currently we only support the following methods:
    ///
    /// * GetConfig/GetIcebergCatalogConfig
    /// * ListIcebergNamespaces
    /// * CheckIcebergNamespaceExists
    /// * GetIcebergNamespace
    /// * CreateIcebergNamespace (only supports single level)
    /// * DeleteIcebergNamespace
    /// * UpdateIcebergNamespace properties
    /// * ListTableIdentifiers
    /// * CreateIcebergTable
    /// * DeleteIcebergTable
    /// * GetIcebergTable
    /// * UpdateIcebergTable (CommitTable)
    /// * LoadIcebergTableCredentials
    /// * RegisterTable
    ///
    /// Users are required to provided the `X-Goog-User-Project` header with the
    /// project id or number which can be different from the bucket project id.
    /// That project will be charged for the API calls and the calling user must have
    /// access to that project. The caller must have `serviceusage.services.use`
    /// permission on the project.
    #[derive(Debug, Clone)]
    pub struct IcebergCatalogServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IcebergCatalogServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IcebergCatalogServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IcebergCatalogServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IcebergCatalogServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// GetIcebergCatalogConfig lists all catalog configuration settings. Most
        /// importantly it contains the optional `endpoints` field which lists what
        /// methods this catalog supports, since we are not supporting all the methods
        /// right now.
        /// It returns all the methods defined in this service (subject to project
        /// config allowlisting).
        ///
        /// This is not a GCP resource.
        pub async fn get_iceberg_catalog_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergCatalogConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IcebergCatalogConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/GetIcebergCatalogConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "GetIcebergCatalogConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Iceberg namespaces in the catalog. We only support one level of
        /// nesting for namespaces.
        pub async fn list_iceberg_namespaces(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIcebergNamespacesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIcebergNamespacesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/ListIcebergNamespaces",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "ListIcebergNamespaces",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns 204 if the namespace exists, 404 otherwise.
        pub async fn check_iceberg_namespace_exists(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergNamespaceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/CheckIcebergNamespaceExists",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "CheckIcebergNamespaceExists",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an Iceberg namespace in the catalog (or checks if it exists, if the
        /// method is HEAD).
        pub async fn get_iceberg_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IcebergNamespace>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/GetIcebergNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "GetIcebergNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a namespace in the catalog.
        pub async fn create_iceberg_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIcebergNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IcebergNamespace>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/CreateIcebergNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "CreateIcebergNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns 204, not 200 on success.
        pub async fn delete_iceberg_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIcebergNamespaceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/DeleteIcebergNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "DeleteIcebergNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates namespace properties.
        pub async fn update_iceberg_namespace(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIcebergNamespaceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateIcebergNamespaceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/UpdateIcebergNamespace",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "UpdateIcebergNamespace",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists table identifiers (not *tables*) in the namespace.
        pub async fn list_iceberg_table_identifiers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIcebergTableIdentifiersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIcebergTableIdentifiersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/ListIcebergTableIdentifiers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "ListIcebergTableIdentifiers",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a table in the namespace.
        pub async fn create_iceberg_table(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIcebergTableRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/CreateIcebergTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "CreateIcebergTable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns 204 if the table exists, 404 otherwise. This is a `HEAD` HTTP
        /// method.
        pub async fn check_iceberg_table_exists(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergTableRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/CheckIcebergTableExists",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "CheckIcebergTableExists",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a table in the namespace.
        pub async fn delete_iceberg_table(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIcebergTableRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/DeleteIcebergTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "DeleteIcebergTable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a table in the namespace.
        pub async fn get_iceberg_table(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergTableRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/GetIcebergTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "GetIcebergTable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Loads credentials for a table in the namespace.
        pub async fn load_iceberg_table_credentials(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergTableRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LoadIcebergTableCredentialsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/LoadIcebergTableCredentials",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "LoadIcebergTableCredentials",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// This is CommitTable Iceberg API, which maps to `UpdateIcebergTable` in the
        /// Google API nomenclature.
        pub async fn update_iceberg_table(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIcebergTableRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/UpdateIcebergTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "UpdateIcebergTable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register a table using given metadata file location.
        pub async fn register_iceberg_table(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterIcebergTableRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::api::HttpBody>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/RegisterIcebergTable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "RegisterIcebergTable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the Iceberg REST Catalog configuration options.
        pub async fn get_iceberg_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIcebergCatalogRequest>,
        ) -> std::result::Result<tonic::Response<super::IcebergCatalog>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/GetIcebergCatalog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "GetIcebergCatalog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the Iceberg REST Catalogs.
        pub async fn list_iceberg_catalogs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListIcebergCatalogsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListIcebergCatalogsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/ListIcebergCatalogs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "ListIcebergCatalogs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the Iceberg REST Catalog.
        /// Delete does not delete a catalog that has contents -- at least one
        /// namespace.
        ///
        /// Delete is not supported for all catalog types.
        pub async fn delete_iceberg_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIcebergCatalogRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/DeleteIcebergCatalog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "DeleteIcebergCatalog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the Iceberg REST Catalog configuration options.
        pub async fn update_iceberg_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIcebergCatalogRequest>,
        ) -> std::result::Result<tonic::Response<super::IcebergCatalog>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/UpdateIcebergCatalog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "UpdateIcebergCatalog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates the Iceberg REST Catalog.
        /// Currently only supports Google Cloud Storage Bucket catalogs.
        /// Google Cloud Storage Bucket catalog id is the bucket for which the
        /// catalog is created (e.g. `my-catalog` for `gs://my-catalog`).
        ///
        /// If the bucket does not exist, of the caller does not have bucket metadata
        /// permissions, the catalog will not be created.
        pub async fn create_iceberg_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateIcebergCatalogRequest>,
        ) -> std::result::Result<tonic::Response<super::IcebergCatalog>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/CreateIcebergCatalog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "CreateIcebergCatalog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Failover the catalog to a new primary replica region.
        pub async fn failover_iceberg_catalog(
            &mut self,
            request: impl tonic::IntoRequest<super::FailoverIcebergCatalogRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FailoverIcebergCatalogResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.biglake.v1.IcebergCatalogService/FailoverIcebergCatalog",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.biglake.v1.IcebergCatalogService",
                        "FailoverIcebergCatalog",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
