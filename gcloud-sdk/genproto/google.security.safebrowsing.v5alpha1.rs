// This file is @generated by prost-build.
/// A request that the client issues to search for specific hash prefixes.
///
/// This is designed to only searches threat lists, and does not search
/// non-threat lists such as the Global Cache.
///
/// **What's new in V5**: Clients don't need to specify a `ClientInfo` or the
/// states of the hash lists in their local database. This is for improved
/// privacy. Furthermore, clients don't need to send which threat types they are
/// interested in.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchHashesRequest {
    /// Required. The hash prefixes to be looked up. Clients MUST NOT send more
    /// than 1000 hash prefixes. However, following the URL processing procedure,
    /// clients SHOULD NOT need to send more than 30 hash prefixes.
    ///
    /// Currently each hash prefix is required to be exactly 4 bytes long. This MAY
    /// be relaxed in the future.
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub hash_prefixes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Optional. If the client is interested in filtering, such as only retrieving
    /// specific kinds of threats, this can be specified. If omitted, all matching
    /// threats are returned. It is highly recommended to omit this to get the most
    /// complete protection Safe Browsing can offer.
    ///
    /// The filter is specified using Google Common Expression Language, which can
    /// be found at <https://github.com/google/cel-spec> along with general examples.
    /// Here are some specific examples that can be used here:
    ///
    /// The filter `"threat_type == ThreatType.SOCIAL_ENGINEERING"` requires that
    /// the within `FullHashDetail` the threat type must be `SOCIAL_ENGINEERING`.
    /// The identifier `"threat_type"` refers to the current threat
    /// type. The identifier `"ThreatType"` refers to the collection of all
    /// possible threat types.
    ///
    /// The filter `"threat_type in [ ThreatType.UNWANTED_SOFTWARE,
    /// ThreatType.MALWARE ]"` requires that the threat type must be either
    /// `UNWANTED_SOFTWARE` or `MALWARE`.
    #[prost(string, tag = "2")]
    pub filter: ::prost::alloc::string::String,
}
/// The response returned after searching threat hashes.
///
/// If nothing is found, the server will return an OK status (HTTP status code
/// 200) with the `full_hashes` field empty, rather than returning a NOT_FOUND
/// status (HTTP status code 404).
///
/// **What's new in V5**: There is a separation between `FullHash` and
/// `FullHashDetail`. In the case when a hash represents a site having multiple
/// threats (e.g. both MALWARE and SOCIAL_ENGINEERING), the full hash does not
/// need to be sent twice as in V4. Furthermore, the cache duration has been
/// simplified into a single `cache_duration` field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchHashesResponse {
    /// Unordered list. The unordered list of full hashes found.
    #[prost(message, repeated, tag = "1")]
    pub full_hashes: ::prost::alloc::vec::Vec<FullHash>,
    /// The client-side cache duration. The client MUST add this duration to the
    /// current time to determine the expiration time. The expiration time then
    /// applies to every hash prefix queried by the client in the request,
    /// regardless of how many full hashes are returned in the response. Even if
    /// the server returns no full hashes for a particular hash prefix, this fact
    /// MUST also be cached by the client.
    ///
    /// If and only if the field `full_hashes` is empty, the client MAY increase
    /// the `cache_duration` to determine a new expiration that is later than that
    /// specified by the server. In any case, the increased cache duration must not
    /// be longer than 24 hours.
    ///
    /// Important: the client MUST NOT assume that the server will return the same
    /// cache duration for all responses. The server MAY choose different cache
    /// durations for different responses depending on the situation.
    #[prost(message, optional, tag = "2")]
    pub cache_duration: ::core::option::Option<::prost_types::Duration>,
}
/// The full hash identified with one or more matches.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FullHash {
    /// The matching full hash. This is the SHA256 hash. The length will be exactly
    /// 32 bytes.
    #[prost(bytes = "vec", tag = "1")]
    pub full_hash: ::prost::alloc::vec::Vec<u8>,
    /// Unordered list. A repeated field identifying the details relevant to this
    /// full hash.
    #[prost(message, repeated, tag = "2")]
    pub full_hash_details: ::prost::alloc::vec::Vec<full_hash::FullHashDetail>,
}
/// Nested message and enum types in `FullHash`.
pub mod full_hash {
    /// Details about a matching full hash.
    ///
    /// An important note about forward compatibility: new threat types and threat
    /// attributes may be added by the server at any time; those additions are
    /// considered minor version changes. It is Google's policy not to expose minor
    /// version numbers in APIs (see
    /// <https://cloud.google.com/apis/design/versioning> for the versioning policy),
    /// so clients MUST be prepared to receive `FullHashDetail` messages containing
    /// `ThreatType` enum values or `ThreatAttribute` enum values that are
    /// considered invalid by the client. Therefore, it is the client's
    /// responsibility to check for the validity of all `ThreatType` and
    /// `ThreatAttribute` enum values; if any value is considered invalid, the
    /// client MUST disregard the entire `FullHashDetail` message.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FullHashDetail {
        /// The type of threat. This field will never be empty.
        #[prost(enumeration = "super::ThreatType", tag = "1")]
        pub threat_type: i32,
        /// Unordered list. Additional attributes about those full hashes. This may
        /// be empty.
        #[prost(
            enumeration = "super::ThreatAttribute",
            repeated,
            packed = "false",
            tag = "2"
        )]
        pub attributes: ::prost::alloc::vec::Vec<i32>,
    }
}
/// A request to obtain a hash list, which may be a threat list or a non-threat
/// list such as the Global Cache.
///
/// **What's new in V5**: What was previously called `states` in V4 is renamed to
/// `version` for clarity. Lists are now named, platform types and threat entry
/// types are removed. It is now possible for multiple lists to have the same
/// threat type, or a single list concerned with multiple threat types. In
/// contrast to V4's variable-length hash prefixes which has caused trouble in
/// many client implementations: all hashes in a list now have a single length,
/// permitting much more efficient client implementations. Constraints have been
/// simplified, and compression type is removed (compression is always applied).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHashListRequest {
    /// Required. The name of this particular hash list. It may be a threat list,
    /// or it may be the Global Cache.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the hash list that the client already has. If this is the
    /// first time the client is fetching the hash list, this field MUST be
    /// left empty. Otherwise, the client SHOULD supply the version previously
    /// received from the server. The client MUST NOT manipulate those bytes.
    ///
    /// **What's new in V5**: in V4 of the API, this was called `states`; it is now
    /// renamed to `version` for clarity.
    #[prost(bytes = "vec", tag = "2")]
    pub version: ::prost::alloc::vec::Vec<u8>,
    /// The size constraints on the list. If omitted, there are no
    /// constraints. Constraints are recommended on all devices with limited
    /// processing power, bandwidth, or storage.
    #[prost(message, optional, tag = "4")]
    pub size_constraints: ::core::option::Option<SizeConstraints>,
}
/// The constraints on the sizes of the hash lists.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeConstraints {
    /// The maximum size in number of entries. The update will not contain more
    /// entries than this value, but it is possible that the update will contain
    /// fewer entries than this value. This MUST be at least 1024. If omitted or
    /// zero, no update size limit is set.
    #[prost(int32, tag = "1")]
    pub max_update_entries: i32,
    /// Sets the maximum number of entries that the client is willing to have
    /// in the local database for the list. (The server MAY cause the client to
    /// store less than this number of entries.) If omitted or zero, no database
    /// size limit is set.
    #[prost(int32, tag = "2")]
    pub max_database_entries: i32,
}
/// The Rice-Golomb encoded data. Used for either hashes or
/// removal indices. It is guaranteed that every hash or index here has the same
/// length, and this length is exactly 32 bits.
///
/// Generally speaking, if we sort all the entries lexicographically, we will
/// find that the higher order bits tend not to change as frequently as lower
/// order bits. This means that if we also take the adjacent difference between
/// entries, the higher order bits have a high probability of being zero. This
/// exploits this high probability of zero by essentially choosing a certain
/// number of bits; all bits more significant than this are likely to be zero so
/// we use unary encoding. See the `rice_parameter` field.
///
/// Historical note: the Rice-delta encoding was first used in V4 of this API. In
/// V5, two significant improvements were made: firstly, the Rice-delta encoding
/// is now available with hash prefixes longer than 4 bytes; secondly, the
/// encoded data are now treated as big-endian so as to avoid a costly sorting
/// step.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiceDeltaEncoded32Bit {
    /// The first entry in the encoded data (hashes or indices), or, if only a
    /// single hash prefix or index was encoded, that entry's value. If the field
    /// is empty, the entry is zero.
    #[prost(uint32, tag = "1")]
    pub first_value: u32,
    /// The Golomb-Rice parameter. This parameter is guaranteed to be between 3 and
    /// 30, inclusive.
    #[prost(int32, tag = "2")]
    pub rice_parameter: i32,
    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    #[prost(int32, tag = "3")]
    pub entries_count: i32,
    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[prost(bytes = "vec", tag = "4")]
    pub encoded_data: ::prost::alloc::vec::Vec<u8>,
}
/// Same as `RiceDeltaEncoded32Bit` except this encodes 64-bit numbers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiceDeltaEncoded64Bit {
    /// The first entry in the encoded data (hashes), or, if only a single
    /// hash prefix was encoded, that entry's value. If the field is empty, the
    /// entry is zero.
    #[prost(uint64, tag = "1")]
    pub first_value: u64,
    /// The Golomb-Rice parameter. This parameter is guaranteed to be between 35
    /// and 62, inclusive.
    #[prost(int32, tag = "2")]
    pub rice_parameter: i32,
    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    #[prost(int32, tag = "3")]
    pub entries_count: i32,
    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[prost(bytes = "vec", tag = "4")]
    pub encoded_data: ::prost::alloc::vec::Vec<u8>,
}
/// Same as `RiceDeltaEncoded32Bit` except this encodes 128-bit numbers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiceDeltaEncoded128Bit {
    /// The upper 64 bits of the first entry in the encoded data (hashes). If the
    /// field is empty, the upper 64 bits are all zero.
    #[prost(uint64, tag = "1")]
    pub first_value_hi: u64,
    /// The lower 64 bits of the first entry in the encoded data (hashes). If the
    /// field is empty, the lower 64 bits are all zero.
    #[prost(fixed64, tag = "2")]
    pub first_value_lo: u64,
    /// The Golomb-Rice parameter. This parameter is guaranteed to be between 99
    /// and 126, inclusive.
    #[prost(int32, tag = "3")]
    pub rice_parameter: i32,
    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    #[prost(int32, tag = "4")]
    pub entries_count: i32,
    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[prost(bytes = "vec", tag = "5")]
    pub encoded_data: ::prost::alloc::vec::Vec<u8>,
}
/// Same as `RiceDeltaEncoded32Bit` except this encodes 256-bit numbers.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiceDeltaEncoded256Bit {
    /// The first 64 bits of the first entry in the encoded data (hashes). If the
    /// field is empty, the first 64 bits are all zero.
    #[prost(uint64, tag = "1")]
    pub first_value_first_part: u64,
    /// The 65 through 128th bits of the first entry in the encoded data (hashes).
    /// If the field is empty, the 65 through 128th bits are all zero.
    #[prost(fixed64, tag = "2")]
    pub first_value_second_part: u64,
    /// The 129 through 192th bits of the first entry in the encoded data (hashes).
    /// If the field is empty, the 129 through 192th bits are all zero.
    #[prost(fixed64, tag = "3")]
    pub first_value_third_part: u64,
    /// The last 64 bits of the first entry in the encoded data (hashes). If the
    /// field is empty, the last 64 bits are all zero.
    #[prost(fixed64, tag = "4")]
    pub first_value_fourth_part: u64,
    /// The Golomb-Rice parameter. This parameter is guaranteed to be between 227
    /// and 254, inclusive.
    #[prost(int32, tag = "5")]
    pub rice_parameter: i32,
    /// The number of entries that are delta encoded in the encoded data. If only a
    /// single integer was encoded, this will be zero and the single value will be
    /// stored in `first_value`.
    #[prost(int32, tag = "6")]
    pub entries_count: i32,
    /// The encoded deltas that are encoded using the Golomb-Rice coder.
    #[prost(bytes = "vec", tag = "7")]
    pub encoded_data: ::prost::alloc::vec::Vec<u8>,
}
/// Metadata about a particular hash list.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HashListMetadata {
    /// Unordered list. If not empty, this specifies that the hash list is a kind
    /// of threat list, and this enumerates the kind of threats associated with
    /// hashes or hash prefixes in this hash list. May be empty if the entry does
    /// not represent a threat, i.e. in the case that it represents a likely safe
    /// type.
    #[prost(enumeration = "ThreatType", repeated, packed = "false", tag = "1")]
    pub threat_types: ::prost::alloc::vec::Vec<i32>,
    /// Unordered list. If not empty, this specifies that the hash list represents
    /// a list of likely safe hashes, and this enumerates the ways they are
    /// considered likely safe. This field is mutually exclusive with the
    /// threat_types field.
    #[prost(enumeration = "LikelySafeType", repeated, packed = "false", tag = "2")]
    pub likely_safe_types: ::prost::alloc::vec::Vec<i32>,
    /// A human-readable description about this list. Written in English.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// The supported hash length for this hash list. Each hash list will support
    /// exactly one length. If a different hash length is introduced for the same
    /// set of threat types or safe types, it will be introduced as a separate list
    /// with a distinct name and respective hash length set.
    #[prost(enumeration = "hash_list_metadata::HashLength", tag = "6")]
    pub hash_length: i32,
}
/// Nested message and enum types in `HashListMetadata`.
pub mod hash_list_metadata {
    /// The length of hashes in a hash list.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HashLength {
        /// Unspecified length.
        Unspecified = 0,
        /// Each hash is a four-byte prefix.
        FourBytes = 2,
        /// Each hash is an eight-byte prefix.
        EightBytes = 3,
        /// Each hash is a sixteen-byte prefix.
        SixteenBytes = 4,
        /// Each hash is a thirty-two-byte full hash.
        ThirtyTwoBytes = 5,
    }
    impl HashLength {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HASH_LENGTH_UNSPECIFIED",
                Self::FourBytes => "FOUR_BYTES",
                Self::EightBytes => "EIGHT_BYTES",
                Self::SixteenBytes => "SIXTEEN_BYTES",
                Self::ThirtyTwoBytes => "THIRTY_TWO_BYTES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HASH_LENGTH_UNSPECIFIED" => Some(Self::Unspecified),
                "FOUR_BYTES" => Some(Self::FourBytes),
                "EIGHT_BYTES" => Some(Self::EightBytes),
                "SIXTEEN_BYTES" => Some(Self::SixteenBytes),
                "THIRTY_TWO_BYTES" => Some(Self::ThirtyTwoBytes),
                _ => None,
            }
        }
    }
}
/// A list of hashes identified by its name.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HashList {
    /// The name of the hash list. Note that the Global Cache is also just a hash
    /// list and can be referred to here.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The version of the hash list. The client MUST NOT manipulate those bytes.
    #[prost(bytes = "vec", tag = "2")]
    pub version: ::prost::alloc::vec::Vec<u8>,
    /// When true, this is a partial diff containing additions and removals
    /// based on what the client already has. When false, this is the complete
    /// hash list.
    ///
    /// When false, the client MUST delete any locally stored version for this
    /// hash list. This means that either the version possessed by the client is
    /// seriously out-of-date or the client data is believed to be corrupt. The
    /// `compressed_removals` field will be empty.
    ///
    /// When true, the client MUST apply an incremental update by applying
    /// removals and then additions.
    #[prost(bool, tag = "3")]
    pub partial_update: bool,
    /// The Rice-delta encoded version of removal indices. Since each hash list
    /// definitely has less than 2^32 entries, the indices are treated as 32-bit
    /// integers and encoded.
    #[prost(message, optional, tag = "5")]
    pub compressed_removals: ::core::option::Option<RiceDeltaEncoded32Bit>,
    /// Clients should wait at least this long to get the hash list again. If
    /// omitted or zero, clients SHOULD fetch immediately because it indicates that
    /// the server has an additional update to be sent to the client, but could not
    /// due to the client-specified constraints.
    #[prost(message, optional, tag = "6")]
    pub minimum_wait_duration: ::core::option::Option<::prost_types::Duration>,
    /// The sorted list of all hashes, hashed again with SHA256.
    /// This is the checksum for the sorted list of all hashes present in the
    /// database after applying the provided update. In the case that no updates
    /// were provided, the server will omit this field to indicate
    /// that the client should use the existing checksum.
    #[prost(bytes = "vec", tag = "7")]
    pub sha256_checksum: ::prost::alloc::vec::Vec<u8>,
    /// Metadata about the hash list. This is not populated by the `GetHashList`
    /// method, but this is populated by the
    /// `ListHashLists` method.
    #[prost(message, optional, tag = "8")]
    pub metadata: ::core::option::Option<HashListMetadata>,
    /// The Rice-delta encoded version of additions. The hash prefix lengths of
    /// additions are uniform across all additions in the list.
    #[prost(oneof = "hash_list::CompressedAdditions", tags = "4, 9, 10, 11")]
    pub compressed_additions: ::core::option::Option<hash_list::CompressedAdditions>,
}
/// Nested message and enum types in `HashList`.
pub mod hash_list {
    /// The Rice-delta encoded version of additions. The hash prefix lengths of
    /// additions are uniform across all additions in the list.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CompressedAdditions {
        /// The 4-byte additions.
        #[prost(message, tag = "4")]
        AdditionsFourBytes(super::RiceDeltaEncoded32Bit),
        /// The 8-byte additions.
        #[prost(message, tag = "9")]
        AdditionsEightBytes(super::RiceDeltaEncoded64Bit),
        /// The 16-byte additions.
        #[prost(message, tag = "10")]
        AdditionsSixteenBytes(super::RiceDeltaEncoded128Bit),
        /// The 32-byte additions.
        #[prost(message, tag = "11")]
        AdditionsThirtyTwoBytes(super::RiceDeltaEncoded256Bit),
    }
}
/// The request to get multiple hash lists at the same time.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetHashListsRequest {
    /// Required. The names of the particular hash lists. The list MAY be a threat
    /// list, or it may be the Global Cache. The names MUST NOT contain duplicates;
    /// if they did, the client will get an error.
    #[prost(string, repeated, tag = "1")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The versions of the hash list that the client already has. If this is the
    /// first time the client is fetching the hash lists, the field should be
    /// left empty. Otherwise, the client should supply the versions previously
    /// received from the server. The client MUST NOT manipulate those bytes.
    ///
    /// The client need not send the versions in the same order as the
    /// corresponding list names. The client may send fewer or more versions in a
    /// request than there are names. However the client MUST NOT send multiple
    /// versions that correspond to the same name; if it did, the client will get
    /// an error.
    ///
    /// Historical note: in V4 of the API, this was called
    /// `states`; it is now renamed to `version` for clarity.
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub version: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The size constraints on each list. If omitted, there are no
    /// constraints. Note that the sizes here are per-list, not aggregated across
    /// all lists.
    #[prost(message, optional, tag = "4")]
    pub size_constraints: ::core::option::Option<SizeConstraints>,
}
/// The response containing multiple hash lists.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetHashListsResponse {
    /// The hash lists in the same order given in the request.
    #[prost(message, repeated, tag = "1")]
    pub hash_lists: ::prost::alloc::vec::Vec<HashList>,
}
/// The request to list the available hash lists.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHashListsRequest {
    /// The maximum number of hash lists to return. The service may return fewer
    /// than this value. If unspecified, the server will choose a page size, which
    /// may be larger than the number of hash lists so that pagination is not
    /// necessary.
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    /// A page token, received from a previous `ListHashLists` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response containing metadata about hash lists.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHashListsResponse {
    /// The hash lists in an arbitrary order. Only metadata about the
    /// hash lists will be included, not the contents.
    #[prost(message, repeated, tag = "1")]
    pub hash_lists: ::prost::alloc::vec::Vec<HashList>,
    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Types of threats.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreatType {
    /// Unknown threat type. If this is returned by the server, the client shall
    /// disregard the enclosing `FullHashDetail` altogether.
    Unspecified = 0,
    /// Malware threat type. Malware is any software or mobile application
    /// specifically designed to harm a computer, a mobile device, the software
    /// it's running, or its users. Malware exhibits malicious behavior that can
    /// include installing software without user consent and installing harmful
    /// software such as viruses.
    ///
    /// More information can be found
    /// [here](<https://developers.google.com/search/docs/monitor-debug/security/malware>).
    Malware = 1,
    /// Social engineering threat type. Social engineering pages falsely purport to
    /// act on behalf of a third party with the intention of confusing viewers into
    /// performing an action with which the viewer would only trust a true agent of
    /// that third party. Phishing is a type of social engineering that tricks the
    /// viewer into performing the specific action of providing information, such
    /// as login credentials.
    ///
    /// More information can be found
    /// [here](<https://developers.google.com/search/docs/monitor-debug/security/social-engineering>).
    SocialEngineering = 2,
    /// Unwanted software threat type. Unwanted software is any software that does
    /// not adhere to [Google's Software
    /// Principles](<https://www.google.com/about/software-principles.html>) but
    /// isn't malware.
    UnwantedSoftware = 3,
    /// Potentially harmful application threat type [as used by Google Play Protect
    /// for the Play
    /// Store](<https://developers.google.com/android/play-protect/potentially-harmful-applications>).
    PotentiallyHarmfulApplication = 4,
}
impl ThreatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "THREAT_TYPE_UNSPECIFIED",
            Self::Malware => "MALWARE",
            Self::SocialEngineering => "SOCIAL_ENGINEERING",
            Self::UnwantedSoftware => "UNWANTED_SOFTWARE",
            Self::PotentiallyHarmfulApplication => "POTENTIALLY_HARMFUL_APPLICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THREAT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MALWARE" => Some(Self::Malware),
            "SOCIAL_ENGINEERING" => Some(Self::SocialEngineering),
            "UNWANTED_SOFTWARE" => Some(Self::UnwantedSoftware),
            "POTENTIALLY_HARMFUL_APPLICATION" => {
                Some(Self::PotentiallyHarmfulApplication)
            }
            _ => None,
        }
    }
}
/// Types of likely-safe sites.
///
/// Note that the `SearchHashesResponse` intentionally does not contain
/// `LikelySafeType`.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LikelySafeType {
    /// Unknown.
    Unspecified = 0,
    /// This site is likely safe enough for general browsing. This is also known as
    /// the global cache.
    GeneralBrowsing = 1,
    /// This site is likely safe enough that there is no need to run Client-Side
    /// Detection models or password protection checks.
    Csd = 2,
    /// This site is likely safe enough that downloads from the site need not be
    /// checked.
    Download = 3,
}
impl LikelySafeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LIKELY_SAFE_TYPE_UNSPECIFIED",
            Self::GeneralBrowsing => "GENERAL_BROWSING",
            Self::Csd => "CSD",
            Self::Download => "DOWNLOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIKELY_SAFE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "GENERAL_BROWSING" => Some(Self::GeneralBrowsing),
            "CSD" => Some(Self::Csd),
            "DOWNLOAD" => Some(Self::Download),
            _ => None,
        }
    }
}
/// Attributes of threats. These attributes may confer additional meaning to a
/// particular threat but will not affect the threat type. For example, an
/// attribute may specify a lower confidence while a different attribute may
/// specify higher confidence. More attributes may be added in the future.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ThreatAttribute {
    /// Unknown attribute. If this is returned by the server, the client shall
    /// disregard the enclosing `FullHashDetail` altogether.
    Unspecified = 0,
    /// Indicates that the threat_type should not be used for enforcement.
    Canary = 1,
    /// Indicates that the threat_type should only be used for enforcement on
    /// frames.
    FrameOnly = 2,
}
impl ThreatAttribute {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "THREAT_ATTRIBUTE_UNSPECIFIED",
            Self::Canary => "CANARY",
            Self::FrameOnly => "FRAME_ONLY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "THREAT_ATTRIBUTE_UNSPECIFIED" => Some(Self::Unspecified),
            "CANARY" => Some(Self::Canary),
            "FRAME_ONLY" => Some(Self::FrameOnly),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod safe_browsing_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Safe Browsing APIs enable clients to check web resources (most commonly
    /// URLs) against Google's constantly updated lists of unsafe web resources.
    #[derive(Debug, Clone)]
    pub struct SafeBrowsingClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl SafeBrowsingClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> SafeBrowsingClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SafeBrowsingClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            SafeBrowsingClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Search for full hashes matching the specified prefixes.
        ///
        /// This is a custom method as defined by https://google.aip.dev/136 (the
        /// custom method refers to this method having a custom name within Google's
        /// general API development nomenclature; it does not refer to using a custom
        /// HTTP method).
        pub async fn search_hashes(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchHashesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchHashesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.security.safebrowsing.v5alpha1.SafeBrowsing/SearchHashes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.security.safebrowsing.v5alpha1.SafeBrowsing",
                        "SearchHashes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the latest contents of a hash list. A hash list may either by a threat
        /// list or a non-threat list such as the Global Cache.
        ///
        /// This is a standard Get method as defined by https://google.aip.dev/131 and
        /// the HTTP method is also GET.
        pub async fn get_hash_list(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHashListRequest>,
        ) -> std::result::Result<tonic::Response<super::HashList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.security.safebrowsing.v5alpha1.SafeBrowsing/GetHashList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.security.safebrowsing.v5alpha1.SafeBrowsing",
                        "GetHashList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List hash lists.
        ///
        /// In the V5 API, Google will never remove a hash list that has ever been
        /// returned by this method. This enables clients to skip using this method and
        /// simply hard-code all hash lists they need.
        ///
        /// This is a standard List method as defined by https://google.aip.dev/132 and
        /// the HTTP method is GET.
        pub async fn list_hash_lists(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHashListsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListHashListsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.security.safebrowsing.v5alpha1.SafeBrowsing/ListHashLists",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.security.safebrowsing.v5alpha1.SafeBrowsing",
                        "ListHashLists",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get multiple hash lists at once.
        ///
        /// It is very common for a client to need to get multiple hash lists. Using
        /// this method is preferred over using the regular Get method multiple times.
        ///
        /// This is a standard batch Get method as defined by
        /// https://google.aip.dev/231 and the HTTP method is also GET.
        pub async fn batch_get_hash_lists(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetHashListsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetHashListsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.security.safebrowsing.v5alpha1.SafeBrowsing/BatchGetHashLists",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.security.safebrowsing.v5alpha1.SafeBrowsing",
                        "BatchGetHashLists",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
