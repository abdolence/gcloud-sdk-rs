// This file is @generated by prost-build.
/// Framework is a collection of CloudControls which represents
/// industry/GCP/Customer defined
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Framework {
    /// Required. Identifier. The name of the framework.
    /// Format:
    /// organizations/{organization}/locations/{location}/frameworks/{framework_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Major revision of the framework incremented in ascending
    /// order.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. Display name of the framework. The maximum length is 200
    /// characters.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the framework. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The type of the framework. The default is TYPE_CUSTOM.
    #[prost(enumeration = "framework::FrameworkType", tag = "6")]
    pub r#type: i32,
    /// Optional. The details of the cloud control groups included in the
    /// framework.
    #[prost(message, repeated, tag = "7")]
    pub cloud_control_group_details: ::prost::alloc::vec::Vec<
        framework::CloudControlGroupDetails,
    >,
    /// Optional. The details of the cloud controls directly added without any
    /// grouping in the framework.
    #[prost(message, repeated, tag = "8")]
    pub cloud_control_details: ::prost::alloc::vec::Vec<CloudControlDetails>,
    /// Optional. The category of the framework.
    #[prost(enumeration = "FrameworkCategory", repeated, packed = "false", tag = "9")]
    pub category: ::prost::alloc::vec::Vec<i32>,
    /// Output only. cloud providers supported
    #[prost(enumeration = "CloudProvider", repeated, packed = "false", tag = "10")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// Output only. target resource types supported by the Framework.
    #[prost(enumeration = "TargetResourceType", repeated, packed = "false", tag = "11")]
    pub supported_target_resource_types: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `Framework`.
pub mod framework {
    /// The details of the cloud control group included in the framework.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudControlGroupDetails {
        /// The inline definition will be replaced with a reference to the
        /// CloudControlGroup resource in future.
        #[prost(oneof = "cloud_control_group_details::Kind", tags = "1")]
        pub kind: ::core::option::Option<cloud_control_group_details::Kind>,
    }
    /// Nested message and enum types in `CloudControlGroupDetails`.
    pub mod cloud_control_group_details {
        /// The inline definition will be replaced with a reference to the
        /// CloudControlGroup resource in future.
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            /// The cloud control group included in the framework.
            #[prost(message, tag = "1")]
            CloudControlGroup(super::super::CloudControlGroup),
        }
    }
    /// The type of the framework.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameworkType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The framework is a built-in framework if it is created and managed by
        /// GCP.
        BuiltIn = 1,
        /// The framework is a custom framework if it is created and managed by the
        /// user.
        Custom = 2,
    }
    impl FrameworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FRAMEWORK_TYPE_UNSPECIFIED",
                Self::BuiltIn => "BUILT_IN",
                Self::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FRAMEWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BUILT_IN" => Some(Self::BuiltIn),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// CloudControlGroup is an optional entity within a Framework that helps
/// customers organize their CloudControls.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlGroup {
    /// Required. The name of the cloud control group in the format:
    /// “organizations/{organization}/locations/{location}/
    /// cloudControlGroups/{cloud-control-group}”
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The description of the cloud control group.The maximum length is
    /// 2000 characters.
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Output only. The type of the cloud control group. Default is
    /// TYPE_CUSTOM.
    #[prost(enumeration = "cloud_control_group::CloudControlGroupType", tag = "3")]
    pub r#type: i32,
    /// Optional. The control identifier used to fetch the findings. This is same
    /// as the control report name.
    #[prost(string, tag = "4")]
    pub control_id: ::prost::alloc::string::String,
    /// Required. The details of the cloud controls to be referred to in the
    /// framework.
    #[prost(message, repeated, tag = "5")]
    pub cloud_control_details: ::prost::alloc::vec::Vec<CloudControlDetails>,
    /// Optional. Major revision of the cloud control group.
    #[prost(int64, tag = "6")]
    pub major_revision_id: i64,
    /// Optional. The industry-defined Control assciated with the cloud controls in
    /// this group.
    /// organizations/{organization}/locations/{location}/controls/{control_id}
    #[prost(string, tag = "8")]
    pub control: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CloudControlGroup`.
pub mod cloud_control_group {
    /// CloudControlGroupType is the type of the CloudControlGroup.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CloudControlGroupType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The CloudControlGroup is a built-in group provided by GCP.
        BuiltIn = 1,
        /// The CloudControlGroup is a custom group created by the user.
        Custom = 2,
    }
    impl CloudControlGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLOUD_CONTROL_GROUP_TYPE_UNSPECIFIED",
                Self::BuiltIn => "BUILT_IN",
                Self::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLOUD_CONTROL_GROUP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BUILT_IN" => Some(Self::BuiltIn),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// CloudControlDetails contains the details of a CloudControl.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlDetails {
    /// Required. The name of the CloudControl in the format:
    /// “organizations/{organization}/locations/{location}/
    /// cloudControls/{cloud-control}”
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Major revision of cloudcontrol
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. Parameters is a key-value pair that is required by the
    /// CloudControl. The specification of these parameters will be present in
    /// cloudcontrol.Eg: { "name": "location","value": "us-west-1"}.
    #[prost(message, repeated, tag = "4")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
}
/// FrameworkReference contains the reference of a framework.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkReference {
    /// Required. In the format:
    /// organizations/{org}/locations/{location}/frameworks/{framework}
    #[prost(string, tag = "1")]
    pub framework: ::prost::alloc::string::String,
    /// Optional. Major revision id of the framework. If not specified, corresponds
    /// to the latest revision of the framework.
    #[prost(int64, optional, tag = "2")]
    pub major_revision_id: ::core::option::Option<i64>,
}
/// Parameters is a key-value pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
    /// Required. The name of the parameter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The value of the parameter
    #[prost(message, optional, boxed, tag = "2")]
    pub parameter_value: ::core::option::Option<::prost::alloc::boxed::Box<ParamValue>>,
}
/// A CloudControl is a GCP-provided parameterized concept which is used to
/// satisfy a Security or Compliance intent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControl {
    /// Required. Identifier. The resource name of the cloud control.
    /// Format:
    /// organizations/{organization}/locations/{location}/cloudControls/{cloud_control_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Major revision of the cloud control incremented in ascending
    /// order.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. A description of the cloud control. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The display name of the cloud control. The maximum length is 200
    /// characters.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The supported enforcement mode of the cloud control. Default
    /// is DETECTIVE.
    #[prost(enumeration = "EnforcementMode", repeated, packed = "false", tag = "7")]
    pub supported_enforcement_modes: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The parameter spec of the cloud control.
    #[prost(message, repeated, tag = "8")]
    pub parameter_spec: ::prost::alloc::vec::Vec<ParameterSpec>,
    /// Optional. The Policy to be enforced to prevent/detect resource
    /// non-compliance.
    #[prost(message, repeated, tag = "9")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    /// Optional. The severity of findings generated by the cloud control.
    #[prost(enumeration = "Severity", tag = "11")]
    pub severity: i32,
    /// Optional. The finding_category of the cloud control. The maximum length is
    /// 255 characters.
    #[prost(string, tag = "12")]
    pub finding_category: ::prost::alloc::string::String,
    /// Optional. cloud providers supported
    #[prost(enumeration = "CloudProvider", repeated, packed = "false", tag = "13")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The Frameworks that include this CloudControl
    #[prost(string, repeated, tag = "14")]
    pub related_frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The remediation steps for the findings generated by the cloud
    /// control. The maximum length is 400 characters.
    #[prost(string, tag = "15")]
    pub remediation_steps: ::prost::alloc::string::String,
    /// Optional. The categories of the cloud control.
    #[prost(
        enumeration = "CloudControlCategory",
        repeated,
        packed = "false",
        tag = "16"
    )]
    pub categories: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The last updated time of the cloud control.
    /// The create_time is used because a new CC is created whenever we update an
    /// existing CC.
    #[prost(message, optional, tag = "17")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. target resource types supported by the CloudControl.
    #[prost(enumeration = "TargetResourceType", repeated, packed = "false", tag = "18")]
    pub supported_target_resource_types: ::prost::alloc::vec::Vec<i32>,
}
/// A parameter spec of the cloud control.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterSpec {
    /// Required. The name of the parameter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The display name of the parameter. The maximum length is 200
    /// characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the parameter. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Required. if the parameter is required
    #[prost(bool, tag = "4")]
    pub is_required: bool,
    /// Required. Parameter value type.
    #[prost(enumeration = "parameter_spec::ValueType", tag = "5")]
    pub value_type: i32,
    /// Optional. The default value of the parameter.
    #[prost(message, optional, tag = "6")]
    pub default_value: ::core::option::Option<ParamValue>,
    /// Optional. List of parameter substitutions.
    #[prost(message, repeated, tag = "7")]
    pub substitution_rules: ::prost::alloc::vec::Vec<ParameterSubstitutionRule>,
    /// Optional. ParameterSpec for oneof attributes.
    #[prost(message, repeated, tag = "8")]
    pub sub_parameters: ::prost::alloc::vec::Vec<ParameterSpec>,
    /// Optional. The allowed set of values for the parameter.
    #[prost(message, optional, tag = "9")]
    pub validation: ::core::option::Option<Validation>,
}
/// Nested message and enum types in `ParameterSpec`.
pub mod parameter_spec {
    /// The type of the parameter value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// String value.
        String = 3,
        /// Boolean value.
        Boolean = 4,
        /// String list value.
        Stringlist = 5,
        /// Numeric value.
        Number = 6,
        /// OneOf value.
        Oneof = 7,
    }
    impl ValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VALUE_TYPE_UNSPECIFIED",
                Self::String => "STRING",
                Self::Boolean => "BOOLEAN",
                Self::Stringlist => "STRINGLIST",
                Self::Number => "NUMBER",
                Self::Oneof => "ONEOF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "BOOLEAN" => Some(Self::Boolean),
                "STRINGLIST" => Some(Self::Stringlist),
                "NUMBER" => Some(Self::Number),
                "ONEOF" => Some(Self::Oneof),
                _ => None,
            }
        }
    }
}
/// Validation of the parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validation {
    /// Defines validators for parameter values.
    #[prost(oneof = "validation::Constraint", tags = "1, 2, 3")]
    pub constraint: ::core::option::Option<validation::Constraint>,
}
/// Nested message and enum types in `Validation`.
pub mod validation {
    /// Defines validators for parameter values.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Constraint {
        /// Allowed set of values for the parameter.
        #[prost(message, tag = "1")]
        AllowedValues(super::AllowedValues),
        /// Allowed range for numeric parameters.
        #[prost(message, tag = "2")]
        IntRange(super::IntRange),
        /// Regular expression for string parameters.
        #[prost(message, tag = "3")]
        RegexpPattern(super::RegexpPattern),
    }
}
/// Allowed set of values for the parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedValues {
    /// Required. List of allowed values for the parameter.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<ParamValue>,
}
/// Regular Expression Validator for parameter values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegexpPattern {
    /// Required. Regex Pattern to match the value(s) of parameter.
    #[prost(string, tag = "1")]
    pub pattern: ::prost::alloc::string::String,
}
/// Number range for number parameters.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntRange {
    /// Required. Minimum allowed value for the numeric parameter (inclusive).
    #[prost(int64, tag = "1")]
    pub min: i64,
    /// Required. Maximum allowed value for the numeric parameter (inclusive).
    #[prost(int64, tag = "2")]
    pub max: i64,
}
/// A list of strings.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringList {
    /// Required. The strings in the list.
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Possible parameter value types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamValue {
    /// The kind of value.
    #[prost(oneof = "param_value::Kind", tags = "3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<param_value::Kind>,
}
/// Nested message and enum types in `ParamValue`.
pub mod param_value {
    /// The kind of value.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Represents a string value.
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        /// Represents a boolean value.
        #[prost(bool, tag = "4")]
        BoolValue(bool),
        /// Represents a repeated string.
        #[prost(message, tag = "5")]
        StringListValue(super::StringList),
        /// Represents a double value.
        #[prost(double, tag = "6")]
        NumberValue(f64),
        /// Represents sub-parameter values.
        #[prost(message, tag = "7")]
        OneofValue(::prost::alloc::boxed::Box<super::Parameter>),
    }
}
/// Parameter substitution rules.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParameterSubstitutionRule {
    /// The type of substitution.
    #[prost(oneof = "parameter_substitution_rule::SubstitutionType", tags = "1, 2")]
    pub substitution_type: ::core::option::Option<
        parameter_substitution_rule::SubstitutionType,
    >,
}
/// Nested message and enum types in `ParameterSubstitutionRule`.
pub mod parameter_substitution_rule {
    /// The type of substitution.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SubstitutionType {
        /// Placeholder substitution rule.
        #[prost(message, tag = "1")]
        PlaceholderSubstitutionRule(super::PlaceholderSubstitutionRule),
        /// Attribute substitution rule.
        #[prost(message, tag = "2")]
        AttributeSubstitutionRule(super::AttributeSubstitutionRule),
    }
}
/// Attribute at the given path is substituted entirely.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AttributeSubstitutionRule {
    /// Fully qualified proto attribute path (in dot notation).
    /// Example: rules\[0\].cel_expression.resource_types_values
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
}
/// Placeholder is substituted in the rendered string.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceholderSubstitutionRule {
    /// Fully qualified proto attribute path (e.g., dot notation)
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
}
/// A rule of the cloud control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rule {
    /// Optional. Description of the Rule. The maximum length is 2000 characters.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    /// Required. The functionality enabled by the Rule.
    #[prost(enumeration = "RuleActionType", repeated, packed = "false", tag = "16")]
    pub rule_action_types: ::prost::alloc::vec::Vec<i32>,
    /// The implementation of the rule.
    #[prost(oneof = "rule::Implementation", tags = "1")]
    pub implementation: ::core::option::Option<rule::Implementation>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    /// The implementation of the rule.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Implementation {
        /// Logic expression in CEL language.
        #[prost(message, tag = "1")]
        CelExpression(super::CelExpression),
    }
}
/// A [CEL
/// expression](<https://cloud.google.com/certificate-authority-service/docs/using-cel>).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CelExpression {
    /// Required. Logic expression in CEL language.
    /// The max length of the condition is 1000 characters.
    #[prost(string, tag = "1")]
    pub expression: ::prost::alloc::string::String,
    /// The criteria of the CEL expression.
    #[prost(oneof = "cel_expression::Criteria", tags = "3")]
    pub criteria: ::core::option::Option<cel_expression::Criteria>,
}
/// Nested message and enum types in `CELExpression`.
pub mod cel_expression {
    /// The criteria of the CEL expression.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Criteria {
        /// The resource instance types on which this expression is defined.
        /// Format will be of the form : `<canonical service name>/<type>`
        /// Example: `compute.googleapis.com/Instance`.
        #[prost(message, tag = "3")]
        ResourceTypesValues(super::StringList),
    }
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have \[Operation.error\]\[\] value with a
    /// \[google.rpc.Status.code\]\[google.rpc.Status.code\] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Represents a Regulatory control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Control {
    /// Output only. The name of a Control. Format:
    /// 'organizations/{organization}/locations/{location}/controls/{control}''
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. display_name
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The description of the control.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Output only. Group where the control belongs. E.g. Access Control.
    #[prost(enumeration = "control::Family", tag = "5")]
    pub family: i32,
    /// Output only. Regulatory Family of the control E.g. Access Control
    #[prost(message, optional, tag = "6")]
    pub control_family: ::core::option::Option<ControlFamily>,
    /// Output only. The control comes under whoose responsibility e.g. GOOGLE,
    /// CUSTOMER or SHARED.
    #[prost(enumeration = "RegulatoryControlResponsibilityType", tag = "7")]
    pub responsibility_type: i32,
    /// Output only. Google responsibility description of regulatory control.
    #[prost(string, tag = "8")]
    pub google_responsibility_description: ::prost::alloc::string::String,
    /// Output only. Google responsibility implementation of regulatory control.
    #[prost(string, tag = "9")]
    pub google_responsibility_implementation: ::prost::alloc::string::String,
    /// Output only. Customer responsibility description of regulatory control.
    #[prost(string, tag = "10")]
    pub customer_responsibility_description: ::prost::alloc::string::String,
    /// Output only. Customer responsibility implementation of regulatory control.
    #[prost(string, tag = "11")]
    pub customer_responsibility_implementation: ::prost::alloc::string::String,
    /// Output only. Description of shared Responsibility between Google and
    /// Customer in implementing this control
    #[prost(string, tag = "12")]
    pub shared_responsibility_description: ::prost::alloc::string::String,
    /// Output only. Link to the public documentation related to this control
    #[prost(string, tag = "13")]
    pub additional_content_uri: ::prost::alloc::string::String,
    /// Output only. The Frameworks that include this CloudControl
    #[prost(string, repeated, tag = "14")]
    pub related_frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Control`.
pub mod control {
    /// Family of the control. E.g. Access Control
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Family {
        /// Unspecified. Invalid state.
        Unspecified = 0,
        /// Access Control
        Ac = 1,
        /// Awareness and Training
        At = 2,
        /// Audit and Accountability
        Au = 3,
        /// Certification, Accreditation and Security Assessments
        Ca = 4,
        /// Configuration Management
        Cm = 5,
        /// Contingency Planning
        Cp = 6,
        /// Identification and Authentication
        Ia = 7,
        /// Incident Response
        Ir = 8,
        /// Maintenance
        Ma = 9,
        /// Media Protection
        Mp = 10,
        /// Physical and Environmental Protection
        Pe = 11,
        /// Security Planning
        Pl = 12,
        /// Personnel Security
        Ps = 13,
        /// Risk Assessment
        Ra = 14,
        /// System Services and Acquisition
        Sa = 15,
        /// System and Communications Protection
        Sc = 16,
        /// System and Information Integrity
        Si = 17,
        /// Supply Chain Risk Management
        Sr = 18,
    }
    impl Family {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FAMILY_UNSPECIFIED",
                Self::Ac => "AC",
                Self::At => "AT",
                Self::Au => "AU",
                Self::Ca => "CA",
                Self::Cm => "CM",
                Self::Cp => "CP",
                Self::Ia => "IA",
                Self::Ir => "IR",
                Self::Ma => "MA",
                Self::Mp => "MP",
                Self::Pe => "PE",
                Self::Pl => "PL",
                Self::Ps => "PS",
                Self::Ra => "RA",
                Self::Sa => "SA",
                Self::Sc => "SC",
                Self::Si => "SI",
                Self::Sr => "SR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAMILY_UNSPECIFIED" => Some(Self::Unspecified),
                "AC" => Some(Self::Ac),
                "AT" => Some(Self::At),
                "AU" => Some(Self::Au),
                "CA" => Some(Self::Ca),
                "CM" => Some(Self::Cm),
                "CP" => Some(Self::Cp),
                "IA" => Some(Self::Ia),
                "IR" => Some(Self::Ir),
                "MA" => Some(Self::Ma),
                "MP" => Some(Self::Mp),
                "PE" => Some(Self::Pe),
                "PL" => Some(Self::Pl),
                "PS" => Some(Self::Ps),
                "RA" => Some(Self::Ra),
                "SA" => Some(Self::Sa),
                "SC" => Some(Self::Sc),
                "SI" => Some(Self::Si),
                "SR" => Some(Self::Sr),
                _ => None,
            }
        }
    }
}
/// Regulatory Family of the control
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlFamily {
    /// ID of the regulatory control family.
    #[prost(string, tag = "1")]
    pub family_id: ::prost::alloc::string::String,
    /// Display name of the regulatory control family.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// Regulatory Control Responsibility Type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RegulatoryControlResponsibilityType {
    /// Unspecified. Invalid state.
    Unspecified = 0,
    /// Google responsibility.
    Google = 1,
    /// Customer responsibility.
    Customer = 2,
    /// Shared responsibility.
    Shared = 3,
}
impl RegulatoryControlResponsibilityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REGULATORY_CONTROL_RESPONSIBILITY_TYPE_UNSPECIFIED",
            Self::Google => "GOOGLE",
            Self::Customer => "CUSTOMER",
            Self::Shared => "SHARED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGULATORY_CONTROL_RESPONSIBILITY_TYPE_UNSPECIFIED" => {
                Some(Self::Unspecified)
            }
            "GOOGLE" => Some(Self::Google),
            "CUSTOMER" => Some(Self::Customer),
            "SHARED" => Some(Self::Shared),
            _ => None,
        }
    }
}
/// The enforcement mode of the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnforcementMode {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The cloud control is enforced to prevent resource non-compliance.
    Preventive = 1,
    /// The cloud control is enforced to detect resource non-compliance.
    Detective = 2,
    /// The cloud control is enforced to audit resource non-compliance.
    Audit = 3,
}
impl EnforcementMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENFORCEMENT_MODE_UNSPECIFIED",
            Self::Preventive => "PREVENTIVE",
            Self::Detective => "DETECTIVE",
            Self::Audit => "AUDIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENFORCEMENT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "PREVENTIVE" => Some(Self::Preventive),
            "DETECTIVE" => Some(Self::Detective),
            "AUDIT" => Some(Self::Audit),
            _ => None,
        }
    }
}
/// The category of the framework.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameworkCategory {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Standard framework
    IndustryDefinedStandard = 1,
    /// Assured Workloads framework
    AssuredWorkloads = 2,
    /// Data Security framework
    DataSecurity = 3,
    /// Google Best Practices framework
    GoogleBestPractices = 4,
    /// User created framework.
    CustomFramework = 5,
}
impl FrameworkCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FRAMEWORK_CATEGORY_UNSPECIFIED",
            Self::IndustryDefinedStandard => "INDUSTRY_DEFINED_STANDARD",
            Self::AssuredWorkloads => "ASSURED_WORKLOADS",
            Self::DataSecurity => "DATA_SECURITY",
            Self::GoogleBestPractices => "GOOGLE_BEST_PRACTICES",
            Self::CustomFramework => "CUSTOM_FRAMEWORK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAMEWORK_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "INDUSTRY_DEFINED_STANDARD" => Some(Self::IndustryDefinedStandard),
            "ASSURED_WORKLOADS" => Some(Self::AssuredWorkloads),
            "DATA_SECURITY" => Some(Self::DataSecurity),
            "GOOGLE_BEST_PRACTICES" => Some(Self::GoogleBestPractices),
            "CUSTOM_FRAMEWORK" => Some(Self::CustomFramework),
            _ => None,
        }
    }
}
/// The category of the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudControlCategory {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Infrastructure
    CcCategoryInfrastructure = 1,
    /// Artificial Intelligence
    CcCategoryArtificialIntelligence = 2,
    /// Physical Security
    CcCategoryPhysicalSecurity = 3,
    /// Data Security
    CcCategoryDataSecurity = 4,
    /// Network Security
    CcCategoryNetworkSecurity = 5,
    /// Incident Management
    CcCategoryIncidentManagement = 6,
    /// Identity & Access Management
    CcCategoryIdentityAndAccessManagement = 7,
    /// Encryption
    CcCategoryEncryption = 8,
    /// Logs Management & Infrastructure
    CcCategoryLogsManagementAndInfrastructure = 9,
    /// HR, Admin & Processes
    CcCategoryHrAdminAndProcesses = 10,
    /// Third Party & Sub-Processor Management
    CcCategoryThirdPartyAndSubProcessorManagement = 11,
    /// Legal & Disclosures
    CcCategoryLegalAndDisclosures = 12,
    /// Vulnerability Management
    CcCategoryVulnerabilityManagement = 13,
    /// Privacy
    CcCategoryPrivacy = 14,
    /// BCDR (Business Continuity and Disaster Recovery)
    CcCategoryBcdr = 15,
}
impl CloudControlCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_CONTROL_CATEGORY_UNSPECIFIED",
            Self::CcCategoryInfrastructure => "CC_CATEGORY_INFRASTRUCTURE",
            Self::CcCategoryArtificialIntelligence => {
                "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE"
            }
            Self::CcCategoryPhysicalSecurity => "CC_CATEGORY_PHYSICAL_SECURITY",
            Self::CcCategoryDataSecurity => "CC_CATEGORY_DATA_SECURITY",
            Self::CcCategoryNetworkSecurity => "CC_CATEGORY_NETWORK_SECURITY",
            Self::CcCategoryIncidentManagement => "CC_CATEGORY_INCIDENT_MANAGEMENT",
            Self::CcCategoryIdentityAndAccessManagement => {
                "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT"
            }
            Self::CcCategoryEncryption => "CC_CATEGORY_ENCRYPTION",
            Self::CcCategoryLogsManagementAndInfrastructure => {
                "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE"
            }
            Self::CcCategoryHrAdminAndProcesses => "CC_CATEGORY_HR_ADMIN_AND_PROCESSES",
            Self::CcCategoryThirdPartyAndSubProcessorManagement => {
                "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT"
            }
            Self::CcCategoryLegalAndDisclosures => "CC_CATEGORY_LEGAL_AND_DISCLOSURES",
            Self::CcCategoryVulnerabilityManagement => {
                "CC_CATEGORY_VULNERABILITY_MANAGEMENT"
            }
            Self::CcCategoryPrivacy => "CC_CATEGORY_PRIVACY",
            Self::CcCategoryBcdr => "CC_CATEGORY_BCDR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_CONTROL_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "CC_CATEGORY_INFRASTRUCTURE" => Some(Self::CcCategoryInfrastructure),
            "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE" => {
                Some(Self::CcCategoryArtificialIntelligence)
            }
            "CC_CATEGORY_PHYSICAL_SECURITY" => Some(Self::CcCategoryPhysicalSecurity),
            "CC_CATEGORY_DATA_SECURITY" => Some(Self::CcCategoryDataSecurity),
            "CC_CATEGORY_NETWORK_SECURITY" => Some(Self::CcCategoryNetworkSecurity),
            "CC_CATEGORY_INCIDENT_MANAGEMENT" => Some(Self::CcCategoryIncidentManagement),
            "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT" => {
                Some(Self::CcCategoryIdentityAndAccessManagement)
            }
            "CC_CATEGORY_ENCRYPTION" => Some(Self::CcCategoryEncryption),
            "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE" => {
                Some(Self::CcCategoryLogsManagementAndInfrastructure)
            }
            "CC_CATEGORY_HR_ADMIN_AND_PROCESSES" => {
                Some(Self::CcCategoryHrAdminAndProcesses)
            }
            "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT" => {
                Some(Self::CcCategoryThirdPartyAndSubProcessorManagement)
            }
            "CC_CATEGORY_LEGAL_AND_DISCLOSURES" => {
                Some(Self::CcCategoryLegalAndDisclosures)
            }
            "CC_CATEGORY_VULNERABILITY_MANAGEMENT" => {
                Some(Self::CcCategoryVulnerabilityManagement)
            }
            "CC_CATEGORY_PRIVACY" => Some(Self::CcCategoryPrivacy),
            "CC_CATEGORY_BCDR" => Some(Self::CcCategoryBcdr),
            _ => None,
        }
    }
}
/// The cloud platform.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudProvider {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Amazon Web Services (AWS).
    Aws = 1,
    /// Microsoft Azure.
    Azure = 2,
    /// Google Cloud.
    Gcp = 3,
}
impl CloudProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_PROVIDER_UNSPECIFIED",
            Self::Aws => "AWS",
            Self::Azure => "AZURE",
            Self::Gcp => "GCP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "AWS" => Some(Self::Aws),
            "AZURE" => Some(Self::Azure),
            "GCP" => Some(Self::Gcp),
            _ => None,
        }
    }
}
/// The severity of the finding.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// This value is used for findings when a source doesn't write a severity
    /// value.
    Unspecified = 0,
    /// Vulnerability:
    /// A critical vulnerability is easily discoverable by an external actor,
    /// exploitable, and results in the direct ability to execute arbitrary code,
    /// exfiltrate data, and otherwise gain additional access and privileges to
    /// cloud resources and workloads. Examples include publicly accessible
    /// unprotected user data and public SSH access with weak or no
    /// passwords.
    ///
    /// Threat:
    /// Indicates a threat that is able to access, modify, or delete data or
    /// execute unauthorized code within existing resources.
    Critical = 1,
    /// Vulnerability:
    /// A high risk vulnerability can be easily discovered and exploited in
    /// combination with other vulnerabilities in order to gain direct access and
    /// the ability to execute arbitrary code, exfiltrate data, and otherwise
    /// gain additional access and privileges to cloud resources and workloads.
    /// An example is a database with weak or no passwords that is only
    /// accessible internally. This database could easily be compromised by an
    /// actor that had access to the internal network.
    ///
    /// Threat:
    /// Indicates a threat that is able to create new computational resources in
    /// an environment but not able to access data or execute code in existing
    /// resources.
    High = 2,
    /// Vulnerability:
    /// A medium risk vulnerability could be used by an actor to gain access to
    /// resources or privileges that enable them to eventually (through multiple
    /// steps or a complex exploit) gain access and the ability to execute
    /// arbitrary code or exfiltrate data. An example is a service account with
    /// access to more projects than it should have. If an actor gains access to
    /// the service account, they could potentially use that access to manipulate
    /// a project the service account was not intended to.
    ///
    /// Threat:
    /// Indicates a threat that is able to cause operational impact but may not
    /// access data or execute unauthorized code.
    Medium = 3,
    /// Vulnerability:
    /// A low risk vulnerability hampers a security organization's ability to
    /// detect vulnerabilities or active threats in their deployment, or prevents
    /// the root cause investigation of security issues. An example is monitoring
    /// and logs being disabled for resource configurations and access.
    ///
    /// Threat:
    /// Indicates a threat that has obtained minimal access to an environment but
    /// is not able to access data, execute code, or create resources.
    Low = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Critical => "CRITICAL",
            Self::High => "HIGH",
            Self::Medium => "MEDIUM",
            Self::Low => "LOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "CRITICAL" => Some(Self::Critical),
            "HIGH" => Some(Self::High),
            "MEDIUM" => Some(Self::Medium),
            "LOW" => Some(Self::Low),
            _ => None,
        }
    }
}
/// The action type of the rule.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RuleActionType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Preventative action type.
    Preventive = 1,
    /// Detective action type.
    Detective = 2,
    /// Audit action type.
    Audit = 3,
}
impl RuleActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RULE_ACTION_TYPE_UNSPECIFIED",
            Self::Preventive => "RULE_ACTION_TYPE_PREVENTIVE",
            Self::Detective => "RULE_ACTION_TYPE_DETECTIVE",
            Self::Audit => "RULE_ACTION_TYPE_AUDIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RULE_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RULE_ACTION_TYPE_PREVENTIVE" => Some(Self::Preventive),
            "RULE_ACTION_TYPE_DETECTIVE" => Some(Self::Detective),
            "RULE_ACTION_TYPE_AUDIT" => Some(Self::Audit),
            _ => None,
        }
    }
}
/// TargetResourceType represents the type of resource that a control or
/// framework can be applied to.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TargetResourceType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Target resource is an Organization.
    TargetResourceCrmTypeOrg = 1,
    /// Target resource is a Folder.
    TargetResourceCrmTypeFolder = 2,
    /// Target resource is a Project.
    TargetResourceCrmTypeProject = 3,
    /// Target resource is an Application.
    Application = 4,
}
impl TargetResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TARGET_RESOURCE_TYPE_UNSPECIFIED",
            Self::TargetResourceCrmTypeOrg => "TARGET_RESOURCE_CRM_TYPE_ORG",
            Self::TargetResourceCrmTypeFolder => "TARGET_RESOURCE_CRM_TYPE_FOLDER",
            Self::TargetResourceCrmTypeProject => "TARGET_RESOURCE_CRM_TYPE_PROJECT",
            Self::Application => "TARGET_RESOURCE_TYPE_APPLICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TARGET_RESOURCE_CRM_TYPE_ORG" => Some(Self::TargetResourceCrmTypeOrg),
            "TARGET_RESOURCE_CRM_TYPE_FOLDER" => Some(Self::TargetResourceCrmTypeFolder),
            "TARGET_RESOURCE_CRM_TYPE_PROJECT" => {
                Some(Self::TargetResourceCrmTypeProject)
            }
            "TARGET_RESOURCE_TYPE_APPLICATION" => Some(Self::Application),
            _ => None,
        }
    }
}
/// Request message for \[ListFrameworks\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworksRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of frameworks to return. The default value is
    /// `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A pagination token returned from a previous request to list
    /// frameworks. Provide this token to retrieve the next page of results.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for \[ListFrameworks\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworksResponse {
    /// The list of \[Framework\]\[google.cloud.cloudsecuritycompliance.v1.Framework\]
    /// resources.
    #[prost(message, repeated, tag = "1")]
    pub frameworks: ::prost::alloc::vec::Vec<Framework>,
    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Message for getting a Framework.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkRequest {
    /// Required. The name of the framework to retrieve.
    /// Format:
    /// organizations/{organization}/locations/{location}/frameworks/{framework_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The Framework major revision to retrieve. If not specified, the
    /// most recently updated revision_id is retrieved.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
}
/// Message for creating a Framework
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the framework.
    /// This is not the full name of the framework.
    /// This is the last part of the full name of the framework.
    #[prost(string, tag = "2")]
    pub framework_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub framework: ::core::option::Option<Framework>,
}
/// Message for updating a Framework
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFrameworkRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Framework resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub framework: ::core::option::Option<Framework>,
    /// Optional. The major revision ID of the framework to update.
    #[prost(int64, tag = "3")]
    pub major_revision_id: i64,
}
/// Message for deleting a Framework
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFrameworkRequest {
    /// Required. Name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/frameworks/{framework}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for \[ListCloudControls\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudControlsRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of CloudControls to return. The default value
    /// is `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A pagination token returned from a previous request to list
    /// CloudControls. Provide this token to retrieve the next page of results.
    ///
    /// When paginating, parent provided to
    /// ListCloudControls request must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for ListCloudControls.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudControlsResponse {
    /// The list of CloudControl resources.
    #[prost(message, repeated, tag = "1")]
    pub cloud_controls: ::prost::alloc::vec::Vec<CloudControl>,
    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Message for getting a CloudControl.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudControlRequest {
    /// Required. The name of the cloudcontrol to retrieve in the format:
    /// organizations/{organization}/locations/{location}/cloudControls/{cloud_control}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a CloudControl
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudControlRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the CloudControl.
    /// This is the last segment of the CloudControl resource name.
    /// Format: `^[a-zA-Z][a-zA-Z0-9-]{0,61}\[a-zA-Z0-9\]$`.
    #[prost(string, tag = "2")]
    pub cloud_control_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub cloud_control: ::core::option::Option<CloudControl>,
}
/// Message for updating a CloudControl.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCloudControlRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// CloudControl resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten. The fields that can be updated are:
    ///
    /// 1. Display_name
    /// 1. Description
    /// 1. Parameters
    /// 1. Rules
    /// 1. ParameterSpec.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub cloud_control: ::core::option::Option<CloudControl>,
}
/// Message for deleting a CloudControl.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCloudControlRequest {
    /// Required. Name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/CloudControls/{CloudControl}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod config_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for config resources
    #[derive(Debug, Clone)]
    pub struct ConfigClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConfigClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConfigClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConfigClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConfigClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists Frameworks in a given organization.
        pub async fn list_frameworks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/ListFrameworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "ListFrameworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Framework.
        pub async fn get_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/GetFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "GetFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a single framework for a given resource.
        pub async fn create_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/CreateFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "CreateFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single Framework.
        pub async fn update_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/UpdateFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "UpdateFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Framework.
        pub async fn delete_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/DeleteFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "DeleteFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CloudControls in a given organization.
        pub async fn list_cloud_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudControlsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudControlsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/ListCloudControls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "ListCloudControls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single CloudControl.
        pub async fn get_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/GetCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "GetCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a single CloudControl for a given resource.
        pub async fn create_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/CreateCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "CreateCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single CloudControl.
        pub async fn update_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/UpdateCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "UpdateCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single CloudControl.
        pub async fn delete_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/DeleteCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "DeleteCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// FrameworkDeployment is a resource that represents a deployment using a
/// framework.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkDeployment {
    /// Identifier. FrameworkDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. target_resource_config referencing either an already existing
    /// target_resource or contains config for a target_resource to be created
    #[prost(message, optional, tag = "2")]
    pub target_resource_config: ::core::option::Option<TargetResourceConfig>,
    /// Output only. The resource on which the Framework is deployed based on the
    /// provided TargetResourceConfig. In format organizations/{organization},
    /// folders/{folder}, projects/{project} or
    /// projects/{project}/locations/{location}/applications/{application}.
    #[prost(string, tag = "3")]
    pub computed_target_resource: ::prost::alloc::string::String,
    /// Required. Framework resource reference
    #[prost(message, optional, tag = "4")]
    pub framework: ::core::option::Option<FrameworkReference>,
    /// Optional. User provided description of the deployment
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Required. Deployment mode and parameters for each of the cloud_controls
    /// part of the framework.
    #[prost(message, repeated, tag = "6")]
    pub cloud_control_metadata: ::prost::alloc::vec::Vec<CloudControlMetadata>,
    /// Output only. State of the deployment
    #[prost(enumeration = "DeploymentState", tag = "7")]
    pub deployment_state: i32,
    /// Output only. This field is inlined just for cloudNext because the one
    /// platform apis of CCDeployment does not exist. Beyond cloud
    /// next it will be replaced with the field below which is the
    /// references of cloud control deployment
    #[deprecated]
    #[prost(message, repeated, tag = "8")]
    pub cc_deployments: ::prost::alloc::vec::Vec<CloudControlDeployment>,
    /// Output only. The time at which the resource was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the resource last updated.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a CustomComplianceFramework. You can
    /// also provide the `etag` when you delete a CustomComplianceFramework, to
    /// help ensure that you're deleting the intended version of the
    /// CustomComplianceFramework.
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. Similarly we'll also have a field for CloudControlGroups
    #[prost(message, repeated, tag = "12")]
    pub cc_group_deployments: ::prost::alloc::vec::Vec<CloudControlGroupDeployment>,
    /// Output only. The display name of the target resource.
    #[prost(string, tag = "13")]
    pub target_resource_display_name: ::prost::alloc::string::String,
    /// Output only. The references to the cloud control deployments.
    /// Example: If a framework deployment deploys two cloud controls,
    /// cc-deployment-1 and cc-deployment-2, then the
    /// cloud_control_deployment_references will be:
    /// {
    /// cloud_control_deployment_reference: {
    /// cloud_control_deployment:
    /// "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-1"
    /// },
    /// cloud_control_deployment_reference: {
    /// cloud_control_deployment:
    /// "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-2"
    /// }
    #[prost(message, repeated, tag = "14")]
    pub cloud_control_deployment_references: ::prost::alloc::vec::Vec<
        CloudControlDeploymentReference,
    >,
}
/// CloudControlDeployment is a resource that represents a deployment using a
/// cloud control.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlDeployment {
    /// Identifier. CloudControlDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. target_resource_config referencing either an already existing
    /// target_resource or contains config for a target_resource to be created
    #[prost(message, optional, tag = "2")]
    pub target_resource_config: ::core::option::Option<TargetResourceConfig>,
    /// Output only. The resource on which the CloudControl is deployed based on
    /// the provided TargetResourceConfig. In format organizations/{organization},
    /// folders/{folder} or projects/{project}.
    #[prost(string, tag = "3")]
    pub target_resource: ::prost::alloc::string::String,
    /// Required. CloudControlReference, Deployment mode and parameters for the
    /// cloud_control
    #[prost(message, optional, tag = "4")]
    pub cloud_control_metadata: ::core::option::Option<CloudControlMetadata>,
    /// Optional. User provided description of the deployment
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. State of the deployment
    #[prost(enumeration = "DeploymentState", tag = "6")]
    pub deployment_state: i32,
    /// Output only. The time at which the resource was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the resource last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a CustomComplianceCloudControl. You can
    /// also provide the `etag` when you delete a CustomComplianceCloudControl, to
    /// help ensure that you're deleting the intended version of the
    /// CustomComplianceCloudControl.
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The cloud control after parameter substitution.
    #[prost(message, optional, tag = "10")]
    pub parameter_substituted_cloud_control: ::core::option::Option<CloudControl>,
    /// Output only. The references to the framework deployments that this cloud
    /// control deployment is part of.
    #[prost(message, repeated, tag = "11")]
    pub framework_deployment_references: ::prost::alloc::vec::Vec<
        FrameworkDeploymentReference,
    >,
    /// Output only. The name of the application, project, folder, or organization
    /// that the cloud control is deployed on.
    #[prost(string, tag = "12")]
    pub target_resource_display_name: ::prost::alloc::string::String,
}
/// TargetResourceConfig contains either the name of the target_resource or
/// contains the config to create a new target_resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceConfig {
    /// Resource config for the target_resource
    #[prost(oneof = "target_resource_config::ResourceConfig", tags = "1, 2")]
    pub resource_config: ::core::option::Option<target_resource_config::ResourceConfig>,
}
/// Nested message and enum types in `TargetResourceConfig`.
pub mod target_resource_config {
    /// Resource config for the target_resource
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ResourceConfig {
        /// Optional. CRM node in format organizations/{organization},
        /// folders/{folder}, projects/{project} or
        /// projects/{project}/locations/{location}/applications/{application}.
        #[prost(string, tag = "1")]
        ExistingTargetResource(::prost::alloc::string::String),
        /// Optional. Config to create a new resource and use that as the
        /// target_resource for deployment
        #[prost(message, tag = "2")]
        TargetResourceCreationConfig(super::TargetResourceCreationConfig),
    }
}
/// TargetResourceCreationConfig contains the config to create a new resource
/// and use that as the target_resource for deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceCreationConfig {
    /// Resource creation config for the target_resource
    #[prost(
        oneof = "target_resource_creation_config::ResourceCreationConfig",
        tags = "1, 2"
    )]
    pub resource_creation_config: ::core::option::Option<
        target_resource_creation_config::ResourceCreationConfig,
    >,
}
/// Nested message and enum types in `TargetResourceCreationConfig`.
pub mod target_resource_creation_config {
    /// Resource creation config for the target_resource
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ResourceCreationConfig {
        /// Optional. Config to create a new folder
        #[prost(message, tag = "1")]
        FolderCreationConfig(super::FolderCreationConfig),
        /// Optional. Config to create a new project
        #[prost(message, tag = "2")]
        ProjectCreationConfig(super::ProjectCreationConfig),
    }
}
/// FolderCreationConfig contains the config to create a new folder.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FolderCreationConfig {
    /// Required. organizations/{org} or folders/{folder}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Display name of the folder to be created
    #[prost(string, tag = "2")]
    pub folder_display_name: ::prost::alloc::string::String,
}
/// ProjectCreationConfig contains the config to create a new project.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProjectCreationConfig {
    /// Required. organizations/{org} or folders/{folder}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Display name of the project to be created
    #[prost(string, tag = "2")]
    pub project_display_name: ::prost::alloc::string::String,
    /// Required. Billing account id to be used for the project
    #[prost(string, tag = "3")]
    pub billing_account_id: ::prost::alloc::string::String,
}
/// CloudControlMetadata contains the metadata for each of the cloud controls
/// part of the framework.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlMetadata {
    /// Required. Cloud control details
    #[prost(message, optional, tag = "1")]
    pub cloud_control_details: ::core::option::Option<CloudControlDetails>,
    /// Required. Enforcement mode of the cloud control
    #[prost(enumeration = "EnforcementMode", tag = "2")]
    pub enforcement_mode: i32,
}
/// CloudControlGroupDeployment contains the cloud control group and the cloud
/// control deployments in the group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlGroupDeployment {
    /// Required. Cloud control group
    #[prost(message, optional, tag = "1")]
    pub cloud_control_group: ::core::option::Option<CloudControlGroup>,
    /// Required. Cloud control deployments in the group
    #[deprecated]
    #[prost(message, repeated, tag = "2")]
    pub cc_deployments: ::prost::alloc::vec::Vec<CloudControlDeployment>,
    /// Output only. The references to the cloud control deployments in the cloud
    /// control group. For example, if a cloud control group has two cloud
    /// controls, `cloud-control-1` and `cloud-control-2`, and the cloud control
    /// deployments for these cloud controls are `cloud-control-deployment-1` and
    /// `cloud-control-deployment-2` respectively, then the
    /// references are:
    ///
    /// ```text,
    /// cloud_control_deployment_reference: {
    ///    cloud_control_deployment:
    ///    "organizations/{organization}/locations/{location}/cloudControlDeployments/cloud-control-deployment-1"
    /// },
    /// cloud_control_deployment_reference: {
    ///   cloud_control_deployment:
    ///   "organizations/{organization}/locations/{location}/cloudControlDeployments/cloud-control-deployment-2"
    /// }
    /// ```
    #[prost(message, repeated, tag = "3")]
    pub cc_deployment_references: ::prost::alloc::vec::Vec<
        CloudControlDeploymentReference,
    >,
}
/// Request message for CreateFrameworkDeployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkDeploymentRequest {
    /// Required. Value for parent. Supported formats:
    /// organizations/{organization}/locations/{location}
    /// Only global location is supported.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. User provided identifier. It should be unique in scope of a
    /// parent Please note that this is optional and if not provided, a random UUID
    /// will be generated.
    #[prost(string, tag = "2")]
    pub framework_deployment_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub framework_deployment: ::core::option::Option<FrameworkDeployment>,
}
/// Request message for DeleteFrameworkDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFrameworkDeploymentRequest {
    /// Required. Name of the framework deployment to be deleted
    /// FrameworkDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An opaque identifier for the current version of the resource.
    ///
    /// If you provide this value, then it must match the existing value. If the
    /// values don't match, then the request fails with an
    /// \[ABORTED\]\[google.rpc.Code.ABORTED\] error.
    ///
    /// If you omit this value, then the resource is deleted regardless of its
    /// current `etag` value.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Request message for GetFrameworkDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkDeploymentRequest {
    /// Required. FrameworkDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for ListFrameworkDeployments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworkDeploymentsRequest {
    /// Required. Parent value for ListFrameworkDeploymentsRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter to be applied on the resource, defined by EBNF grammar
    /// <https://google.aip.dev/assets/misc/ebnf-filtering.txt.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort results. Supported are "name", "name desc" or "" (unsorted).
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing FrameworkDeployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworkDeploymentsResponse {
    /// The list of FrameworkDeployments.
    #[prost(message, repeated, tag = "1")]
    pub framework_deployments: ::prost::alloc::vec::Vec<FrameworkDeployment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetCloudControlDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudControlDeploymentRequest {
    /// Required. CloudControlDeployment name in either of the following formats:
    /// organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for ListCloudControlDeployments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudControlDeploymentsRequest {
    /// Required. Parent value for ListCloudControlDeploymentsRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter to be applied on the resource, defined by EBNF grammar
    /// <https://google.aip.dev/assets/misc/ebnf-filtering.txt.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort results. Supported are "name", "name desc" or "" (unsorted).
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Message for response to listing CloudControlDeployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudControlDeploymentsResponse {
    /// The list of CloudControlDeployments.
    #[prost(message, repeated, tag = "1")]
    pub cloud_control_deployments: ::prost::alloc::vec::Vec<CloudControlDeployment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The reference to the cloud control deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudControlDeploymentReference {
    /// Output only. The name of the cloud control deployment. The format is:
    /// organizations/{org}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    #[prost(string, tag = "1")]
    pub cloud_control_deployment: ::prost::alloc::string::String,
}
/// The reference to the framework deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkDeploymentReference {
    /// Output only. The name of the framework. The format is:
    /// organizations/{org}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub framework_deployment: ::prost::alloc::string::String,
    /// Optional. The reference to the framework that this deployment is for.
    /// Example: {
    /// framework:
    /// "organizations/{org}/locations/{location}/frameworks/{framework}",
    /// major_revision_id: 1
    /// }
    #[prost(message, optional, tag = "2")]
    pub framework_reference: ::core::option::Option<FrameworkReference>,
    /// Optional. The display name of the framework.
    #[prost(string, tag = "3")]
    pub framework_display_name: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentState {
    /// Unspecified. Invalid state.
    Unspecified = 0,
    /// Validating the deployment.
    Validating = 1,
    /// Deployment is in CREATING state.
    Creating = 2,
    /// Deployment is in DELETING state.
    Deleting = 3,
    /// Deployment has failed.
    Failed = 4,
    /// Deployment is ready.
    Ready = 5,
    /// Deployment is partially deployed.
    PartiallyDeployed = 6,
    /// Deployment is partially deleted.
    PartiallyDeleted = 7,
}
impl DeploymentState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_STATE_UNSPECIFIED",
            Self::Validating => "DEPLOYMENT_STATE_VALIDATING",
            Self::Creating => "DEPLOYMENT_STATE_CREATING",
            Self::Deleting => "DEPLOYMENT_STATE_DELETING",
            Self::Failed => "DEPLOYMENT_STATE_FAILED",
            Self::Ready => "DEPLOYMENT_STATE_READY",
            Self::PartiallyDeployed => "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED",
            Self::PartiallyDeleted => "DEPLOYMENT_STATE_PARTIALLY_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_STATE_VALIDATING" => Some(Self::Validating),
            "DEPLOYMENT_STATE_CREATING" => Some(Self::Creating),
            "DEPLOYMENT_STATE_DELETING" => Some(Self::Deleting),
            "DEPLOYMENT_STATE_FAILED" => Some(Self::Failed),
            "DEPLOYMENT_STATE_READY" => Some(Self::Ready),
            "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED" => Some(Self::PartiallyDeployed),
            "DEPLOYMENT_STATE_PARTIALLY_DELETED" => Some(Self::PartiallyDeleted),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod deployment_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct DeploymentClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeploymentClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeploymentClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeploymentClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeploymentClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new FrameworkDeployment in a given project and location.
        pub async fn create_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/CreateFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "CreateFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single FrameworkDeployment.
        pub async fn delete_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/DeleteFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "DeleteFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single FrameworkDeployment.
        pub async fn get_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FrameworkDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/GetFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "GetFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists FrameworkDeployments in a given parent and location.
        pub async fn list_framework_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworkDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworkDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/ListFrameworkDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "ListFrameworkDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single CloudControlDeployment.
        pub async fn get_cloud_control_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudControlDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloudControlDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/GetCloudControlDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "GetCloudControlDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CloudControlDeployments under a given parent.
        pub async fn list_cloud_control_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudControlDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudControlDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/ListCloudControlDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "ListCloudControlDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
