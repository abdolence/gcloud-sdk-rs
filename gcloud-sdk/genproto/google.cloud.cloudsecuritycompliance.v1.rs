// This file is @generated by prost-build.
/// A framework is a collection of cloud controls and regulatory controls
/// that represent security best practices or industry-defined standards such as
/// FedRAMP or NIST.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Framework {
    /// Required. Identifier. The name of the framework, in the format
    /// `organizations/{organization}/locations/{location}/frameworks/{framework_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The major version of the framework, which is incremented in
    /// ascending order.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. The friendly name of the framework. The maximum length is 200
    /// characters.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the framework. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The type of framework.
    #[prost(enumeration = "framework::FrameworkType", tag = "6")]
    pub r#type: i32,
    /// Optional. The cloud control details that are directly added without any
    /// grouping in the framework.
    #[prost(message, repeated, tag = "8")]
    pub cloud_control_details: ::prost::alloc::vec::Vec<CloudControlDetails>,
    /// Optional. The category of the framework.
    #[prost(enumeration = "FrameworkCategory", repeated, packed = "false", tag = "9")]
    pub category: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The cloud providers that are supported by the framework.
    #[prost(enumeration = "CloudProvider", repeated, packed = "false", tag = "10")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The target resource types that are supported by the framework.
    #[prost(enumeration = "TargetResourceType", repeated, packed = "false", tag = "11")]
    pub supported_target_resource_types: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The supported enforcement modes of the framework.
    #[prost(enumeration = "EnforcementMode", repeated, packed = "false", tag = "13")]
    pub supported_enforcement_modes: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `Framework`.
pub mod framework {
    /// The type of framework.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameworkType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// A framework that's provided and managed by Google.
        BuiltIn = 1,
        /// A framework that's created and managed by you.
        Custom = 2,
    }
    impl FrameworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FRAMEWORK_TYPE_UNSPECIFIED",
                Self::BuiltIn => "BUILT_IN",
                Self::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FRAMEWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BUILT_IN" => Some(Self::BuiltIn),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// The details of a cloud control.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlDetails {
    /// Required. The name of the cloud control, in the format
    /// `organizations/{organization}/locations/{location}/cloudControls/{cloud-control}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The major version of the cloud control.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. Parameters are key-value pairs that let you provide your custom
    /// location requirements, environment requirements, or other settings that are
    /// relevant to the cloud control. An example parameter is
    /// `{"name": "location","value": "us-west-1"}`.
    #[prost(message, repeated, tag = "4")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
}
/// The reference of a framework, in the format
/// `organizations/{organization}/locations/{location}/frameworks/{framework}`.
/// The only supported location is `global`.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkReference {
    /// Required. The major version of the framework. If not specified, the version
    /// corresponds to the latest version of the framework.
    #[prost(string, tag = "1")]
    pub framework: ::prost::alloc::string::String,
    /// Optional. The major version of the framework. If not specified, the version
    /// corresponds to the latest version of the framework.
    #[prost(int64, optional, tag = "2")]
    pub major_revision_id: ::core::option::Option<i64>,
}
/// Parameters are key-value pairs that let you provide your custom location
/// requirements, environment requirements, or other settings that are
/// relevant to the cloud control.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
    /// Required. The name or key of the parameter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The value of the parameter.
    #[prost(message, optional, boxed, tag = "2")]
    pub parameter_value: ::core::option::Option<::prost::alloc::boxed::Box<ParamValue>>,
}
/// A cloud control is a set of rules and associated metadata that you can
/// use to define your organization's security or compliance intent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControl {
    /// Required. Identifier. The name of the cloud control, in the format
    /// `organizations/{organization}/locations/{location}/cloudControls/{cloud_control_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The major version of the cloud control, which is incremented
    /// in ascending order.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. A description of the cloud control. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The friendly name of the cloud control. The maximum length is 200
    /// characters.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The supported enforcement modes for the cloud control.
    #[prost(enumeration = "EnforcementMode", repeated, packed = "false", tag = "7")]
    pub supported_enforcement_modes: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The parameter specifications for the cloud control.
    #[prost(message, repeated, tag = "8")]
    pub parameter_spec: ::prost::alloc::vec::Vec<ParameterSpec>,
    /// Optional. The rules that you can enforce to meet your security or
    /// compliance intent.
    #[prost(message, repeated, tag = "9")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    /// Optional. The severity of the findings that are generated by the cloud
    /// control.
    #[prost(enumeration = "Severity", tag = "11")]
    pub severity: i32,
    /// Optional. The finding category for the cloud control findings. The maximum
    /// length is 255 characters.
    #[prost(string, tag = "12")]
    pub finding_category: ::prost::alloc::string::String,
    /// Optional. The supported cloud providers.
    #[prost(enumeration = "CloudProvider", repeated, packed = "false", tag = "13")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The frameworks that include this cloud control.
    #[prost(string, repeated, tag = "14")]
    pub related_frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The remediation steps for the cloud control findings. The
    /// maximum length is 400 characters.
    #[prost(string, tag = "15")]
    pub remediation_steps: ::prost::alloc::string::String,
    /// Optional. The categories for the cloud control.
    #[prost(
        enumeration = "CloudControlCategory",
        repeated,
        packed = "false",
        tag = "16"
    )]
    pub categories: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The time that the cloud control was last updated.
    /// `create_time` is used because a new cloud control is created
    /// whenever an existing cloud control is updated.
    #[prost(message, optional, tag = "17")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The target resource types that are supported by the cloud
    /// control.
    #[prost(enumeration = "TargetResourceType", repeated, packed = "false", tag = "18")]
    pub supported_target_resource_types: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `CloudControl`.
pub mod cloud_control {
    /// The type of cloud control.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// A cloud control that's created and managed by you.
        Custom = 1,
        /// A cloud control that's provided and managed by Google.
        BuiltIn = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Custom => "CUSTOM",
                Self::BuiltIn => "BUILT_IN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOM" => Some(Self::Custom),
                "BUILT_IN" => Some(Self::BuiltIn),
                _ => None,
            }
        }
    }
}
/// The parameter specification for the cloud control.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterSpec {
    /// Required. The name of the parameter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The friendly name of the parameter. The maximum length is 200
    /// characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the parameter. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Required. Whether the parameter is required.
    #[prost(bool, tag = "4")]
    pub is_required: bool,
    /// Required. The parameter value type.
    #[prost(enumeration = "parameter_spec::ValueType", tag = "5")]
    pub value_type: i32,
    /// Optional. The default value of the parameter.
    #[prost(message, optional, tag = "6")]
    pub default_value: ::core::option::Option<ParamValue>,
    /// Optional. The list of parameter substitutions.
    #[prost(message, repeated, tag = "7")]
    pub substitution_rules: ::prost::alloc::vec::Vec<ParameterSubstitutionRule>,
    /// Optional. The parameter specification for `oneOf` attributes.
    #[prost(message, repeated, tag = "8")]
    pub sub_parameters: ::prost::alloc::vec::Vec<ParameterSpec>,
    /// Optional. The permitted set of values for the parameter.
    #[prost(message, optional, tag = "9")]
    pub validation: ::core::option::Option<Validation>,
}
/// Nested message and enum types in `ParameterSpec`.
pub mod parameter_spec {
    /// The type of parameter value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// A string value.
        String = 3,
        /// A boolean value.
        Boolean = 4,
        /// A string list value.
        Stringlist = 5,
        /// A numeric value.
        Number = 6,
        /// A oneOf value.
        Oneof = 7,
    }
    impl ValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VALUE_TYPE_UNSPECIFIED",
                Self::String => "STRING",
                Self::Boolean => "BOOLEAN",
                Self::Stringlist => "STRINGLIST",
                Self::Number => "NUMBER",
                Self::Oneof => "ONEOF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "BOOLEAN" => Some(Self::Boolean),
                "STRINGLIST" => Some(Self::Stringlist),
                "NUMBER" => Some(Self::Number),
                "ONEOF" => Some(Self::Oneof),
                _ => None,
            }
        }
    }
}
/// The validation of the parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validation {
    /// Defines validators for parameter values.
    #[prost(oneof = "validation::Constraint", tags = "1, 2, 3")]
    pub constraint: ::core::option::Option<validation::Constraint>,
}
/// Nested message and enum types in `Validation`.
pub mod validation {
    /// Defines validators for parameter values.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Constraint {
        /// The permitted set of values for the parameter.
        #[prost(message, tag = "1")]
        AllowedValues(super::AllowedValues),
        /// The permitted range for numeric parameters.
        #[prost(message, tag = "2")]
        IntRange(super::IntRange),
        /// The regular expression for string parameters.
        #[prost(message, tag = "3")]
        RegexpPattern(super::RegexpPattern),
    }
}
/// The allowed set of values for the parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedValues {
    /// Required. The list of allowed values for the parameter.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<ParamValue>,
}
/// The regular expression (regex) validator for parameter values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegexpPattern {
    /// Required. The regex pattern to match the values of the parameter with.
    #[prost(string, tag = "1")]
    pub pattern: ::prost::alloc::string::String,
}
/// The number range for number parameters.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntRange {
    /// Required. The minimum permitted value for the numeric parameter
    /// (inclusive).
    #[prost(int64, tag = "1")]
    pub min: i64,
    /// Required. The maximum permitted value for the numeric parameter
    /// (inclusive).
    #[prost(int64, tag = "2")]
    pub max: i64,
}
/// A list of strings for the parameter value.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringList {
    /// Required. The strings in the list.
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// The possible parameter value types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamValue {
    /// The list of possible parameter value types.
    #[prost(oneof = "param_value::Kind", tags = "3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<param_value::Kind>,
}
/// Nested message and enum types in `ParamValue`.
pub mod param_value {
    /// The list of possible parameter value types.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A string value.
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        /// A boolean value.
        #[prost(bool, tag = "4")]
        BoolValue(bool),
        /// A repeated string.
        #[prost(message, tag = "5")]
        StringListValue(super::StringList),
        /// A double value.
        #[prost(double, tag = "6")]
        NumberValue(f64),
        /// Sub-parameter values.
        #[prost(message, tag = "7")]
        OneofValue(::prost::alloc::boxed::Box<super::Parameter>),
    }
}
/// The parameter substitution rules.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParameterSubstitutionRule {
    /// The type of substitution.
    #[prost(oneof = "parameter_substitution_rule::SubstitutionType", tags = "1, 2")]
    pub substitution_type: ::core::option::Option<
        parameter_substitution_rule::SubstitutionType,
    >,
}
/// Nested message and enum types in `ParameterSubstitutionRule`.
pub mod parameter_substitution_rule {
    /// The type of substitution.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SubstitutionType {
        /// The placeholder substitution rule.
        #[prost(message, tag = "1")]
        PlaceholderSubstitutionRule(super::PlaceholderSubstitutionRule),
        /// The attribute substitution rule.
        #[prost(message, tag = "2")]
        AttributeSubstitutionRule(super::AttributeSubstitutionRule),
    }
}
/// The attribute at the given path that's substituted entirely.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AttributeSubstitutionRule {
    /// The fully qualified proto attribute path, in dot notation.
    /// For example: `rules\[0\].cel_expression.resource_types_values`
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
}
/// The placeholder that's substituted in the rendered string.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceholderSubstitutionRule {
    /// The fully qualified proto attribute path, in dot notation.
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
}
/// A rule in the cloud control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rule {
    /// Optional. The rule description. The maximum length is 2000 characters.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    /// Required. The functionality that's enabled by the rule.
    #[prost(enumeration = "RuleActionType", repeated, packed = "false", tag = "16")]
    pub rule_action_types: ::prost::alloc::vec::Vec<i32>,
    /// The rule implementation.
    #[prost(oneof = "rule::Implementation", tags = "1")]
    pub implementation: ::core::option::Option<rule::Implementation>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    /// The rule implementation.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Implementation {
        /// The rule's logic expression in Common Expression Language (CEL).
        #[prost(message, tag = "1")]
        CelExpression(super::CelExpression),
    }
}
/// A Common Expression Language (CEL) expression that's used to create a rule.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CelExpression {
    /// Required. The logical expression in CEL. The maximum length of the
    /// condition is 1000 characters. For more information, see [CEL
    /// expression](<https://cloud.google.com/security-command-center/docs/compliance-manager-write-cel-expressions>).
    #[prost(string, tag = "1")]
    pub expression: ::prost::alloc::string::String,
    /// The criteria of the CEL expression.
    #[prost(oneof = "cel_expression::Criteria", tags = "3")]
    pub criteria: ::core::option::Option<cel_expression::Criteria>,
}
/// Nested message and enum types in `CELExpression`.
pub mod cel_expression {
    /// The criteria of the CEL expression.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Criteria {
        /// The resource instance types on which this expression is defined.
        /// The format is `<SERVICE_NAME>/<type>`.
        /// For example: `compute.googleapis.com/Instance`
        #[prost(message, tag = "3")]
        ResourceTypesValues(super::StringList),
    }
}
/// The metadata for the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The server-defined resource path for the target of the
    /// operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. The name of the verb that was executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. The human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested that the operation
    /// be cancelled. If an operation was cancelled successfully, then the field
    /// \[google.longrunning.Operation.error\]\[google.longrunning.Operation.error\]
    /// contains the value \[google.rpc.Code.CANCELLED\]\[google.rpc.Code.CANCELLED\].
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. The API version that was used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// The regulatory family of the control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlFamily {
    /// The identifier for the regulatory control family.
    #[prost(string, tag = "1")]
    pub family_id: ::prost::alloc::string::String,
    /// The friendly name for the regulatory control family.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// The responsibility type for the regulatory control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RegulatoryControlResponsibilityType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Google's responsibility.
    Google = 1,
    /// Your responsibility.
    Customer = 2,
    /// Shared responsibility.
    Shared = 3,
}
impl RegulatoryControlResponsibilityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "REGULATORY_CONTROL_RESPONSIBILITY_TYPE_UNSPECIFIED",
            Self::Google => "GOOGLE",
            Self::Customer => "CUSTOMER",
            Self::Shared => "SHARED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REGULATORY_CONTROL_RESPONSIBILITY_TYPE_UNSPECIFIED" => {
                Some(Self::Unspecified)
            }
            "GOOGLE" => Some(Self::Google),
            "CUSTOMER" => Some(Self::Customer),
            "SHARED" => Some(Self::Shared),
            _ => None,
        }
    }
}
/// The enforcement mode for the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnforcementMode {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The cloud control is enforced to prevent non-compliance.
    Preventive = 1,
    /// The cloud control is enforced to detect non-compliance.
    Detective = 2,
    /// The cloud control is enforced to audit for non-compliance.
    Audit = 3,
}
impl EnforcementMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENFORCEMENT_MODE_UNSPECIFIED",
            Self::Preventive => "PREVENTIVE",
            Self::Detective => "DETECTIVE",
            Self::Audit => "AUDIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENFORCEMENT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "PREVENTIVE" => Some(Self::Preventive),
            "DETECTIVE" => Some(Self::Detective),
            "AUDIT" => Some(Self::Audit),
            _ => None,
        }
    }
}
/// The category for the framework.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameworkCategory {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// An industry-defined framework.
    IndustryDefinedStandard = 1,
    /// An Assured Workloads framework.
    AssuredWorkloads = 2,
    /// A data security posture framework.
    DataSecurity = 3,
    /// A Google's best practices framework.
    GoogleBestPractices = 4,
    /// A user-created framework.
    CustomFramework = 5,
}
impl FrameworkCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FRAMEWORK_CATEGORY_UNSPECIFIED",
            Self::IndustryDefinedStandard => "INDUSTRY_DEFINED_STANDARD",
            Self::AssuredWorkloads => "ASSURED_WORKLOADS",
            Self::DataSecurity => "DATA_SECURITY",
            Self::GoogleBestPractices => "GOOGLE_BEST_PRACTICES",
            Self::CustomFramework => "CUSTOM_FRAMEWORK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAMEWORK_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "INDUSTRY_DEFINED_STANDARD" => Some(Self::IndustryDefinedStandard),
            "ASSURED_WORKLOADS" => Some(Self::AssuredWorkloads),
            "DATA_SECURITY" => Some(Self::DataSecurity),
            "GOOGLE_BEST_PRACTICES" => Some(Self::GoogleBestPractices),
            "CUSTOM_FRAMEWORK" => Some(Self::CustomFramework),
            _ => None,
        }
    }
}
/// The category for the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudControlCategory {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The infrastructure security category.
    CcCategoryInfrastructure = 1,
    /// The artificial intelligence category.
    CcCategoryArtificialIntelligence = 2,
    /// The physical security category.
    CcCategoryPhysicalSecurity = 3,
    /// The data security category.
    CcCategoryDataSecurity = 4,
    /// The network security category.
    CcCategoryNetworkSecurity = 5,
    /// The incident management category.
    CcCategoryIncidentManagement = 6,
    /// The identity and access management category.
    CcCategoryIdentityAndAccessManagement = 7,
    /// The encryption category.
    CcCategoryEncryption = 8,
    /// The logs management and infrastructure category.
    CcCategoryLogsManagementAndInfrastructure = 9,
    /// The HR, admin, and processes category.
    CcCategoryHrAdminAndProcesses = 10,
    /// The third-party and sub-processor management category.
    CcCategoryThirdPartyAndSubProcessorManagement = 11,
    /// The legal and disclosures category.
    CcCategoryLegalAndDisclosures = 12,
    /// The vulnerability management category.
    CcCategoryVulnerabilityManagement = 13,
    /// The privacy category.
    CcCategoryPrivacy = 14,
    /// The business continuity and disaster recovery (BCDR) category.
    CcCategoryBcdr = 15,
}
impl CloudControlCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_CONTROL_CATEGORY_UNSPECIFIED",
            Self::CcCategoryInfrastructure => "CC_CATEGORY_INFRASTRUCTURE",
            Self::CcCategoryArtificialIntelligence => {
                "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE"
            }
            Self::CcCategoryPhysicalSecurity => "CC_CATEGORY_PHYSICAL_SECURITY",
            Self::CcCategoryDataSecurity => "CC_CATEGORY_DATA_SECURITY",
            Self::CcCategoryNetworkSecurity => "CC_CATEGORY_NETWORK_SECURITY",
            Self::CcCategoryIncidentManagement => "CC_CATEGORY_INCIDENT_MANAGEMENT",
            Self::CcCategoryIdentityAndAccessManagement => {
                "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT"
            }
            Self::CcCategoryEncryption => "CC_CATEGORY_ENCRYPTION",
            Self::CcCategoryLogsManagementAndInfrastructure => {
                "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE"
            }
            Self::CcCategoryHrAdminAndProcesses => "CC_CATEGORY_HR_ADMIN_AND_PROCESSES",
            Self::CcCategoryThirdPartyAndSubProcessorManagement => {
                "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT"
            }
            Self::CcCategoryLegalAndDisclosures => "CC_CATEGORY_LEGAL_AND_DISCLOSURES",
            Self::CcCategoryVulnerabilityManagement => {
                "CC_CATEGORY_VULNERABILITY_MANAGEMENT"
            }
            Self::CcCategoryPrivacy => "CC_CATEGORY_PRIVACY",
            Self::CcCategoryBcdr => "CC_CATEGORY_BCDR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_CONTROL_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "CC_CATEGORY_INFRASTRUCTURE" => Some(Self::CcCategoryInfrastructure),
            "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE" => {
                Some(Self::CcCategoryArtificialIntelligence)
            }
            "CC_CATEGORY_PHYSICAL_SECURITY" => Some(Self::CcCategoryPhysicalSecurity),
            "CC_CATEGORY_DATA_SECURITY" => Some(Self::CcCategoryDataSecurity),
            "CC_CATEGORY_NETWORK_SECURITY" => Some(Self::CcCategoryNetworkSecurity),
            "CC_CATEGORY_INCIDENT_MANAGEMENT" => Some(Self::CcCategoryIncidentManagement),
            "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT" => {
                Some(Self::CcCategoryIdentityAndAccessManagement)
            }
            "CC_CATEGORY_ENCRYPTION" => Some(Self::CcCategoryEncryption),
            "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE" => {
                Some(Self::CcCategoryLogsManagementAndInfrastructure)
            }
            "CC_CATEGORY_HR_ADMIN_AND_PROCESSES" => {
                Some(Self::CcCategoryHrAdminAndProcesses)
            }
            "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT" => {
                Some(Self::CcCategoryThirdPartyAndSubProcessorManagement)
            }
            "CC_CATEGORY_LEGAL_AND_DISCLOSURES" => {
                Some(Self::CcCategoryLegalAndDisclosures)
            }
            "CC_CATEGORY_VULNERABILITY_MANAGEMENT" => {
                Some(Self::CcCategoryVulnerabilityManagement)
            }
            "CC_CATEGORY_PRIVACY" => Some(Self::CcCategoryPrivacy),
            "CC_CATEGORY_BCDR" => Some(Self::CcCategoryBcdr),
            _ => None,
        }
    }
}
/// The cloud provider that's associated with the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudProvider {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Amazon Web Services (AWS).
    Aws = 1,
    /// Microsoft Azure.
    Azure = 2,
    /// Google Cloud.
    Gcp = 3,
}
impl CloudProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_PROVIDER_UNSPECIFIED",
            Self::Aws => "AWS",
            Self::Azure => "AZURE",
            Self::Gcp => "GCP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "AWS" => Some(Self::Aws),
            "AZURE" => Some(Self::Azure),
            "GCP" => Some(Self::Gcp),
            _ => None,
        }
    }
}
/// The severity of the finding.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// A critical vulnerability is easily discoverable by an external actor,
    /// exploitable, and results in the direct ability to execute arbitrary code,
    /// exfiltrate data, and otherwise gain additional access and privileges to
    /// cloud resources and workloads. Examples include publicly accessible
    /// unprotected user data and public SSH access with weak or no
    /// passwords.
    ///
    /// A critical threat is a threat that can access, modify, or delete data or
    /// execute unauthorized code within existing resources.
    Critical = 1,
    /// A high-risk vulnerability can be easily discovered and exploited in
    /// combination with other vulnerabilities to gain direct access and
    /// the ability to execute arbitrary code, exfiltrate data, and otherwise
    /// gain additional access and privileges to cloud resources and workloads.
    /// An example is a database with weak or no passwords that is only
    /// accessible internally. This database could easily be compromised by an
    /// actor that had access to the internal network.
    ///
    /// A high-risk threat is a threat that can create new computational
    /// resources in an environment but can't access data or execute code in
    /// existing resources.
    High = 2,
    /// A medium-risk vulnerability can be used by an actor to gain access to
    /// resources or privileges that enable them to eventually (through multiple
    /// steps or a complex exploit) gain access and the ability to execute
    /// arbitrary code or exfiltrate data. An example is a service account with
    /// access to more projects than it should have. If an actor gains access to
    /// the service account, they could potentially use that access to manipulate
    /// a project the service account was not intended to.
    ///
    /// A medium-risk threat can cause operational impact but might not
    /// access data or execute unauthorized code.
    Medium = 3,
    /// A low-risk vulnerability hampers a security organization's ability to
    /// detect vulnerabilities or active threats in their deployment, or prevents
    /// the root cause investigation of security issues. An example is monitoring
    /// and logs being disabled for resource configurations and access.
    ///
    /// A low-risk threat is a threat that has obtained minimal access to an
    /// environment but can't access data, execute code, or create resources.
    Low = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Critical => "CRITICAL",
            Self::High => "HIGH",
            Self::Medium => "MEDIUM",
            Self::Low => "LOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "CRITICAL" => Some(Self::Critical),
            "HIGH" => Some(Self::High),
            "MEDIUM" => Some(Self::Medium),
            "LOW" => Some(Self::Low),
            _ => None,
        }
    }
}
/// The action type of the rule.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RuleActionType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The rule is intended to prevent non-compliance.
    Preventive = 1,
    /// The rule is intended to detect non-compliance.
    Detective = 2,
    /// The rule is intended to audit non-compliance.
    Audit = 3,
}
impl RuleActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RULE_ACTION_TYPE_UNSPECIFIED",
            Self::Preventive => "RULE_ACTION_TYPE_PREVENTIVE",
            Self::Detective => "RULE_ACTION_TYPE_DETECTIVE",
            Self::Audit => "RULE_ACTION_TYPE_AUDIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RULE_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RULE_ACTION_TYPE_PREVENTIVE" => Some(Self::Preventive),
            "RULE_ACTION_TYPE_DETECTIVE" => Some(Self::Detective),
            "RULE_ACTION_TYPE_AUDIT" => Some(Self::Audit),
            _ => None,
        }
    }
}
/// The type of resource that a control or framework can be applied to.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TargetResourceType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The target resource is a Google Cloud organization.
    TargetResourceCrmTypeOrg = 1,
    /// The target resource is a folder.
    TargetResourceCrmTypeFolder = 2,
    /// The target resource is a project.
    TargetResourceCrmTypeProject = 3,
    /// The target resource is an application in App Hub.
    Application = 4,
}
impl TargetResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TARGET_RESOURCE_TYPE_UNSPECIFIED",
            Self::TargetResourceCrmTypeOrg => "TARGET_RESOURCE_CRM_TYPE_ORG",
            Self::TargetResourceCrmTypeFolder => "TARGET_RESOURCE_CRM_TYPE_FOLDER",
            Self::TargetResourceCrmTypeProject => "TARGET_RESOURCE_CRM_TYPE_PROJECT",
            Self::Application => "TARGET_RESOURCE_TYPE_APPLICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TARGET_RESOURCE_CRM_TYPE_ORG" => Some(Self::TargetResourceCrmTypeOrg),
            "TARGET_RESOURCE_CRM_TYPE_FOLDER" => Some(Self::TargetResourceCrmTypeFolder),
            "TARGET_RESOURCE_CRM_TYPE_PROJECT" => {
                Some(Self::TargetResourceCrmTypeProject)
            }
            "TARGET_RESOURCE_TYPE_APPLICATION" => Some(Self::Application),
            _ => None,
        }
    }
}
/// The request message for \[GenerateFrameworkAuditScopeReport\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateFrameworkAuditScopeReportRequest {
    /// Required. The organization, folder or project for the audit report.
    ///
    /// Supported formats are the following:
    ///
    /// * `projects/{project_id}/locations/{location}`
    /// * `folders/{folder_id}/locations/{location}`
    /// * `organizations/{organization_id}/locations/{location}`
    #[prost(string, tag = "1")]
    pub scope: ::prost::alloc::string::String,
    /// Required. The format that the scope report bytes is returned in.
    #[prost(
        enumeration = "generate_framework_audit_scope_report_request::Format",
        tag = "2"
    )]
    pub report_format: i32,
    /// Required. The compliance framework that the scope report is generated for.
    #[prost(string, tag = "3")]
    pub compliance_framework: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GenerateFrameworkAuditScopeReportRequest`.
pub mod generate_framework_audit_scope_report_request {
    /// The set of options for the audit scope report format.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The report format is the Open Document Format (ODF).
        Odf = 1,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FORMAT_UNSPECIFIED",
                Self::Odf => "ODF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "ODF" => Some(Self::Odf),
                _ => None,
            }
        }
    }
}
/// The response message for \[GenerateFrameworkAuditScopeReport\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateFrameworkAuditScopeReportResponse {
    /// Identifier. The name of the audit report, in the format that was
    /// given in the request.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The compliance framework that the audit scope report is generated
    /// for.
    #[prost(string, tag = "2")]
    pub compliance_framework: ::prost::alloc::string::String,
    /// The set of options that the audit scope report is exported in.
    #[prost(
        oneof = "generate_framework_audit_scope_report_response::AuditReport",
        tags = "3"
    )]
    pub audit_report: ::core::option::Option<
        generate_framework_audit_scope_report_response::AuditReport,
    >,
}
/// Nested message and enum types in `GenerateFrameworkAuditScopeReportResponse`.
pub mod generate_framework_audit_scope_report_response {
    /// The set of options that the audit scope report is exported in.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum AuditReport {
        /// The audit scope report content in byte format.
        #[prost(bytes, tag = "3")]
        ScopeReportContents(::prost::alloc::vec::Vec<u8>),
    }
}
/// Additional information for an audit operation.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReportSummary {
    /// Output only. The total number of checks.
    #[prost(int32, tag = "1")]
    pub total_count: i32,
    /// Output only. The number of compliant checks.
    #[prost(int32, tag = "2")]
    pub compliant_count: i32,
    /// Output only. The number of checks with violations.
    #[prost(int32, tag = "3")]
    pub violation_count: i32,
    /// Output only. The number of checks with "manual review needed" status.
    #[prost(int32, tag = "4")]
    pub manual_review_needed_count: i32,
    /// Output only. The number of checks that can't be performed due to errors.
    #[prost(int32, tag = "5")]
    pub error_count: i32,
}
/// The request message for \[CreateFrameworkAudit\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkAuditRequest {
    /// Required. The parent resource where this framework audit is created.
    ///
    /// Supported formats are the following:
    ///
    /// * `organizations/{organization_id}/locations/{location}`
    /// * `folders/{folder_id}/locations/{location}`
    /// * `projects/{project_id}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The ID to use for the framework audit. The ID becomes the final
    /// component of the framework audit's full resource name.
    ///
    /// The ID must be between 4-63 characters, and valid characters
    /// are `\[a-z][0-9]-\`.
    #[prost(string, tag = "2")]
    pub framework_audit_id: ::prost::alloc::string::String,
    /// Required. The framework audit to create.
    #[prost(message, optional, tag = "3")]
    pub framework_audit: ::core::option::Option<FrameworkAudit>,
}
/// A destination for the framework audit.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkAuditDestination {
    /// The type of destination.
    #[prost(oneof = "framework_audit_destination::DestinationType", tags = "1")]
    pub destination_type: ::core::option::Option<
        framework_audit_destination::DestinationType,
    >,
}
/// Nested message and enum types in `FrameworkAuditDestination`.
pub mod framework_audit_destination {
    /// The type of destination.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DestinationType {
        /// The Cloud Storage bucket destination.
        #[prost(message, tag = "1")]
        Bucket(super::BucketDestination),
    }
}
/// A Cloud Storage bucket destination.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BucketDestination {
    /// Required. The URI of the Cloud Storage bucket.
    #[prost(string, tag = "1")]
    pub bucket_uri: ::prost::alloc::string::String,
    /// Optional. The format of the framework audit.
    #[prost(enumeration = "bucket_destination::Format", tag = "3")]
    pub framework_audit_format: i32,
}
/// Nested message and enum types in `BucketDestination`.
pub mod bucket_destination {
    /// The set of options for the framework audit format.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The format for the framework audit report is Open Document.
        Odf = 1,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FORMAT_UNSPECIFIED",
                Self::Odf => "ODF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "ODF" => Some(Self::Odf),
                _ => None,
            }
        }
    }
}
/// A framework audit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkAudit {
    /// Output only. Identifier. The name of the framework audit.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The ID of the framework audit.
    #[prost(string, tag = "2")]
    pub framework_audit_id: ::prost::alloc::string::String,
    /// Output only. The compliance framework used for the audit.
    #[prost(string, tag = "3")]
    pub compliance_framework: ::prost::alloc::string::String,
    /// Output only. The scope of the audit.
    #[prost(string, tag = "4")]
    pub scope: ::prost::alloc::string::String,
    /// Required. The destination for the audit reports.
    #[prost(message, optional, tag = "5")]
    pub framework_audit_destination: ::core::option::Option<FrameworkAuditDestination>,
    /// Output only. The time that the audit started.
    #[prost(message, optional, tag = "6")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time that the audit finished.
    #[prost(message, optional, tag = "7")]
    pub finish_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The overall compliance state of the audit.
    #[prost(enumeration = "ComplianceState", tag = "8")]
    pub compliance_state: i32,
    /// Output only. The summary of the report.
    #[prost(message, optional, tag = "9")]
    pub report_summary: ::core::option::Option<ReportSummary>,
    /// Optional. The details for the cloud control groups within this audit.
    #[prost(message, repeated, tag = "10")]
    pub cloud_control_group_audit_details: ::prost::alloc::vec::Vec<
        CloudControlGroupAuditDetails,
    >,
    /// Optional. The details for the cloud controls within this audit.
    #[prost(message, repeated, tag = "11")]
    pub cloud_control_audit_details: ::prost::alloc::vec::Vec<CloudControlAuditDetails>,
    /// Output only. The ID of the long-running operation.
    #[prost(string, tag = "12")]
    pub operation_id: ::prost::alloc::string::String,
    /// Output only. The framework audit state of the audit.
    #[prost(enumeration = "framework_audit::State", tag = "13")]
    pub state: i32,
}
/// Nested message and enum types in `FrameworkAudit`.
pub mod framework_audit {
    /// The state of the framework audit.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The audit is scheduled.
        Scheduled = 1,
        /// The audit is running.
        Running = 2,
        /// The audit results are being uploaded.
        Uploading = 3,
        /// The audit failed.
        Failed = 4,
        /// The audit completed successfully.
        Succeeded = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Scheduled => "SCHEDULED",
                Self::Running => "RUNNING",
                Self::Uploading => "UPLOADING",
                Self::Failed => "FAILED",
                Self::Succeeded => "SUCCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SCHEDULED" => Some(Self::Scheduled),
                "RUNNING" => Some(Self::Running),
                "UPLOADING" => Some(Self::Uploading),
                "FAILED" => Some(Self::Failed),
                "SUCCEEDED" => Some(Self::Succeeded),
                _ => None,
            }
        }
    }
}
/// The request message for \[ListFrameworkAudits\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworkAuditsRequest {
    /// Required. The parent resource where the framework audits are listed.
    ///
    /// Supported formats are the following:
    ///
    /// * `organizations/{organization_id}/locations/{location}`
    /// * `folders/{folder_id}/locations/{location}`
    /// * `projects/{project_id}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of framework audits to return. The service
    /// might return fewer audits than this value. If unspecified, a maximum of 10
    /// framework audits are returned. The maximum value is 50; values above 50 are
    /// limited to 50.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The `next_page_token` value that's returned from a previous list
    /// request, if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The filters to apply to the framework audits.
    /// Supported filters are `compliance_framework`, `compliance_state`,
    /// `create_time,` and `framework_audit_name`. If the filter is invalid, an
    /// invalid argument error is returned.
    /// For syntax details, see \[AIP-160\]\[<https://google.aip.dev/160\].>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response message for \[ListFrameworkAudits\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworkAuditsResponse {
    /// The framework audits.
    #[prost(message, repeated, tag = "1")]
    pub framework_audits: ::prost::alloc::vec::Vec<FrameworkAudit>,
    /// A token, which you can send as the `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for \[GetFrameworkAudit\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkAuditRequest {
    /// Required. The name of the framework audit to retrieve.
    ///
    /// Supported formats are the following:
    ///
    /// * `organizations/{organization_id}/locations/{location}/frameworkAudits/{frameworkAuditName}`
    /// * `folders/{folder_id}/locations/{location}/frameworkAudits/{frameworkAuditName}`
    /// * `projects/{project_id}/locations/{location}/frameworkAudits/{frameworkAuditName}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The details for a cloud control group.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlGroupAuditDetails {
    /// Output only. The ID of the cloud control group.
    #[prost(string, tag = "1")]
    pub cloud_control_group_id: ::prost::alloc::string::String,
    /// Output only. The display name of the cloud control group.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The description of the cloud control group.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The responsibility type.
    #[prost(string, tag = "4")]
    pub responsibility_type: ::prost::alloc::string::String,
    /// Output only. The description of Google's responsibility.
    #[prost(string, tag = "5")]
    pub google_responsibility_description: ::prost::alloc::string::String,
    /// Output only. The implementation of Google's responsibility.
    #[prost(string, tag = "6")]
    pub google_responsibility_implementation: ::prost::alloc::string::String,
    /// Output only. The description of your responsibility.
    #[prost(string, tag = "7")]
    pub customer_responsibility_description: ::prost::alloc::string::String,
    /// Output only. The implementation of your responsibility.
    #[prost(string, tag = "8")]
    pub customer_responsibility_implementation: ::prost::alloc::string::String,
    /// Output only. The compliance state of the control group.
    #[prost(enumeration = "ComplianceState", tag = "9")]
    pub compliance_state: i32,
    /// Output only. The ID of the regulatory control.
    #[prost(string, tag = "10")]
    pub control_id: ::prost::alloc::string::String,
    /// Output only. The control family.
    #[prost(message, optional, tag = "11")]
    pub control_family: ::core::option::Option<ControlFamily>,
    /// Output only. The details for the cloud controls within this group.
    #[prost(message, repeated, tag = "12")]
    pub cloud_control_details: ::prost::alloc::vec::Vec<CloudControlAuditDetails>,
    /// Output only. The summary of the report.
    #[prost(message, optional, tag = "13")]
    pub report_summary: ::core::option::Option<ReportSummary>,
}
/// The details for a finding.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FindingDetails {
    /// Output only. The name of the finding.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The compliance state of the finding.
    #[prost(enumeration = "ComplianceState", tag = "2")]
    pub compliance_state: i32,
    /// Output only. The observation details for the finding.
    #[prost(message, optional, tag = "3")]
    pub observation: ::core::option::Option<ObservationDetails>,
    /// Output only. The evidence details for the finding.
    #[prost(message, optional, tag = "4")]
    pub evidence: ::core::option::Option<EvidenceDetails>,
}
/// The observation details for a finding.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ObservationDetails {
    /// Output only. The current value.
    #[prost(string, tag = "1")]
    pub current_value: ::prost::alloc::string::String,
    /// Optional. The expected value.
    #[prost(string, tag = "2")]
    pub expected_value: ::prost::alloc::string::String,
    /// Output only. Any guidance for the observation.
    #[prost(string, tag = "3")]
    pub guidance: ::prost::alloc::string::String,
}
/// The evidence details for a finding.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EvidenceDetails {
    /// Output only. The resource identifier.
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Output only. The service identifier.
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
    /// Output only. The path to the evidence.
    #[prost(string, tag = "3")]
    pub evidence_path: ::prost::alloc::string::String,
}
/// The details for a cloud control audit.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlAuditDetails {
    /// Output only. The name of the cloud control.
    #[prost(string, tag = "1")]
    pub cloud_control: ::prost::alloc::string::String,
    /// Output only. The ID of the cloud control.
    #[prost(string, tag = "2")]
    pub cloud_control_id: ::prost::alloc::string::String,
    /// Output only. The description of the cloud control.
    #[prost(string, tag = "3")]
    pub cloud_control_description: ::prost::alloc::string::String,
    /// Output only. The overall status of the findings for the control.
    #[prost(enumeration = "ComplianceState", tag = "4")]
    pub compliance_state: i32,
    /// Output only. The summary of the report.
    #[prost(message, optional, tag = "5")]
    pub report_summary: ::core::option::Option<ReportSummary>,
    /// Output only. The findings for the control.
    #[prost(message, repeated, tag = "6")]
    pub findings: ::prost::alloc::vec::Vec<FindingDetails>,
}
/// The state of compliance after evaluation is complete.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComplianceState {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The resource is compliant.
    Compliant = 1,
    /// The resource has a violation.
    Violation = 2,
    /// The resource requires manual review from you.
    ManualReviewNeeded = 3,
    /// An error occurred while computing the resource status.
    Error = 4,
    /// The resource can't be audited.
    AuditNotSupported = 5,
}
impl ComplianceState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMPLIANCE_STATE_UNSPECIFIED",
            Self::Compliant => "COMPLIANT",
            Self::Violation => "VIOLATION",
            Self::ManualReviewNeeded => "MANUAL_REVIEW_NEEDED",
            Self::Error => "ERROR",
            Self::AuditNotSupported => "AUDIT_NOT_SUPPORTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPLIANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPLIANT" => Some(Self::Compliant),
            "VIOLATION" => Some(Self::Violation),
            "MANUAL_REVIEW_NEEDED" => Some(Self::ManualReviewNeeded),
            "ERROR" => Some(Self::Error),
            "AUDIT_NOT_SUPPORTED" => Some(Self::AuditNotSupported),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod audit_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct AuditClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AuditClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AuditClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AuditClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AuditClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Generates an audit scope report for a framework.
        pub async fn generate_framework_audit_scope_report(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GenerateFrameworkAuditScopeReportRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::GenerateFrameworkAuditScopeReportResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Audit/GenerateFrameworkAuditScopeReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Audit",
                        "GenerateFrameworkAuditScopeReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an audit scope report for a framework.
        pub async fn create_framework_audit(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkAuditRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Audit/CreateFrameworkAudit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Audit",
                        "CreateFrameworkAudit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the framework audits for a given organization, folder, or project.
        pub async fn list_framework_audits(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworkAuditsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworkAuditsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Audit/ListFrameworkAudits",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Audit",
                        "ListFrameworkAudits",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details for a framework audit.
        pub async fn get_framework_audit(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkAuditRequest>,
        ) -> std::result::Result<tonic::Response<super::FrameworkAudit>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Audit/GetFrameworkAudit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Audit",
                        "GetFrameworkAudit",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The request message for \[UpdateCmEnrollment\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCmEnrollmentRequest {
    /// Required. The Compliance Manager enrollment to update.
    /// The `name` field is used to identify the settings that you want to update.
    #[prost(message, optional, tag = "1")]
    pub cm_enrollment: ::core::option::Option<CmEnrollment>,
    /// Optional. The list of fields that you want to update.
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
/// The request message for \[CalculateEffectiveCmEnrollment\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CalculateEffectiveCmEnrollmentRequest {
    /// Required. The name of the Compliance Manager enrollment to calculate.
    ///
    /// Supported formats are the following:
    ///
    /// * `organizations/{organization_id}/locations/{location}/cmEnrollment`
    /// * `folders/{folder_id}/locations/{location}/cmEnrollment`
    /// * `projects/{project_id}/locations/{location}/cmEnrollment`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The settings for Compliance Manager at a specific resource scope.=
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CmEnrollment {
    /// Identifier. The name of the Compliance Manager enrollment.
    ///
    /// Supported formats are the following:
    ///
    /// * `organizations/{organization_id}/locations/{location}/cmEnrollment`
    /// * `folders/{folder_id}/locations/{location}/cmEnrollment`
    /// * `projects/{project_id}/locations/{location}/cmEnrollment`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. Whether the resource is enrolled in Compliance Manager.
    /// This setting is inherited by all descendants.
    #[prost(bool, tag = "2")]
    pub enrolled: bool,
    /// Optional. The audit configuration for Compliance Manager.
    /// If set at a scope, this configuration overrides any inherited audit
    /// configuration.
    #[prost(message, optional, tag = "3")]
    pub audit_config: ::core::option::Option<AuditConfig>,
}
/// The response message for \[CalculateEffectiveCmEnrollment\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculateEffectiveCmEnrollmentResponse {
    /// The effective Compliance Manager enrollment for the resource.
    #[prost(message, optional, tag = "1")]
    pub cm_enrollment: ::core::option::Option<CmEnrollment>,
}
/// The audit configuration for Compliance Manager.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuditConfig {
    /// Required. The list of destinations that can be selected for uploading audit
    /// reports to.
    #[prost(message, repeated, tag = "1")]
    pub destinations: ::prost::alloc::vec::Vec<audit_config::CmEligibleDestination>,
}
/// Nested message and enum types in `AuditConfig`.
pub mod audit_config {
    /// The destination details where audit reports are
    /// uploaded.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct CmEligibleDestination {
        /// Set of options for the report destination location.
        #[prost(oneof = "cm_eligible_destination::CmEligibleDestinations", tags = "1")]
        pub cm_eligible_destinations: ::core::option::Option<
            cm_eligible_destination::CmEligibleDestinations,
        >,
    }
    /// Nested message and enum types in `CmEligibleDestination`.
    pub mod cm_eligible_destination {
        /// Set of options for the report destination location.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum CmEligibleDestinations {
            /// The Cloud Storage bucket where audit reports and evidences can be
            /// uploaded. The format is `gs://{bucket_name}`.
            #[prost(string, tag = "1")]
            GcsBucket(::prost::alloc::string::String),
        }
    }
}
/// Generated client implementations.
pub mod cm_enrollment_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing CmEnrollment related RPCs for
    /// complianceManager.
    #[derive(Debug, Clone)]
    pub struct CmEnrollmentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CmEnrollmentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CmEnrollmentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CmEnrollmentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CmEnrollmentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Updates the Compliance Manager enrollment for a resource to facilitate
        /// an audit.
        /// Use this method to enroll a resource in Compliance Manager or to
        /// create or update feature-specific configurations.
        pub async fn update_cm_enrollment(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCmEnrollmentRequest>,
        ) -> std::result::Result<tonic::Response<super::CmEnrollment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.CmEnrollmentService/UpdateCmEnrollment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.CmEnrollmentService",
                        "UpdateCmEnrollment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Calculates the effective Compliance Manager enrollment for a resource.
        /// An effective enrollment is either a direct enrollment of a
        /// resource (if it exists), or an enrollment of the closest parent of a
        /// resource that's enrolled in Compliance Manager.
        pub async fn calculate_effective_cm_enrollment(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CalculateEffectiveCmEnrollmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::CalculateEffectiveCmEnrollmentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.CmEnrollmentService/CalculateEffectiveCmEnrollment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.CmEnrollmentService",
                        "CalculateEffectiveCmEnrollment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request message for \[ListFrameworks\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworksRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of frameworks to return. The default value is
    /// `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A pagination token returned from a previous request to list
    /// frameworks. Provide this token to retrieve the next page of results.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message for \[ListFrameworks\]\[\].
/// Returns a paginated list of Framework resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworksResponse {
    /// The list of framework resources.
    #[prost(message, repeated, tag = "1")]
    pub frameworks: ::prost::alloc::vec::Vec<Framework>,
    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for \[GetFramework\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkRequest {
    /// Required. The name of the framework to retrieve, in the format
    /// `organizations/{organization}/locations/{location}/frameworks/{framework_id}`
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The framework major version to retrieve. If not specified, the
    /// most recently updated `revision_id` is retrieved.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
}
/// The request message for \[CreateFramework\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The identifier (ID) of the framework. The ID is not the full name
    /// of the framework; it's the last part of the full name of the framework.
    #[prost(string, tag = "2")]
    pub framework_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub framework: ::core::option::Option<Framework>,
}
/// The request message for \[UpdateFramework\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFrameworkRequest {
    /// Optional. A field mask is used to specify the fields to be overwritten in
    /// the framework resource by the update. The fields specified in the
    /// `update_mask` are relative to the resource, not the full request. A field
    /// is overwritten if it is in the mask. If you don't provide a mask then all
    /// fields present in the request will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource that is being updated.
    #[prost(message, optional, tag = "2")]
    pub framework: ::core::option::Option<Framework>,
    /// Optional. The major version ID of the framework to update.
    #[prost(int64, tag = "3")]
    pub major_revision_id: i64,
}
/// Request message for \[DeleteFramework\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFrameworkRequest {
    /// Required. The name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/frameworks/{framework}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for \[ListCloudControls\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudControlsRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of cloud controls to return. The default value
    /// is `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A pagination token that's returned from a previous request to
    /// list cloud controls. Provide this token to retrieve the next page of
    /// results.
    ///
    /// When paginating, the parent that you provide to the
    /// \[ListCloudControls\]\[google.cloud.cloudsecuritycompliance.v1.Config.ListCloudControls\]
    /// request must match the call that provided the page token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// The response message for \[ListCloudControls\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudControlsResponse {
    /// The list of CloudControl resources.
    #[prost(message, repeated, tag = "1")]
    pub cloud_controls: ::prost::alloc::vec::Vec<CloudControl>,
    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for \[GetCloudControl\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudControlRequest {
    /// Required. The name of the cloud control to retrieve, in the format
    /// `organizations/{organization}/locations/{location}/cloudControls/{cloud_control}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The major version of the cloud control to retrieve. If not
    /// specified, the most recently updated `revision_id` is retrieved.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
}
/// The request message for \[CreateCloudControl\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudControlRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The identifier for the cloud control, which is the last segment
    /// of the cloud control name. The format is
    /// `^[a-zA-Z][a-zA-Z0-9-]{0,61}\[a-zA-Z0-9\]$`.
    #[prost(string, tag = "2")]
    pub cloud_control_id: ::prost::alloc::string::String,
    /// Required. The cloud control that's being created.
    #[prost(message, optional, tag = "3")]
    pub cloud_control: ::core::option::Option<CloudControl>,
}
/// The request message for \[UpdateCloudControl\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCloudControlRequest {
    /// Optional. Use a field mask to specify the fields to be overwritten in the
    /// cloud control during the update.
    /// The fields that you specify in the `update_mask` are relative to the
    /// cloud control, not the full request. A field is overwritten if it is in
    /// the mask. If you don't provide a mask, all fields in the request
    /// are updated.
    ///
    /// You can update the following fields:
    ///
    /// * Display name
    /// * Description
    /// * Parameters
    /// * Rules
    /// * Parameter specification
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The cloud control that you're updating.
    #[prost(message, optional, tag = "2")]
    pub cloud_control: ::core::option::Option<CloudControl>,
}
/// The request message for \[DeleteCloudControl\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCloudControlRequest {
    /// Required. The name of the cloud control to delete, in the format
    /// `organizations/{organization}/locations/{location}/CloudControls/{CloudControl}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod config_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Config Service manages compliance frameworks, cloud controls, and their
    /// configurations.
    #[derive(Debug, Clone)]
    pub struct ConfigClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConfigClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConfigClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConfigClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConfigClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the frameworks (both built-in and custom) that are available within
        /// the parent resource. The latest major version of each framework is
        /// returned.
        /// This method supports pagination.
        pub async fn list_frameworks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/ListFrameworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "ListFrameworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a framework.
        /// This method retrieves the latest major version of the framework.
        ///
        /// To retrieve a specific major version, include `major_revision_id` in
        /// the request.
        pub async fn get_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/GetFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "GetFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a custom framework in a given parent resource.
        /// You can't create built-in frameworks because those are managed by
        /// Google.
        pub async fn create_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/CreateFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "CreateFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a custom framework.
        /// This method allows for partial updates of a framework. Use the
        /// `update_mask` to specify which fields to update. Consider the following:
        ///
        /// * If you provide an `update_mask`, only the fields that are specified
        ///  in the mask are updated.
        /// * If you don't provide an `update_mask`, all the fields that are present
        ///  in the request's `framework` body are used to overwrite the existing
        ///  resource.
        ///
        /// You can only update frameworks with the `CUSTOM` type.
        /// A successful update creates a new version of the framework.
        pub async fn update_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/UpdateFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "UpdateFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a custom framework, including all its major and
        /// minor revisions. Consider the following:
        ///
        /// * You can't delete built-in frameworks. You can only delete frameworks
        ///  with type `CUSTOM`.
        /// * You can't delete frameworks that are deployed to a resource.
        /// * You can't restore a deleted framework. This action is permanent.
        pub async fn delete_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/DeleteFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "DeleteFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the cloud controls (both built-in and custom) that are available
        /// in a given parent resource. The latest major version of each cloud control
        /// is returned.
        /// This method supports pagination.
        pub async fn list_cloud_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudControlsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudControlsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/ListCloudControls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "ListCloudControls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a cloud control.
        /// This method retrieves the latest major version of a cloud control that
        /// you identify by name.
        ///
        /// By default, the latest major version of the cloud control is returned.
        /// To retrieve a specific major version, include `major_revision_id` in
        /// the request.
        pub async fn get_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/GetCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "GetCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a custom cloud control in a given parent
        /// resource.
        /// You can't create built-in cloud controls because those are managed by
        /// Google.
        pub async fn create_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/CreateCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "CreateCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a custom cloud control.
        /// This method allows for partial updates of a cloud control. Use the
        /// `update_mask` to specify which fields to update. Consider the following:
        ///
        /// * If you provide an `update_mask`, only the fields that are specified
        ///  in the mask are updated.
        /// * If you don't provide an `update_mask`, all the fields that are present
        ///  in the request's `cloud_control` body are used to overwrite the existing
        ///  resource.
        ///
        /// You can only update cloud controls with the `CUSTOM` type.
        /// A successful update creates a new version of the cloud control.
        pub async fn update_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/UpdateCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "UpdateCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a custom cloud control, including all its
        /// major and minor revisions. Consider the following:
        ///
        /// * You can't delete built-in cloud controls. You can only delete cloud
        ///  controls with type `CUSTOM`.
        /// * You can't delete cloud controls if any of the versions are referenced
        ///  by a framework.
        /// * You can't restore a deleted cloud control. This action is permanent.
        pub async fn delete_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/DeleteCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "DeleteCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Framework deployments represent the assignment of a framework to a target
/// resource. Supported target resources are organizations, folders, and
/// projects.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkDeployment {
    /// Identifier. The name of the framework deployment, in the format
    /// `organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The details of the target resource that you want to deploy the
    /// framework to. You can specify an existing resource, or create a new one.
    #[prost(message, optional, tag = "2")]
    pub target_resource_config: ::core::option::Option<TargetResourceConfig>,
    /// Output only. The target resource to deploy the framework to, in one  the
    /// following formats:
    ///
    /// * `organizations/{organizationID}`
    /// * `folders/{folderID}`
    /// * `projects/{projectID}`
    #[prost(string, tag = "3")]
    pub computed_target_resource: ::prost::alloc::string::String,
    /// Required. A reference to the framework that you're deploying.
    #[prost(message, optional, tag = "4")]
    pub framework: ::core::option::Option<FrameworkReference>,
    /// Optional. A user-provided description of the framework deployment.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Required. The deployment mode and parameters for each of the cloud controls
    /// in the framework. Every cloud control in the framework includes metadata.
    #[prost(message, repeated, tag = "6")]
    pub cloud_control_metadata: ::prost::alloc::vec::Vec<CloudControlMetadata>,
    /// Output only. The state for the framework deployment.
    #[prost(enumeration = "DeploymentState", tag = "7")]
    pub deployment_state: i32,
    /// Output only. The time at which the resource was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the resource last updated.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a framework deployment. You can also
    /// provide the `etag` when you delete a framework deployment, to help
    /// ensure that you're deleting the intended version of the
    /// framework deployment.
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The display name of the target resource.
    #[prost(string, tag = "13")]
    pub target_resource_display_name: ::prost::alloc::string::String,
    /// Output only. The references to the cloud control deployments. The reference
    /// includes all the cloud control deployments that are in the framework or in
    /// a cloud control group.
    ///
    /// For example, if a framework deployment deploys two
    /// cloud controls, `cc-deployment-1` and `cc-deployment-2`, then the
    /// references are:
    ///
    /// ```text,
    /// {
    /// cloud_control_deployment_reference: {
    ///    cloud_control_deployment:
    ///    "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-1"
    /// },
    /// cloud_control_deployment_reference: {
    ///   cloud_control_deployment:
    ///   "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-2"
    /// }
    /// ```
    #[prost(message, repeated, tag = "14")]
    pub cloud_control_deployment_references: ::prost::alloc::vec::Vec<
        CloudControlDeploymentReference,
    >,
}
/// A cloud control deployment represents the deployment of a particular cloud
/// control on a target resource. Supported target resources are
/// `organizations/{organizationID}`, `folders/{folderID}`, and
/// `projects/{projectID}`.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlDeployment {
    /// Identifier. The name for the cloud control deployment, in the format
    /// `organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The details of the target resource that the cloud control is
    /// deployed You can use an existing target resource or create a new target.
    #[prost(message, optional, tag = "2")]
    pub target_resource_config: ::core::option::Option<TargetResourceConfig>,
    /// Output only. The resource that the cloud control is deployed on, in one of
    /// the following formats:
    ///
    /// * `organizations/{organizationID}`
    /// * `folders/{folderID}`
    /// * `projects/{projectID}`
    #[prost(string, tag = "3")]
    pub target_resource: ::prost::alloc::string::String,
    /// Required. The deployment mode and parameters for the cloud control.
    #[prost(message, optional, tag = "4")]
    pub cloud_control_metadata: ::core::option::Option<CloudControlMetadata>,
    /// Optional. A friendly description for the cloud control deployment.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The state of the cloud control deployment.
    #[prost(enumeration = "DeploymentState", tag = "6")]
    pub deployment_state: i32,
    /// Output only. The time when the resource was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the resource was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. To prevent concurrent updates from overwriting each other,
    /// provide the `etag` when you update a cloud control deployment. You can also
    /// provide the `etag` when you delete a cloud control deployment to help
    /// ensure that you're deleting the intended version of the
    /// deployment.
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The cloud control after the given parameters are substituted.
    #[prost(message, optional, tag = "10")]
    pub parameter_substituted_cloud_control: ::core::option::Option<CloudControl>,
    /// Output only. The references to the framework deployments that this cloud
    /// control deployment is part of. A cloud control deployment can be part of
    /// multiple framework deployments.
    #[prost(message, repeated, tag = "11")]
    pub framework_deployment_references: ::prost::alloc::vec::Vec<
        FrameworkDeploymentReference,
    >,
    /// Output only. The display name of the target resource.
    #[prost(string, tag = "12")]
    pub target_resource_display_name: ::prost::alloc::string::String,
}
/// The name of the target resource or the configuration that's required to
/// create a new target resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceConfig {
    /// The resource configuration for the target resource.
    #[prost(oneof = "target_resource_config::ResourceConfig", tags = "1, 2")]
    pub resource_config: ::core::option::Option<target_resource_config::ResourceConfig>,
}
/// Nested message and enum types in `TargetResourceConfig`.
pub mod target_resource_config {
    /// The resource configuration for the target resource.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ResourceConfig {
        /// Optional. The resource hierarchy node, in one of the following formats:
        ///
        /// * `organizations/{organizationID}`
        /// * `folders/{folderID}`
        /// * `projects/{projectID}`
        #[prost(string, tag = "1")]
        ExistingTargetResource(::prost::alloc::string::String),
        /// Optional. The details that are required to create a resource and use
        /// that resource as the target resource for deployment.
        #[prost(message, tag = "2")]
        TargetResourceCreationConfig(super::TargetResourceCreationConfig),
    }
}
/// The configuration that's required to create a target resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceCreationConfig {
    /// The configuration that's required to create the target resource.
    #[prost(
        oneof = "target_resource_creation_config::ResourceCreationConfig",
        tags = "1, 2"
    )]
    pub resource_creation_config: ::core::option::Option<
        target_resource_creation_config::ResourceCreationConfig,
    >,
}
/// Nested message and enum types in `TargetResourceCreationConfig`.
pub mod target_resource_creation_config {
    /// The configuration that's required to create the target resource.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ResourceCreationConfig {
        /// Optional. The configuration that's required to create a folder.
        #[prost(message, tag = "1")]
        FolderCreationConfig(super::FolderCreationConfig),
        /// Optional. The configuration that's required to create a project.
        #[prost(message, tag = "2")]
        ProjectCreationConfig(super::ProjectCreationConfig),
    }
}
/// The configuration that's required to create a folder to be used
/// as the target resource for a deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FolderCreationConfig {
    /// Required. The parent of the folder, in the format
    /// `organizations/{organizationID}` or `folders/{folderID}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The display name of the folder.
    #[prost(string, tag = "2")]
    pub folder_display_name: ::prost::alloc::string::String,
}
/// The configuration that's required to create a project to be used
/// as the target resource of a deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProjectCreationConfig {
    /// Required. The parent of the project, in the format
    /// `organizations/{organizationID}` or `folders/{folderID}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The display name of the project.
    #[prost(string, tag = "2")]
    pub project_display_name: ::prost::alloc::string::String,
    /// Required. The billing account ID for the project.
    #[prost(string, tag = "3")]
    pub billing_account_id: ::prost::alloc::string::String,
}
/// The enforcement mode and parameters of a cloud
/// control deployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlMetadata {
    /// Required. The cloud control name and parameters.
    #[prost(message, optional, tag = "1")]
    pub cloud_control_details: ::core::option::Option<CloudControlDetails>,
    /// Required. The enforcement mode of the cloud control.
    #[prost(enumeration = "EnforcementMode", tag = "2")]
    pub enforcement_mode: i32,
}
/// The request message for \[CreateFrameworkDeployment\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkDeploymentRequest {
    /// Required. The parent resource of the framework deployment in the format
    /// `organizations/{organization}/locations/{location}`.
    /// Only the global location is supported.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. An identifier for the framework deployment that's unique in scope
    /// of the parent. If you don't specify a value, then a random UUID is
    /// generated.
    #[prost(string, tag = "2")]
    pub framework_deployment_id: ::prost::alloc::string::String,
    /// Required. The framework deployment that you're creating.
    #[prost(message, optional, tag = "3")]
    pub framework_deployment: ::core::option::Option<FrameworkDeployment>,
}
/// The request message for \[DeleteFrameworkDeployment\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFrameworkDeploymentRequest {
    /// Required. The name of the framework deployment that you want to delete,
    /// in the format
    /// `organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An opaque identifier for the current version of the resource.
    ///
    /// If you provide this value, then it must match the existing value. If the
    /// values don't match, then the request fails with an
    /// \[`ABORTED`\]\[google.rpc.Code.ABORTED\] error.
    ///
    /// If you omit this value, then the resource is deleted regardless of its
    /// current `etag` value.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// The request message for \[GetFrameworkDeployment\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkDeploymentRequest {
    /// Required. The name of the framework deployment, in the format
    /// `organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for \[ListFrameworkDeployments\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworkDeploymentsRequest {
    /// Required. The parent resource of the framework deployment, in the format
    /// `organizations/{organization}/locations/{location}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The requested page size. The server might return fewer items than
    /// requested.
    /// If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token that identifies a page of results the server should
    /// return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The filter to be applied on the resource, as defined by
    /// [AIP-160: Filtering](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The sort order for the results. The following values are
    /// supported:
    ///
    /// * `name`
    /// * `name desc`
    ///
    /// If you do not specify a value, then the results are not sorted.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response message for \[ListFrameworkDeployments\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworkDeploymentsResponse {
    /// The list of framework deployments.
    #[prost(message, repeated, tag = "1")]
    pub framework_deployments: ::prost::alloc::vec::Vec<FrameworkDeployment>,
    /// A token that identifies the next page of results that the server
    /// should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for \[GetCloudControlDeployment\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudControlDeploymentRequest {
    /// Required. The name for the cloud control deployment, in the format
    /// `organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// The request message for \[ListCloudControlDeployments\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudControlDeploymentsRequest {
    /// Required. The parent resource for the cloud control deployment, in the
    /// format `organizations/{organization}/locations/{location}`. The only
    /// supported location is `global`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The requested page size. The server might return fewer items than
    /// you requested.
    /// If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token that identifies the page of results that the server
    /// should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The filter to apply on the resource, as defined by
    /// [AIP-160: Filtering](<https://google.aip.dev/160>).
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The sort order for the results. The following values are
    /// supported:
    ///
    /// * `name`
    /// * `name desc`
    ///
    /// If you do not specify a value, then the results are not sorted.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response message for \[ListCloudControlDeployments\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudControlDeploymentsResponse {
    /// The list of cloud control deployments.
    #[prost(message, repeated, tag = "1")]
    pub cloud_control_deployments: ::prost::alloc::vec::Vec<CloudControlDeployment>,
    /// A token that identifies the next page of results that the server
    /// should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The reference to a cloud control deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudControlDeploymentReference {
    /// Output only. The name of the CloudControlDeployment. The format is
    /// `organizations/{org}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub cloud_control_deployment: ::prost::alloc::string::String,
}
/// The reference to a framework deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkDeploymentReference {
    /// Output only. The name of the framework deployment, in the format
    /// `organizations/{org}/locations/{location}/frameworkDeployments/{framework_deployment_id}`.
    /// The only supported location is `global`.
    #[prost(string, tag = "1")]
    pub framework_deployment: ::prost::alloc::string::String,
    /// Optional. The reference to the framework that this deployment is for.
    /// For example:
    ///
    /// ```text,
    /// {
    ///   framework:
    ///   "organizations/{org}/locations/{location}/frameworks/{framework}",
    ///   major_revision_id: 1
    /// }
    /// ```
    ///
    /// The only supported location is `global`.
    #[prost(message, optional, tag = "2")]
    pub framework_reference: ::core::option::Option<FrameworkReference>,
    /// Optional. The display name of the framework that this framework deployment
    /// is for.
    #[prost(string, tag = "3")]
    pub framework_display_name: ::prost::alloc::string::String,
}
/// The state of the deployment resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentState {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Validating the deployment.
    Validating = 1,
    /// Deployment is being created.
    Creating = 2,
    /// Deployment is being deleted.
    Deleting = 3,
    /// Deployment has failed. All the changes made by the deployment were
    /// successfully rolled back. You can retry or delete a deployment that's
    /// in this state.
    Failed = 4,
    /// Deployment is successful and ready to use.
    Ready = 5,
    /// Deployment is partially deployed. All the cloud controls weren't deployed
    /// successfully. Retrying the operation resumes from the first failed
    /// step.
    PartiallyDeployed = 6,
    /// Deployment is partially deleted. All the cloud control deployments weren't
    /// deleted successfully. Retrying the operation resumes from the first
    /// failed step.
    PartiallyDeleted = 7,
}
impl DeploymentState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_STATE_UNSPECIFIED",
            Self::Validating => "DEPLOYMENT_STATE_VALIDATING",
            Self::Creating => "DEPLOYMENT_STATE_CREATING",
            Self::Deleting => "DEPLOYMENT_STATE_DELETING",
            Self::Failed => "DEPLOYMENT_STATE_FAILED",
            Self::Ready => "DEPLOYMENT_STATE_READY",
            Self::PartiallyDeployed => "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED",
            Self::PartiallyDeleted => "DEPLOYMENT_STATE_PARTIALLY_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_STATE_VALIDATING" => Some(Self::Validating),
            "DEPLOYMENT_STATE_CREATING" => Some(Self::Creating),
            "DEPLOYMENT_STATE_DELETING" => Some(Self::Deleting),
            "DEPLOYMENT_STATE_FAILED" => Some(Self::Failed),
            "DEPLOYMENT_STATE_READY" => Some(Self::Ready),
            "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED" => Some(Self::PartiallyDeployed),
            "DEPLOYMENT_STATE_PARTIALLY_DELETED" => Some(Self::PartiallyDeleted),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod deployment_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Deployment service allows users to manage deployments of Frameworks and
    /// Cloud Controls on a target resource.
    #[derive(Debug, Clone)]
    pub struct DeploymentClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeploymentClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeploymentClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeploymentClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeploymentClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a framework deployment in a given parent resource. A
        /// framework deployment lets you assign a particular framework version to an
        /// organization, folder, or project so that you can control and monitor
        /// those resources using the framework's cloud controls.
        pub async fn create_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/CreateFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "CreateFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a framework deployment.
        pub async fn delete_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/DeleteFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "DeleteFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a framework deployment.
        pub async fn get_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FrameworkDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/GetFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "GetFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the framework deployments in a given parent resource.
        pub async fn list_framework_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworkDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworkDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/ListFrameworkDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "ListFrameworkDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details about a cloud control deployment.
        pub async fn get_cloud_control_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudControlDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloudControlDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/GetCloudControlDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "GetCloudControlDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the cloud conrol deployments in a given parent resource.
        pub async fn list_cloud_control_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudControlDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudControlDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/ListCloudControlDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "ListCloudControlDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// The request message for
/// \[ListFrameworkComplianceSummariesRequest\]\[google.cloud.cloudsecuritycompliance.v1.ListFrameworkComplianceSummariesRequest\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworkComplianceSummariesRequest {
    /// Required. The parent scope for the framework compliance summary.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The requested page size. The server might return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token that identifies the page of results that the server
    /// should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// The response message for
/// \[ListFrameworkComplianceSummariesResponse\]\[google.cloud.cloudsecuritycompliance.v1.ListFrameworkComplianceSummariesResponse\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworkComplianceSummariesResponse {
    /// The list of framework compliance summaries.
    #[prost(message, repeated, tag = "1")]
    pub framework_compliance_summaries: ::prost::alloc::vec::Vec<
        FrameworkComplianceSummary,
    >,
    /// Output only. The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The response message for \[GetFrameworkComplianceReport\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkComplianceReport {
    /// The name of the framework.
    #[prost(string, tag = "1")]
    pub framework: ::prost::alloc::string::String,
    /// The description of the framework.
    #[prost(string, tag = "2")]
    pub framework_description: ::prost::alloc::string::String,
    /// Output only. The last updated time of the report.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The control assessment details of the framework.
    #[prost(message, optional, tag = "4")]
    pub control_assessment_details: ::core::option::Option<ControlAssessmentDetails>,
    /// The type of framework.
    #[prost(enumeration = "framework::FrameworkType", tag = "5")]
    pub framework_type: i32,
    /// The list of cloud providers supported by the framework.
    #[prost(enumeration = "CloudProvider", repeated, tag = "6")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// The list of framework categories supported.
    #[prost(enumeration = "FrameworkCategory", repeated, tag = "7")]
    pub framework_categories: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The display name for the framework.
    #[prost(string, tag = "8")]
    pub framework_display_name: ::prost::alloc::string::String,
    /// Identifier. The name of the framework compliance report.
    #[prost(string, tag = "9")]
    pub name: ::prost::alloc::string::String,
    /// The latest major revision ID of the framework.
    #[prost(int64, tag = "10")]
    pub major_revision_id: i64,
    /// The latest minor revision ID of the latest major revision of the framework.
    #[prost(int64, tag = "11")]
    pub minor_revision_id: i64,
    /// The target resource details of the framework.
    #[prost(message, repeated, tag = "12")]
    pub target_resource_details: ::prost::alloc::vec::Vec<TargetResourceDetails>,
}
/// The request message for \[FetchFrameworkComplianceReport\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FetchFrameworkComplianceReportRequest {
    /// Required. The name of the framework compliance report to retrieve.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The end time of the report.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The request message for \[ListFindingSummaries\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFindingSummariesRequest {
    /// Required. The parent scope for the framework overview page.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The requested page size. The server might return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token that identifies the page of results that the server
    /// should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The filtering results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. The end time of the finding summary.
    #[deprecated]
    #[prost(message, optional, tag = "5")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The response message for \[ListFindingSummaries\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFindingSummariesResponse {
    /// List of finding summary by category.
    #[prost(message, repeated, tag = "1")]
    pub finding_summaries: ::prost::alloc::vec::Vec<FindingSummary>,
    /// Output only. The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for \[ListControlComplianceSummaries\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListControlComplianceSummariesRequest {
    /// Required. The parent scope for the framework overview page.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The end time of the control compliance summary.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The requested page size. The server might return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A token that identifies the page of results that the server
    /// should return.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The filtering results.
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// The response message for \[ListControlComplianceSummaries\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlComplianceSummariesResponse {
    /// The list of control compliance details.
    #[prost(message, repeated, tag = "1")]
    pub control_compliance_summaries: ::prost::alloc::vec::Vec<ControlComplianceSummary>,
    /// Output only. The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The request message for \[AggregateFrameworkComplianceReport\]\[\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AggregateFrameworkComplianceReportRequest {
    /// Required. The name of the aggregated compliance report over time to
    /// retrieve.
    ///
    /// The supported format is:
    /// `organizations/{organization_id}/locations/{location}/frameworkComplianceReports/{framework_compliance_report}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The start and end time range for the aggregated compliance
    /// report.
    #[prost(message, optional, tag = "2")]
    pub interval: ::core::option::Option<super::super::super::r#type::Interval>,
    /// Optional. The filtering results.
    #[prost(string, tag = "3")]
    pub filter: ::prost::alloc::string::String,
}
/// The response message for \[AggregateFrameworkComplianceReport\]\[\].
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregateFrameworkComplianceReportResponse {
    /// The list of aggregated compliance reports.
    #[prost(message, repeated, tag = "1")]
    pub aggregated_compliance_reports: ::prost::alloc::vec::Vec<
        AggregatedComplianceReport,
    >,
}
/// The details for a control assessment.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlAssessmentDetails {
    /// The number of controls that are passing or not assessed.
    #[prost(int32, tag = "1")]
    pub passing_controls: i32,
    /// The number of controls that are failing.
    #[prost(int32, tag = "2")]
    pub failing_controls: i32,
    /// The number of controls that were assessed and are passing.
    #[prost(int32, tag = "3")]
    pub assessed_passing_controls: i32,
    /// The number of controls that aren't assessed because they require manual
    /// review.
    #[prost(int32, tag = "4")]
    pub not_assessed_controls: i32,
}
/// The details for a framework compliance summary.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkComplianceSummary {
    /// The name of the framework.
    #[prost(string, tag = "1")]
    pub framework: ::prost::alloc::string::String,
    /// The control assessment details of the framework.
    #[prost(message, optional, tag = "2")]
    pub control_assessment_details: ::core::option::Option<ControlAssessmentDetails>,
    /// The type of framework.
    #[prost(enumeration = "framework::FrameworkType", tag = "3")]
    pub framework_type: i32,
    /// The list of cloud providers supported by the framework.
    #[prost(enumeration = "CloudProvider", repeated, tag = "4")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// The list of framework categories supported by the framework.
    #[prost(enumeration = "FrameworkCategory", repeated, tag = "5")]
    pub framework_categories: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The display name for the framework.
    #[prost(string, tag = "6")]
    pub framework_display_name: ::prost::alloc::string::String,
    /// Identifier. The name of the framework compliance summary.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    /// The major revision ID of the framework.
    #[prost(int64, tag = "8")]
    pub major_revision_id: i64,
    /// The minor revision ID of the framework.
    #[prost(int64, tag = "9")]
    pub minor_revision_id: i64,
    /// The target resource details for the framework.
    #[prost(message, repeated, tag = "10")]
    pub target_resource_details: ::prost::alloc::vec::Vec<TargetResourceDetails>,
}
/// The details for a finding.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FindingSummary {
    /// The category of the finding.
    #[prost(string, tag = "1")]
    pub finding_category: ::prost::alloc::string::String,
    /// The class of the finding.
    #[prost(enumeration = "FindingClass", tag = "2")]
    pub finding_class: i32,
    /// The severity of the finding.
    #[prost(enumeration = "Severity", tag = "3")]
    pub severity: i32,
    /// The count of the finding.
    #[prost(int64, tag = "4")]
    pub finding_count: i64,
    /// Output only. The last updated time of the finding.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. The list of compliance frameworks that the finding belongs to.
    #[prost(string, repeated, tag = "6")]
    pub related_frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Identifier. The name of the finding summary.
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
}
/// The details for control compliance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ControlComplianceSummary {
    /// The name of the control.
    #[prost(string, tag = "1")]
    pub control: ::prost::alloc::string::String,
    /// The display name of the control.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The description of the control.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The overall evaluation status of the control.
    #[prost(enumeration = "EvaluationState", tag = "4")]
    pub overall_evaluation_state: i32,
    /// The total number of findings for the control.
    #[prost(int32, tag = "5")]
    pub total_findings_count: i32,
    /// The list of compliance frameworks that the control belongs to.
    #[prost(string, repeated, tag = "6")]
    pub compliance_frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The list of similar controls.
    #[prost(message, repeated, tag = "7")]
    pub similar_controls: ::prost::alloc::vec::Vec<SimilarControls>,
    /// The list of cloud control reports.
    #[prost(message, repeated, tag = "8")]
    pub cloud_control_reports: ::prost::alloc::vec::Vec<CloudControlReport>,
    /// The responsibility type for the control.
    #[prost(enumeration = "RegulatoryControlResponsibilityType", tag = "9")]
    pub control_responsibility_type: i32,
    /// Whether the control is a fake control. Fake controls are created
    /// and mapped to cloud controls that don't belong to a control group.
    #[prost(bool, tag = "10")]
    pub is_fake_control: bool,
    /// Identifier. The name of the control compliance summary.
    #[prost(string, tag = "11")]
    pub name: ::prost::alloc::string::String,
}
/// The cloud control report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlReport {
    /// The name of the cloud control.
    #[prost(string, tag = "1")]
    pub cloud_control: ::prost::alloc::string::String,
    /// The display name of the cloud control.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// The description of the cloud control.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// The list of categories for the cloud control.
    #[prost(string, repeated, tag = "6")]
    pub categories: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The list of similar controls.
    #[prost(message, repeated, tag = "9")]
    pub similar_controls: ::prost::alloc::vec::Vec<SimilarControls>,
    /// The type of the cloud control.
    #[prost(enumeration = "cloud_control::Type", tag = "10")]
    pub cloud_control_type: i32,
    /// The category of the finding.
    #[prost(string, tag = "11")]
    pub finding_category: ::prost::alloc::string::String,
    /// The list of rules that correspond to the cloud control.
    #[prost(message, repeated, tag = "12")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    /// The severity of the finding.
    #[prost(enumeration = "Severity", tag = "15")]
    pub finding_severity: i32,
    /// The enforcement mode of the cloud control.
    #[prost(enumeration = "EnforcementMode", tag = "16")]
    pub enforcement_mode: i32,
    /// The name of the cloud control deployment.
    #[prost(string, tag = "17")]
    pub cloud_control_deployment: ::prost::alloc::string::String,
    /// The major revision ID of the cloud control.
    #[prost(int64, tag = "18")]
    pub major_revision_id: i64,
    /// The minor revision ID of the cloud control.
    #[prost(int64, tag = "19")]
    pub minor_revision_id: i64,
    /// The major revision IDs of the frameworks that the cloud control belongs to.
    #[prost(int64, repeated, tag = "20")]
    pub framework_major_revision_ids: ::prost::alloc::vec::Vec<i64>,
    /// The assessment details of the cloud control.
    #[prost(oneof = "cloud_control_report::AssessmentDetails", tags = "13, 14")]
    pub assessment_details: ::core::option::Option<
        cloud_control_report::AssessmentDetails,
    >,
}
/// Nested message and enum types in `CloudControlReport`.
pub mod cloud_control_report {
    /// The assessment details of the cloud control.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum AssessmentDetails {
        /// The details of a manual cloud control assessment.
        #[prost(message, tag = "13")]
        ManualCloudControlAssessmentDetails(super::ManualCloudControlAssessmentDetails),
        /// The details of a cloud control assessment.
        #[prost(message, tag = "14")]
        CloudControlAssessmentDetails(super::CloudControlAssessmentDetails),
    }
}
/// The details for a manual cloud control assessment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ManualCloudControlAssessmentDetails {
    /// The guide for assessing a cloud control manually.
    #[prost(string, repeated, tag = "1")]
    pub manual_cloud_control_guide: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// The cloud control assessment details for non-manual cloud controls.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudControlAssessmentDetails {
    /// The number of findings for the cloud control.
    #[prost(int32, tag = "1")]
    pub findings_count: i32,
    /// Output only. The evaluation status of the cloud control.
    #[prost(enumeration = "EvaluationState", tag = "2")]
    pub evaluation_state: i32,
}
/// The similar controls.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimilarControls {
    /// The name of the framework.
    #[prost(string, tag = "1")]
    pub framework: ::prost::alloc::string::String,
    /// The ID of the control.
    #[prost(string, tag = "2")]
    pub control_id: ::prost::alloc::string::String,
}
/// The aggregated compliance report.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AggregatedComplianceReport {
    /// The control assessment details of the framework.
    #[prost(message, optional, tag = "1")]
    pub control_assessment_details: ::core::option::Option<ControlAssessmentDetails>,
    /// The report time of the aggregated compliance report.
    #[prost(message, optional, tag = "2")]
    pub report_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// The details for a target resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceDetails {
    /// The framework deployment name for the target resource.
    ///
    /// For example,
    /// `organizations/{organization_id}/locations/{location}/frameworkDeployments/{framework_deployment_id}`
    #[prost(string, tag = "1")]
    pub framework_deployment: ::prost::alloc::string::String,
    /// The display name of the target resource. For example, `google.com`,
    /// `staging-project`, or `development-folder`.
    #[prost(string, tag = "2")]
    pub target_resource_display_name: ::prost::alloc::string::String,
    /// The target resource. For example, `organizations/1234567890`,
    /// `projects/1234567890`, or `folders/1234567890`.
    #[prost(string, tag = "3")]
    pub target_resource: ::prost::alloc::string::String,
    /// The create time of the target resource.
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The update time of the target resource.
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The major revision ID of the framework for the target resource.
    #[prost(int64, tag = "6")]
    pub major_revision_id: i64,
    /// The minor revision ID of the framework for the target resource.
    #[prost(int64, tag = "7")]
    pub minor_revision_id: i64,
}
/// The evaluation state of the control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EvaluationState {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The control is passing.
    Passed = 1,
    /// The control is failing.
    Failed = 2,
    /// The control is not assessed.
    NotAssessed = 3,
}
impl EvaluationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "EVALUATION_STATE_UNSPECIFIED",
            Self::Passed => "EVALUATION_STATE_PASSED",
            Self::Failed => "EVALUATION_STATE_FAILED",
            Self::NotAssessed => "EVALUATION_STATE_NOT_ASSESSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EVALUATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "EVALUATION_STATE_PASSED" => Some(Self::Passed),
            "EVALUATION_STATE_FAILED" => Some(Self::Failed),
            "EVALUATION_STATE_NOT_ASSESSED" => Some(Self::NotAssessed),
            _ => None,
        }
    }
}
/// A finding is a record of assessment data like security, risk, health, or
/// privacy.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FindingClass {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The activity is unwanted or malicious.
    Threat = 1,
    /// A potential weakness in software that increases risk to
    /// confidentiality, integrity, and availability.
    Vulnerability = 2,
    /// A potential weakness in a cloud resource or asset configuration that
    /// increases risk.
    Misconfiguration = 3,
    /// A security observation that is for informational purposes.
    Observation = 4,
    /// An error that prevents Security Command Center from functioning properly.
    SccError = 5,
    /// A potential security risk that's due to a change in the security
    /// posture.
    PostureViolation = 6,
    /// A combination of security issues that represent a more severe
    /// security problem when taken together.
    ToxicCombination = 7,
    /// A potential security risk to data assets that contain sensitive
    /// data.
    SensitiveDataRisk = 8,
    /// A resource or resource group where high risk attack paths
    /// converge, based on attack path simulations (APS).
    Chokepoint = 9,
}
impl FindingClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FINDING_CLASS_UNSPECIFIED",
            Self::Threat => "THREAT",
            Self::Vulnerability => "VULNERABILITY",
            Self::Misconfiguration => "MISCONFIGURATION",
            Self::Observation => "OBSERVATION",
            Self::SccError => "SCC_ERROR",
            Self::PostureViolation => "POSTURE_VIOLATION",
            Self::ToxicCombination => "TOXIC_COMBINATION",
            Self::SensitiveDataRisk => "SENSITIVE_DATA_RISK",
            Self::Chokepoint => "CHOKEPOINT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FINDING_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
            "THREAT" => Some(Self::Threat),
            "VULNERABILITY" => Some(Self::Vulnerability),
            "MISCONFIGURATION" => Some(Self::Misconfiguration),
            "OBSERVATION" => Some(Self::Observation),
            "SCC_ERROR" => Some(Self::SccError),
            "POSTURE_VIOLATION" => Some(Self::PostureViolation),
            "TOXIC_COMBINATION" => Some(Self::ToxicCombination),
            "SENSITIVE_DATA_RISK" => Some(Self::SensitiveDataRisk),
            "CHOKEPOINT" => Some(Self::Chokepoint),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod monitoring_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct MonitoringClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MonitoringClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MonitoringClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MonitoringClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MonitoringClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists the framework compliance summary for a given scope.
        pub async fn list_framework_compliance_summaries(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListFrameworkComplianceSummariesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworkComplianceSummariesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Monitoring/ListFrameworkComplianceSummaries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Monitoring",
                        "ListFrameworkComplianceSummaries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the finding summary by category for a given scope.
        pub async fn list_finding_summaries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFindingSummariesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFindingSummariesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Monitoring/ListFindingSummaries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Monitoring",
                        "ListFindingSummaries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches the framework compliance report for a given scope.
        pub async fn fetch_framework_compliance_report(
            &mut self,
            request: impl tonic::IntoRequest<
                super::FetchFrameworkComplianceReportRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FrameworkComplianceReport>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Monitoring/FetchFrameworkComplianceReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Monitoring",
                        "FetchFrameworkComplianceReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the control compliance summary for a given scope.
        pub async fn list_control_compliance_summaries(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListControlComplianceSummariesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListControlComplianceSummariesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Monitoring/ListControlComplianceSummaries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Monitoring",
                        "ListControlComplianceSummaries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the aggregated compliance report over time for a given scope.
        pub async fn aggregate_framework_compliance_report(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregateFrameworkComplianceReportRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::AggregateFrameworkComplianceReportResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Monitoring/AggregateFrameworkComplianceReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Monitoring",
                        "AggregateFrameworkComplianceReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
