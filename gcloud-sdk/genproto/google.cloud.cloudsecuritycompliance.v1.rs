// This file is @generated by prost-build.
/// A Framework is a collection of CloudControls to address security and
/// compliance requirements. Frameworks can be used for prevention, detection,
/// and auditing. They can be either built-in, industry-standard frameworks
/// provided by GCP/AZURE/AWS (e.g., NIST, FedRAMP) or custom frameworks created
/// by users.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Framework {
    /// Required. Identifier. The name of the framework.
    /// Format:
    /// organizations/{organization}/locations/{location}/frameworks/{framework_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Major revision of the framework incremented in ascending
    /// order.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. Display name of the framework. The maximum length is 200
    /// characters.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the framework. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The type of the framework. The default is TYPE_CUSTOM.
    #[prost(enumeration = "framework::FrameworkType", tag = "6")]
    pub r#type: i32,
    /// Optional. The details of the cloud controls directly added without any
    /// grouping in the framework.
    #[prost(message, repeated, tag = "8")]
    pub cloud_control_details: ::prost::alloc::vec::Vec<CloudControlDetails>,
    /// Optional. The category of the framework.
    #[prost(enumeration = "FrameworkCategory", repeated, packed = "false", tag = "9")]
    pub category: ::prost::alloc::vec::Vec<i32>,
    /// Output only. cloud providers supported
    #[prost(enumeration = "CloudProvider", repeated, packed = "false", tag = "10")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// Output only. target resource types supported by the Framework.
    #[prost(enumeration = "TargetResourceType", repeated, packed = "false", tag = "11")]
    pub supported_target_resource_types: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The supported enforcement modes of the framework.
    #[prost(enumeration = "EnforcementMode", repeated, packed = "false", tag = "13")]
    pub supported_enforcement_modes: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `Framework`.
pub mod framework {
    /// The type of the framework.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrameworkType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// The framework is a built-in framework if it is created and managed by
        /// GCP.
        BuiltIn = 1,
        /// The framework is a custom framework if it is created and managed by the
        /// user.
        Custom = 2,
    }
    impl FrameworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FRAMEWORK_TYPE_UNSPECIFIED",
                Self::BuiltIn => "BUILT_IN",
                Self::Custom => "CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FRAMEWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BUILT_IN" => Some(Self::BuiltIn),
                "CUSTOM" => Some(Self::Custom),
                _ => None,
            }
        }
    }
}
/// CloudControlDetails contains the details of a CloudControl.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlDetails {
    /// Required. The name of the CloudControl in the format:
    /// “organizations/{organization}/locations/{location}/
    /// cloudControls/{cloud-control}”
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Major revision of cloudcontrol
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. Parameters is a key-value pair that is required by the
    /// CloudControl. The specification of these parameters will be present in
    /// cloudcontrol.Eg: { "name": "location","value": "us-west-1"}.
    #[prost(message, repeated, tag = "4")]
    pub parameters: ::prost::alloc::vec::Vec<Parameter>,
}
/// FrameworkReference contains the reference of a framework.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkReference {
    /// Required. In the format:
    /// organizations/{org}/locations/{location}/frameworks/{framework}
    #[prost(string, tag = "1")]
    pub framework: ::prost::alloc::string::String,
    /// Optional. Major revision id of the framework. If not specified, corresponds
    /// to the latest revision of the framework.
    #[prost(int64, optional, tag = "2")]
    pub major_revision_id: ::core::option::Option<i64>,
}
/// Parameters is a key-value pair.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Parameter {
    /// Required. The name of the parameter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The value of the parameter
    #[prost(message, optional, boxed, tag = "2")]
    pub parameter_value: ::core::option::Option<::prost::alloc::boxed::Box<ParamValue>>,
}
/// A CloudControl is the fundamental unit encapsulating the rules
/// to meet a specific security or compliance intent. It can contain
/// various rule types (like Organization Policies, CEL expressions, etc.)
/// enabling different enforcement modes (Preventive, Detective, Audit).
/// CloudControls are often parameterized for reusability and can be either
/// BUILT_IN (provided by Google) or CUSTOM (defined by the user).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControl {
    /// Required. Identifier. The resource name of the cloud control.
    /// Format:
    /// organizations/{organization}/locations/{location}/cloudControls/{cloud_control_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Major revision of the cloud control incremented in ascending
    /// order.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
    /// Optional. A description of the cloud control. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The display name of the cloud control. The maximum length is 200
    /// characters.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. The supported enforcement mode of the cloud control. Default
    /// is DETECTIVE.
    #[prost(enumeration = "EnforcementMode", repeated, packed = "false", tag = "7")]
    pub supported_enforcement_modes: ::prost::alloc::vec::Vec<i32>,
    /// Optional. The parameter spec of the cloud control.
    #[prost(message, repeated, tag = "8")]
    pub parameter_spec: ::prost::alloc::vec::Vec<ParameterSpec>,
    /// Optional. The Policy to be enforced to prevent/detect resource
    /// non-compliance.
    #[prost(message, repeated, tag = "9")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    /// Optional. The severity of findings generated by the cloud control.
    #[prost(enumeration = "Severity", tag = "11")]
    pub severity: i32,
    /// Optional. The finding_category of the cloud control. The maximum length is
    /// 255 characters.
    #[prost(string, tag = "12")]
    pub finding_category: ::prost::alloc::string::String,
    /// Optional. cloud providers supported
    #[prost(enumeration = "CloudProvider", repeated, packed = "false", tag = "13")]
    pub supported_cloud_providers: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The Frameworks that include this CloudControl
    #[prost(string, repeated, tag = "14")]
    pub related_frameworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The remediation steps for the findings generated by the cloud
    /// control. The maximum length is 400 characters.
    #[prost(string, tag = "15")]
    pub remediation_steps: ::prost::alloc::string::String,
    /// Optional. The categories of the cloud control.
    #[prost(
        enumeration = "CloudControlCategory",
        repeated,
        packed = "false",
        tag = "16"
    )]
    pub categories: ::prost::alloc::vec::Vec<i32>,
    /// Output only. The last updated time of the cloud control.
    /// The create_time is used because a new CC is created whenever we update an
    /// existing CC.
    #[prost(message, optional, tag = "17")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. target resource types supported by the CloudControl.
    #[prost(enumeration = "TargetResourceType", repeated, packed = "false", tag = "18")]
    pub supported_target_resource_types: ::prost::alloc::vec::Vec<i32>,
}
/// A parameter spec of the cloud control.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterSpec {
    /// Required. The name of the parameter.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The display name of the parameter. The maximum length is 200
    /// characters.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. The description of the parameter. The maximum length is 2000
    /// characters.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Required. if the parameter is required
    #[prost(bool, tag = "4")]
    pub is_required: bool,
    /// Required. Parameter value type.
    #[prost(enumeration = "parameter_spec::ValueType", tag = "5")]
    pub value_type: i32,
    /// Optional. The default value of the parameter.
    #[prost(message, optional, tag = "6")]
    pub default_value: ::core::option::Option<ParamValue>,
    /// Optional. List of parameter substitutions.
    #[prost(message, repeated, tag = "7")]
    pub substitution_rules: ::prost::alloc::vec::Vec<ParameterSubstitutionRule>,
    /// Optional. ParameterSpec for oneof attributes.
    #[prost(message, repeated, tag = "8")]
    pub sub_parameters: ::prost::alloc::vec::Vec<ParameterSpec>,
    /// Optional. The allowed set of values for the parameter.
    #[prost(message, optional, tag = "9")]
    pub validation: ::core::option::Option<Validation>,
}
/// Nested message and enum types in `ParameterSpec`.
pub mod parameter_spec {
    /// The type of the parameter value.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueType {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// String value.
        String = 3,
        /// Boolean value.
        Boolean = 4,
        /// String list value.
        Stringlist = 5,
        /// Numeric value.
        Number = 6,
        /// OneOf value.
        Oneof = 7,
    }
    impl ValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VALUE_TYPE_UNSPECIFIED",
                Self::String => "STRING",
                Self::Boolean => "BOOLEAN",
                Self::Stringlist => "STRINGLIST",
                Self::Number => "NUMBER",
                Self::Oneof => "ONEOF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VALUE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STRING" => Some(Self::String),
                "BOOLEAN" => Some(Self::Boolean),
                "STRINGLIST" => Some(Self::Stringlist),
                "NUMBER" => Some(Self::Number),
                "ONEOF" => Some(Self::Oneof),
                _ => None,
            }
        }
    }
}
/// Validation of the parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Validation {
    /// Defines validators for parameter values.
    #[prost(oneof = "validation::Constraint", tags = "1, 2, 3")]
    pub constraint: ::core::option::Option<validation::Constraint>,
}
/// Nested message and enum types in `Validation`.
pub mod validation {
    /// Defines validators for parameter values.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Constraint {
        /// Allowed set of values for the parameter.
        #[prost(message, tag = "1")]
        AllowedValues(super::AllowedValues),
        /// Allowed range for numeric parameters.
        #[prost(message, tag = "2")]
        IntRange(super::IntRange),
        /// Regular expression for string parameters.
        #[prost(message, tag = "3")]
        RegexpPattern(super::RegexpPattern),
    }
}
/// Allowed set of values for the parameter.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedValues {
    /// Required. List of allowed values for the parameter.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<ParamValue>,
}
/// Regular Expression Validator for parameter values.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RegexpPattern {
    /// Required. Regex Pattern to match the value(s) of parameter.
    #[prost(string, tag = "1")]
    pub pattern: ::prost::alloc::string::String,
}
/// Number range for number parameters.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntRange {
    /// Required. Minimum allowed value for the numeric parameter (inclusive).
    #[prost(int64, tag = "1")]
    pub min: i64,
    /// Required. Maximum allowed value for the numeric parameter (inclusive).
    #[prost(int64, tag = "2")]
    pub max: i64,
}
/// A list of strings.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringList {
    /// Required. The strings in the list.
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Possible parameter value types.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParamValue {
    /// The kind of value.
    #[prost(oneof = "param_value::Kind", tags = "3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<param_value::Kind>,
}
/// Nested message and enum types in `ParamValue`.
pub mod param_value {
    /// The kind of value.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Represents a string value.
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        /// Represents a boolean value.
        #[prost(bool, tag = "4")]
        BoolValue(bool),
        /// Represents a repeated string.
        #[prost(message, tag = "5")]
        StringListValue(super::StringList),
        /// Represents a double value.
        #[prost(double, tag = "6")]
        NumberValue(f64),
        /// Represents sub-parameter values.
        #[prost(message, tag = "7")]
        OneofValue(::prost::alloc::boxed::Box<super::Parameter>),
    }
}
/// Parameter substitution rules.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ParameterSubstitutionRule {
    /// The type of substitution.
    #[prost(oneof = "parameter_substitution_rule::SubstitutionType", tags = "1, 2")]
    pub substitution_type: ::core::option::Option<
        parameter_substitution_rule::SubstitutionType,
    >,
}
/// Nested message and enum types in `ParameterSubstitutionRule`.
pub mod parameter_substitution_rule {
    /// The type of substitution.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum SubstitutionType {
        /// Placeholder substitution rule.
        #[prost(message, tag = "1")]
        PlaceholderSubstitutionRule(super::PlaceholderSubstitutionRule),
        /// Attribute substitution rule.
        #[prost(message, tag = "2")]
        AttributeSubstitutionRule(super::AttributeSubstitutionRule),
    }
}
/// Attribute at the given path is substituted entirely.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AttributeSubstitutionRule {
    /// Fully qualified proto attribute path (in dot notation).
    /// Example: rules\[0\].cel_expression.resource_types_values
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
}
/// Placeholder is substituted in the rendered string.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PlaceholderSubstitutionRule {
    /// Fully qualified proto attribute path (e.g., dot notation)
    #[prost(string, tag = "1")]
    pub attribute: ::prost::alloc::string::String,
}
/// A rule of the cloud control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Rule {
    /// Optional. Description of the Rule. The maximum length is 2000 characters.
    #[prost(string, tag = "10")]
    pub description: ::prost::alloc::string::String,
    /// Required. The functionality enabled by the Rule.
    #[prost(enumeration = "RuleActionType", repeated, packed = "false", tag = "16")]
    pub rule_action_types: ::prost::alloc::vec::Vec<i32>,
    /// The implementation of the rule.
    #[prost(oneof = "rule::Implementation", tags = "1")]
    pub implementation: ::core::option::Option<rule::Implementation>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    /// The implementation of the rule.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Implementation {
        /// Logic expression in CEL language.
        #[prost(message, tag = "1")]
        CelExpression(super::CelExpression),
    }
}
/// A [CEL
/// expression](<https://cloud.google.com/certificate-authority-service/docs/using-cel>).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CelExpression {
    /// Required. Logic expression in CEL language.
    /// The max length of the condition is 1000 characters.
    #[prost(string, tag = "1")]
    pub expression: ::prost::alloc::string::String,
    /// The criteria of the CEL expression.
    #[prost(oneof = "cel_expression::Criteria", tags = "3")]
    pub criteria: ::core::option::Option<cel_expression::Criteria>,
}
/// Nested message and enum types in `CELExpression`.
pub mod cel_expression {
    /// The criteria of the CEL expression.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Criteria {
        /// The resource instance types on which this expression is defined.
        /// Format will be of the form : `<canonical service name>/<type>`
        /// Example: `compute.googleapis.com/Instance`.
        #[prost(message, tag = "3")]
        ResourceTypesValues(super::StringList),
    }
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have \[Operation.error\]\[\] value with a
    /// \[google.rpc.Status.code\]\[google.rpc.Status.code\] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// The enforcement mode of the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EnforcementMode {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// The cloud control is enforced to prevent resource non-compliance.
    Preventive = 1,
    /// The cloud control is enforced to detect resource non-compliance.
    Detective = 2,
    /// The cloud control is enforced to audit resource non-compliance.
    Audit = 3,
}
impl EnforcementMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENFORCEMENT_MODE_UNSPECIFIED",
            Self::Preventive => "PREVENTIVE",
            Self::Detective => "DETECTIVE",
            Self::Audit => "AUDIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENFORCEMENT_MODE_UNSPECIFIED" => Some(Self::Unspecified),
            "PREVENTIVE" => Some(Self::Preventive),
            "DETECTIVE" => Some(Self::Detective),
            "AUDIT" => Some(Self::Audit),
            _ => None,
        }
    }
}
/// The category of the framework.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FrameworkCategory {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Standard framework
    IndustryDefinedStandard = 1,
    /// Assured Workloads framework
    AssuredWorkloads = 2,
    /// Data Security framework
    DataSecurity = 3,
    /// Google Best Practices framework
    GoogleBestPractices = 4,
    /// User created framework.
    CustomFramework = 5,
}
impl FrameworkCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FRAMEWORK_CATEGORY_UNSPECIFIED",
            Self::IndustryDefinedStandard => "INDUSTRY_DEFINED_STANDARD",
            Self::AssuredWorkloads => "ASSURED_WORKLOADS",
            Self::DataSecurity => "DATA_SECURITY",
            Self::GoogleBestPractices => "GOOGLE_BEST_PRACTICES",
            Self::CustomFramework => "CUSTOM_FRAMEWORK",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FRAMEWORK_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "INDUSTRY_DEFINED_STANDARD" => Some(Self::IndustryDefinedStandard),
            "ASSURED_WORKLOADS" => Some(Self::AssuredWorkloads),
            "DATA_SECURITY" => Some(Self::DataSecurity),
            "GOOGLE_BEST_PRACTICES" => Some(Self::GoogleBestPractices),
            "CUSTOM_FRAMEWORK" => Some(Self::CustomFramework),
            _ => None,
        }
    }
}
/// The category of the cloud control.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudControlCategory {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Infrastructure
    CcCategoryInfrastructure = 1,
    /// Artificial Intelligence
    CcCategoryArtificialIntelligence = 2,
    /// Physical Security
    CcCategoryPhysicalSecurity = 3,
    /// Data Security
    CcCategoryDataSecurity = 4,
    /// Network Security
    CcCategoryNetworkSecurity = 5,
    /// Incident Management
    CcCategoryIncidentManagement = 6,
    /// Identity & Access Management
    CcCategoryIdentityAndAccessManagement = 7,
    /// Encryption
    CcCategoryEncryption = 8,
    /// Logs Management & Infrastructure
    CcCategoryLogsManagementAndInfrastructure = 9,
    /// HR, Admin & Processes
    CcCategoryHrAdminAndProcesses = 10,
    /// Third Party & Sub-Processor Management
    CcCategoryThirdPartyAndSubProcessorManagement = 11,
    /// Legal & Disclosures
    CcCategoryLegalAndDisclosures = 12,
    /// Vulnerability Management
    CcCategoryVulnerabilityManagement = 13,
    /// Privacy
    CcCategoryPrivacy = 14,
    /// BCDR (Business Continuity and Disaster Recovery)
    CcCategoryBcdr = 15,
}
impl CloudControlCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_CONTROL_CATEGORY_UNSPECIFIED",
            Self::CcCategoryInfrastructure => "CC_CATEGORY_INFRASTRUCTURE",
            Self::CcCategoryArtificialIntelligence => {
                "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE"
            }
            Self::CcCategoryPhysicalSecurity => "CC_CATEGORY_PHYSICAL_SECURITY",
            Self::CcCategoryDataSecurity => "CC_CATEGORY_DATA_SECURITY",
            Self::CcCategoryNetworkSecurity => "CC_CATEGORY_NETWORK_SECURITY",
            Self::CcCategoryIncidentManagement => "CC_CATEGORY_INCIDENT_MANAGEMENT",
            Self::CcCategoryIdentityAndAccessManagement => {
                "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT"
            }
            Self::CcCategoryEncryption => "CC_CATEGORY_ENCRYPTION",
            Self::CcCategoryLogsManagementAndInfrastructure => {
                "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE"
            }
            Self::CcCategoryHrAdminAndProcesses => "CC_CATEGORY_HR_ADMIN_AND_PROCESSES",
            Self::CcCategoryThirdPartyAndSubProcessorManagement => {
                "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT"
            }
            Self::CcCategoryLegalAndDisclosures => "CC_CATEGORY_LEGAL_AND_DISCLOSURES",
            Self::CcCategoryVulnerabilityManagement => {
                "CC_CATEGORY_VULNERABILITY_MANAGEMENT"
            }
            Self::CcCategoryPrivacy => "CC_CATEGORY_PRIVACY",
            Self::CcCategoryBcdr => "CC_CATEGORY_BCDR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_CONTROL_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "CC_CATEGORY_INFRASTRUCTURE" => Some(Self::CcCategoryInfrastructure),
            "CC_CATEGORY_ARTIFICIAL_INTELLIGENCE" => {
                Some(Self::CcCategoryArtificialIntelligence)
            }
            "CC_CATEGORY_PHYSICAL_SECURITY" => Some(Self::CcCategoryPhysicalSecurity),
            "CC_CATEGORY_DATA_SECURITY" => Some(Self::CcCategoryDataSecurity),
            "CC_CATEGORY_NETWORK_SECURITY" => Some(Self::CcCategoryNetworkSecurity),
            "CC_CATEGORY_INCIDENT_MANAGEMENT" => Some(Self::CcCategoryIncidentManagement),
            "CC_CATEGORY_IDENTITY_AND_ACCESS_MANAGEMENT" => {
                Some(Self::CcCategoryIdentityAndAccessManagement)
            }
            "CC_CATEGORY_ENCRYPTION" => Some(Self::CcCategoryEncryption),
            "CC_CATEGORY_LOGS_MANAGEMENT_AND_INFRASTRUCTURE" => {
                Some(Self::CcCategoryLogsManagementAndInfrastructure)
            }
            "CC_CATEGORY_HR_ADMIN_AND_PROCESSES" => {
                Some(Self::CcCategoryHrAdminAndProcesses)
            }
            "CC_CATEGORY_THIRD_PARTY_AND_SUB_PROCESSOR_MANAGEMENT" => {
                Some(Self::CcCategoryThirdPartyAndSubProcessorManagement)
            }
            "CC_CATEGORY_LEGAL_AND_DISCLOSURES" => {
                Some(Self::CcCategoryLegalAndDisclosures)
            }
            "CC_CATEGORY_VULNERABILITY_MANAGEMENT" => {
                Some(Self::CcCategoryVulnerabilityManagement)
            }
            "CC_CATEGORY_PRIVACY" => Some(Self::CcCategoryPrivacy),
            "CC_CATEGORY_BCDR" => Some(Self::CcCategoryBcdr),
            _ => None,
        }
    }
}
/// The cloud platform.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CloudProvider {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Amazon Web Services (AWS).
    Aws = 1,
    /// Microsoft Azure.
    Azure = 2,
    /// Google Cloud.
    Gcp = 3,
}
impl CloudProvider {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CLOUD_PROVIDER_UNSPECIFIED",
            Self::Aws => "AWS",
            Self::Azure => "AZURE",
            Self::Gcp => "GCP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CLOUD_PROVIDER_UNSPECIFIED" => Some(Self::Unspecified),
            "AWS" => Some(Self::Aws),
            "AZURE" => Some(Self::Azure),
            "GCP" => Some(Self::Gcp),
            _ => None,
        }
    }
}
/// The severity of the finding.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// This value is used for findings when a source doesn't write a severity
    /// value.
    Unspecified = 0,
    /// Vulnerability:
    /// A critical vulnerability is easily discoverable by an external actor,
    /// exploitable, and results in the direct ability to execute arbitrary code,
    /// exfiltrate data, and otherwise gain additional access and privileges to
    /// cloud resources and workloads. Examples include publicly accessible
    /// unprotected user data and public SSH access with weak or no
    /// passwords.
    ///
    /// Threat:
    /// Indicates a threat that is able to access, modify, or delete data or
    /// execute unauthorized code within existing resources.
    Critical = 1,
    /// Vulnerability:
    /// A high risk vulnerability can be easily discovered and exploited in
    /// combination with other vulnerabilities in order to gain direct access and
    /// the ability to execute arbitrary code, exfiltrate data, and otherwise
    /// gain additional access and privileges to cloud resources and workloads.
    /// An example is a database with weak or no passwords that is only
    /// accessible internally. This database could easily be compromised by an
    /// actor that had access to the internal network.
    ///
    /// Threat:
    /// Indicates a threat that is able to create new computational resources in
    /// an environment but not able to access data or execute code in existing
    /// resources.
    High = 2,
    /// Vulnerability:
    /// A medium risk vulnerability could be used by an actor to gain access to
    /// resources or privileges that enable them to eventually (through multiple
    /// steps or a complex exploit) gain access and the ability to execute
    /// arbitrary code or exfiltrate data. An example is a service account with
    /// access to more projects than it should have. If an actor gains access to
    /// the service account, they could potentially use that access to manipulate
    /// a project the service account was not intended to.
    ///
    /// Threat:
    /// Indicates a threat that is able to cause operational impact but may not
    /// access data or execute unauthorized code.
    Medium = 3,
    /// Vulnerability:
    /// A low risk vulnerability hampers a security organization's ability to
    /// detect vulnerabilities or active threats in their deployment, or prevents
    /// the root cause investigation of security issues. An example is monitoring
    /// and logs being disabled for resource configurations and access.
    ///
    /// Threat:
    /// Indicates a threat that has obtained minimal access to an environment but
    /// is not able to access data, execute code, or create resources.
    Low = 4,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Critical => "CRITICAL",
            Self::High => "HIGH",
            Self::Medium => "MEDIUM",
            Self::Low => "LOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "CRITICAL" => Some(Self::Critical),
            "HIGH" => Some(Self::High),
            "MEDIUM" => Some(Self::Medium),
            "LOW" => Some(Self::Low),
            _ => None,
        }
    }
}
/// The action type of the rule.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RuleActionType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Preventative action type.
    Preventive = 1,
    /// Detective action type.
    Detective = 2,
    /// Audit action type.
    Audit = 3,
}
impl RuleActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "RULE_ACTION_TYPE_UNSPECIFIED",
            Self::Preventive => "RULE_ACTION_TYPE_PREVENTIVE",
            Self::Detective => "RULE_ACTION_TYPE_DETECTIVE",
            Self::Audit => "RULE_ACTION_TYPE_AUDIT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RULE_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RULE_ACTION_TYPE_PREVENTIVE" => Some(Self::Preventive),
            "RULE_ACTION_TYPE_DETECTIVE" => Some(Self::Detective),
            "RULE_ACTION_TYPE_AUDIT" => Some(Self::Audit),
            _ => None,
        }
    }
}
/// TargetResourceType represents the type of resource that a control or
/// framework can be applied to.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TargetResourceType {
    /// Default value. This value is unused.
    Unspecified = 0,
    /// Target resource is an Organization.
    TargetResourceCrmTypeOrg = 1,
    /// Target resource is a Folder.
    TargetResourceCrmTypeFolder = 2,
    /// Target resource is a Project.
    TargetResourceCrmTypeProject = 3,
    /// Target resource is an Application.
    Application = 4,
}
impl TargetResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "TARGET_RESOURCE_TYPE_UNSPECIFIED",
            Self::TargetResourceCrmTypeOrg => "TARGET_RESOURCE_CRM_TYPE_ORG",
            Self::TargetResourceCrmTypeFolder => "TARGET_RESOURCE_CRM_TYPE_FOLDER",
            Self::TargetResourceCrmTypeProject => "TARGET_RESOURCE_CRM_TYPE_PROJECT",
            Self::Application => "TARGET_RESOURCE_TYPE_APPLICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TARGET_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TARGET_RESOURCE_CRM_TYPE_ORG" => Some(Self::TargetResourceCrmTypeOrg),
            "TARGET_RESOURCE_CRM_TYPE_FOLDER" => Some(Self::TargetResourceCrmTypeFolder),
            "TARGET_RESOURCE_CRM_TYPE_PROJECT" => {
                Some(Self::TargetResourceCrmTypeProject)
            }
            "TARGET_RESOURCE_TYPE_APPLICATION" => Some(Self::Application),
            _ => None,
        }
    }
}
/// Request message for listing Frameworks.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworksRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    /// Only global location is supported.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of frameworks to return. The default value is
    /// `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A pagination token returned from a previous request to list
    /// frameworks. Provide this token to retrieve the next page of results.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for listing Frameworks.
/// Contains a paginated list of Framework resources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworksResponse {
    /// The list of Framework resources.
    #[prost(message, repeated, tag = "1")]
    pub frameworks: ::prost::alloc::vec::Vec<Framework>,
    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for getting a Framework.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkRequest {
    /// Required. The name of the framework to retrieve.
    /// Format:
    /// organizations/{organization}/locations/{location}/frameworks/{framework_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The Framework major version to retrieve. If not specified, the
    /// most recently updated revision_id is retrieved.
    #[prost(int64, tag = "2")]
    pub major_revision_id: i64,
}
/// Request message for creating a Framework
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the framework.
    /// This is not the full name of the framework.
    /// This is the last part of the full name of the framework.
    #[prost(string, tag = "2")]
    pub framework_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub framework: ::core::option::Option<Framework>,
}
/// Request message for updating a Framework.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFrameworkRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Framework resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub framework: ::core::option::Option<Framework>,
    /// Optional. The major version ID of the framework to update.
    #[prost(int64, tag = "3")]
    pub major_revision_id: i64,
}
/// Request message for deleting a Framework.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFrameworkRequest {
    /// Required. Name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/frameworks/{framework}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for listing CloudControls.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudControlsRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of CloudControls to return. The default value
    /// is `500`.
    ///
    /// If you exceed the maximum value of `1000`, then the service uses the
    /// maximum value.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A pagination token returned from a previous request to list
    /// CloudControls. Provide this token to retrieve the next page of results.
    ///
    /// When paginating, parent provided to
    /// ListCloudControls request must match the call that provided the page
    /// token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message for ListCloudControls.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudControlsResponse {
    /// The list of CloudControl resources.
    #[prost(message, repeated, tag = "1")]
    pub cloud_controls: ::prost::alloc::vec::Vec<CloudControl>,
    /// A pagination token. To retrieve the next page of results, call the method
    /// again with this token.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for getting a CloudControl.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudControlRequest {
    /// Required. The name of the cloudcontrol to retrieve in the format:
    /// organizations/{organization}/locations/{location}/cloudControls/{cloud_control}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for creating a CloudControl
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCloudControlRequest {
    /// Required. The parent resource name, in the format
    /// `organizations/{organization}/locations/{location}`.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. ID of the CloudControl.
    /// This is the last segment of the CloudControl resource name.
    /// Format: `^[a-zA-Z][a-zA-Z0-9-]{0,61}\[a-zA-Z0-9\]$`.
    #[prost(string, tag = "2")]
    pub cloud_control_id: ::prost::alloc::string::String,
    /// Required. The resource being created
    #[prost(message, optional, tag = "3")]
    pub cloud_control: ::core::option::Option<CloudControl>,
}
/// Request message for UpdateCloudControl.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCloudControlRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// CloudControl resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields present in the request will be
    /// overwritten. The fields that can be updated are:
    ///
    /// 1. Display_name
    /// 1. Description
    /// 1. Parameters
    /// 1. Rules
    /// 1. ParameterSpec.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated
    #[prost(message, optional, tag = "2")]
    pub cloud_control: ::core::option::Option<CloudControl>,
}
/// Request message for deleting a CloudControl.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteCloudControlRequest {
    /// Required. Name of the resource, in the format
    /// `organizations/{organization}/locations/{location}/CloudControls/{CloudControl}`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod config_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Config Service manages compliance frameworks, cloud controls, and their
    /// configurations.
    #[derive(Debug, Clone)]
    pub struct ConfigClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ConfigClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ConfigClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ConfigClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ConfigClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all Frameworks (both Built-in and Custom) available within a given
        /// parent resource. This method supports pagination.
        /// The latest major version of each Framework is returned.
        pub async fn list_frameworks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/ListFrameworks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "ListFrameworks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single Framework.
        /// This method retrieves a Framework resource, which can be either Built-in or
        /// Custom, identified by its name.
        ///
        /// By default, the latest major version of the Framework is returned.
        /// A specific major version can be retrieved by specifying the
        /// `major_revision_id` in the request.
        pub async fn get_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/GetFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "GetFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Framework with type `Custom` under a given parent resource.
        /// Frameworks with type `Built-in` are managed by Google and cannot be created
        /// through this API.
        pub async fn create_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/CreateFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "CreateFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single Framework.
        /// This method allows for partial updates of a Framework resource. The fields
        /// to be updated are specified using the `update_mask`.
        ///
        /// * If an `update_mask` is provided, only the fields specified in the mask
        ///  will be updated.
        /// * If no `update_mask` is provided, all fields present in the request's
        ///  `framework` body will be used to overwrite the existing resource.
        ///
        /// This operation can only be performed on Frameworks with type `CUSTOM`.
        /// A successful update will result in a new version of the Framework.
        pub async fn update_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Framework>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/UpdateFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "UpdateFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Custom Framework, including all its minor and
        /// minor revisions.
        ///
        /// * This operation can only be performed on Frameworks with type `CUSTOM`.
        ///  Built-in Frameworks cannot be deleted.
        /// * The Framework cannot be deleted if it is currently deployed on any
        ///  resource.
        /// * This action is permanent and cannot be undone.
        pub async fn delete_framework(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFrameworkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/DeleteFramework",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "DeleteFramework",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all CloudControls (both Built-in and Custom) available within a given
        /// parent resource. This method supports pagination.
        /// The latest major version of each CloudControl is returned.
        pub async fn list_cloud_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudControlsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudControlsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/ListCloudControls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "ListCloudControls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single CloudControl.
        /// This method retrieves a CloudControl resource, which can be either Built-in
        /// or Custom, identified by its name.
        ///
        /// By default, the latest major version of the CloudControl is returned.
        /// A specific major version can be retrieved by specifying the
        /// `major_revision_id` in the request.
        pub async fn get_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/GetCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "GetCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new CloudControl with type `Custom` under a given parent
        /// resource. `Built-in` CloudControls are managed by Google and cannot be
        /// created through this API.
        pub async fn create_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/CreateCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "CreateCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a single CloudControl.
        /// This method allows for partial updates of a Custom CloudControl resource.
        /// Built-in CloudControls cannot be updated.
        ///
        /// * If an `update_mask` is provided, only the fields specified in the mask
        ///  will be updated.
        /// * If no `update_mask` is provided, all fields present in the request's
        ///  `cloud_control` body will be used to overwrite the existing resource.
        ///
        /// A successful update will result in a new version of the CloudControl.
        pub async fn update_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<super::CloudControl>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/UpdateCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "UpdateCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single Custom CloudControl, including all its
        /// major and minor revisions.
        ///
        /// * This operation can only be performed on CloudControls with type `CUSTOM`.
        ///  Built-in CloudControls cannot be deleted.
        /// * The CloudControl cannot be deleted if any of its revisions are currently
        ///  referenced by any Framework.
        /// * This action is permanent and cannot be undone.
        pub async fn delete_cloud_control(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCloudControlRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Config/DeleteCloudControl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Config",
                        "DeleteCloudControl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// FrameworkDeployment represents deployment of a Framework on a target
/// resource. Supported target resources are organizations/{organization},
/// folders/{folder}, and projects/{project}.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameworkDeployment {
    /// Identifier. FrameworkDeployment name in the following format:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The details of the target resource on which the Framework is to
    /// be deployed. It can either be an existing target resource or a new target
    /// resource to be created.
    #[prost(message, optional, tag = "2")]
    pub target_resource_config: ::core::option::Option<TargetResourceConfig>,
    /// Output only. The resource on which the Framework is deployed based on the
    /// provided TargetResourceConfig in the following format:
    /// organizations/{organization}, folders/{folder} or projects/{project}
    #[prost(string, tag = "3")]
    pub computed_target_resource: ::prost::alloc::string::String,
    /// Required. Reference to the framework to be deployed.
    #[prost(message, optional, tag = "4")]
    pub framework: ::core::option::Option<FrameworkReference>,
    /// Optional. User provided description of the Framework deployment
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Required. Deployment mode and parameters for each of the Cloud Controls in
    /// the framework. Every Cloud Control in the framework must have a
    /// CloudControlMetadata.
    #[prost(message, repeated, tag = "6")]
    pub cloud_control_metadata: ::prost::alloc::vec::Vec<CloudControlMetadata>,
    /// Output only. State of the Framework Deployment
    #[prost(enumeration = "DeploymentState", tag = "7")]
    pub deployment_state: i32,
    /// Output only. The time at which the resource was created.
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the resource last updated.
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a FrameworkDeployment. You can also
    /// provide the `etag` when you delete a FrameworkDeployment, to help
    /// ensure that you're deleting the intended version of the
    /// FrameworkDeployment.
    #[prost(string, tag = "11")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The display name of the target resource.
    #[prost(string, tag = "13")]
    pub target_resource_display_name: ::prost::alloc::string::String,
    /// Output only. The references to the cloud control deployments. It has all
    /// the CloudControlDeployments which are either directly added in the
    /// framework or through a CloudControlGroup. Example: If a framework
    /// deployment deploys two cloud controls, cc-deployment-1 and cc-deployment-2,
    /// then the cloud_control_deployment_references will be:
    /// {
    /// cloud_control_deployment_reference: {
    /// cloud_control_deployment:
    /// "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-1"
    /// },
    /// cloud_control_deployment_reference: {
    /// cloud_control_deployment:
    /// "organizations/{organization}/locations/{location}/cloudControlDeployments/cc-deployment-2"
    /// }
    #[prost(message, repeated, tag = "14")]
    pub cloud_control_deployment_references: ::prost::alloc::vec::Vec<
        CloudControlDeploymentReference,
    >,
}
/// CloudControlDeployment represents deployment of a CloudControl on a target
/// resource. Supported target resources are organizations/{organization},
/// folders/{folder}, and projects/{project}.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlDeployment {
    /// Identifier. CloudControlDeployment name in the following format:
    /// organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The details of the target resource on which the CloudControl is
    /// to be deployed. It can either be an existing target resource or a new
    /// target resource to be created.
    #[prost(message, optional, tag = "2")]
    pub target_resource_config: ::core::option::Option<TargetResourceConfig>,
    /// Output only. The resource on which the CloudControl is deployed based on
    /// the provided TargetResourceConfig in the following format:
    /// organizations/{organization}, folders/{folder} or projects/{project}.
    #[prost(string, tag = "3")]
    pub target_resource: ::prost::alloc::string::String,
    /// Required. Deployment mode and parameters for the Cloud Control.
    #[prost(message, optional, tag = "4")]
    pub cloud_control_metadata: ::core::option::Option<CloudControlMetadata>,
    /// Optional. User provided description of the CloudControl deployment
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    /// Output only. State of the CloudControl deployment
    #[prost(enumeration = "DeploymentState", tag = "6")]
    pub deployment_state: i32,
    /// Output only. The time at which the resource was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time at which the resource last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. To prevent concurrent updates from overwriting each other, always
    /// provide the `etag` when you update a CloudControlDeployment. You can also
    /// provide the `etag` when you delete a CloudControlDeployment, to help
    /// ensure that you're deleting the intended version of the
    /// CloudControlDeployment.
    #[prost(string, tag = "9")]
    pub etag: ::prost::alloc::string::String,
    /// Output only. The CloudControl after substitution of given parameters.
    #[prost(message, optional, tag = "10")]
    pub parameter_substituted_cloud_control: ::core::option::Option<CloudControl>,
    /// Output only. The references to the Framework deployments that this Cloud
    /// Control deployment is part of. A Cloud Control deployment can be part of
    /// multiple Framework deployments.
    #[prost(message, repeated, tag = "11")]
    pub framework_deployment_references: ::prost::alloc::vec::Vec<
        FrameworkDeploymentReference,
    >,
    /// Output only. The display name of the target resource.
    #[prost(string, tag = "12")]
    pub target_resource_display_name: ::prost::alloc::string::String,
}
/// TargetResourceConfig contains either the name of the target_resource or
/// contains the config to create a new target_resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceConfig {
    /// Resource config for the target_resource
    #[prost(oneof = "target_resource_config::ResourceConfig", tags = "1, 2")]
    pub resource_config: ::core::option::Option<target_resource_config::ResourceConfig>,
}
/// Nested message and enum types in `TargetResourceConfig`.
pub mod target_resource_config {
    /// Resource config for the target_resource
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ResourceConfig {
        /// Optional. CRM node in format organizations/{organization},
        /// folders/{folder}, or projects/{project}
        #[prost(string, tag = "1")]
        ExistingTargetResource(::prost::alloc::string::String),
        /// Optional. Config to create a new resource and use that as the
        /// target_resource for deployment.
        #[prost(message, tag = "2")]
        TargetResourceCreationConfig(super::TargetResourceCreationConfig),
    }
}
/// TargetResourceCreationConfig contains the config to create a new resource to
/// be used as the target_resource of a deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TargetResourceCreationConfig {
    /// Resource creation config for the target_resource
    #[prost(
        oneof = "target_resource_creation_config::ResourceCreationConfig",
        tags = "1, 2"
    )]
    pub resource_creation_config: ::core::option::Option<
        target_resource_creation_config::ResourceCreationConfig,
    >,
}
/// Nested message and enum types in `TargetResourceCreationConfig`.
pub mod target_resource_creation_config {
    /// Resource creation config for the target_resource
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum ResourceCreationConfig {
        /// Optional. Config to create a new folder to be used as the target_resource
        /// of a deployment.
        #[prost(message, tag = "1")]
        FolderCreationConfig(super::FolderCreationConfig),
        /// Optional. Config to create a new project to be used as the
        /// target_resource of a deployment.
        #[prost(message, tag = "2")]
        ProjectCreationConfig(super::ProjectCreationConfig),
    }
}
/// FolderCreationConfig contains the config to create a new folder to be used
/// as the target_resource of a deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FolderCreationConfig {
    /// Required. The parent of the folder to be created. It can be an
    /// organizations/{org} or folders/{folder}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Display name of the folder to be created
    #[prost(string, tag = "2")]
    pub folder_display_name: ::prost::alloc::string::String,
}
/// ProjectCreationConfig contains the config to create a new project to be used
/// as the target_resource of a deployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProjectCreationConfig {
    /// Required. organizations/{org} or folders/{folder}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Display name of the project to be created.
    #[prost(string, tag = "2")]
    pub project_display_name: ::prost::alloc::string::String,
    /// Required. Billing account id to be used for the project.
    #[prost(string, tag = "3")]
    pub billing_account_id: ::prost::alloc::string::String,
}
/// CloudControlMetadata contains the enforcement mode and parameters of a Cloud
/// Control Deployment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudControlMetadata {
    /// Required. Cloud control name and parameters.
    #[prost(message, optional, tag = "1")]
    pub cloud_control_details: ::core::option::Option<CloudControlDetails>,
    /// Required. Enforcement mode of the cloud control
    #[prost(enumeration = "EnforcementMode", tag = "2")]
    pub enforcement_mode: i32,
}
/// Request message for CreateFrameworkDeployment API.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFrameworkDeploymentRequest {
    /// Required. The parent resource of the FrameworkDeployment in the format:
    /// organizations/{organization}/locations/{location}
    /// Only global location is supported.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. User provided identifier. It should be unique in scope of a
    /// parent. This is optional and if not provided, a random UUID will be
    /// generated.
    #[prost(string, tag = "2")]
    pub framework_deployment_id: ::prost::alloc::string::String,
    /// Required. The FrameworkDeployment to be created.
    #[prost(message, optional, tag = "3")]
    pub framework_deployment: ::core::option::Option<FrameworkDeployment>,
}
/// Request message for DeleteFrameworkDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFrameworkDeploymentRequest {
    /// Required. name of the FrameworkDeployment to be deleted in the following
    /// format:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An opaque identifier for the current version of the resource.
    ///
    /// If you provide this value, then it must match the existing value. If the
    /// values don't match, then the request fails with an
    /// \[ABORTED\]\[google.rpc.Code.ABORTED\] error.
    ///
    /// If you omit this value, then the resource is deleted regardless of its
    /// current `etag` value.
    #[prost(string, tag = "2")]
    pub etag: ::prost::alloc::string::String,
}
/// Request message for GetFrameworkDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetFrameworkDeploymentRequest {
    /// Required. FrameworkDeployment name in the following format:
    /// organizations/{organization}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for ListFrameworkDeployments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListFrameworkDeploymentsRequest {
    /// Required. parent resource of the FrameworkDeployment in the format:
    /// organizations/{organization}/locations/{location}
    /// Only global location is supported.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter to be applied on the resource, defined by EBNF grammar
    /// <https://google.aip.dev/assets/misc/ebnf-filtering.txt.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort results. Supported are "name", "name desc" or "" (unsorted).
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListFrameworkDeployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFrameworkDeploymentsResponse {
    /// The list of FrameworkDeployments.
    #[prost(message, repeated, tag = "1")]
    pub framework_deployments: ::prost::alloc::vec::Vec<FrameworkDeployment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request message for GetCloudControlDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCloudControlDeploymentRequest {
    /// Required. CloudControlDeployment name in the following format:
    /// organizations/{organization}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request message for ListCloudControlDeployments.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListCloudControlDeploymentsRequest {
    /// Required. parent resource of the CloudControlDeployment in the format:
    /// organizations/{organization}/locations/{location}
    /// Only global location is supported.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filter to be applied on the resource, defined by EBNF grammar
    /// <https://google.aip.dev/assets/misc/ebnf-filtering.txt.>
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Sort results. Supported are "name", "name desc" or "" (unsorted).
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response message for ListCloudControlDeployments.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCloudControlDeploymentsResponse {
    /// The list of CloudControlDeployments.
    #[prost(message, repeated, tag = "1")]
    pub cloud_control_deployments: ::prost::alloc::vec::Vec<CloudControlDeployment>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The reference to a CloudControlDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CloudControlDeploymentReference {
    /// Output only. The name of the CloudControlDeployment. The format is:
    /// organizations/{org}/locations/{location}/cloudControlDeployments/{cloud_control_deployment_id}
    #[prost(string, tag = "1")]
    pub cloud_control_deployment: ::prost::alloc::string::String,
}
/// The reference to a FrameworkDeployment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameworkDeploymentReference {
    /// Output only. The name of the FrameworkDeployment. The format is:
    /// organizations/{org}/locations/{location}/frameworkDeployments/{framework_deployment_id}
    #[prost(string, tag = "1")]
    pub framework_deployment: ::prost::alloc::string::String,
    /// Optional. The reference to the Framework that this deployment is for.
    /// Example: {
    /// framework:
    /// "organizations/{org}/locations/{location}/frameworks/{framework}",
    /// major_revision_id: 1
    /// }
    #[prost(message, optional, tag = "2")]
    pub framework_reference: ::core::option::Option<FrameworkReference>,
    /// Optional. The display name of the Framework that this FrameworkDeployment
    /// is for.
    #[prost(string, tag = "3")]
    pub framework_display_name: ::prost::alloc::string::String,
}
/// DeploymentState represents the state of the Deployment resource.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeploymentState {
    /// Unspecified. Invalid state.
    Unspecified = 0,
    /// Validating the deployment.
    Validating = 1,
    /// Deployment is in CREATING state.
    Creating = 2,
    /// Deployment is in DELETING state.
    Deleting = 3,
    /// Deployment has failed. All the changes made by the deployment have been
    /// successfully rolled back. A deployment in the FAILED state can be retried
    /// or deleted.
    Failed = 4,
    /// Deployment is successful and ready to use.
    Ready = 5,
    /// Deployment is partially deployed. All the Cloud Controls were not deployed
    /// successfully. Retrying the operation will resume from the first failed
    /// step.
    PartiallyDeployed = 6,
    /// Deployment is partially deleted. All the Cloud Control Deployments were not
    /// deleted successfully. Retrying the operation will resume from the first
    /// failed step.
    PartiallyDeleted = 7,
}
impl DeploymentState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEPLOYMENT_STATE_UNSPECIFIED",
            Self::Validating => "DEPLOYMENT_STATE_VALIDATING",
            Self::Creating => "DEPLOYMENT_STATE_CREATING",
            Self::Deleting => "DEPLOYMENT_STATE_DELETING",
            Self::Failed => "DEPLOYMENT_STATE_FAILED",
            Self::Ready => "DEPLOYMENT_STATE_READY",
            Self::PartiallyDeployed => "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED",
            Self::PartiallyDeleted => "DEPLOYMENT_STATE_PARTIALLY_DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEPLOYMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "DEPLOYMENT_STATE_VALIDATING" => Some(Self::Validating),
            "DEPLOYMENT_STATE_CREATING" => Some(Self::Creating),
            "DEPLOYMENT_STATE_DELETING" => Some(Self::Deleting),
            "DEPLOYMENT_STATE_FAILED" => Some(Self::Failed),
            "DEPLOYMENT_STATE_READY" => Some(Self::Ready),
            "DEPLOYMENT_STATE_PARTIALLY_DEPLOYED" => Some(Self::PartiallyDeployed),
            "DEPLOYMENT_STATE_PARTIALLY_DELETED" => Some(Self::PartiallyDeleted),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod deployment_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Deployment service allows users to manage deployments of Frameworks and
    /// Cloud Controls on a target resource.
    #[derive(Debug, Clone)]
    pub struct DeploymentClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DeploymentClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DeploymentClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DeploymentClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DeploymentClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new FrameworkDeployment in a given parent resource.
        pub async fn create_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/CreateFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "CreateFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single FrameworkDeployment.
        pub async fn delete_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/DeleteFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "DeleteFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single FrameworkDeployment.
        pub async fn get_framework_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFrameworkDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FrameworkDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/GetFrameworkDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "GetFrameworkDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists FrameworkDeployments in a given parent resource.
        pub async fn list_framework_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFrameworkDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFrameworkDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/ListFrameworkDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "ListFrameworkDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single CloudControlDeployment.
        pub async fn get_cloud_control_deployment(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCloudControlDeploymentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CloudControlDeployment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/GetCloudControlDeployment",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "GetCloudControlDeployment",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CloudControlDeployments in a given parent resource.
        pub async fn list_cloud_control_deployments(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCloudControlDeploymentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCloudControlDeploymentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.cloudsecuritycompliance.v1.Deployment/ListCloudControlDeployments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.cloudsecuritycompliance.v1.Deployment",
                        "ListCloudControlDeployments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
