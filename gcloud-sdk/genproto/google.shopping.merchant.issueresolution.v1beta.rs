// This file is @generated by prost-build.
/// Response containing an issue resolution content and actions for listed
/// account issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderAccountIssuesResponse {
    /// List of account issues for a given account.
    ///
    /// This list can be shown with compressed, expandable items. In the compressed
    /// form, the title and impact should be shown for each issue. Once the issue
    /// is expanded, the detailed
    /// [content][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.prerendered_content]
    /// and available
    /// [actions][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.actions]
    /// should be rendered.
    #[prost(message, repeated, tag = "1")]
    pub rendered_issues: ::prost::alloc::vec::Vec<RenderedIssue>,
}
/// Request to provide issue resolution content and actions for business's
/// account issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderAccountIssuesRequest {
    /// Required. The account to fetch issues for.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The [IETF BCP-47](<https://tools.ietf.org/html/bcp47>) language
    /// code used to localize issue resolution content. If not set, the result will
    /// be in default language `en-US`.
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    /// Optional. The [IANA](<https://www.iana.org/time-zones>) timezone used to
    /// localize times in an issue resolution content. For example
    /// 'America/Los_Angeles'. If not set, results will use as a default UTC.
    #[prost(string, tag = "3")]
    pub time_zone: ::prost::alloc::string::String,
    /// Optional. The payload for configuring how the content should be rendered.
    #[prost(message, optional, tag = "4")]
    pub payload: ::core::option::Option<RenderIssuesRequestPayload>,
}
/// The payload for configuring how the content should be rendered.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RenderIssuesRequestPayload {
    /// Optional. How the detailed content should be returned. Default option is to
    /// return the content as a pre-rendered HTML text.
    #[prost(enumeration = "ContentOption", optional, tag = "1")]
    pub content_option: ::core::option::Option<i32>,
    /// Optional. How actions with user input form should be handled. If not
    /// provided, actions will be returned as links that points the business to
    /// Merchant Center where they can request the action.
    #[prost(enumeration = "UserInputActionRenderingOption", optional, tag = "2")]
    pub user_input_action_option: ::core::option::Option<i32>,
}
/// Response containing an issue resolution content and actions for listed
/// product issues.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderProductIssuesResponse {
    /// List of issues for a given product.
    ///
    /// This list can be shown with compressed, expandable items. In the compressed
    /// form, the
    /// [title][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.title]
    /// and
    /// [impact][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.impact]
    /// should be shown for each issue. Once the issue is expanded, the detailed
    /// [content][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.prerendered_content]
    /// and available
    /// [actions][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.actions]
    /// should be rendered.
    #[prost(message, repeated, tag = "1")]
    pub rendered_issues: ::prost::alloc::vec::Vec<RenderedIssue>,
}
/// Request to provide an issue resolution content and actions for product issues
/// of business's product.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderProductIssuesRequest {
    /// Required. The name of the product to fetch issues for.
    /// Format: `accounts/{account}/products/{product}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The [IETF BCP-47](<https://tools.ietf.org/html/bcp47>) language
    /// code used to localize an issue resolution content. If not set, the result
    /// will be in default language `en-US`.
    #[prost(string, tag = "2")]
    pub language_code: ::prost::alloc::string::String,
    /// Optional. The [IANA](<https://www.iana.org/time-zones>) timezone used to
    /// localize times in an issue resolution content. For example
    /// 'America/Los_Angeles'. If not set, results will use as a default UTC.
    #[prost(string, tag = "3")]
    pub time_zone: ::prost::alloc::string::String,
    /// Optional. The payload for configuring how the content should be rendered.
    #[prost(message, optional, tag = "4")]
    pub payload: ::core::option::Option<RenderIssuesRequestPayload>,
}
/// An issue affecting specific business or their product.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RenderedIssue {
    /// Title of the issue.
    #[prost(string, tag = "1")]
    pub title: ::prost::alloc::string::String,
    /// Clarifies the severity of the issue.
    ///
    /// The [summarizing
    /// message][google.shopping.merchant.issueresolution.v1beta.Impact.message],
    /// if present, should be shown right under the title for each issue. It helps
    /// business to quickly understand the impact of the issue.
    ///
    /// The detailed
    /// [breakdown][google.shopping.merchant.issueresolution.v1beta.Impact.breakdowns]
    /// helps the business to fully understand the impact of the issue. It can be
    /// rendered as dialog that opens when the business mouse over the summarized
    /// impact statement.
    ///
    /// Issues with different
    /// [severity][google.shopping.merchant.issueresolution.v1beta.Impact.severity]
    /// can be styled differently. They may use a different color or icon to signal
    /// the difference between `ERROR`, `WARNING` and `INFO`.
    #[prost(message, optional, tag = "2")]
    pub impact: ::core::option::Option<Impact>,
    /// A list of actionable steps that can be executed to solve the issue. An
    /// example is requesting a re-review or providing arguments when business
    /// disagrees with the issue.
    ///
    /// Actions that are supported in (your) third-party application can be
    /// rendered as buttons and should be available to the business when they
    /// expand the issue.
    #[prost(message, repeated, tag = "4")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
    /// Detailed content of the issue. Should be shown to the business when they
    /// expand the issue. The form in which is the content returned is specified
    /// with the [content
    /// option][google.shopping.merchant.issueresolution.v1beta.RenderIssuesRequestPayload.content_option]
    /// request field.
    #[prost(oneof = "rendered_issue::Content", tags = "3")]
    pub content: ::core::option::Option<rendered_issue::Content>,
    /// Out-of-court dispute settlement (ODS) contains a link to a page where
    /// the business can bring their appeal to an [external
    /// body](<https://support.google.com/european-union-digital-services-act-redress-options/answer/13535501>).
    /// It may contains a detailed instructions and any values needed for the
    /// business to proceed with their request.
    ///
    /// The ODS is a part of the EU's Digital Service ACT (DSA). If present, it
    /// should be shown to the business.
    ///
    /// The ODS may differ for individual issues and thus it should be by default
    /// shown in the detail of the issue. It could be shown next to
    /// [actions][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.actions]
    /// for the issue.
    ///
    /// In some cases the ODS could be the same for all issues in the list. If the
    /// values for individual issues do not differ, then the ODS could be shown
    /// only once. For example under the list with issues. This is an optional UX
    /// improvement. If values differ, then ODS needs to be shown in details of
    /// individual issues.
    #[prost(oneof = "rendered_issue::OutOfCourtDisputeSettlement", tags = "5")]
    pub out_of_court_dispute_settlement: ::core::option::Option<
        rendered_issue::OutOfCourtDisputeSettlement,
    >,
}
/// Nested message and enum types in `RenderedIssue`.
pub mod rendered_issue {
    /// Detailed content of the issue. Should be shown to the business when they
    /// expand the issue. The form in which is the content returned is specified
    /// with the [content
    /// option][google.shopping.merchant.issueresolution.v1beta.RenderIssuesRequestPayload.content_option]
    /// request field.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Content {
        /// Details of the issue as a pre-rendered HTML. HTML elements contain CSS
        /// classes that can be used to customize the style of the content.
        ///
        /// Always sanitize the HTML before embedding it directly to your
        /// application. The sanitizer needs to allow basic HTML tags, such as:
        /// `div`, `span`, `p`, `a`, `ul`, `li`, `table`, `tr`, `td`. For example,
        /// you can use [DOMPurify](<https://www.npmjs.com/package/dompurify>).
        ///
        /// CSS classes:
        ///
        /// * `issue-detail` - top level container for the detail of the issue
        /// * `callout-banners` - section of the `issue-detail` with callout banners
        /// * `callout-banner` - single callout banner, inside `callout-banners`
        /// * `callout-banner-info` - callout with important information (default)
        /// * `callout-banner-warning` - callout with a warning
        /// * `callout-banner-error` - callout informing about an error (most severe)
        /// * `issue-content` - section of the `issue-detail`, contains multiple
        /// `content-element`
        /// * `content-element` - content element such as a list, link or paragraph,
        /// inside `issue-content`
        /// * `root-causes` - unordered list with items describing root causes of the
        /// issue, inside `issue-content`
        /// * `root-causes-intro` - intro text before the `root-causes` list, inside
        /// `issue-content`
        /// * `segment` - section of the text, `span` inside paragraph
        /// * `segment-attribute` - section of the text that represents a product
        /// attribute, for example 'image\_link'
        /// * `segment-literal` - section of the text that contains a special value,
        /// for example '0-1000 kg'
        /// * `segment-bold` - section of the text that should be rendered as bold
        /// * `segment-italic` - section of the text that should be rendered as
        /// italic
        /// * `tooltip` - used on paragraphs that should be rendered with a tooltip.
        /// A section of the text in such a paragraph will have a class
        /// `tooltip-text` and is intended to be shown in a mouse over dialog. If the
        /// style is not used, the `tooltip-text` section would be shown on a new
        /// line, after the main part of the text.
        /// * `tooltip-text` - marks a section of the text within a `tooltip`, that
        /// is intended to be shown in a mouse over dialog.
        /// * `tooltip-icon` - marks a section of the text within a `tooltip`, that
        /// can be replaced with a tooltip icon, for example '?' or 'i'. By default,
        /// this section contains a `br` tag, that is separating the main text and
        /// the tooltip text when the style is not used.
        /// * `tooltip-style-question` - the tooltip shows helpful information,
        /// can use the '?' as an icon.
        /// * `tooltip-style-info` - the tooltip adds additional information fitting
        /// to the context, can use the 'i' as an icon.
        /// * `content-moderation` - marks the paragraph that explains how the issue
        /// was identified.
        /// * `new-element` - Present for new elements added to the pre-rendered
        /// content in the future. To make sure that a new content element does not
        /// break your style, you can hide everything with this class.
        #[prost(string, tag = "3")]
        PrerenderedContent(::prost::alloc::string::String),
    }
    /// Out-of-court dispute settlement (ODS) contains a link to a page where
    /// the business can bring their appeal to an [external
    /// body](<https://support.google.com/european-union-digital-services-act-redress-options/answer/13535501>).
    /// It may contains a detailed instructions and any values needed for the
    /// business to proceed with their request.
    ///
    /// The ODS is a part of the EU's Digital Service ACT (DSA). If present, it
    /// should be shown to the business.
    ///
    /// The ODS may differ for individual issues and thus it should be by default
    /// shown in the detail of the issue. It could be shown next to
    /// [actions][google.shopping.merchant.issueresolution.v1beta.RenderedIssue.actions]
    /// for the issue.
    ///
    /// In some cases the ODS could be the same for all issues in the list. If the
    /// values for individual issues do not differ, then the ODS could be shown
    /// only once. For example under the list with issues. This is an optional UX
    /// improvement. If values differ, then ODS needs to be shown in details of
    /// individual issues.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OutOfCourtDisputeSettlement {
        /// Pre-rendered HTML that contains a link to the external location where the
        /// ODS can be requested and instructions for how to request it. HTML
        /// elements contain CSS classes that can be used to customize the style of
        /// this snippet.
        ///
        /// Always sanitize the HTML before embedding it directly to your
        /// application. The sanitizer needs to allow basic HTML tags, such as:
        /// `div`, `span`, `p`, `a`, `ul`, `li`, `table`, `tr`, `td`. For example,
        /// you can use [DOMPurify](<https://www.npmjs.com/package/dompurify>).
        ///
        /// CSS classes:
        ///
        /// * `ods-section`* - wrapper around the out-of-court dispute resolution
        /// section
        /// * `ods-description`* - intro text for the out-of-court dispute
        /// resolution. It may contain multiple segments and a link.
        /// * `ods-param`* - wrapper around the header-value pair for parameters that
        /// the business may need to provide during the ODS process.
        /// * `ods-routing-id`* - ods param for the Routing ID.
        /// * `ods-reference-id`* - ods param for the Routing ID.
        /// * `ods-param-header`* - header for the ODS parameter
        /// * `ods-param-value`* - value of the ODS parameter. This value should be
        /// rendered in a way that it is easy for the user to identify and copy.
        /// * `segment` - section of the text, `span` inside paragraph
        /// * `segment-attribute` - section of the text that represents a product
        /// attribute, for example 'image\_link'
        /// * `segment-literal` - section of the text that contains a special value,
        /// for example '0-1000 kg'
        /// * `segment-bold` - section of the text that should be rendered as bold
        /// * `segment-italic` - section of the text that should be rendered as
        /// italic
        /// * `tooltip` - used on paragraphs that should be rendered with a tooltip.
        /// A section of the text in such a paragraph will have a class
        /// `tooltip-text` and is intended to be shown in a mouse over dialog. If the
        /// style is not used, the `tooltip-text` section would be shown on a new
        /// line, after the main part of the text.
        /// * `tooltip-text` - marks a section of the text within a `tooltip`, that
        /// is intended to be shown in a mouse over dialog.
        /// * `tooltip-icon` - marks a section of the text within a `tooltip`, that
        /// can be replaced with a tooltip icon, for example '?' or 'i'. By default,
        /// this section contains a `br` tag, that is separating the main text and
        /// the tooltip text when the style is not used.
        /// * `tooltip-style-question` - the tooltip shows helpful information,
        /// can use the '?' as an icon.
        /// * `tooltip-style-info` - the tooltip adds additional information fitting
        /// to the context, can use the 'i' as an icon.
        #[prost(string, tag = "5")]
        PrerenderedOutOfCourtDisputeSettlement(::prost::alloc::string::String),
    }
}
/// Overall impact of the issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Impact {
    /// Optional. Message summarizing the overall impact of the issue. If present,
    /// it should be rendered to the business. For example: "Disapproves 90k offers
    /// in 25 countries"
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    /// The severity of the issue.
    #[prost(enumeration = "Severity", tag = "2")]
    pub severity: i32,
    /// Detailed impact breakdown. Explains the types of restriction the issue has
    /// in different shopping destinations and territory. If present, it should be
    /// rendered to the business. Can be shown as a mouse over dropdown or a
    /// dialog. Each breakdown item represents a group of regions with the same
    /// impact details.
    #[prost(message, repeated, tag = "3")]
    pub breakdowns: ::prost::alloc::vec::Vec<Breakdown>,
}
/// A detailed impact breakdown for a group of regions where the impact of the
/// issue on different shopping destinations is the same.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Breakdown {
    /// Lists of regions. Should be rendered as a title for this group of details.
    /// The full list should be shown to the business. If the list is too long, it
    /// is recommended to make it expandable.
    #[prost(message, repeated, tag = "1")]
    pub regions: ::prost::alloc::vec::Vec<breakdown::Region>,
    /// Human readable, localized description of issue's effect on different
    /// targets. Should be rendered as a list.
    ///
    /// For example:
    ///
    /// * "Products not showing in ads"
    /// * "Products not showing organically"
    #[prost(string, repeated, tag = "4")]
    pub details: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Breakdown`.
pub mod breakdown {
    /// Region with code and localized name.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Region {
        /// The \[CLDR territory code\]
        /// (<http://www.unicode.org/repos/cldr/tags/latest/common/main/en.xml>)
        #[prost(string, tag = "1")]
        pub code: ::prost::alloc::string::String,
        /// The localized name of the region.
        /// For region with code='001' the value is 'All countries' or the equivalent
        /// in other languages.
        #[prost(string, tag = "2")]
        pub name: ::prost::alloc::string::String,
    }
}
/// An actionable step that can be executed to solve the issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    /// Label of the action button.
    #[prost(string, tag = "4")]
    pub button_label: ::prost::alloc::string::String,
    /// Controlling whether the button is active or disabled. The value is 'false'
    /// when the action was already requested or is not available. If the action is
    /// not available then a
    /// [reason][google.shopping.merchant.issueresolution.v1beta.Action.reasons]
    /// will be present. If (your) third-party application shows a disabled button
    /// for action that is not available, then it should also show reasons.
    #[prost(bool, tag = "5")]
    pub is_available: bool,
    /// List of reasons why the action is not available. The list of reasons is
    /// empty if the action is available. If there is only one reason, it can be
    /// displayed next to the disabled button. If there are more reasons, all of
    /// them should be displayed, for example in a pop-up dialog.
    #[prost(message, repeated, tag = "6")]
    pub reasons: ::prost::alloc::vec::Vec<action::Reason>,
    /// An actionable step that can be executed to solve the issue.
    #[prost(oneof = "action::Action", tags = "2, 3, 7")]
    pub action: ::core::option::Option<action::Action>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    /// A single reason why the action is not available.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Reason {
        /// Messages summarizing the reason, why the action is not available.
        /// For example: "Review requested on Jan 03. Review requests can take a few
        /// days to complete."
        #[prost(string, tag = "1")]
        pub message: ::prost::alloc::string::String,
        /// Detailed explanation of the reason. Should be displayed as a hint if
        /// present.
        #[prost(string, optional, tag = "2")]
        pub detail: ::core::option::Option<::prost::alloc::string::String>,
        /// Optional. An action that needs to be performed to solve the problem
        /// represented by this reason. This action will always be available. Should
        /// be rendered as a link or button next to the summarizing message.
        ///
        /// For example, the review may be available only once the business configure
        /// all required attributes. In such a situation this action can be a link to
        /// the form, where they can fill the missing attribute to unblock the main
        /// action.
        #[prost(message, optional, tag = "3")]
        pub action: ::core::option::Option<super::Action>,
    }
    /// An actionable step that can be executed to solve the issue.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        /// Action implemented and performed in (your) third-party application. The
        /// application should point the business to the place, where they can access
        /// the corresponding functionality or provide instructions, if the specific
        /// functionality is not available.
        #[prost(message, tag = "2")]
        BuiltinSimpleAction(super::BuiltInSimpleAction),
        /// Action that is implemented and performed outside of (your) third-party
        /// application. The application needs to redirect the business to the
        /// external location where they can perform the action.
        #[prost(message, tag = "3")]
        ExternalAction(super::ExternalAction),
        /// Action implemented and performed in (your) third-party application.
        /// The application needs to show an additional content and input form to the
        /// business as specified for given action. They can trigger the action only
        /// when they provided all required inputs.
        #[prost(message, tag = "7")]
        BuiltinUserInputAction(super::BuiltInUserInputAction),
    }
}
/// Action that is implemented and performed in (your) third-party application.
/// Represents various functionality that is expected to be available to business
/// and will help them with resolving the issue. The application should point the
/// business to the place, where they can access the corresponding functionality.
/// If the functionality is not supported, it is recommended to explain the
/// situation to the business and provide them with instructions how to solve the
/// issue.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuiltInSimpleAction {
    /// The type of action that represents a functionality that is expected to be
    /// available in third-party application.
    #[prost(enumeration = "built_in_simple_action::BuiltInSimpleActionType", tag = "1")]
    pub r#type: i32,
    /// The attribute that needs to be updated. Present when the
    /// [type][google.shopping.merchant.issueresolution.v1beta.BuiltInSimpleAction.type]
    /// is `EDIT_ITEM_ATTRIBUTE`.
    ///
    /// This field contains a code for attribute, represented in snake_case. You
    /// can find a list of product's attributes, with their codes
    /// [here](<https://support.google.com/merchants/answer/7052112>).
    #[prost(string, optional, tag = "2")]
    pub attribute_code: ::core::option::Option<::prost::alloc::string::String>,
    /// Long text from an external source that should be available to the business.
    /// Present when the
    /// [type][google.shopping.merchant.issueresolution.v1beta.BuiltInSimpleAction.type]
    /// is `SHOW_ADDITIONAL_CONTENT`.
    #[prost(message, optional, tag = "3")]
    pub additional_content: ::core::option::Option<
        built_in_simple_action::AdditionalContent,
    >,
}
/// Nested message and enum types in `BuiltInSimpleAction`.
pub mod built_in_simple_action {
    /// Long text from external source.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdditionalContent {
        /// Title of the additional content;
        #[prost(string, tag = "1")]
        pub title: ::prost::alloc::string::String,
        /// Long text organized into paragraphs.
        #[prost(string, repeated, tag = "2")]
        pub paragraphs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Enum specifying the type of action in third-party application.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BuiltInSimpleActionType {
        /// Default value. Will never be provided by the API.
        Unspecified = 0,
        /// Redirect the business to the part of your application where they can
        /// verify their phone.
        VerifyPhone = 1,
        /// Redirect the business to the part of your application where they can
        /// claim their website.
        ClaimWebsite = 2,
        /// Redirect the business to the part of your application where they can add
        /// products.
        AddProducts = 3,
        /// Open a form where the business can edit their contact information.
        AddContactInfo = 4,
        /// Redirect the business to the part of your application where they can link
        /// ads account.
        LinkAdsAccount = 5,
        /// Open a form where the business can add their business registration
        /// number.
        AddBusinessRegistrationNumber = 6,
        /// Open a form where the business can edit an attribute. The attribute that
        /// needs to be updated is specified in
        /// [attribute_code][google.shopping.merchant.issueresolution.v1beta.BuiltInSimpleAction.attribute_code]
        /// field of the action.
        EditItemAttribute = 7,
        /// Redirect the business from the product issues to the diagnostic page with
        /// their account issues in your application.
        ///
        /// This action will be returned only for product issues that are caused by
        /// an account issue and thus the business should resolve the problem on the
        /// account level.
        FixAccountIssue = 8,
        /// Show [additional
        /// content][google.shopping.merchant.issueresolution.v1beta.BuiltInSimpleAction.additional_content]
        /// to the business.
        ///
        /// This action will be used for example to deliver a justification from
        /// national authority.
        ShowAdditionalContent = 9,
    }
    impl BuiltInSimpleActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BUILT_IN_SIMPLE_ACTION_TYPE_UNSPECIFIED",
                Self::VerifyPhone => "VERIFY_PHONE",
                Self::ClaimWebsite => "CLAIM_WEBSITE",
                Self::AddProducts => "ADD_PRODUCTS",
                Self::AddContactInfo => "ADD_CONTACT_INFO",
                Self::LinkAdsAccount => "LINK_ADS_ACCOUNT",
                Self::AddBusinessRegistrationNumber => "ADD_BUSINESS_REGISTRATION_NUMBER",
                Self::EditItemAttribute => "EDIT_ITEM_ATTRIBUTE",
                Self::FixAccountIssue => "FIX_ACCOUNT_ISSUE",
                Self::ShowAdditionalContent => "SHOW_ADDITIONAL_CONTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BUILT_IN_SIMPLE_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "VERIFY_PHONE" => Some(Self::VerifyPhone),
                "CLAIM_WEBSITE" => Some(Self::ClaimWebsite),
                "ADD_PRODUCTS" => Some(Self::AddProducts),
                "ADD_CONTACT_INFO" => Some(Self::AddContactInfo),
                "LINK_ADS_ACCOUNT" => Some(Self::LinkAdsAccount),
                "ADD_BUSINESS_REGISTRATION_NUMBER" => {
                    Some(Self::AddBusinessRegistrationNumber)
                }
                "EDIT_ITEM_ATTRIBUTE" => Some(Self::EditItemAttribute),
                "FIX_ACCOUNT_ISSUE" => Some(Self::FixAccountIssue),
                "SHOW_ADDITIONAL_CONTENT" => Some(Self::ShowAdditionalContent),
                _ => None,
            }
        }
    }
}
/// Action that is implemented and performed in (your) third-party application.
/// The application needs to show an additional content and input form to the
/// business. They can start the action only when they provided all required
/// inputs. The application will request processing of the action by calling the
/// [triggeraction
/// method](<https://developers.google.com/merchant/api/reference/rest/issueresolution_v1beta/issueresolution/triggeraction>).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BuiltInUserInputAction {
    /// Contains the action's context that must be included as part of the
    /// [TriggerActionPayload.action_context][google.shopping.merchant.issueresolution.v1beta.TriggerActionPayload.action_context]
    /// in
    /// [TriggerActionRequest.payload][google.shopping.merchant.issueresolution.v1beta.TriggerActionRequest.payload]
    /// to call the `triggeraction` method. The content should be treated as opaque
    /// and must not be modified.
    #[prost(string, tag = "1")]
    pub action_context: ::prost::alloc::string::String,
    /// Actions may provide multiple different flows. Business selects one that
    /// fits best to their intent. Selecting the flow is the first step in user's
    /// interaction with the action. It affects what input fields will be available
    /// and required and also how the request will be processed.
    #[prost(message, repeated, tag = "3")]
    pub flows: ::prost::alloc::vec::Vec<ActionFlow>,
}
/// Flow that can be selected for an action. When a business selects a flow,
/// application should open a dialog with more information and input form.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionFlow {
    /// Not for display but need to be sent back for the selected action flow.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Text value describing the intent for the action flow. It can be used as an
    /// input label if business needs to pick one of multiple flows. For example:
    /// "I disagree with the issue"
    #[prost(string, tag = "2")]
    pub label: ::prost::alloc::string::String,
    /// A list of input fields.
    #[prost(message, repeated, tag = "3")]
    pub inputs: ::prost::alloc::vec::Vec<InputField>,
    /// Title of the request dialog. For example: "Before you request a review"
    #[prost(string, tag = "4")]
    pub dialog_title: ::prost::alloc::string::String,
    /// Message displayed in the request dialog. For example: "Make sure you've
    /// fixed all your country-specific issues. If not, you may have to wait 7 days
    /// to request another review". There may be an more information to be shown in
    /// a tooltip.
    #[prost(message, optional, tag = "7")]
    pub dialog_message: ::core::option::Option<TextWithTooltip>,
    /// Important message to be highlighted in the request dialog. For example:
    /// "You can only request a review for disagreeing with this issue once. If
    /// it's not approved, you'll need to fix the issue and wait a few days before
    /// you can request another review."
    #[prost(message, optional, tag = "8")]
    pub dialog_callout: ::core::option::Option<Callout>,
    /// Label for the button to trigger the action from the action dialog. For
    /// example: "Request review"
    #[prost(string, tag = "9")]
    pub dialog_button_label: ::prost::alloc::string::String,
}
/// Input field that needs to be available to the business. If the field is
/// marked as required, then a value needs to be provided for a successful
/// processing of the request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputField {
    /// Not for display but need to be sent back for the given input field.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Input field label. There may be more information to be shown in a tooltip.
    #[prost(message, optional, tag = "2")]
    pub label: ::core::option::Option<TextWithTooltip>,
    /// Whether the field is required. The action button needs to stay disabled
    /// till values for all required fields are provided.
    #[prost(bool, tag = "3")]
    pub required: bool,
    /// Specific type of the input field.
    #[prost(oneof = "input_field::ValueInput", tags = "4, 5, 6")]
    pub value_input: ::core::option::Option<input_field::ValueInput>,
}
/// Nested message and enum types in `InputField`.
pub mod input_field {
    /// Text input allows the business to provide a text value.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextInput {
        /// Type of the text input
        #[prost(enumeration = "text_input::TextInputType", tag = "1")]
        pub r#type: i32,
        /// Additional info regarding the field to be displayed to the business. For
        /// example, warning to not include personal identifiable information. There
        /// may be more information to be shown in a tooltip.
        #[prost(message, optional, tag = "2")]
        pub additional_info: ::core::option::Option<super::TextWithTooltip>,
        /// Information about the required format. If present, it should be shown
        /// close to the input field to help the business to provide a correct value.
        /// For example: "VAT numbers should be in a format similar to SK9999999999"
        #[prost(string, optional, tag = "3")]
        pub format_info: ::core::option::Option<::prost::alloc::string::String>,
        /// Text to be used as the
        /// [aria-label](<https://www.w3.org/TR/WCAG20-TECHS/ARIA14.html>) for the
        /// input.
        #[prost(string, optional, tag = "4")]
        pub aria_label: ::core::option::Option<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `TextInput`.
    pub mod text_input {
        /// Enum specifying the type of the text input and how it should be rendered.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum TextInputType {
            /// Default value. Will never be provided by the API.
            Unspecified = 0,
            /// Used when a short text is expected. The field can be rendered as a
            /// [text
            /// field](<https://www.w3.org/TR/2012/WD-html-markup-20121025/input.text.html#input.text>).
            GenericShortText = 1,
            /// Used when a longer text is expected. The field should be rendered as a
            /// [textarea](<https://www.w3.org/TR/2012/WD-html-markup-20121025/textarea.html#textarea>).
            GenericLongText = 2,
        }
        impl TextInputType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "TEXT_INPUT_TYPE_UNSPECIFIED",
                    Self::GenericShortText => "GENERIC_SHORT_TEXT",
                    Self::GenericLongText => "GENERIC_LONG_TEXT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TEXT_INPUT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "GENERIC_SHORT_TEXT" => Some(Self::GenericShortText),
                    "GENERIC_LONG_TEXT" => Some(Self::GenericLongText),
                    _ => None,
                }
            }
        }
    }
    /// Choice input allows the business to select one of the offered choices. Some
    /// choices may be linked to additional input fields that should be displayed
    /// under or next to the choice option. The value for the additional input
    /// field needs to be provided only when the specific choice is selected by the
    /// the business. For example, additional input field can be hidden or disabled
    /// until the business selects the specific choice.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChoiceInput {
        /// A list of choices. Only one option can be selected.
        #[prost(message, repeated, tag = "1")]
        pub options: ::prost::alloc::vec::Vec<choice_input::ChoiceInputOption>,
    }
    /// Nested message and enum types in `ChoiceInput`.
    pub mod choice_input {
        /// A choice that the business can select.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ChoiceInputOption {
            /// Not for display but need to be sent back for the selected choice
            /// option.
            #[prost(string, tag = "1")]
            pub id: ::prost::alloc::string::String,
            /// Short description of the choice option. There may be more information
            /// to be shown as a tooltip.
            #[prost(message, optional, tag = "2")]
            pub label: ::core::option::Option<super::super::TextWithTooltip>,
            /// Input that should be displayed when this option is selected.
            /// The additional input will not contain a `ChoiceInput`.
            #[prost(message, optional, tag = "3")]
            pub additional_input: ::core::option::Option<super::super::InputField>,
        }
    }
    /// Checkbox input allows the business to provide a boolean value. Corresponds
    /// to the [html input
    /// type=checkbox](<https://www.w3.org/TR/2012/WD-html-markup-20121025/input.checkbox.html#input.checkbox>).
    ///
    /// If the business checks the box, the input value for the field is `true`,
    /// otherwise it is `false`.
    ///
    /// This type of input is often used as a confirmation that the business
    /// completed required steps before they are allowed to start the action. In
    /// such a case, the input field is marked as
    /// [required][google.shopping.merchant.issueresolution.v1beta.InputField.required]
    /// and the button to trigger the action should stay disabled until the
    /// business checks the box.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CheckboxInput {}
    /// Specific type of the input field.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueInput {
        /// Input field to provide text information.
        /// Corresponds to the [html input
        /// type=text](<https://www.w3.org/TR/2012/WD-html-markup-20121025/input.text.html#input.text>)
        /// or [html
        /// textarea](<https://www.w3.org/TR/2012/WD-html-markup-20121025/textarea.html#textarea>).
        #[prost(message, tag = "4")]
        TextInput(TextInput),
        /// Input field to select one of the offered choices.
        /// Corresponds to the [html input
        /// type=radio](<https://www.w3.org/TR/2012/WD-html-markup-20121025/input.radio.html#input.radio>).
        #[prost(message, tag = "5")]
        ChoiceInput(ChoiceInput),
        /// Input field to provide a boolean value.
        /// Corresponds to the [html input
        /// type=checkbox](<https://www.w3.org/TR/2012/WD-html-markup-20121025/input.checkbox.html#input.checkbox>).
        #[prost(message, tag = "6")]
        CheckboxInput(CheckboxInput),
    }
}
/// Block of text that may contain a tooltip with more information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextWithTooltip {
    /// The suggested type of an icon for tooltip, if a tooltip is present.
    #[prost(enumeration = "text_with_tooltip::TooltipIconStyle", tag = "3")]
    pub tooltip_icon_style: i32,
    /// Value of the text message. The form in which the value is returned is
    /// specified with the content option request field.
    #[prost(oneof = "text_with_tooltip::Value", tags = "1")]
    pub value: ::core::option::Option<text_with_tooltip::Value>,
    /// Text that is meant to be shown in a tooltip for the main message. The
    /// tooltip is present when there is additional content needed to be available
    /// to the business. The form in which the value is returned is specified with
    /// the content option request field.
    #[prost(oneof = "text_with_tooltip::TooltipValue", tags = "2")]
    pub tooltip_value: ::core::option::Option<text_with_tooltip::TooltipValue>,
}
/// Nested message and enum types in `TextWithTooltip`.
pub mod text_with_tooltip {
    /// Enum specifying the type of an icon that is being used to display a
    /// corresponding tooltip in the Merchant Center.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TooltipIconStyle {
        /// Default value. Will never be provided by the API.
        Unspecified = 0,
        /// Used when the tooltip adds additional information to the context,
        /// the 'i' can be used as an icon.
        Info = 1,
        /// Used when the tooltip shows helpful information, the '?' can be used as
        /// an icon.
        Question = 2,
    }
    impl TooltipIconStyle {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TOOLTIP_ICON_STYLE_UNSPECIFIED",
                Self::Info => "INFO",
                Self::Question => "QUESTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOOLTIP_ICON_STYLE_UNSPECIFIED" => Some(Self::Unspecified),
                "INFO" => Some(Self::Info),
                "QUESTION" => Some(Self::Question),
                _ => None,
            }
        }
    }
    /// Value of the text message. The form in which the value is returned is
    /// specified with the content option request field.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// Value of the message as a simple text.
        #[prost(string, tag = "1")]
        SimpleValue(::prost::alloc::string::String),
    }
    /// Text that is meant to be shown in a tooltip for the main message. The
    /// tooltip is present when there is additional content needed to be available
    /// to the business. The form in which the value is returned is specified with
    /// the content option request field.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TooltipValue {
        /// Value of the tooltip as a simple text.
        #[prost(string, tag = "2")]
        SimpleTooltipValue(::prost::alloc::string::String),
    }
}
/// An important message that should be highlighted. Usually displayed as a
/// banner.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Callout {
    /// Can be used to render messages with different severity in different styles.
    /// Snippets off all types contain important information that should be
    /// displayed to the business.
    #[prost(enumeration = "callout::CalloutStyleHint", tag = "1")]
    pub style_hint: i32,
    /// A full message that needs to be shown to the business.
    #[prost(message, optional, tag = "3")]
    pub full_message: ::core::option::Option<TextWithTooltip>,
}
/// Nested message and enum types in `Callout`.
pub mod callout {
    /// Enum specifying the suggested style, how the message should be rendered.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CalloutStyleHint {
        /// Default value. Will never be provided by the API.
        Unspecified = 0,
        /// The most important type of information highlighting problems, like an
        /// unsuccessful outcome of previously requested actions.
        Error = 1,
        /// Information warning about pending problems, risks or deadlines.
        Warning = 2,
        /// Default severity for important information like pending status of
        /// previously requested action or cooldown for re-review.
        Info = 3,
    }
    impl CalloutStyleHint {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CALLOUT_STYLE_HINT_UNSPECIFIED",
                Self::Error => "ERROR",
                Self::Warning => "WARNING",
                Self::Info => "INFO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CALLOUT_STYLE_HINT_UNSPECIFIED" => Some(Self::Unspecified),
                "ERROR" => Some(Self::Error),
                "WARNING" => Some(Self::Warning),
                "INFO" => Some(Self::Info),
                _ => None,
            }
        }
    }
}
/// Action that is implemented and performed outside of the third-party
/// application. It should redirect the business to the provided URL of an
/// external system where they can perform the action. For example to request a
/// review in the Merchant Center.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalAction {
    /// The type of external action.
    #[prost(enumeration = "external_action::ExternalActionType", tag = "1")]
    pub r#type: i32,
    /// URL to external system, for example Merchant Center, where the business can
    /// perform the action.
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExternalAction`.
pub mod external_action {
    /// Enum specifying the type of action that requires to redirect the business
    /// to an external location.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExternalActionType {
        /// Default value. Will never be provided by the API.
        Unspecified = 0,
        /// Redirect to Merchant Center where the business can request a review for
        /// issue related to their product.
        ReviewProductIssueInMerchantCenter = 1,
        /// Redirect to Merchant Center where the business can request a review for
        /// issue related to their account.
        ReviewAccountIssueInMerchantCenter = 2,
        /// Redirect to the form in Help Center where the business can request a
        /// legal appeal for the issue.
        LegalAppealInHelpCenter = 3,
        /// Redirect to Merchant Center where the business can perform identity
        /// verification.
        VerifyIdentityInMerchantCenter = 4,
    }
    impl ExternalActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXTERNAL_ACTION_TYPE_UNSPECIFIED",
                Self::ReviewProductIssueInMerchantCenter => {
                    "REVIEW_PRODUCT_ISSUE_IN_MERCHANT_CENTER"
                }
                Self::ReviewAccountIssueInMerchantCenter => {
                    "REVIEW_ACCOUNT_ISSUE_IN_MERCHANT_CENTER"
                }
                Self::LegalAppealInHelpCenter => "LEGAL_APPEAL_IN_HELP_CENTER",
                Self::VerifyIdentityInMerchantCenter => {
                    "VERIFY_IDENTITY_IN_MERCHANT_CENTER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXTERNAL_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "REVIEW_PRODUCT_ISSUE_IN_MERCHANT_CENTER" => {
                    Some(Self::ReviewProductIssueInMerchantCenter)
                }
                "REVIEW_ACCOUNT_ISSUE_IN_MERCHANT_CENTER" => {
                    Some(Self::ReviewAccountIssueInMerchantCenter)
                }
                "LEGAL_APPEAL_IN_HELP_CENTER" => Some(Self::LegalAppealInHelpCenter),
                "VERIFY_IDENTITY_IN_MERCHANT_CENTER" => {
                    Some(Self::VerifyIdentityInMerchantCenter)
                }
                _ => None,
            }
        }
    }
}
/// Request to start the selected action
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerActionRequest {
    /// Required. The business's account that is triggering the action.
    /// Format: `accounts/{account}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The payload for the triggered action.
    #[prost(message, optional, tag = "2")]
    pub payload: ::core::option::Option<TriggerActionPayload>,
    /// Optional. Language code [IETF BCP 47
    /// syntax](<https://tools.ietf.org/html/bcp47>) used to localize the response.
    /// If not set, the result will be in default language `en-US`.
    #[prost(string, tag = "3")]
    pub language_code: ::prost::alloc::string::String,
}
/// The payload for the triggered action.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerActionPayload {
    /// Required. The
    /// [context][google.shopping.merchant.issueresolution.v1beta.BuiltInUserInputAction.action_context]
    /// from the selected action. The value is obtained from rendered issues and
    /// needs to be sent back to identify the
    /// [action][google.shopping.merchant.issueresolution.v1beta.Action.builtin_user_input_action]
    /// that is being triggered.
    #[prost(string, tag = "1")]
    pub action_context: ::prost::alloc::string::String,
    /// Required. Input provided by the business.
    #[prost(message, optional, tag = "2")]
    pub action_input: ::core::option::Option<ActionInput>,
}
/// Response informing about the started action.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TriggerActionResponse {
    /// The message for the business.
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
}
/// Input provided by the business.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionInput {
    /// Required.
    /// [Id][google.shopping.merchant.issueresolution.v1beta.ActionFlow.id] of the
    /// selected action flow.
    #[prost(string, tag = "1")]
    pub action_flow_id: ::prost::alloc::string::String,
    /// Required. Values for input fields.
    #[prost(message, repeated, tag = "2")]
    pub input_values: ::prost::alloc::vec::Vec<InputValue>,
}
/// Input provided by the business for input field.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputValue {
    /// Required.
    /// [Id][google.shopping.merchant.issueresolution.v1beta.InputField.id] of the
    /// corresponding input field.
    #[prost(string, tag = "1")]
    pub input_field_id: ::prost::alloc::string::String,
    /// Value provided by the business.
    #[prost(oneof = "input_value::Value", tags = "2, 3, 4")]
    pub value: ::core::option::Option<input_value::Value>,
}
/// Nested message and enum types in `InputValue`.
pub mod input_value {
    /// Value for [text
    /// input][google.shopping.merchant.issueresolution.v1beta.InputField.TextInput]
    /// field.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TextInputValue {
        /// Required. Text provided by the business.
        #[prost(string, tag = "1")]
        pub value: ::prost::alloc::string::String,
    }
    /// Value for [choice
    /// input][google.shopping.merchant.issueresolution.v1beta.InputField.ChoiceInput]
    /// field.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChoiceInputValue {
        /// Required. [Id][InputField.ChoiceInput.id] of the option that was selected
        /// by the business.
        #[prost(string, tag = "1")]
        pub choice_input_option_id: ::prost::alloc::string::String,
    }
    /// Value for [checkbox
    /// input][google.shopping.merchant.issueresolution.v1beta.InputField.CheckboxInput]
    /// field.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CheckboxInputValue {
        /// Required. True if the business checked the box field. False otherwise.
        #[prost(bool, tag = "1")]
        pub value: bool,
    }
    /// Value provided by the business.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        /// Value for [text
        /// input][google.shopping.merchant.issueresolution.v1beta.InputField.TextInput]
        /// field.
        #[prost(message, tag = "2")]
        TextInputValue(TextInputValue),
        /// Value for [choice
        /// input][google.shopping.merchant.issueresolution.v1beta.InputField.ChoiceInput]
        /// field.
        #[prost(message, tag = "3")]
        ChoiceInputValue(ChoiceInputValue),
        /// Value for [checkbox
        /// input][google.shopping.merchant.issueresolution.v1beta.InputField.CheckboxInput]
        /// field.
        #[prost(message, tag = "4")]
        CheckboxInputValue(CheckboxInputValue),
    }
}
/// Enum specifying the severity of the issue.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Severity {
    /// Default value. Will never be provided by the API.
    Unspecified = 0,
    /// Causes either an account suspension or an item disapproval. Errors should
    /// be resolved as soon as possible to ensure items are eligible to appear in
    /// results again.
    Error = 1,
    /// Warnings can negatively impact the performance of ads and can lead to item
    /// or account suspensions in the future unless the issue is resolved.
    Warning = 2,
    /// Infos are suggested optimizations to increase data quality. Resolving these
    /// issues is recommended, but not required.
    Info = 3,
}
impl Severity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SEVERITY_UNSPECIFIED",
            Self::Error => "ERROR",
            Self::Warning => "WARNING",
            Self::Info => "INFO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEVERITY_UNSPECIFIED" => Some(Self::Unspecified),
            "ERROR" => Some(Self::Error),
            "WARNING" => Some(Self::Warning),
            "INFO" => Some(Self::Info),
            _ => None,
        }
    }
}
/// Enum specifying how is the content returned.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentOption {
    /// Default value. Will never be provided by the API.
    Unspecified = 0,
    /// Returns the detail of the issue as a pre-rendered HTML text.
    PreRenderedHtml = 1,
}
impl ContentOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CONTENT_OPTION_UNSPECIFIED",
            Self::PreRenderedHtml => "PRE_RENDERED_HTML",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTENT_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "PRE_RENDERED_HTML" => Some(Self::PreRenderedHtml),
            _ => None,
        }
    }
}
/// Enum specifying how actions with user input forms, such as requesting
/// re-review, are handled.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UserInputActionRenderingOption {
    /// Default value. Will never be provided by the API.
    Unspecified = 0,
    /// Actions that require user input are represented only as links that points
    /// the business to Merchant Center where they can request the action. Provides
    /// easier to implement alternative to `BUILT_IN_USER_INPUT_ACTIONS`.
    RedirectToMerchantCenter = 1,
    /// Returns content and input form definition for each complex action. Your
    /// application needs to display this content and input form to the business
    /// before they can request processing of the action. To start the action, your
    /// application needs to call the `triggeraction` method.
    BuiltInUserInputActions = 2,
}
impl UserInputActionRenderingOption {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "USER_INPUT_ACTION_RENDERING_OPTION_UNSPECIFIED",
            Self::RedirectToMerchantCenter => "REDIRECT_TO_MERCHANT_CENTER",
            Self::BuiltInUserInputActions => "BUILT_IN_USER_INPUT_ACTIONS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "USER_INPUT_ACTION_RENDERING_OPTION_UNSPECIFIED" => Some(Self::Unspecified),
            "REDIRECT_TO_MERCHANT_CENTER" => Some(Self::RedirectToMerchantCenter),
            "BUILT_IN_USER_INPUT_ACTIONS" => Some(Self::BuiltInUserInputActions),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod issue_resolution_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to provide an issue resolution content for account issues and product
    /// issues.
    #[derive(Debug, Clone)]
    pub struct IssueResolutionServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IssueResolutionServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IssueResolutionServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IssueResolutionServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IssueResolutionServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Provide a list of business's account issues with an issue resolution
        /// content and available actions. This content and actions are meant to be
        /// rendered and shown in third-party applications.
        pub async fn render_account_issues(
            &mut self,
            request: impl tonic::IntoRequest<super::RenderAccountIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RenderAccountIssuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.issueresolution.v1beta.IssueResolutionService/RenderAccountIssues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.issueresolution.v1beta.IssueResolutionService",
                        "RenderAccountIssues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Provide a list of issues for business's product with an issue resolution
        /// content and available actions. This content and actions are meant to be
        /// rendered and shown in third-party applications.
        pub async fn render_product_issues(
            &mut self,
            request: impl tonic::IntoRequest<super::RenderProductIssuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RenderProductIssuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.issueresolution.v1beta.IssueResolutionService/RenderProductIssues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.issueresolution.v1beta.IssueResolutionService",
                        "RenderProductIssues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Start an action. The action can be requested by a business in
        /// third-party application. Before the business can request the action, the
        /// third-party application needs to show them action specific content and
        /// display a user input form.
        ///
        /// The action can be successfully started only once all `required` inputs are
        /// provided. If any `required` input is missing, or invalid value was
        /// provided, the service will return 400 error. Validation errors will contain
        /// [Ids][google.shopping.merchant.issueresolution.v1beta.InputField.id] for
        /// all problematic field together with translated, human readable error
        /// messages that can be shown to the user.
        pub async fn trigger_action(
            &mut self,
            request: impl tonic::IntoRequest<super::TriggerActionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TriggerActionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.shopping.merchant.issueresolution.v1beta.IssueResolutionService/TriggerAction",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.shopping.merchant.issueresolution.v1beta.IssueResolutionService",
                        "TriggerAction",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
