// This file is @generated by prost-build.
/// Request message to subscribe the Audit Manager service for given resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnrollResourceRequest {
    /// Required. The resource to be enrolled to the audit manager. Scope format
    /// should be resource_type/resource_identifier Eg:
    /// projects/{project}/locations/{location},
    /// folders/{folder}/locations/{location}
    /// organizations/{organization}/locations/{location}
    #[prost(string, tag = "1")]
    pub scope: ::prost::alloc::string::String,
    /// Required. List of destination among which customer can choose to upload
    /// their reports during the audit process. While enrolling at a
    /// organization/folder level, customer can choose Cloud storage bucket in any
    /// project. If the audit is triggered at project level using the service agent
    /// at organization/folder level, all the destination options associated with
    /// respective organization/folder level service agent will be available to
    /// auditing projects.
    #[prost(message, repeated, tag = "2")]
    pub destinations: ::prost::alloc::vec::Vec<
        enroll_resource_request::EligibleDestination,
    >,
}
/// Nested message and enum types in `EnrollResourceRequest`.
pub mod enroll_resource_request {
    /// The destination details where the audit report must be uploaded.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EligibleDestination {
        /// The options for the report destination location.
        #[prost(oneof = "eligible_destination::EligibleDestinations", tags = "3")]
        pub eligible_destinations: ::core::option::Option<
            eligible_destination::EligibleDestinations,
        >,
    }
    /// Nested message and enum types in `EligibleDestination`.
    pub mod eligible_destination {
        /// The options for the report destination location.
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum EligibleDestinations {
            /// The Cloud Storage bucket location where the audit report and evidences
            /// can be uploaded during the `GenerateAuditReport` API call.
            #[prost(string, tag = "3")]
            EligibleGcsBucket(::prost::alloc::string::String),
        }
    }
}
/// Message for requesting audit scope report.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateAuditScopeReportRequest {
    /// Required. Scope for which the AuditScopeReport is required. Must be of
    /// format resource_type/resource_identifier Eg:
    /// projects/{project}/locations/{location},
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "2")]
    pub scope: ::prost::alloc::string::String,
    /// Required. Compliance Standard against which the Scope Report must be
    /// generated. Eg: FEDRAMP_MODERATE
    #[prost(string, tag = "3")]
    pub compliance_standard: ::prost::alloc::string::String,
    /// Required. The format in which the Scope report bytes should be returned.
    #[prost(
        enumeration = "generate_audit_scope_report_request::AuditScopeReportFormat",
        tag = "4"
    )]
    pub report_format: i32,
    /// Required. Compliance framework against which the Scope Report must be
    /// generated.
    #[prost(string, tag = "5")]
    pub compliance_framework: ::prost::alloc::string::String,
}
/// Nested message and enum types in `GenerateAuditScopeReportRequest`.
pub mod generate_audit_scope_report_request {
    /// The options for the audit scope report format.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuditScopeReportFormat {
        /// Unspecified. Invalid format.
        Unspecified = 0,
        /// Audit Scope Report creation format is Open Document.
        Odf = 1,
    }
    impl AuditScopeReportFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AUDIT_SCOPE_REPORT_FORMAT_UNSPECIFIED",
                Self::Odf => "AUDIT_SCOPE_REPORT_FORMAT_ODF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIT_SCOPE_REPORT_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "AUDIT_SCOPE_REPORT_FORMAT_ODF" => Some(Self::Odf),
                _ => None,
            }
        }
    }
}
/// Message for requesting the Audit Report.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GenerateAuditReportRequest {
    /// Required. Scope for which the AuditScopeReport is required. Must be of
    /// format resource_type/resource_identifier Eg:
    /// projects/{project}/locations/{location},
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "1")]
    pub scope: ::prost::alloc::string::String,
    /// Required. Compliance Standard against which the Scope Report must be
    /// generated. Eg: FEDRAMP_MODERATE
    #[prost(string, tag = "3")]
    pub compliance_standard: ::prost::alloc::string::String,
    /// Required. The format in which the audit report should be created.
    #[prost(enumeration = "generate_audit_report_request::AuditReportFormat", tag = "4")]
    pub report_format: i32,
    /// Required. Compliance framework against which the Report must be generated.
    #[prost(string, tag = "5")]
    pub compliance_framework: ::prost::alloc::string::String,
    /// Set of options for the report destination location.
    #[prost(oneof = "generate_audit_report_request::Destination", tags = "2")]
    pub destination: ::core::option::Option<generate_audit_report_request::Destination>,
}
/// Nested message and enum types in `GenerateAuditReportRequest`.
pub mod generate_audit_report_request {
    /// The options for the audit report format.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuditReportFormat {
        /// Unspecified. Invalid state.
        Unspecified = 0,
        /// Audit Report creation format is Open Document.
        Odf = 1,
    }
    impl AuditReportFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AUDIT_REPORT_FORMAT_UNSPECIFIED",
                Self::Odf => "AUDIT_REPORT_FORMAT_ODF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIT_REPORT_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "AUDIT_REPORT_FORMAT_ODF" => Some(Self::Odf),
                _ => None,
            }
        }
    }
    /// Set of options for the report destination location.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Destination {
        /// Destination Cloud storage bucket where report and evidence must be
        /// uploaded. The Cloud storage bucket provided here must be selected among
        /// the buckets entered during the enrollment process.
        #[prost(string, tag = "2")]
        GcsUri(::prost::alloc::string::String),
    }
}
/// Message for getting the enrollment status of a resource.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetResourceEnrollmentStatusRequest {
    /// Required. Format
    /// folders/{folder}/locations/{location}/resourceEnrollmentStatuses/{resource_enrollment_status},
    /// projects/{project}/locations/{location}/resourceEnrollmentStatuses/{resource_enrollment_status},
    /// organizations/{organization}/locations/{location}/resourceEnrollmentStatuses/{resource_enrollment_status}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for listing all the descendent resources under parent with
/// enrollment.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourceEnrollmentStatusesRequest {
    /// Required. The parent scope for which the list of resources with enrollments
    /// are required.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of resources to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message with all the descendent resources with enrollment.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourceEnrollmentStatusesResponse {
    /// The resources with their enrollment status.
    #[prost(message, repeated, tag = "1")]
    pub resource_enrollment_statuses: ::prost::alloc::vec::Vec<ResourceEnrollmentStatus>,
    /// Output only. The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Message for requesting to list the audit reports.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListAuditReportsRequest {
    /// Required. The parent scope for which to list the reports.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of resources to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message with all the audit reports.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAuditReportsResponse {
    /// Output only. The audit reports.
    #[prost(message, repeated, tag = "1")]
    pub audit_reports: ::prost::alloc::vec::Vec<AuditReport>,
    /// Output only. The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Message for requesting the overall audit report for an audit report name.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetAuditReportRequest {
    /// Required. Format
    /// projects/{project}/locations/{location}/auditReports/{audit_report},
    /// folders/{folder}/locations/{location}/auditReports/{audit_report}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for requesting all the controls for a compliance standard.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListControlsRequest {
    /// Required. Format
    /// projects/{project}/locations/{location}/standards/{standard},
    /// folders/{folder}/locations/{location}/standards/{standard}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of resources to return.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. The next_page_token value returned from a previous List request,
    /// if any.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
/// Response message with all the controls for a compliance standard.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListControlsResponse {
    /// Output only. The controls for the compliance standard.
    #[prost(message, repeated, tag = "1")]
    pub controls: ::prost::alloc::vec::Vec<Control>,
    /// Output only. The token to retrieve the next page of results.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// The `ReportGenerationProgress` is part of
/// \[google.longrunning.Operation\]\[google.longrunning.Operation\] returned to the
/// client for every `GetOperation` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportGenerationProgress {
    /// Output only. The current state of execution for report generation.
    #[prost(enumeration = "OperationState", tag = "1")]
    pub state: i32,
    /// Output only. States the reason of failure during the audit report
    /// generation process. This field is set only if the state attribute is
    /// OPERATION_STATE_FAILED.
    #[prost(string, tag = "2")]
    pub failure_reason: ::prost::alloc::string::String,
    /// Shows the progress of the CESS service evaluation process. The progress is
    /// defined in terms of percentage complete and is being fetched from the CESS
    /// service.
    #[prost(double, tag = "20")]
    pub evaluation_percent_complete: f64,
    /// Shows the report generation progress of the CESS Result Processor Service.
    /// The // progress is defined in terms of percentage complete and is being
    /// fetched from the CESS service. If report_generation_in_progress is non zero
    /// then evaluation_percent_complete will be 100%.
    #[prost(double, tag = "30")]
    pub report_generation_percent_complete: f64,
    /// Shows the report uploading progress of the CESS Result Processor Service.
    /// The progress is defined in terms of percentage complete and is being
    /// fetched from the CESS service. If report_uploading_in_progress is non zero
    /// then evaluation_percent_complete and report_generation_percent_complete
    /// will be 100%.
    #[prost(double, tag = "40")]
    pub report_uploading_percent_complete: f64,
    /// Output only. The Cloud Storage bucket where the audit report will be
    /// uploaded once the evaluation process is completed.
    #[prost(string, tag = "50")]
    pub destination_gcs_bucket: ::prost::alloc::string::String,
    /// Output only. The name of the audit report.
    #[prost(string, tag = "51")]
    pub audit_report: ::prost::alloc::string::String,
}
/// The enrollment resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enrollment {
    /// Identifier. The name of this Enrollment, in the format of scope given in
    /// request.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The locations where the generated reports can be uploaded.
    #[prost(message, repeated, tag = "3")]
    pub destination_details: ::prost::alloc::vec::Vec<DestinationDetails>,
}
/// The audit scope report.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AuditScopeReport {
    /// Identifier. The name of this Audit Report, in the format of scope given in
    /// request.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// The options in which the audit scope report is exported.
    #[prost(oneof = "audit_scope_report::AuditReport", tags = "1")]
    pub audit_report: ::core::option::Option<audit_scope_report::AuditReport>,
}
/// Nested message and enum types in `AuditScopeReport`.
pub mod audit_scope_report {
    /// The options in which the audit scope report is exported.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum AuditReport {
        /// The audit scope report content in byte format.
        #[prost(bytes, tag = "1")]
        ScopeReportContents(::prost::alloc::vec::Vec<u8>),
    }
}
/// The metadata of the long-running operation.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have \[Operation.error\]\[\] value with a
    /// \[google.rpc.Status.code\]\[google.rpc.Status.code\] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// A resource with its enrollment status.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceEnrollmentStatus {
    /// Identifier. The name of this resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Enrollment which contains enrolled destination details for a
    /// resource
    #[prost(message, optional, tag = "2")]
    pub enrollment: ::core::option::Option<Enrollment>,
    /// Output only. Is resource enrolled.
    #[deprecated]
    #[prost(bool, tag = "3")]
    pub enrolled: bool,
    /// Output only. Display name of the project/folder/organization.
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Enrollment state of the resource.
    #[prost(
        enumeration = "resource_enrollment_status::ResourceEnrollmentState",
        tag = "5"
    )]
    pub enrollment_state: i32,
}
/// Nested message and enum types in `ResourceEnrollmentStatus`.
pub mod resource_enrollment_status {
    /// The different enrollment states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceEnrollmentState {
        /// Unspecified. Invalid state.
        Unspecified = 0,
        /// Not enrolled.
        NotEnrolled = 1,
        /// Resource is not enrolled but the parent is enrolled.
        Inherited = 2,
        /// Enrolled.
        Enrolled = 3,
    }
    impl ResourceEnrollmentState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESOURCE_ENROLLMENT_STATE_UNSPECIFIED",
                Self::NotEnrolled => "NOT_ENROLLED",
                Self::Inherited => "INHERITED",
                Self::Enrolled => "ENROLLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESOURCE_ENROLLMENT_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "NOT_ENROLLED" => Some(Self::NotEnrolled),
                "INHERITED" => Some(Self::Inherited),
                "ENROLLED" => Some(Self::Enrolled),
                _ => None,
            }
        }
    }
}
/// An audit report.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuditReport {
    /// Identifier. The name of this Audit Report, in the format of scope given in
    /// request.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Report summary with compliance, violation counts etc.
    #[prost(message, optional, tag = "2")]
    pub report_summary: ::core::option::Option<ReportSummary>,
    /// Output only. ClientOperationId
    #[prost(string, tag = "3")]
    pub operation_id: ::prost::alloc::string::String,
    /// Output only. The location where the generated report will be uploaded.
    #[prost(message, optional, tag = "4")]
    pub destination_details: ::core::option::Option<DestinationDetails>,
    /// Output only. Compliance Standard.
    #[prost(string, tag = "5")]
    pub compliance_standard: ::prost::alloc::string::String,
    /// Output only. The parent scope on which the report was generated.
    #[prost(string, tag = "6")]
    pub scope: ::prost::alloc::string::String,
    /// Output only. Creation time of the audit report.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The overall status of controls
    #[prost(message, repeated, tag = "8")]
    pub control_details: ::prost::alloc::vec::Vec<ControlDetails>,
    /// Output only. The state of Audit Report Generation.
    #[prost(enumeration = "audit_report::ReportGenerationState", tag = "9")]
    pub report_generation_state: i32,
    /// Output only. Compliance Framework of Audit Report
    #[prost(string, tag = "10")]
    pub compliance_framework: ::prost::alloc::string::String,
    /// Output only. The ID/ Number for the scope on which the audit report was
    /// generated.
    #[prost(string, tag = "11")]
    pub scope_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `AuditReport`.
pub mod audit_report {
    /// The different states of the Audit Manager report generation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReportGenerationState {
        /// Unspecified. Invalid state.
        Unspecified = 0,
        /// Audit report generation process is in progress, ie. operation state is
        /// neither OPERATION_STATE_DONE nor OPERATION_STATE_FAILED.
        InProgress = 1,
        /// Audit report generation process is completed. Operation state is
        /// OPERATION_STATE_DONE.
        Completed = 2,
        /// Audit report generation process has failed. Operation state is
        /// OPERATION_STATE_FAILED.
        Failed = 3,
        /// Audit report generation process has completed. But report summary is
        /// unknown. This is valid for older reports.
        SummaryUnknown = 4,
    }
    impl ReportGenerationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "REPORT_GENERATION_STATE_UNSPECIFIED",
                Self::InProgress => "IN_PROGRESS",
                Self::Completed => "COMPLETED",
                Self::Failed => "FAILED",
                Self::SummaryUnknown => "SUMMARY_UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPORT_GENERATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                "SUMMARY_UNKNOWN" => Some(Self::SummaryUnknown),
                _ => None,
            }
        }
    }
}
/// The regulatory family of the control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlFamily {
    /// The ID of the regulatory control family.
    #[prost(string, tag = "1")]
    pub family_id: ::prost::alloc::string::String,
    /// The display name of the regulatory control family.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
}
/// A control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Control {
    /// Output only. The control identifier used to fetch the findings. This is
    /// same as the control report name.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Output only. Display name of the control.
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    /// Output only. Group where the control belongs. E.g. Access Control.
    #[prost(enumeration = "control::Family", tag = "3")]
    pub family: i32,
    /// Output only. Regulatory Family of the control E.g. Access Control
    #[prost(message, optional, tag = "10")]
    pub control_family: ::core::option::Option<ControlFamily>,
    /// Output only. Regulatory control ask of the control
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Output only. The type of responsibility for implementing this control. It
    /// can be google, customer or shared.
    #[prost(string, tag = "5")]
    pub responsibility_type: ::prost::alloc::string::String,
    /// Output only. Description of the google responsibility for implementing this
    /// control.
    #[prost(string, tag = "6")]
    pub google_responsibility_description: ::prost::alloc::string::String,
    /// Output only. Implementation of the google responsibility for implementing
    /// this control.
    #[prost(string, tag = "7")]
    pub google_responsibility_implementation: ::prost::alloc::string::String,
    /// Output only. Description of the customer responsibility for implementing
    /// this control.
    #[prost(string, tag = "8")]
    pub customer_responsibility_description: ::prost::alloc::string::String,
    /// Output only. Implementation of the customer responsibility for implementing
    /// this control.
    #[prost(string, tag = "9")]
    pub customer_responsibility_implementation: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Control`.
pub mod control {
    /// The family of the control. For example, Access Control.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Family {
        /// Unspecified. Invalid state.
        Unspecified = 0,
        /// Access Control
        Ac = 1,
        /// Awareness and Training
        At = 2,
        /// Audit and Accountability
        Au = 3,
        /// Certification, Accreditation and Security Assessments
        Ca = 4,
        /// Configuration Management
        Cm = 5,
        /// Contingency Planning
        Cp = 6,
        /// Identification and Authentication
        Ia = 7,
        /// Incident Response
        Ir = 8,
        /// Maintenance
        Ma = 9,
        /// Media Protection
        Mp = 10,
        /// Physical and Environmental Protection
        Pe = 11,
        /// Security Planning
        Pl = 12,
        /// Personnel Security
        Ps = 13,
        /// Risk Assessment
        Ra = 14,
        /// System Services and Acquisition
        Sa = 15,
        /// System and Communications Protection
        Sc = 16,
        /// System and Information Integrity
        Si = 17,
        /// Supply Chain Risk Management
        Sr = 18,
    }
    impl Family {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FAMILY_UNSPECIFIED",
                Self::Ac => "AC",
                Self::At => "AT",
                Self::Au => "AU",
                Self::Ca => "CA",
                Self::Cm => "CM",
                Self::Cp => "CP",
                Self::Ia => "IA",
                Self::Ir => "IR",
                Self::Ma => "MA",
                Self::Mp => "MP",
                Self::Pe => "PE",
                Self::Pl => "PL",
                Self::Ps => "PS",
                Self::Ra => "RA",
                Self::Sa => "SA",
                Self::Sc => "SC",
                Self::Si => "SI",
                Self::Sr => "SR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FAMILY_UNSPECIFIED" => Some(Self::Unspecified),
                "AC" => Some(Self::Ac),
                "AT" => Some(Self::At),
                "AU" => Some(Self::Au),
                "CA" => Some(Self::Ca),
                "CM" => Some(Self::Cm),
                "CP" => Some(Self::Cp),
                "IA" => Some(Self::Ia),
                "IR" => Some(Self::Ir),
                "MA" => Some(Self::Ma),
                "MP" => Some(Self::Mp),
                "PE" => Some(Self::Pe),
                "PL" => Some(Self::Pl),
                "PS" => Some(Self::Ps),
                "RA" => Some(Self::Ra),
                "SA" => Some(Self::Sa),
                "SC" => Some(Self::Sc),
                "SI" => Some(Self::Si),
                "SR" => Some(Self::Sr),
                _ => None,
            }
        }
    }
}
/// The locations where the generated reports are saved.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DestinationDetails {
    #[prost(oneof = "destination_details::Destination", tags = "1")]
    pub destination: ::core::option::Option<destination_details::Destination>,
}
/// Nested message and enum types in `DestinationDetails`.
pub mod destination_details {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Destination {
        /// The Cloud Storage bucket where the audit report is/will be uploaded.
        #[prost(string, tag = "1")]
        GcsBucketUri(::prost::alloc::string::String),
    }
}
/// The additional information for an audit operation.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ReportSummary {
    /// Total number of checks.
    #[prost(int32, tag = "1")]
    pub total_count: i32,
    /// Number of compliant checks.
    #[prost(int32, tag = "2")]
    pub compliant_count: i32,
    /// Number of checks with violations.
    #[prost(int32, tag = "3")]
    pub violation_count: i32,
    /// Number of checks with "manual review needed" status.
    #[prost(int32, tag = "4")]
    pub manual_review_needed_count: i32,
    /// Number of checks that could not be performed due to errors.
    #[prost(int32, tag = "5")]
    pub error_count: i32,
}
/// The evaluation details for a control.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ControlDetails {
    /// The control for which the findings are being reported.
    #[prost(message, optional, tag = "1")]
    pub control: ::core::option::Option<Control>,
    /// Output only. Overall status of the findings for the control.
    #[prost(enumeration = "ComplianceState", tag = "2")]
    pub compliance_state: i32,
    /// Report summary with compliance, violation counts etc.
    #[prost(message, optional, tag = "3")]
    pub control_report_summary: ::core::option::Option<ReportSummary>,
}
/// The different execution states of the Audit Manager service.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationState {
    /// Unspecified. Invalid state.
    Unspecified = 0,
    /// Audit report generation process has not started.
    NotStarted = 10,
    /// Audit Manager is currently evaluating the workloads against specific
    /// standard.
    EvaluationInProgress = 20,
    /// Audit Manager has completed Evaluation for the workload.
    EvaluationDone = 21,
    /// Audit Manager is creating audit report from the evaluated data.
    EvidenceReportGenerationInProgress = 30,
    /// Audit Manager has completed generation of the audit report.
    EvidenceReportGenerationDone = 31,
    /// Audit Manager is uploading the audit report and evidences to the customer
    /// provided destination.
    EvidenceUploadInProgress = 40,
    /// Audit report generation process is completed.
    Done = 50,
    /// Audit report generation process has failed.
    Failed = 60,
}
impl OperationState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "OPERATION_STATE_UNSPECIFIED",
            Self::NotStarted => "OPERATION_STATE_NOT_STARTED",
            Self::EvaluationInProgress => "OPERATION_STATE_EVALUATION_IN_PROGRESS",
            Self::EvaluationDone => "OPERATION_STATE_EVALUATION_DONE",
            Self::EvidenceReportGenerationInProgress => {
                "OPERATION_STATE_EVIDENCE_REPORT_GENERATION_IN_PROGRESS"
            }
            Self::EvidenceReportGenerationDone => {
                "OPERATION_STATE_EVIDENCE_REPORT_GENERATION_DONE"
            }
            Self::EvidenceUploadInProgress => {
                "OPERATION_STATE_EVIDENCE_UPLOAD_IN_PROGRESS"
            }
            Self::Done => "OPERATION_STATE_DONE",
            Self::Failed => "OPERATION_STATE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATION_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "OPERATION_STATE_NOT_STARTED" => Some(Self::NotStarted),
            "OPERATION_STATE_EVALUATION_IN_PROGRESS" => Some(Self::EvaluationInProgress),
            "OPERATION_STATE_EVALUATION_DONE" => Some(Self::EvaluationDone),
            "OPERATION_STATE_EVIDENCE_REPORT_GENERATION_IN_PROGRESS" => {
                Some(Self::EvidenceReportGenerationInProgress)
            }
            "OPERATION_STATE_EVIDENCE_REPORT_GENERATION_DONE" => {
                Some(Self::EvidenceReportGenerationDone)
            }
            "OPERATION_STATE_EVIDENCE_UPLOAD_IN_PROGRESS" => {
                Some(Self::EvidenceUploadInProgress)
            }
            "OPERATION_STATE_DONE" => Some(Self::Done),
            "OPERATION_STATE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// The compliance state after evaluation.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ComplianceState {
    /// Unspecified. Invalid state.
    Unspecified = 0,
    /// Compliant.
    Compliant = 1,
    /// Violation.
    Violation = 2,
    /// MANUAL_REVIEW_NEEDED, requires manual review
    ManualReviewNeeded = 3,
    /// Error while computing status.
    Error = 4,
    /// Cannot be audited
    AuditNotSupported = 5,
}
impl ComplianceState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COMPLIANCE_STATE_UNSPECIFIED",
            Self::Compliant => "COMPLIANT",
            Self::Violation => "VIOLATION",
            Self::ManualReviewNeeded => "MANUAL_REVIEW_NEEDED",
            Self::Error => "ERROR",
            Self::AuditNotSupported => "AUDIT_NOT_SUPPORTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPLIANCE_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "COMPLIANT" => Some(Self::Compliant),
            "VIOLATION" => Some(Self::Violation),
            "MANUAL_REVIEW_NEEDED" => Some(Self::ManualReviewNeeded),
            "ERROR" => Some(Self::Error),
            "AUDIT_NOT_SUPPORTED" => Some(Self::AuditNotSupported),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod audit_manager_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources
    #[derive(Debug, Clone)]
    pub struct AuditManagerClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AuditManagerClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AuditManagerClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AuditManagerClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AuditManagerClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Enrolls the customer resource(folder/project/organization) to the audit
        /// manager service by creating the audit managers Service Agent in customers
        /// workload and granting required permissions to the Service Agent. Please
        /// note that if enrollment request is made on the already enrolled workload
        /// then enrollment is executed overriding the existing set of destinations.
        pub async fn enroll_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::EnrollResourceRequest>,
        ) -> std::result::Result<tonic::Response<super::Enrollment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/EnrollResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "EnrollResource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Generates a demo report highlighting different responsibilities
        /// (Google/Customer/ shared) required to be fulfilled for the customer's
        /// workload to be compliant with the given standard.
        pub async fn generate_audit_scope_report(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateAuditScopeReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AuditScopeReport>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/GenerateAuditScopeReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "GenerateAuditScopeReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Register the Audit Report generation requests and returns the OperationId
        /// using which the customer can track the report generation progress.
        pub async fn generate_audit_report(
            &mut self,
            request: impl tonic::IntoRequest<super::GenerateAuditReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/GenerateAuditReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "GenerateAuditReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists audit reports in the selected parent scope
        pub async fn list_audit_reports(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAuditReportsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAuditReportsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/ListAuditReports",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "ListAuditReports",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get the overall audit report
        pub async fn get_audit_report(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAuditReportRequest>,
        ) -> std::result::Result<tonic::Response<super::AuditReport>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/GetAuditReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "GetAuditReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get a resource along with its enrollment status.
        pub async fn get_resource_enrollment_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetResourceEnrollmentStatusRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourceEnrollmentStatus>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/GetResourceEnrollmentStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "GetResourceEnrollmentStatus",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches all resources under the parent along with their enrollment.
        pub async fn list_resource_enrollment_statuses(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListResourceEnrollmentStatusesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListResourceEnrollmentStatusesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/ListResourceEnrollmentStatuses",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "ListResourceEnrollmentStatuses",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets controls needed to be implemented to be compliant to a standard.
        pub async fn list_controls(
            &mut self,
            request: impl tonic::IntoRequest<super::ListControlsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListControlsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.auditmanager.v1.AuditManager/ListControls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.auditmanager.v1.AuditManager",
                        "ListControls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
