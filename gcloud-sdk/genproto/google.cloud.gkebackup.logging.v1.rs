// This file is @generated by prost-build.
/// Backup as stored in Platform log. It's used to log the details of
/// a createBackup/updateBackup request, so only fields that can be taken
/// from API calls are included here.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedBackup {
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "1")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// delete_lock_days specifies the number of days from the create_time of this
    /// Backup before which deletion will be blocked.
    #[prost(int32, tag = "2")]
    pub delete_lock_days: i32,
    /// retain_days specifies the desired number of days from the create_time of
    /// this Backup after which it will be automatically deleted.
    #[prost(int32, tag = "3")]
    pub retain_days: i32,
    /// User specified descriptive string for this Backup.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Current state of the Backup
    #[prost(enumeration = "logged_backup::State", tag = "5")]
    pub state: i32,
    /// Human-readable description of why the backup is in the current `state`.
    #[prost(string, tag = "6")]
    pub state_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LoggedBackup`.
pub mod logged_backup {
    /// State
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The Backup resource is in the process of being created.
        Unspecified = 0,
        /// The Backup resource has been created and the associated BackupJob
        /// Kubernetes resource has been injected into the source cluster.
        Creating = 1,
        /// The gkebackup agent in the cluster has begun executing the backup
        /// operation.
        InProgress = 2,
        /// The backup operation has completed successfully.
        Succeeded = 3,
        /// The backup operation has failed.
        Failed = 4,
        /// This Backup resource (and its associated artifacts) is in the process
        /// of being deleted.
        Deleting = 5,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::InProgress => "IN_PROGRESS",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// A BackupChannel imposes constraints on where clusters can be backed up.
/// The BackupChannel should be in the same project and region
/// as the cluster being backed up.
/// The backup can be created only in destination_project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedBackupChannel {
    /// The project where Backups are allowed to be stored.
    /// The format is `projects/{project}`.
    #[prost(string, tag = "1")]
    pub destination_project: ::prost::alloc::string::String,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// User specified descriptive string for this BackupChannel.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
/// Namespaces, list of namespaces
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Namespaces {
    /// namespaces
    #[prost(string, repeated, tag = "1")]
    pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// NamespacedName
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NamespacedName {
    /// the namespace of the resource in Kubernetes
    #[prost(string, tag = "1")]
    pub namespace: ::prost::alloc::string::String,
    /// the name of the resource in Kubernetes
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
/// NamespacedNames
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamespacedNames {
    /// a list of namespaced names in Kubernetes
    #[prost(message, repeated, tag = "1")]
    pub namespaced_names: ::prost::alloc::vec::Vec<NamespacedName>,
}
/// Encryption key.
/// This only contains the key metadata, and no key material.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EncryptionKey {
    /// Google KMS encryption key in the format:
    /// projects/<project>/locations/<location>/keyRings/<key-ring>/cryptoKeys/<key>
    #[prost(string, tag = "1")]
    pub gcp_kms_encryption_key: ::prost::alloc::string::String,
}
/// BackupPlan as stored in Platform log. It's used to log the details of
/// a createBackupPlan/updateBackupPlan request, so only fields that can be taken
/// from user input are included here.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedBackupPlan {
    /// User specified descriptive string for this BackupPlan.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// GCP resource name of the source cluster for this BackupPlan.
    #[prost(string, tag = "2")]
    pub cluster: ::prost::alloc::string::String,
    /// RetentionPolicy governs lifecycle of Backups created under this plan.
    #[prost(message, optional, tag = "3")]
    pub retention_policy: ::core::option::Option<logged_backup_plan::RetentionPolicy>,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Defines scheduled Backup creation under this BackupPlan.
    #[prost(message, optional, tag = "5")]
    pub backup_schedule: ::core::option::Option<logged_backup_plan::Schedule>,
    /// A flag indicates whether the plan has been deactivated.
    #[prost(bool, tag = "6")]
    pub deactivated: bool,
    /// Defines backup configuration of this BackupPlan.
    #[prost(message, optional, tag = "7")]
    pub backup_config: ::core::option::Option<logged_backup_plan::BackupConfig>,
    /// A number that represents the current risk level of this BackupPlan from RPO
    /// perspective with 1 being no risk and 5 being highest risk.
    /// Deprecated: Use LoggedBackupPlanMetadata.rpo_risk_level instead.
    #[deprecated]
    #[prost(int32, tag = "8")]
    pub rpo_risk_level: i32,
}
/// Nested message and enum types in `LoggedBackupPlan`.
pub mod logged_backup_plan {
    /// RentionPolicy is an inner message type to define:
    ///
    /// 1. When to automatically delete Backups created under this BackupPlan
    /// 1. A plan level minimum Backup retain days which blocks deletion
    /// 1. Lock to disallow any policy updates
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct RetentionPolicy {
        /// Number of days during which deletion of a Backup created under this
        /// BackupPlan will be blocked.
        #[prost(int32, tag = "1")]
        pub backup_delete_lock_days: i32,
        /// Number of days after which the service will delete a Backup.
        /// If specified, a Backup created under this BackupPlan will be
        /// automatically deleted after its age reaches create_time +
        /// backup_retain_days.
        #[prost(int32, tag = "2")]
        pub backup_retain_days: i32,
        /// A flag denotes that the retention policy of this BackupPlan is locked.
        /// If set to True, no further update is allowed on this policy, including
        /// the 'locked' field itself.
        /// Default to False.
        #[prost(bool, tag = "3")]
        pub locked: bool,
    }
    /// Schedule, an inner message type defines a cron schedule.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Schedule {
        /// A cron style string schedule on which an operation will be executed.
        #[prost(string, tag = "1")]
        pub cron_schedule: ::prost::alloc::string::String,
        /// A flag to toggle scheduled operation.
        #[prost(bool, tag = "2")]
        pub paused: bool,
    }
    /// BackupConfig, an inner message type defines the configuration of creating
    /// a backup from this BackupPlan
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct BackupConfig {
        /// A boolean flag specifies whether volume data should be backed up
        #[prost(bool, tag = "4")]
        pub include_volume_data: bool,
        /// A boolean flag specifies whether secrets should be backed up
        #[prost(bool, tag = "5")]
        pub include_secrets: bool,
        /// Custom encryption key. For preview, support GCP KMS only.
        /// This only contains the key metadata, and no key material.
        #[prost(message, optional, tag = "6")]
        pub encryption_key: ::core::option::Option<super::EncryptionKey>,
        #[prost(oneof = "backup_config::BackupScope", tags = "1, 2, 3")]
        pub backup_scope: ::core::option::Option<backup_config::BackupScope>,
    }
    /// Nested message and enum types in `BackupConfig`.
    pub mod backup_config {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum BackupScope {
            /// If set to true, backup whole cluster
            #[prost(bool, tag = "1")]
            AllNamespaces(bool),
            /// If set, backup the list of namespaces
            #[prost(message, tag = "2")]
            SelectedNamespaces(super::super::Namespaces),
            /// If set, backup the list of applications
            #[prost(message, tag = "3")]
            SelectedApplications(super::super::NamespacedNames),
        }
    }
}
/// LoggedBackupPlanMetadata as stored in Platform log. It's used to log the
/// details of a BackupPlan, which are not provided by users, but are filled
/// by the service.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoggedBackupPlanMetadata {
    /// The name of the backup channel if any.
    #[prost(string, tag = "1")]
    pub backup_channel: ::prost::alloc::string::String,
    /// A number that represents the current risk level of this BackupPlan from RPO
    /// perspective with 1 being no risk and 5 being highest risk.
    #[prost(int32, tag = "2")]
    pub rpo_risk_level: i32,
    /// The reason for the current risk level of this BackupPlan from RPO
    /// perspective.
    #[prost(string, tag = "3")]
    pub rpo_risk_reason: ::prost::alloc::string::String,
}
/// Restore as stored in Platform log. It's used to log the update details of a
/// updateRestore request, so only mutable and non-output_only fields are
/// included here..
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedRestore {
    /// Full name of the Backup resource this Restore resource used to restore
    /// from. Format: projects/*/locations/*/backupPlans/*/backups/*.
    #[prost(string, tag = "1")]
    pub backup: ::prost::alloc::string::String,
    /// GCP Labels.
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// User specified descriptive string for this Restore.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// The current state of the Restore.
    #[prost(enumeration = "logged_restore::State", tag = "4")]
    pub state: i32,
    /// Human-readable description of why the Restore is in its current state.
    #[prost(string, tag = "5")]
    pub state_reason: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LoggedRestore`.
pub mod logged_restore {
    /// Possible values for state of the Restore.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// The Restore resource is in the process of being created.
        Unspecified = 0,
        /// The Restore resource has been created and the associated RestoreJob
        /// Kubernetes resource has been injected into target cluster.
        Creating = 1,
        /// The gkebackup agent in the cluster has begun executing the restore
        /// operation.
        InProgress = 2,
        /// The restore operation has completed successfully. Restored workloads may
        /// not yet be operational.
        Succeeded = 3,
        /// The restore operation has failed.
        Failed = 4,
        /// This Restore resource is in the process of being deleted.
        Deleting = 5,
        /// The Kubernetes resources created by this Restore are being
        /// validated.
        Validating = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::InProgress => "IN_PROGRESS",
                Self::Succeeded => "SUCCEEDED",
                Self::Failed => "FAILED",
                Self::Deleting => "DELETING",
                Self::Validating => "VALIDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "IN_PROGRESS" => Some(Self::InProgress),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "DELETING" => Some(Self::Deleting),
                "VALIDATING" => Some(Self::Validating),
                _ => None,
            }
        }
    }
}
/// A RestoreChannel imposes constraints on where backups can be restored.
/// The RestoreChannel should be in the same project and region
/// as the backups being created.
/// The restore can be created only in destination_project.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedRestoreChannel {
    /// The project where Restores are allowed to be stored.
    /// The format is `projects/{project}`.
    #[prost(string, tag = "1")]
    pub destination_project: ::prost::alloc::string::String,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "2")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// User specified descriptive string for this RestoreChannel.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
/// RestorePlan as stored in Platform log. It's used to log the details of
/// a createRestorePlan/updateRestorePlan request, so only fields that can be
/// taken from user input are included here.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoggedRestorePlan {
    /// User specified descriptive string for this RestorePlan.
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    /// The BackupPlan from which Backups may be used as the source
    /// for Restores created via this RestorePlan.
    /// Format: projects/*/locations/*/backupPlans/\*.
    #[prost(string, tag = "2")]
    pub backup_plan: ::prost::alloc::string::String,
    /// The target cluster into which Restores created via this RestorePlan
    /// will restore data. NOTE: the cluster's region must be the same as the
    /// RestorePlan.
    /// Possible formats:
    ///
    /// 1. projects/*/locations/*/clusters/\*
    /// 1. projects/*/zones/*/clusters/\*
    #[prost(string, tag = "3")]
    pub cluster: ::prost::alloc::string::String,
    /// Configuration of Restores created via this RestorePlan.
    #[prost(message, optional, tag = "4")]
    pub restore_config: ::core::option::Option<RestoreConfig>,
    /// A set of custom labels supplied by user.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Configuration of a restore.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreConfig {
    /// Specifies the mechanism to be used to restore volume data.
    /// Default: VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED (will be treated as
    /// NO_VOLUME_DATA_RESTORATION).
    #[prost(enumeration = "restore_config::VolumeDataRestorePolicy", tag = "1")]
    pub volume_data_restore_policy: i32,
    /// Defines the behavior for handling the situation where cluster-scoped
    /// resources being restored already exist in the target cluster. This MUST be
    /// set to a value other than CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED if
    /// cluster_resource_restore_scope is not empty.
    #[prost(enumeration = "restore_config::ClusterResourceConflictPolicy", tag = "2")]
    pub cluster_resource_conflict_policy: i32,
    /// Defines the behavior for handling the situation where sets of namespaced
    /// resources being restored already exist in the target cluster. This MUST be
    /// set to a value other than NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED if
    /// any namespaced restoration is configured via
    /// namespaced_resource_restore_scope .
    #[prost(enumeration = "restore_config::NamespacedResourceRestoreMode", tag = "3")]
    pub namespaced_resource_restore_mode: i32,
    /// Identifies the cluster-scoped resources to restore from the Backup.
    /// Not specifying it means NO cluster resource will be restored.
    #[prost(message, optional, tag = "4")]
    pub cluster_resource_restore_scope: ::core::option::Option<
        restore_config::ClusterResourceRestoreScope,
    >,
    /// A list of transformation rules to be applied against Kubernetes resources
    /// as they are selected for restoration from a Backup. Rules are executed in
    /// order defined - this order matters, as changes made by a rule may impact
    /// the filtering logic of subsequent rules. An empty list means no
    /// substitution will occur.
    #[prost(message, repeated, tag = "8")]
    pub substitution_rules: ::prost::alloc::vec::Vec<restore_config::SubstitutionRule>,
    /// A list of transformation rules to be applied against Kubernetes resources
    /// as they are selected for restoration from a Backup. Rules are executed in
    /// order defined - this order matters, as changes made by a rule may impact
    /// the filtering logic of subsequent rules. An empty list means no
    /// transformation will occur.
    #[prost(message, repeated, tag = "11")]
    pub transformation_rules: ::prost::alloc::vec::Vec<
        restore_config::TransformationRule,
    >,
    /// Specifies the namespaced resources to restore from the Backup.
    /// Only one of the entries may be specified. If not specified, NO namespaced
    /// resources will be restored.
    #[prost(
        oneof = "restore_config::NamespacedResourceRestoreScope",
        tags = "5, 6, 7, 9, 10"
    )]
    pub namespaced_resource_restore_scope: ::core::option::Option<
        restore_config::NamespacedResourceRestoreScope,
    >,
}
/// Nested message and enum types in `RestoreConfig`.
pub mod restore_config {
    /// This is a direct map to the Kubernetes GroupKind type
    /// [GroupKind](<https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupKind>)
    /// and is used for identifying specific "types" of resources to restore.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct GroupKind {
        /// API group string of a Kubernetes resource, e.g.
        /// "apiextensions.k8s.io", "storage.k8s.io", etc.
        /// Note: use empty string for core API group.
        #[prost(string, tag = "1")]
        pub resource_group: ::prost::alloc::string::String,
        /// Kind of a Kubernetes resource, e.g.
        /// "CustomResourceDefinition", "StorageClass", etc.
        #[prost(string, tag = "2")]
        pub resource_kind: ::prost::alloc::string::String,
    }
    /// ClusterResourceRestoreScope defines the scope of cluster-scoped resources
    /// to restore.
    ///
    /// Some group kinds are not reasonable choices for a restore, and will cause
    /// an error if selected here. Any scope selection that would restore
    /// "all valid" resources automatically excludes these group kinds.
    ///
    /// * gkebackup.gke.io/BackupJob
    /// * gkebackup.gke.io/RestoreJob
    /// * metrics.k8s.io/NodeMetrics
    /// * migration.k8s.io/StorageState
    /// * migration.k8s.io/StorageVersionMigration
    /// * Node
    /// * snapshot.storage.k8s.io/VolumeSnapshotContent
    /// * storage.k8s.io/CSINode
    ///
    /// Some group kinds are driven by restore configuration elsewhere,
    /// and will cause an error if selected here.
    ///
    /// * Namespace
    /// * PersistentVolume
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClusterResourceRestoreScope {
        /// A list of cluster-scoped resource group kinds to restore from the
        /// backup. If specified, only the selected resources will be restored.
        /// Mutually exclusive to any other field in the message.
        #[prost(message, repeated, tag = "1")]
        pub selected_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
        /// A list of cluster-scoped resource group kinds to NOT restore from the
        /// backup. If specified, all valid cluster-scoped resources will be
        /// restored except for those specified in the list.
        /// Mutually exclusive to any other field in the message.
        #[prost(message, repeated, tag = "2")]
        pub excluded_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
        /// If True, all valid cluster-scoped resources will be restored.
        /// Mutually exclusive to any other field in the message.
        #[prost(bool, tag = "3")]
        pub all_group_kinds: bool,
        /// If True, no cluster-scoped resources will be restored.
        /// This has the same restore scope as if the message is not defined.
        /// Mutually exclusive to any other field in the message.
        #[prost(bool, tag = "4")]
        pub no_group_kinds: bool,
    }
    /// A transformation rule to be applied against Kubernetes resources as they
    /// are selected for restoration from a Backup. A rule contains both filtering
    /// logic (which resources are subject to substitution) and substitution logic.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SubstitutionRule {
        /// (Filtering parameter) Any resource subject to substitution must be
        /// contained within one of the listed Kubernetes Namespace in the Backup.
        /// If this field is not provided, no namespace filtering will be performed
        /// (all resources in all Namespaces, including all cluster-scoped resources,
        /// will be candidates for substitution).
        /// To mix cluster-scoped and namespaced resources in the same rule, use an
        /// empty string ("") as one of the target namespaces.
        #[prost(string, repeated, tag = "1")]
        pub target_namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// (Filtering parameter) Any resource subject to substitution must belong to
        /// one of the listed "types".
        /// If this field is not provided, no type filtering will be performed (all
        /// resources of all types matching previous filtering parameters will be
        /// candidates for substitution).
        #[prost(message, repeated, tag = "2")]
        pub target_group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
        /// This is a \[JSONPath\]
        /// (<https://kubernetes.io/docs/reference/kubectl/jsonpath/>)
        /// expression that matches specific fields of candidate
        /// resources and it operates as both a filtering parameter (resources that
        /// are not matched with this expression will not be candidates for
        /// substitution) as well as a field identifier (identifies exactly which
        /// fields out of the candidate resources will be modified).
        #[prost(string, tag = "3")]
        pub target_json_path: ::prost::alloc::string::String,
        /// (Filtering parameter) This is a \[regular expression\]
        /// (<https://en.wikipedia.org/wiki/Regular_expression>)
        /// that is compared against the fields matched by the target_json_path
        /// expression (and must also have passed the previous filters).
        /// Substitution will not be performed against fields whose
        /// value does not match this expression. If this field is NOT specified,
        /// then ALL fields matched by the target_json_path expression will undergo
        /// substitution. Note that an empty (e.g., "", rather than unspecified)
        /// value for this field will only match empty fields.
        #[prost(string, tag = "4")]
        pub original_value_pattern: ::prost::alloc::string::String,
        /// This is the new value to set for any fields that pass the filtering and
        /// selection criteria. To remove a value from a Kubernetes resource, either
        /// leave this field unspecified, or set it to the empty string ("").
        #[prost(string, tag = "5")]
        pub new_value: ::prost::alloc::string::String,
    }
    /// TransformationRuleAction defines a TransformationRule action based on the
    /// JSON Patch RFC (<https://www.rfc-editor.org/rfc/rfc6902>)
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TransformationRuleAction {
        /// op specifies the operation to perform.
        #[prost(enumeration = "transformation_rule_action::Op", tag = "1")]
        pub op: i32,
        /// A string containing a JSON Pointer value that references the location in
        /// the target document to move the value from.
        #[prost(string, tag = "2")]
        pub from_path: ::prost::alloc::string::String,
        /// A string containing a JSON-Pointer value that references a location
        /// within the target document where the operation is performed.
        #[prost(string, tag = "3")]
        pub path: ::prost::alloc::string::String,
        /// A string that specifies the desired value in string format to
        /// use for transformation.
        #[prost(string, tag = "4")]
        pub value: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `TransformationRuleAction`.
    pub mod transformation_rule_action {
        /// Possible values for operations of a transformation rule action.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Op {
            /// Unspecified operation
            Unspecified = 0,
            /// The "remove" operation removes the value at the target location.
            Remove = 1,
            /// The "move" operation removes the value at a specified location and
            /// adds it to the target location.
            Move = 2,
            /// The "copy" operation copies the value at a specified location to the
            /// target location.
            Copy = 3,
            /// The "add" operation performs one of the following functions,
            /// depending upon what the target location references:
            ///
            /// 1. If the target location specifies an array index, a new value is
            ///    inserted into the array at the specified index.
            /// 1. If the target location specifies an object member that does not
            ///    already exist, a new member is added to the object.
            /// 1. If the target location specifies an object member that does exist,
            ///    that member's value is replaced.
            Add = 4,
            /// The "test" operation tests that a value at the target location is
            /// equal to a specified value.
            Test = 5,
            /// The "replace" operation replaces the value at the target location
            /// with a new value.  The operation object MUST contain a "value" member
            /// whose content specifies the replacement value.
            Replace = 6,
        }
        impl Op {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "OP_UNSPECIFIED",
                    Self::Remove => "REMOVE",
                    Self::Move => "MOVE",
                    Self::Copy => "COPY",
                    Self::Add => "ADD",
                    Self::Test => "TEST",
                    Self::Replace => "REPLACE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OP_UNSPECIFIED" => Some(Self::Unspecified),
                    "REMOVE" => Some(Self::Remove),
                    "MOVE" => Some(Self::Move),
                    "COPY" => Some(Self::Copy),
                    "ADD" => Some(Self::Add),
                    "TEST" => Some(Self::Test),
                    "REPLACE" => Some(Self::Replace),
                    _ => None,
                }
            }
        }
    }
    /// ResourceFilter specifies matching criteria to limit the scope of a
    /// change to a specific set of kubernetes resources that are selected for
    /// restoration from a backup.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ResourceFilter {
        /// (Filtering parameter) Any resource subject to transformation must be
        /// contained within one of the listed Kubernetes Namespace in the Backup.
        /// If this field is not provided, no namespace filtering will be performed
        /// (all resources in all Namespaces, including all cluster-scoped resources,
        /// will be candidates for transformation).
        #[prost(string, repeated, tag = "1")]
        pub namespaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        /// (Filtering parameter) Any resource subject to transformation must belong
        /// to one of the listed "types". If this field is not provided, no type
        /// filtering will be performed (all resources of all types matching previous
        /// filtering parameters will be candidates for transformation).
        #[prost(message, repeated, tag = "2")]
        pub group_kinds: ::prost::alloc::vec::Vec<GroupKind>,
        /// This is a \[JSONPath\]
        /// (<https://github.com/json-path/JsonPath/blob/master/README.md>)
        /// expression that matches specific fields of candidate
        /// resources and it operates as a filtering parameter (resources that
        /// are not matched with this expression will not be candidates for
        /// transformation).
        #[prost(string, tag = "3")]
        pub json_path: ::prost::alloc::string::String,
    }
    /// A transformation rule to be applied against Kubernetes resources as they
    /// are selected for restoration from a Backup. A rule contains both filtering
    /// logic (which resources are subject to transform) and transformation logic.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransformationRule {
        /// A list of transformation rule actions to take against candidate
        /// resources. Actions are executed in order defined - this order matters, as
        /// they could potentially interfere with each other and the first operation
        /// could affect the outcome of the second operation.
        #[prost(message, repeated, tag = "1")]
        pub field_actions: ::prost::alloc::vec::Vec<TransformationRuleAction>,
        /// This field is used to specify a set of fields that should be used to
        /// determine which resources in backup should be acted upon by the supplied
        /// transformation rule actions, and this will ensure that only specific
        /// resources are affected by transformation rule actions.
        #[prost(message, optional, tag = "2")]
        pub resource_filter: ::core::option::Option<ResourceFilter>,
        /// The description is a user specified string description of the
        /// transformation rule.
        #[prost(string, tag = "3")]
        pub description: ::prost::alloc::string::String,
    }
    /// Defines how volume data should be restored
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VolumeDataRestorePolicy {
        /// unspecified, default value
        Unspecified = 0,
        /// For each PVC to be restored, will create a new underlying volume (and PV)
        /// from the corresponding VolumeBackup contained within the Backup.
        RestoreVolumeDataFromBackup = 1,
        /// For each PVC to be restored, attempt to reuse the original PV contained
        /// in the Backup (with its original underlying volume).  Note that option
        /// is likely only usable when restoring a workload to its original cluster.
        ReuseVolumeHandleFromBackup = 2,
        /// For each PVC to be restored, PVCs will be created without any particular
        /// action to restore data.  In this case, the normal Kubernetes provisioning
        /// logic would kick in, and this would likely result in either dynamically
        /// provisioning blank PVs or binding to statically provisioned PVs.
        NoVolumeDataRestoration = 3,
    }
    impl VolumeDataRestorePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED",
                Self::RestoreVolumeDataFromBackup => "RESTORE_VOLUME_DATA_FROM_BACKUP",
                Self::ReuseVolumeHandleFromBackup => "REUSE_VOLUME_HANDLE_FROM_BACKUP",
                Self::NoVolumeDataRestoration => "NO_VOLUME_DATA_RESTORATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VOLUME_DATA_RESTORE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "RESTORE_VOLUME_DATA_FROM_BACKUP" => {
                    Some(Self::RestoreVolumeDataFromBackup)
                }
                "REUSE_VOLUME_HANDLE_FROM_BACKUP" => {
                    Some(Self::ReuseVolumeHandleFromBackup)
                }
                "NO_VOLUME_DATA_RESTORATION" => Some(Self::NoVolumeDataRestoration),
                _ => None,
            }
        }
    }
    /// Defines the behavior for handling the situation where cluster-scoped
    /// resources being restored already exist in the target cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClusterResourceConflictPolicy {
        /// Unspecified. Only allowed if no cluster-scoped resources will be
        /// restored.
        Unspecified = 0,
        /// Do not attempt to restore the conflicting resource.
        UseExistingVersion = 1,
        /// Delete the existing version before re-creating it from the Backup.
        /// Note that this is a dangerous option which could cause unintentional
        /// data loss if used inappropriately - for example, deleting a CRD will
        /// cause Kubernetes to delete all CRs of that type.
        UseBackupVersion = 2,
    }
    impl ClusterResourceConflictPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED",
                Self::UseExistingVersion => "USE_EXISTING_VERSION",
                Self::UseBackupVersion => "USE_BACKUP_VERSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLUSTER_RESOURCE_CONFLICT_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "USE_EXISTING_VERSION" => Some(Self::UseExistingVersion),
                "USE_BACKUP_VERSION" => Some(Self::UseBackupVersion),
                _ => None,
            }
        }
    }
    /// Defines the behavior for handling the situation where sets of namespaced
    /// resources being restored already exist in the target cluster.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NamespacedResourceRestoreMode {
        /// Unspecified. Only allowed if no namespaced resources will be restored.
        Unspecified = 0,
        /// When conflicting top-level resources (either Namespaces or
        /// ProtectedApplications, depending upon the scope) are encountered, this
        /// will first trigger a delete of the conflicting resource AND ALL OF ITS
        /// REFERENCED RESOURCES (e.g., all resources in the Namespace or all
        /// resources referenced by the ProtectedApplication) before restoring the
        /// resources from the Backup. This mode should only be used when you are
        /// intending to revert some portion of a cluster to an earlier state.
        DeleteAndRestore = 1,
        /// If conflicting top-level resources (either Namespaces or
        /// ProtectedApplications, depending upon the scope) are encountered at the
        /// beginning of a restore process, the Restore will fail.  If a conflict
        /// occurs during the restore process itself (e.g., because an out of band
        /// process creates conflicting resources), a conflict will be reported.
        FailOnConflict = 2,
        /// This mode merges the backup and the target cluster and skips the
        /// conflicting resources. If a single resource to restore exists in the
        /// cluster before restoration, the resource will be skipped, otherwise it
        /// will be restored.
        MergeSkipOnConflict = 3,
        /// This mode merges the backup and the target cluster and skips the
        /// conflicting resources except volume data. If a PVC to restore already
        /// exists, this mode will restore/reconnect the volume without overwriting
        /// the PVC. It is similar to MERGE_SKIP_ON_CONFLICT except that it will
        /// apply the volume data policy for the conflicting PVCs:
        ///
        /// * RESTORE_VOLUME_DATA_FROM_BACKUP: restore data only and respect the
        ///   reclaim policy of the original PV;
        /// * REUSE_VOLUME_HANDLE_FROM_BACKUP: reconnect and respect the reclaim
        ///   policy of the original PV;
        /// * NO_VOLUME_DATA_RESTORATION: new provision and respect the reclaim
        ///   policy of the original PV.
        ///   Note that this mode could cause data loss as the original PV can be
        ///   retained or deleted depending on its reclaim policy.
        MergeReplaceVolumeOnConflict = 4,
        /// This mode merges the backup and the target cluster and replaces the
        /// conflicting resources with the ones in the backup. If a single resource
        /// to restore exists in the cluster before restoration, the resource will be
        /// replaced with the one from the backup. To replace an existing resource,
        /// the first attempt is to update the resource to match the one from the
        /// backup; if the update fails, the second attempt is to delete the resource
        /// and restore it from the backup.
        /// Note that this mode could cause data loss as it replaces the existing
        /// resources in the target cluster, and the original PV can be retained or
        /// deleted depending on its reclaim policy.
        MergeReplaceOnConflict = 5,
    }
    impl NamespacedResourceRestoreMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED",
                Self::DeleteAndRestore => "DELETE_AND_RESTORE",
                Self::FailOnConflict => "FAIL_ON_CONFLICT",
                Self::MergeSkipOnConflict => "MERGE_SKIP_ON_CONFLICT",
                Self::MergeReplaceVolumeOnConflict => "MERGE_REPLACE_VOLUME_ON_CONFLICT",
                Self::MergeReplaceOnConflict => "MERGE_REPLACE_ON_CONFLICT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NAMESPACED_RESOURCE_RESTORE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "DELETE_AND_RESTORE" => Some(Self::DeleteAndRestore),
                "FAIL_ON_CONFLICT" => Some(Self::FailOnConflict),
                "MERGE_SKIP_ON_CONFLICT" => Some(Self::MergeSkipOnConflict),
                "MERGE_REPLACE_VOLUME_ON_CONFLICT" => {
                    Some(Self::MergeReplaceVolumeOnConflict)
                }
                "MERGE_REPLACE_ON_CONFLICT" => Some(Self::MergeReplaceOnConflict),
                _ => None,
            }
        }
    }
    /// Specifies the namespaced resources to restore from the Backup.
    /// Only one of the entries may be specified. If not specified, NO namespaced
    /// resources will be restored.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum NamespacedResourceRestoreScope {
        /// Restore all namespaced resources in the Backup if set to "True".
        /// Specifying this field to "False" is an error.
        #[prost(bool, tag = "5")]
        AllNamespaces(bool),
        /// A list of selected Namespaces to restore from the Backup. The listed
        /// Namespaces and all resources contained in them will be restored.
        #[prost(message, tag = "6")]
        SelectedNamespaces(super::Namespaces),
        /// A list of selected ProtectedApplications to restore. The listed
        /// ProtectedApplications and all the resources to which they refer will be
        /// restored.
        #[prost(message, tag = "7")]
        SelectedApplications(super::NamespacedNames),
        /// Do not restore any namespaced resources if set to "True".
        /// Specifying this field to "False" is not allowed.
        #[prost(bool, tag = "9")]
        NoNamespaces(bool),
        /// A list of selected namespaces excluded from restoration. All
        /// namespaces except those in this list will be restored.
        #[prost(message, tag = "10")]
        ExcludedNamespaces(super::Namespaces),
    }
}
/// LoggedRestorePlanMetadata as stored in Platform log. It's used to log the
/// details of a RestorePlan, which are not provided by users, but are filled
/// by the service.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LoggedRestorePlanMetadata {
    /// The name of the restore channel if any.
    #[prost(string, tag = "1")]
    pub restore_channel: ::prost::alloc::string::String,
}
/// use case 1
/// A log entry when modification(creation, update, deletion) is made to a
/// BackupPlan
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupPlanChange {
    /// The full name of the old BackupPlan resource that is being modified.
    /// Empty for creation.
    /// Format: projects/{project}/locations/{location}/backupPlans/{backup_plan}
    #[prost(string, tag = "1")]
    pub backup_plan: ::prost::alloc::string::String,
    /// Type of the change is being made.
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    /// Modification details.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The input BackupPlan resource with the updated fields populated to update
    /// the source BackupPlan to.
    #[prost(message, optional, tag = "4")]
    pub input_backup_plan: ::core::option::Option<LoggedBackupPlan>,
    /// The error code and message.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// The metadata of the BackupPlan.
    #[prost(message, optional, tag = "6")]
    pub backup_plan_metadata: ::core::option::Option<LoggedBackupPlanMetadata>,
}
/// use case 2
/// A log entry when modification(creation, update, deletion) is made to a
/// Backup
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupChange {
    /// The full name of the Backup resource that is being modified.
    /// Format:
    /// projects/{project}/locations/{location}/backupPlans/{backup_plan}/backups/{backup}
    #[prost(string, tag = "1")]
    pub backup: ::prost::alloc::string::String,
    /// Type of the change is being made.
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    /// Whether the change is made manually or automatically.
    #[prost(bool, tag = "3")]
    pub scheduled: bool,
    /// Modification details.
    #[prost(message, optional, tag = "4")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The input Backup resource with the updated fields populated to update
    /// the source Backup to, or the backup created automatically from retention
    /// policy.
    #[prost(message, optional, tag = "5")]
    pub input_backup: ::core::option::Option<LoggedBackup>,
    /// The error code and message.
    #[prost(message, optional, tag = "6")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// use case 3
/// A log entry when modification(creation, update, deletion) is made to a
/// restorePlan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestorePlanChange {
    /// The full name of the RestorePlan resource that is being modified.
    /// Empty for creation.
    /// Format: projects/*/locations/*/restorePlans/\*
    #[prost(string, tag = "1")]
    pub restore_plan: ::prost::alloc::string::String,
    /// Type of the change is being made.
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    /// Modification details.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The input RestorePlan resource with the updated fields populated to update
    /// the source RestorePlan to.
    #[prost(message, optional, tag = "4")]
    pub input_restore_plan: ::core::option::Option<LoggedRestorePlan>,
    /// The error code and message.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
    /// The metadata of the RestorePlan.
    #[prost(message, optional, tag = "6")]
    pub restore_plan_metadata: ::core::option::Option<LoggedRestorePlanMetadata>,
}
/// use case 4
/// A log entry when modification(creation, update, deletion) is made to a
/// restore.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreChange {
    /// The full name of the Restore resource that is being modified.
    /// Empty for creation.
    /// Format: projects/*/locations/*/restorePlans/*/restores/*
    #[prost(string, tag = "1")]
    pub restore: ::prost::alloc::string::String,
    /// Type of the change is being made.
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    /// Modification details.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The input Restore resource with the updated fields populated to update
    /// the source Restore to.
    #[prost(message, optional, tag = "4")]
    pub input_restore: ::core::option::Option<LoggedRestore>,
    /// The error code and message.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// use case 5
/// A log entry when modification(creation, update, deletion) is made to a
/// backupChannel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackupChannelChange {
    /// The full name of the BackupChannel resource that is being modified.
    /// Empty for creation.
    /// Format:
    /// projects/{project}/locations/{location}/backupChannels/{backup_channel}
    #[prost(string, tag = "1")]
    pub backup_channel: ::prost::alloc::string::String,
    /// The type of change is being made.
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    /// Modification details.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The input BackupChannel resource with the updated fields populated to
    /// update the source BackupChannel to.
    #[prost(message, optional, tag = "4")]
    pub input_backup_channel: ::core::option::Option<LoggedBackupChannel>,
    /// The error code and message.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// use case 6
/// A log entry when modification(creation, update, deletion) is made to a
/// restoreChannel.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreChannelChange {
    /// The full name of the RestoreChannel resource that is being modified.
    /// Empty for creation.
    /// Format:
    /// projects/{project}/locations/{location}/restoreChannels/{restore_channel}
    #[prost(string, tag = "1")]
    pub restore_channel: ::prost::alloc::string::String,
    /// The type of change is being made.
    #[prost(enumeration = "ChangeType", tag = "2")]
    pub change_type: i32,
    /// Modification details.
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// The input RestoreChannel resource with the updated fields populated to
    /// update the source RestoreChannel to.
    #[prost(message, optional, tag = "4")]
    pub input_restore_channel: ::core::option::Option<LoggedRestoreChannel>,
    /// The error code and message.
    #[prost(message, optional, tag = "5")]
    pub error: ::core::option::Option<super::super::super::super::rpc::Status>,
}
/// The type of changes this log is about.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeType {
    /// Default value, not specified.
    Unspecified = 0,
    /// The resource is created.
    Creation = 1,
    /// The resource is updated.
    Update = 2,
    /// The resource is deleted.
    Deletion = 3,
}
impl ChangeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHANGE_TYPE_UNSPECIFIED",
            Self::Creation => "CREATION",
            Self::Update => "UPDATE",
            Self::Deletion => "DELETION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREATION" => Some(Self::Creation),
            "UPDATE" => Some(Self::Update),
            "DELETION" => Some(Self::Deletion),
            _ => None,
        }
    }
}
