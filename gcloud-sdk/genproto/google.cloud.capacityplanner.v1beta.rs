// This file is @generated by prost-build.
/// Repesents Allocation which is part of aggregated
/// reservations data response of "QueryReservations".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Allocation {
    /// The unique identifier for the resource. This identifier is
    /// defined by the server.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// The creation timestamp for this allocation.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Zone in which the reservation resides.
    #[prost(string, tag = "3")]
    pub zone: ::prost::alloc::string::String,
    /// A description while creating reservation.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// The reservation resource name.
    #[prost(string, tag = "5")]
    pub allocation: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub owner_project_id: ::prost::alloc::string::String,
    /// The status of the reservation.
    #[prost(enumeration = "allocation::Status", tag = "7")]
    pub status: i32,
    /// Specify share-settings to create a shared reservation.
    #[prost(message, optional, tag = "8")]
    pub share_settings: ::core::option::Option<allocation::ShareSettings>,
    /// Absolute time in future when the reservation will be
    /// auto-deleted by Compute Engine.
    #[prost(message, optional, tag = "9")]
    pub auto_delete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The type of the reservation which can only be for a specific SKU for now.
    #[prost(oneof = "allocation::Type", tags = "6")]
    pub r#type: ::core::option::Option<allocation::Type>,
}
/// Nested message and enum types in `Allocation`.
pub mod allocation {
    /// This reservation type allows to pre allocate specific instance
    /// configuration.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SpecificSkuAllocation {
        /// The instance properties for the reservation.
        #[prost(message, optional, tag = "1")]
        pub instance_properties: ::core::option::Option<
            specific_sku_allocation::AllocatedInstanceProperties,
        >,
        /// Specifies the number of resources that are allocated.
        #[prost(int64, tag = "2")]
        pub count: i64,
        /// Indicates how many instances are in use.
        #[prost(int64, tag = "3")]
        pub used_count: i64,
        /// Indicates how many instances are actually usable currently.
        #[prost(int64, tag = "4")]
        pub assured_count: i64,
    }
    /// Nested message and enum types in `SpecificSKUAllocation`.
    pub mod specific_sku_allocation {
        /// Properties of the SKU instances being reserved.
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct AllocatedInstanceProperties {
            /// Specifies type of machine (name only) which has fixed number of vCPUs
            /// and fixed amount of memory. This also includes specifying custom
            /// machine type following custom-NUMBER_OF_CPUS-AMOUNT_OF_MEMORY pattern.
            #[prost(string, tag = "1")]
            pub machine_type: ::prost::alloc::string::String,
            /// Specifies accelerator type and count.
            #[prost(message, repeated, tag = "2")]
            pub guest_accelerator: ::prost::alloc::vec::Vec<
                allocated_instance_properties::AcceleratorConfig,
            >,
            /// Minimum cpu platform the reservation.
            #[prost(string, tag = "3")]
            pub min_cpu_platform: ::prost::alloc::string::String,
            /// Specifies amount of local ssd to reserve with each instance. The type
            /// of disk is local-ssd.
            #[prost(message, repeated, tag = "4")]
            pub local_ssd: ::prost::alloc::vec::Vec<
                allocated_instance_properties::AllocatedDisk,
            >,
        }
        /// Nested message and enum types in `AllocatedInstanceProperties`.
        pub mod allocated_instance_properties {
            /// A specification of the type and number of accelerator cards attached to
            /// the instance.
            #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct AcceleratorConfig {
                /// Accelerator name.
                /// See <https://cloud.google.com/compute/docs/gpus/#introduction> for a
                /// full list of accelerator types.
                #[prost(string, tag = "1")]
                pub r#type: ::prost::alloc::string::String,
                /// The number of the guest accelerator cards exposed to this instance.
                #[prost(int32, tag = "2")]
                pub count: i32,
            }
            /// A specification of the interface and size of disk attached to
            /// the instance.
            #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
            pub struct AllocatedDisk {
                /// Specifies the size of the disk in base-2 GB.
                #[prost(int64, tag = "1")]
                pub disk_size_gb: i64,
                /// Specifies the disk interface to use for attaching this disk, which is
                /// either SCSI or NVME. The default is SCSI.
                #[prost(enumeration = "allocated_disk::DiskInterface", tag = "2")]
                pub disk_interface: i32,
            }
            /// Nested message and enum types in `AllocatedDisk`.
            pub mod allocated_disk {
                /// guest device interface options to use for the disk.
                #[derive(
                    Clone,
                    Copy,
                    Debug,
                    PartialEq,
                    Eq,
                    Hash,
                    PartialOrd,
                    Ord,
                    ::prost::Enumeration
                )]
                #[repr(i32)]
                pub enum DiskInterface {
                    /// Default value. This value is unused.
                    Unspecified = 0,
                    /// SCSI disk interface.
                    Scsi = 1,
                    /// NVME disk interface.
                    Nvme = 2,
                    /// NVDIMM disk interface.
                    Nvdimm = 3,
                    /// ISCSI disk interface.
                    Iscsi = 4,
                }
                impl DiskInterface {
                    /// String value of the enum field names used in the ProtoBuf definition.
                    ///
                    /// The values are not transformed in any way and thus are considered stable
                    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                    pub fn as_str_name(&self) -> &'static str {
                        match self {
                            Self::Unspecified => "DISK_INTERFACE_UNSPECIFIED",
                            Self::Scsi => "SCSI",
                            Self::Nvme => "NVME",
                            Self::Nvdimm => "NVDIMM",
                            Self::Iscsi => "ISCSI",
                        }
                    }
                    /// Creates an enum from field names used in the ProtoBuf definition.
                    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                        match value {
                            "DISK_INTERFACE_UNSPECIFIED" => Some(Self::Unspecified),
                            "SCSI" => Some(Self::Scsi),
                            "NVME" => Some(Self::Nvme),
                            "NVDIMM" => Some(Self::Nvdimm),
                            "ISCSI" => Some(Self::Iscsi),
                            _ => None,
                        }
                    }
                }
            }
        }
    }
    /// The share setting for reservation.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ShareSettings {
        /// Type of sharing for this shared-reservation
        #[prost(enumeration = "share_settings::ShareType", tag = "1")]
        pub share_type: i32,
        /// A List of Project names to specify consumer projects for this
        /// shared-reservation. This is only valid when share_type's value is
        /// SPECIFIC_PROJECTS.
        #[prost(string, repeated, tag = "2")]
        pub projects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    /// Nested message and enum types in `ShareSettings`.
    pub mod share_settings {
        /// Possible scope in which the reservation can be shared. More granularity
        /// can be added in future.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ShareType {
            /// Default value. This value is unused.
            Unspecified = 0,
            /// Shared-reservation is open to entire Organization
            Organization = 1,
            /// Shared-reservation is open to specific projects
            SpecificProjects = 2,
            /// Default value.
            Local = 3,
            /// Shared-reservation is open to direct child projects of specific
            /// folders.
            DirectProjectsUnderSpecificFolders = 4,
        }
        impl ShareType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "SHARE_TYPE_UNSPECIFIED",
                    Self::Organization => "ORGANIZATION",
                    Self::SpecificProjects => "SPECIFIC_PROJECTS",
                    Self::Local => "LOCAL",
                    Self::DirectProjectsUnderSpecificFolders => {
                        "DIRECT_PROJECTS_UNDER_SPECIFIC_FOLDERS"
                    }
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "SHARE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ORGANIZATION" => Some(Self::Organization),
                    "SPECIFIC_PROJECTS" => Some(Self::SpecificProjects),
                    "LOCAL" => Some(Self::Local),
                    "DIRECT_PROJECTS_UNDER_SPECIFIC_FOLDERS" => {
                        Some(Self::DirectProjectsUnderSpecificFolders)
                    }
                    _ => None,
                }
            }
        }
    }
    /// The status of the reservation.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        /// Default value. This value is unused.
        Unspecified = 0,
        /// Invalid Reservation
        Invalid = 1,
        /// Resources are being allocated for the reservation.
        Creating = 2,
        /// Reservation has allocated all its resources.
        Ready = 3,
        /// Reservation is currently being deleted.
        Deleting = 4,
        /// Reservation is currently being resized.
        Updating = 5,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Invalid => "INVALID",
                Self::Creating => "CREATING",
                Self::Ready => "READY",
                Self::Deleting => "DELETING",
                Self::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "INVALID" => Some(Self::Invalid),
                "CREATING" => Some(Self::Creating),
                "READY" => Some(Self::Ready),
                "DELETING" => Some(Self::Deleting),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
    /// The type of the reservation which can only be for a specific SKU for now.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Reservation for instances with specific machine shapes.
        #[prost(message, tag = "6")]
        SpecificAllocation(SpecificSkuAllocation),
    }
}
/// Identifier for a Google Cloud Platform location.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationIdentifier {
    /// The location level such as a region.
    #[prost(enumeration = "LocationLevel", tag = "1")]
    pub location_level: i32,
    /// Required. Location where resource is sourced. For Cloud Storage, the
    /// alphabetically first location is the source.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    /// Optional. Other linked locations.
    #[prost(message, repeated, tag = "3")]
    pub linked_locations: ::prost::alloc::vec::Vec<location_identifier::LinkedLocation>,
}
/// Nested message and enum types in `LocationIdentifier`.
pub mod location_identifier {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct LinkedLocation {
        /// The location level such as a region.
        #[prost(enumeration = "super::LocationLevel", tag = "1")]
        pub location_level: i32,
        /// Required. The linked cloud location.
        #[prost(string, tag = "2")]
        pub location: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub label: ::prost::alloc::string::String,
    }
}
/// The level of the Google Cloud Platform location.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LocationLevel {
    /// Location level is unspecified.
    Unspecified = 0,
    /// Cloud region.
    Region = 1,
    /// Cloud zone.
    Zone = 2,
    /// Globally.
    Global = 3,
    /// A metro.
    Metro = 4,
    /// Dual region pair.
    DualRegion = 5,
    /// Multiple regions.
    MultiRegion = 6,
}
impl LocationLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LOCATION_LEVEL_UNSPECIFIED",
            Self::Region => "REGION",
            Self::Zone => "ZONE",
            Self::Global => "GLOBAL",
            Self::Metro => "METRO",
            Self::DualRegion => "DUAL_REGION",
            Self::MultiRegion => "MULTI_REGION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOCATION_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "REGION" => Some(Self::Region),
            "ZONE" => Some(Self::Zone),
            "GLOBAL" => Some(Self::Global),
            "METRO" => Some(Self::Metro),
            "DUAL_REGION" => Some(Self::DualRegion),
            "MULTI_REGION" => Some(Self::MultiRegion),
            _ => None,
        }
    }
}
/// The resource container of Google Cloud Platform hierarchy such as a project.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ResourceContainer {
    #[prost(enumeration = "resource_container::Type", tag = "1")]
    pub r#type: i32,
    /// Required. Identifier of the resource container. For example, project number
    /// for project type.
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ResourceContainer`.
pub mod resource_container {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Project = 1,
        Folder = 2,
        Org = 3,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::Project => "PROJECT",
                Self::Folder => "FOLDER",
                Self::Org => "ORG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROJECT" => Some(Self::Project),
                "FOLDER" => Some(Self::Folder),
                "ORG" => Some(Self::Org),
                _ => None,
            }
        }
    }
}
/// The id for a Google Cloud Platform resource key.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceIdKey {
    /// Required. Id of the resource.
    #[prost(message, optional, tag = "1")]
    pub resource_id: ::core::option::Option<ResourceIdentifier>,
    /// Demand fields for the resource.
    #[prost(oneof = "resource_id_key::DemandFields", tags = "2")]
    pub demand_fields: ::core::option::Option<resource_id_key::DemandFields>,
}
/// Nested message and enum types in `ResourceIdKey`.
pub mod resource_id_key {
    /// Demand fields for the resource.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum DemandFields {
        /// Required. resource_code for the resource. eg: gce-ram, gce-vcpus,
        /// gce-gpu, gce-tpu, gce-vm, gce-persistent-disk, gce-local-ssd.
        #[prost(string, tag = "2")]
        ResourceCode(::prost::alloc::string::String),
    }
}
/// The identifier for a Google Cloud Platform resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceIdentifier {
    #[prost(string, tag = "1")]
    pub service_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub resource_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub resource_attributes: ::prost::alloc::vec::Vec<ResourceAttribute>,
}
/// An attribute of a Google Cloud Platform resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceAttribute {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<ResourceValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceValue {
    #[prost(enumeration = "Unit", tag = "1")]
    pub unit: i32,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Value>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::Value", tags = "1, 2, 3, 4")]
    pub value: ::core::option::Option<value::Value>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(int64, tag = "1")]
        Int64Value(i64),
        #[prost(string, tag = "2")]
        StringValue(::prost::alloc::string::String),
        #[prost(double, tag = "3")]
        DoubleValue(f64),
        #[prost(bool, tag = "4")]
        BoolValue(bool),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Unit {
    Unspecified = 0,
    Count = 1,
    /// Kilobytes (10^3 bytes)
    Kb = 2,
    /// Gigabytes (10^9 bytes)
    Gb = 3,
    /// Terabytes (10^12 bytes)
    Tb = 4,
    /// Mebibytes (2^20 bytes)
    Mib = 17,
    /// Gibibytes (2^30 bytes)
    Gib = 5,
    /// Tebibytes (2^40 bytes)
    Tib = 6,
    /// Queries per second
    Qps = 7,
    /// Megabytes (10^6 bytes)
    Mb = 8,
    /// Pebibytes (2^50 bytes)
    Pib = 9,
    /// Terabits (10^12 bits) per second
    Tbps = 10,
    GbpsBits = 11,
    GibBits = 12,
    MbpsBits = 13,
    MbpsBytes = 14,
    TbpsBits = 15,
    TbpsBytes = 16,
    Kops = 18,
}
impl Unit {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNIT_UNSPECIFIED",
            Self::Count => "UNIT_COUNT",
            Self::Kb => "KB",
            Self::Gb => "GB",
            Self::Tb => "TB",
            Self::Mib => "MIB",
            Self::Gib => "GIB",
            Self::Tib => "TIB",
            Self::Qps => "QPS",
            Self::Mb => "MB",
            Self::Pib => "PIB",
            Self::Tbps => "TBPS",
            Self::GbpsBits => "GBPS_BITS",
            Self::GibBits => "GIB_BITS",
            Self::MbpsBits => "MBPS_BITS",
            Self::MbpsBytes => "MBPS_BYTES",
            Self::TbpsBits => "TBPS_BITS",
            Self::TbpsBytes => "TBPS_BYTES",
            Self::Kops => "KOPS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNIT_UNSPECIFIED" => Some(Self::Unspecified),
            "UNIT_COUNT" => Some(Self::Count),
            "KB" => Some(Self::Kb),
            "GB" => Some(Self::Gb),
            "TB" => Some(Self::Tb),
            "MIB" => Some(Self::Mib),
            "GIB" => Some(Self::Gib),
            "TIB" => Some(Self::Tib),
            "QPS" => Some(Self::Qps),
            "MB" => Some(Self::Mb),
            "PIB" => Some(Self::Pib),
            "TBPS" => Some(Self::Tbps),
            "GBPS_BITS" => Some(Self::GbpsBits),
            "GIB_BITS" => Some(Self::GibBits),
            "MBPS_BITS" => Some(Self::MbpsBits),
            "MBPS_BYTES" => Some(Self::MbpsBytes),
            "TBPS_BITS" => Some(Self::TbpsBits),
            "TBPS_BYTES" => Some(Self::TbpsBytes),
            "KOPS" => Some(Self::Kops),
            _ => None,
        }
    }
}
/// Request for getting a capacity plan.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GetCapacityPlanRequest {
    /// Required. The name of the capacity plan to retrieve.
    /// Format: projects/{project}/capacityPlans/{capacity_plan}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for querying capacity plans.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QueryCapacityPlansRequest {
    /// Required. The parent resource container.
    /// Format:
    /// projects/{project} or
    /// folders/{folder} or
    /// organizations/{organization}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The maximum number of plans to return per page. The service may
    /// return fewer than this value. If unspecified, the server will use a
    /// sensible default. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `QueryCapacityPlans` call.
    /// Provide this to retrieve the subsequent page.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. The Google Cloud Platform location of capacity plans. If
    /// unspecified, all locations will be included.
    #[prost(string, tag = "4")]
    pub location: ::prost::alloc::string::String,
}
/// Response of querying capacity plans.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCapacityPlansResponse {
    /// List of capacity plans.
    #[prost(message, repeated, tag = "1")]
    pub capacity_plans: ::prost::alloc::vec::Vec<CapacityPlan>,
    /// Token to retrieve the next page of results. This will be empty if there are
    /// no more pages.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Request for capacity plan insights.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCapacityPlanInsightsRequest {
    /// Required. The parent resource container.
    /// Format: projects/{project}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The filters to apply to the capacity plan.
    #[prost(message, optional, tag = "2")]
    pub capacity_plan_filters: ::core::option::Option<CapacityPlanFilters>,
}
/// Response for capacity plan insights.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryCapacityPlanInsightsResponse {
    /// Optional. The aggregated capacity plan view. This is the aggregated view of
    /// all the capacity plans that match the filters.
    #[prost(message, optional, tag = "1")]
    pub aggregated_capacity_plan_view: ::core::option::Option<CapacityPlanView>,
}
/// CapacityPlanFilters is a set of filters to apply to the capacity plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapacityPlanFilters {
    /// Required. The capacity plan keys to include in the response.
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<CapacityPlanKey>,
    /// Required. The capacity types to include in the response.
    #[prost(enumeration = "CapacityType", repeated, packed = "false", tag = "2")]
    pub capacity_types: ::prost::alloc::vec::Vec<i32>,
    /// Optional. Optional capacity plan id. Should be populated for request page
    /// to lock based on the same capacity plan.
    #[prost(string, tag = "3")]
    pub capacity_plan_id: ::prost::alloc::string::String,
}
/// CapacityPlanKey is a the unique identifier for each Capacity Plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapacityPlanKey {
    /// Required. The resource container associated with the capacity plan.
    #[prost(message, optional, tag = "1")]
    pub resource_container: ::core::option::Option<ResourceContainer>,
    /// Required. The resource id key associated with the capacity plan.
    #[prost(message, optional, tag = "2")]
    pub resource_id_key: ::core::option::Option<ResourceIdKey>,
    /// Required. Identifier of location.
    #[prost(message, optional, tag = "3")]
    pub location_id: ::core::option::Option<LocationIdentifier>,
}
/// CapacityPlanView contains the capacity plan key and the time series views.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapacityPlanView {
    /// Required. The capacity plan key associated with the capacity plan view.
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<CapacityPlanKey>,
    /// Required. The time series views associated with the capacity plan view.
    #[prost(message, repeated, tag = "2")]
    pub time_series_views: ::prost::alloc::vec::Vec<TimeSeriesView>,
}
/// TimeSeriesView contains capacity_value which has the timeseries for a given
/// type. Each type as a single timeseries associated with it.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeriesView {
    /// Required. The capacity type associated with the time series view.
    #[prost(enumeration = "CapacityType", tag = "1")]
    pub r#type: i32,
    /// Required. The capacity value associated with the time series view.
    #[prost(message, optional, tag = "2")]
    pub capacity_value: ::core::option::Option<DemandValue>,
}
/// A plan for additional capacity needed by a Google Cloud Platform project.
/// This is synonymous with CapacityDemand, CapacityRequest, and
/// CapacityDemandRequest.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapacityPlan {
    /// Identifier. The  name of the capacity plan.
    ///
    /// Format:
    /// projects/{project}/capacityPlans/{capacity_plan_id}
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The metadata associated with a capacity demand.
    #[prost(message, optional, tag = "2")]
    pub capacity_demand_metadata: ::core::option::Option<DemandMetadata>,
    /// Required. The capacity demand associated with a service.
    #[prost(message, repeated, tag = "3")]
    pub service_demands: ::prost::alloc::vec::Vec<ServiceDemand>,
    /// Output only. User who created the capacity plan.
    #[prost(message, optional, tag = "4")]
    pub reporter: ::core::option::Option<User>,
    /// Output only. State of the plan.
    #[prost(enumeration = "State", tag = "5")]
    pub state: i32,
    /// Output only. Timestamp when the plan was created.
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when the plan was last updated.
    #[prost(message, optional, tag = "7")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Description of the plan.
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Title of the plan.
    #[prost(string, tag = "9")]
    pub title: ::prost::alloc::string::String,
}
/// The metadata associated with a capacity demand.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemandMetadata {
    /// Optional. The preferences associated with a capacity demand.
    #[prost(message, repeated, tag = "1")]
    pub demand_preferences: ::prost::alloc::vec::Vec<DemandPreference>,
}
/// Preference associated with a request, such as flexibility with alternate
/// resource type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemandPreference {
    /// Output only. The preference id.
    #[prost(string, tag = "1")]
    pub preference_id: ::prost::alloc::string::String,
    /// Required. The value of demand preference.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Value>,
}
/// Capacity demand for a service.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceDemand {
    /// Required. Name of the service.
    #[prost(string, tag = "1")]
    pub service: ::prost::alloc::string::String,
    /// Optional. The metadata associated with a service demand.
    #[prost(message, optional, tag = "2")]
    pub demand_metadata: ::core::option::Option<DemandMetadata>,
    /// Required. The demand associated with the resources.
    #[prost(message, repeated, tag = "3")]
    pub resource_demands: ::prost::alloc::vec::Vec<ResourceDemand>,
}
/// Capacity demand for a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceDemand {
    /// Output only. Identifier of resource demand.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Required. The resource container associated with the demand.
    #[prost(message, optional, tag = "2")]
    pub resource_container: ::core::option::Option<ResourceContainer>,
    /// Required. Identifier of resource.
    #[prost(message, optional, tag = "3")]
    pub resource_id: ::core::option::Option<ResourceIdentifier>,
    /// Required. Identifier of location.
    #[prost(message, optional, tag = "4")]
    pub location_id: ::core::option::Option<LocationIdentifier>,
    /// Output only. State of the resource demand.
    #[prost(enumeration = "State", tag = "5")]
    pub state: i32,
    /// Output only. User who reported the demand.
    #[prost(message, optional, tag = "6")]
    pub reporter: ::core::option::Option<User>,
    /// Output only. Timestamp when the demand was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when the demand was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The demand values associated with the resource.
    #[prost(message, optional, tag = "9")]
    pub demand_values: ::core::option::Option<DemandValues>,
    /// Optional. The metadata associated with the demand.
    #[prost(message, optional, tag = "10")]
    pub demand_metadata: ::core::option::Option<DemandMetadata>,
    /// Optional. The child resource demands associated with the resource.
    #[prost(message, repeated, tag = "11")]
    pub child_resource_demands: ::prost::alloc::vec::Vec<ChildResourceDemand>,
}
/// A user who created or updated a capacity demand.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct User {
    /// Required. Email of the user.
    #[prost(string, tag = "1")]
    pub email: ::prost::alloc::string::String,
}
/// The capacity demand values for a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemandValues {
    /// Required. The demand values.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<DemandValue>,
}
/// Capacity demand value for a single resource attribute such as CPU count,
/// vertex AI peak QPM, etc.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DemandValue {
    /// Required. The name of the demand value such as CPU count.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The demand values at different time points.
    #[prost(message, repeated, tag = "2")]
    pub time_values: ::prost::alloc::vec::Vec<TimeValue>,
    /// Required. Unit of measurement.
    #[prost(enumeration = "Unit", tag = "3")]
    pub unit: i32,
}
/// Capacity demand value for a single time point.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeValue {
    /// Required. The time point. If this demand value is non-temporal, set time to
    /// -1.
    #[prost(message, optional, tag = "1")]
    pub time: ::core::option::Option<::prost_types::Timestamp>,
    /// Required. The demand value at the time point.
    #[prost(double, optional, tag = "2")]
    pub value: ::core::option::Option<f64>,
}
/// Capacity demand for a child resource such as shapes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChildResourceDemand {
    /// Required. Identifier of resource.
    #[prost(message, optional, tag = "1")]
    pub resource_id: ::core::option::Option<ResourceIdentifier>,
    /// Required. The demand values associated with the child resource.
    #[prost(message, optional, tag = "2")]
    pub demand_values: ::core::option::Option<DemandValues>,
    /// Optional. The metadata associated with the child resource demand.
    #[prost(message, optional, tag = "3")]
    pub demand_metadata: ::core::option::Option<DemandMetadata>,
}
/// The state of a capacity demand.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// The state is unspecified.
    Unspecified = 0,
    /// The demand is pending review.
    PendingReview = 1,
    /// The demand is in review.
    InReview = 3,
    /// The demand is provisionally approved.
    ApprovedProvisional = 8,
    /// The demand is obsolete.
    Obsolete = 5,
    /// The demand cannot be fulfilled.
    CannotBeFulfilled = 7,
    /// The demand is on hold, contact sales.
    OnHoldContactSales = 9,
    /// The demand is in fulfillment.
    InFulfillment = 10,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "STATE_UNSPECIFIED",
            Self::PendingReview => "PENDING_REVIEW",
            Self::InReview => "IN_REVIEW",
            Self::ApprovedProvisional => "APPROVED_PROVISIONAL",
            Self::Obsolete => "OBSOLETE",
            Self::CannotBeFulfilled => "CANNOT_BE_FULFILLED",
            Self::OnHoldContactSales => "ON_HOLD_CONTACT_SALES",
            Self::InFulfillment => "IN_FULFILLMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "PENDING_REVIEW" => Some(Self::PendingReview),
            "IN_REVIEW" => Some(Self::InReview),
            "APPROVED_PROVISIONAL" => Some(Self::ApprovedProvisional),
            "OBSOLETE" => Some(Self::Obsolete),
            "CANNOT_BE_FULFILLED" => Some(Self::CannotBeFulfilled),
            "ON_HOLD_CONTACT_SALES" => Some(Self::OnHoldContactSales),
            "IN_FULFILLMENT" => Some(Self::InFulfillment),
            _ => None,
        }
    }
}
/// CapacityType is the type of the capacity plan.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CapacityType {
    /// Default value.
    Unknown = 0,
    /// Latest inorganic data stored in horizon DB that is in draft state.
    InorganicDraft = 1,
    /// Latest inorganic data stored in horizon DB that are pending i.e. submitted
    /// or assessment.
    InorganicPending = 2,
    /// Latest inorganic data stored in horizon DB that has been approved.
    InorganicApproved = 3,
}
impl CapacityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "CAPACITY_TYPE_UNKNOWN",
            Self::InorganicDraft => "CAPACITY_TYPE_INORGANIC_DRAFT",
            Self::InorganicPending => "CAPACITY_TYPE_INORGANIC_PENDING",
            Self::InorganicApproved => "CAPACITY_TYPE_INORGANIC_APPROVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CAPACITY_TYPE_UNKNOWN" => Some(Self::Unknown),
            "CAPACITY_TYPE_INORGANIC_DRAFT" => Some(Self::InorganicDraft),
            "CAPACITY_TYPE_INORGANIC_PENDING" => Some(Self::InorganicPending),
            "CAPACITY_TYPE_INORGANIC_APPROVED" => Some(Self::InorganicApproved),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod capacity_planning_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This API allows users to plan for GCP capacity associated with their
    /// projects. Users can request additional capacity for GCP resources such as
    /// VMs, PDs, etc.
    #[derive(Debug, Clone)]
    pub struct CapacityPlanningServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl CapacityPlanningServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> CapacityPlanningServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> CapacityPlanningServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            CapacityPlanningServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns information about the capacity plan.
        pub async fn get_capacity_plan(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCapacityPlanRequest>,
        ) -> std::result::Result<tonic::Response<super::CapacityPlan>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.CapacityPlanningService/GetCapacityPlan",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.CapacityPlanningService",
                        "GetCapacityPlan",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of the capacity plans that are in the parent parameter and
        /// match your specified filters.
        /// (The maximum list length is limited by the pageSize parameter.)
        pub async fn query_capacity_plans(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryCapacityPlansRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCapacityPlansResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.CapacityPlanningService/QueryCapacityPlans",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.CapacityPlanningService",
                        "QueryCapacityPlans",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Query capacity plan insights that are in the parent parameter and match
        /// your specified filters.
        pub async fn query_capacity_plan_insights(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryCapacityPlanInsightsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryCapacityPlanInsightsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.CapacityPlanningService/QueryCapacityPlanInsights",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.CapacityPlanningService",
                        "QueryCapacityPlanInsights",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Repesents Future Reservation request which is part of aggregated
/// reservations data response of "QueryReservations".
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FutureReservation {
    /// A unique identifier for this future reservation. The server
    /// defines this identifier.
    #[prost(int64, tag = "1")]
    pub id: i64,
    /// The creation timestamp for this future reservation.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// URL of the Zone where this future reservation resides.
    #[prost(string, tag = "5")]
    pub zone: ::prost::alloc::string::String,
    /// Description of the future reservation provided by user.
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// The future reservation resource name.
    #[prost(string, tag = "7")]
    pub future_reservation: ::prost::alloc::string::String,
    #[prost(string, tag = "15")]
    pub owner_project_id: ::prost::alloc::string::String,
    /// Time window for this Future Reservation.
    #[prost(message, optional, tag = "9")]
    pub time_window: ::core::option::Option<future_reservation::TimeWindow>,
    /// List of Projects/Folders to share with.
    #[prost(message, optional, tag = "10")]
    pub share_settings: ::core::option::Option<allocation::ShareSettings>,
    /// Name prefix for the reservations to be created at the time of
    /// delivery. The name prefix must comply with RFC1035.
    /// Maximum allowed length for name prefix is 20. Automatically created
    /// reservations name format will be <name-prefix>-date-####.
    #[prost(string, tag = "11")]
    pub name_prefix: ::prost::alloc::string::String,
    /// Status of the Future Reservation
    #[prost(message, optional, tag = "12")]
    pub status: ::core::option::Option<future_reservation::Status>,
    /// Future timestamp when the FR auto-created reservations will be deleted by
    /// Compute Engine. Format of this field must be a valid RFC3339 value.
    #[prost(message, optional, tag = "13")]
    pub auto_created_reservations_delete_time: ::core::option::Option<
        ::prost_types::Timestamp,
    >,
    /// Setting for enabling or disabling automatic deletion for auto-created
    /// reservation. If set to true, auto-created reservations will be
    /// deleted at Future Reservation's end time (default) or at user's defined
    /// timestamp if any of the
    /// \[auto_created_reservations_delete_time, auto_created_reservations_duration\]
    /// values is specified.
    /// For keeping auto-created reservation indefinitely, this value should be set
    /// to false.
    #[prost(bool, tag = "14")]
    pub auto_delete_auto_created_reservations: bool,
    /// The type of the future reservation which can only be for a specific SKU for
    /// now.
    #[prost(oneof = "future_reservation::Type", tags = "8")]
    pub r#type: ::core::option::Option<future_reservation::Type>,
}
/// Nested message and enum types in `FutureReservation`.
pub mod future_reservation {
    /// Represents specific SKU properties for the Future Reservation.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SpecificSkuProperties {
        /// Properties of the SKU instances being reserved.
        #[prost(message, optional, tag = "1")]
        pub instance_properties: ::core::option::Option<
            super::allocation::specific_sku_allocation::AllocatedInstanceProperties,
        >,
        /// Total number of instances for which capacity assurance is requested at a
        /// future time period.
        #[prost(int64, tag = "2")]
        pub total_count: i64,
    }
    /// Represents time window for the Future Reservation.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TimeWindow {
        /// Start time of the Future Reservation.
        #[prost(message, optional, tag = "1")]
        pub start_time: ::core::option::Option<::prost_types::Timestamp>,
        /// End time of the Future Reservation.
        #[prost(message, optional, tag = "2")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// Represents status related to the future reservation.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {
        /// Current state of this Future Reservation
        #[prost(enumeration = "status::ProcurementStatus", tag = "1")]
        pub procurement_status: i32,
        /// Time when Future Reservation would become LOCKED, after which no
        /// modifications to Future Reservation will be allowed. Applicable only
        /// after the Future Reservation is in the APPROVED state. The lock_time is
        /// an RFC3339 string. The procurement_status will transition to PROCURING
        /// state at this time.
        #[prost(message, optional, tag = "2")]
        pub lock_time: ::core::option::Option<::prost_types::Timestamp>,
        /// Fully qualified urls of the automatically created reservations at
        /// start_time.
        #[prost(string, repeated, tag = "3")]
        pub auto_created_reservations: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
        /// This count indicates the fulfilled capacity so far. This is set during
        /// "PROVISIONING" state. This count also includes capacity delivered as part
        /// of existing matching reservations.
        #[prost(int64, tag = "4")]
        pub fulfilled_count: i64,
    }
    /// Nested message and enum types in `Status`.
    pub mod status {
        /// Represents procurement status of the Future Reservation.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ProcurementStatus {
            /// This is unused status value.
            Unspecified = 0,
            /// Future reservation is pending approval by Google Cloud Platform.
            PendingApproval = 1,
            /// Future reservation is approved by Google Cloud Platform.
            Approved = 2,
            /// Future reservation is committed by the customer.
            Committed = 3,
            /// Future reservation is rejected by Google Cloud Platform.
            Declined = 4,
            /// Future reservation is cancelled by the customer.
            Cancelled = 5,
            /// Future reservation is being procured by Google Cloud Platform. Beyond
            /// this point, Future reservation is locked and no further modifications
            /// are allowed.
            Procuring = 6,
            /// Future reservation capacity is being provisioned. This state will be
            /// entered after start_time, while reservations are being created to
            /// provide total_count reserved instance slots. This state will not
            /// persist past start_time + 24h.
            Provisioning = 7,
            /// Future reservation is fulfilled completely.
            Fulfilled = 8,
            /// Future reservation failed. No additional reservations were provided.
            Failed = 9,
            /// Future reservation is partially fulfilled. Additional reservations were
            /// provided but did not reach total_count reserved instance slots.
            FailedPartiallyFulfilled = 10,
            /// Related status for PlanningStatus.Draft. Transitions to
            /// PENDING_APPROVAL upon user submitting FR.
            Drafting = 11,
            /// An Amendment to the Future Reservation has been requested. If the
            /// Amendment is declined, the Future Reservation will be restored to the
            /// last known good state.
            PendingAmendmentApproval = 12,
        }
        impl ProcurementStatus {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "PROCUREMENT_STATUS_UNSPECIFIED",
                    Self::PendingApproval => "PENDING_APPROVAL",
                    Self::Approved => "APPROVED",
                    Self::Committed => "COMMITTED",
                    Self::Declined => "DECLINED",
                    Self::Cancelled => "CANCELLED",
                    Self::Procuring => "PROCURING",
                    Self::Provisioning => "PROVISIONING",
                    Self::Fulfilled => "FULFILLED",
                    Self::Failed => "FAILED",
                    Self::FailedPartiallyFulfilled => "FAILED_PARTIALLY_FULFILLED",
                    Self::Drafting => "DRAFTING",
                    Self::PendingAmendmentApproval => "PENDING_AMENDMENT_APPROVAL",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PROCUREMENT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                    "PENDING_APPROVAL" => Some(Self::PendingApproval),
                    "APPROVED" => Some(Self::Approved),
                    "COMMITTED" => Some(Self::Committed),
                    "DECLINED" => Some(Self::Declined),
                    "CANCELLED" => Some(Self::Cancelled),
                    "PROCURING" => Some(Self::Procuring),
                    "PROVISIONING" => Some(Self::Provisioning),
                    "FULFILLED" => Some(Self::Fulfilled),
                    "FAILED" => Some(Self::Failed),
                    "FAILED_PARTIALLY_FULFILLED" => Some(Self::FailedPartiallyFulfilled),
                    "DRAFTING" => Some(Self::Drafting),
                    "PENDING_AMENDMENT_APPROVAL" => Some(Self::PendingAmendmentApproval),
                    _ => None,
                }
            }
        }
    }
    /// The type of the future reservation which can only be for a specific SKU for
    /// now.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Future Reservation configuration to indicate instance properties and
        /// total count.
        #[prost(message, tag = "8")]
        SpecificSkuProperties(SpecificSkuProperties),
    }
}
/// The `QueryUsageHistories` request.
/// Next : 16
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUsageHistoriesRequest {
    /// Required. The compute engine resource and location for the time series
    /// values to return. The format is:
    ///
    /// ```text
    /// projects/{project}/locations/{location} or
    /// organizations/{organization}/locations/{location} or
    /// folders/{folder}/locations/{location}
    /// ```
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The location level of the reservations usage timeseries.
    #[prost(enumeration = "time_series::LocationType", tag = "11")]
    pub location_level: i32,
    /// Optional. The is_spot flag is used to fetch the usage data for preemptible
    /// Resources.
    #[prost(bool, tag = "14")]
    pub is_spot: bool,
    /// The machine family for the `UsageHistory` values to return. Possible values
    /// include "n1", and "n2d". See
    /// <https://cloud.google.com/compute/docs/machine-types> for more examples.
    /// Empty machine_family will return results matching all machine families.
    #[prost(string, tag = "2")]
    pub machine_family: ::prost::alloc::string::String,
    /// Optional. The machine shape for the `UsageHistory` values to return.
    #[prost(message, optional, tag = "13")]
    pub machine_shape: ::core::option::Option<MachineShape>,
    /// Optional. The disk_type for the `UsageHistory` values to return request
    /// with persistent-disk cloud_resource_type. Empty disk_type will return
    /// results matching all disk types.
    #[prost(string, tag = "7")]
    pub disk_type: ::prost::alloc::string::String,
    /// Optional. Whether the persistent disk is in confidential mode.
    #[prost(bool, tag = "15")]
    pub confidential_mode: bool,
    /// Optional. The GPU type for the `UsageHistory` values to return. Sample
    /// values are "nvidia-tesla-t4", and "nvidia-tesla-a100". See
    /// <https://cloud.google.com/compute/docs/gpus> for a list. Empty gpu_type
    /// will return results matching all GPUs.
    #[prost(string, tag = "8")]
    pub gpu_type: ::prost::alloc::string::String,
    /// Optional. The TPU type for the `UsageHistory` values to return. Empty
    /// tpu_type will return results matching all TPUs.
    #[prost(string, tag = "12")]
    pub tpu_type: ::prost::alloc::string::String,
    /// The resource for the `UsageHistory` values to return. Possible values
    /// include "gce-vcpus", "gce-ram", "gce-local-ssd", "gce-persistent-disk",
    /// "gce-gpu" and "gce-tpu".
    /// Empty cloud_resource_type will return results matching all resources.
    #[prost(string, tag = "3")]
    pub cloud_resource_type: ::prost::alloc::string::String,
    /// The method that should be used to convert sampled usage data to daily
    /// usage values.
    /// AGGREGATION_METHOD_UNSPECIFIED will return results matching all the
    /// aggregation methods.
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "4")]
    pub usage_aggregation_method: i32,
    /// Optional. The start date of reservations usage.
    #[prost(message, optional, tag = "9")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. The end date of reservations usage.
    #[prost(message, optional, tag = "10")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
}
/// The `QueryUsageHistories` response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryUsageHistoriesResponse {
    /// The usage histories that match the request.
    #[prost(message, repeated, tag = "1")]
    pub usage_histories: ::prost::alloc::vec::Vec<UsageHistory>,
}
/// The `QueryForecasts` request.
/// Next : 14
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryForecastsRequest {
    /// Required. The compute engine resource and location for the time series
    /// values to return. The format is:
    ///
    /// projects/{project}/locations/{location} or
    /// organizations/{organization}/locations/{location} or
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The machine family to use to select the `Forecast` values to return.
    /// Possible values include "n1", and "n2d".
    /// Empty machine_family will return results matching all machine families.
    #[prost(string, tag = "2")]
    pub machine_family: ::prost::alloc::string::String,
    /// Optional. The machine shape for the time series values to return.
    #[prost(message, optional, tag = "12")]
    pub machine_shape: ::core::option::Option<MachineShape>,
    /// Optional. The disk_type for the `Forecast` values to return with request
    /// persistent-disk cloud_resource_type.
    /// Empty disk_type will return results matching all disk types.
    #[prost(string, tag = "9")]
    pub disk_type: ::prost::alloc::string::String,
    /// Optional. Whether the persistent disk is in confidential mode.
    #[prost(bool, tag = "13")]
    pub confidential_mode: bool,
    /// Optional. The GPU type for the `Forecast` values to return. Sample values
    /// are "nvidia-tesla-t4", and "nvidia-tesla-a100". See
    /// <https://cloud.google.com/compute/docs/gpus> for a list. Empty gpu_type
    /// will return results matching all GPUs.
    #[prost(string, tag = "10")]
    pub gpu_type: ::prost::alloc::string::String,
    /// Optional. The TPU type for the `Forecast` values to return. Empty tpu_type
    /// will return results matching all TPUs.
    #[prost(string, tag = "11")]
    pub tpu_type: ::prost::alloc::string::String,
    /// The resource for the `Forecast` values to return. Possible values include
    /// "gce-vcpus", "gce-ram", "gce-local-ssd", "gce-persistent-disk", "gce-gpu"
    /// and "gce-tpu".
    /// Empty cloud_resource_type will return results matching all resources.
    #[prost(string, tag = "3")]
    pub cloud_resource_type: ::prost::alloc::string::String,
    /// The type of forecast to use to select the `Forecast` values to return.
    /// FORECAST_TYPE_UNSPECIFIED will return results matching all the forecast
    /// types.
    #[prost(enumeration = "forecast::ForecastType", tag = "4")]
    pub forecast_type: i32,
    /// The prediction interval to use to select the `Forecast` values to return.
    /// PREDICTION_INTERVAL_UNSPECIFIED will return results matching all prediction
    /// intervals.
    #[prost(enumeration = "forecast::PredictionInterval", tag = "5")]
    pub prediction_interval: i32,
    /// Aggregation Method of the historical usage for which the forecast is
    /// generated
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "8")]
    pub aggregation_method: i32,
}
/// The `QueryForecasts` response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryForecastsResponse {
    /// The forecasts that match the request.
    #[prost(message, repeated, tag = "1")]
    pub forecasts: ::prost::alloc::vec::Vec<Forecast>,
}
/// The `QueryReservations` request.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReservationsRequest {
    /// Required. The compute engine resource and location for the time series
    /// values to return. The format is:
    ///
    /// projects/{project}/locations/{location} or
    /// organizations/{organization}/locations/{location} or
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The location level of the reservations usage timeseries.
    #[prost(enumeration = "time_series::LocationType", tag = "16")]
    pub location_level: i32,
    /// Optional. The machine family to use to select the aggregate reserved values
    /// to return. Possible values include "n1", and "n2d" etc. Empty
    /// machine_family will return results matching all machine families.
    #[prost(string, tag = "2")]
    pub machine_family: ::prost::alloc::string::String,
    /// Optional. The machine_shape as a filter to select matching reservations.
    #[prost(message, optional, tag = "11")]
    pub machine_shape: ::core::option::Option<MachineShape>,
    /// Optional. The GPU type for the reserved values to return. Sample values
    /// are "nvidia-tesla-t4", and "nvidia-tesla-a100". See
    /// <https://cloud.google.com/compute/docs/gpus> for a list. Empty gpu_type
    /// will return results matching all GPUs.
    #[prost(string, tag = "3")]
    pub gpu_type: ::prost::alloc::string::String,
    /// Optional. The resource for the reserved values to return. Possible values
    /// include "gce-vcpus", "gce-ram", "gce-local-ssd", "gce-gpu" and "gce-vm".
    #[prost(string, tag = "4")]
    pub cloud_resource_type: ::prost::alloc::string::String,
    /// Optional. The Reservation type for example, future reservation request and
    /// allocation. If unspecified, all types are
    /// included.
    #[prost(enumeration = "query_reservations_request::ReservationType", tag = "5")]
    pub reservation_type: i32,
    /// Optional. Types of share settings to filter reservations in response. If
    /// unspecified, all types are included.
    #[prost(enumeration = "query_reservations_request::ShareType", tag = "6")]
    pub share_type: i32,
    /// Optional. Types of ownerships to filter reservations based on.
    /// In case of OWNED, it filters reservations which are owned by selected
    /// parent project/folder/organization. If unspecified, all types are
    /// included.
    #[prost(enumeration = "query_reservations_request::OwnershipType", tag = "7")]
    pub ownership_type: i32,
    /// Optional. Reservations output data format.
    #[prost(enumeration = "query_reservations_request::ReservationDataLevel", tag = "8")]
    pub reservation_data_level: i32,
    /// Optional. Whether to include pending for approval reservations in the
    /// response. This field is only applicable for future reservations.
    #[prost(bool, tag = "12")]
    pub include_unapproved_reservations: bool,
    /// Optional. Aggregation Method of the historical reservation usage
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "13")]
    pub aggregation_method: i32,
    /// Optional. The start date of reservations usage.
    #[prost(message, optional, tag = "14")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. The end date of reservations usage.
    #[prost(message, optional, tag = "15")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
}
/// Nested message and enum types in `QueryReservationsRequest`.
pub mod query_reservations_request {
    /// Type of the reservation
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReservationType {
        /// No reservation type specified.
        Unspecified = 0,
        /// Allocation refers to realized reservation either auto created or created
        /// by the users on demand.
        Allocation = 1,
        /// Future Reservation requests created by users.
        FutureReservation = 2,
        /// All reservations.
        All = 3,
    }
    impl ReservationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESERVATION_TYPE_UNSPECIFIED",
                Self::Allocation => "RESERVATION_TYPE_ALLOCATION",
                Self::FutureReservation => "RESERVATION_TYPE_FUTURE_RESERVATION",
                Self::All => "RESERVATION_TYPE_ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "RESERVATION_TYPE_ALLOCATION" => Some(Self::Allocation),
                "RESERVATION_TYPE_FUTURE_RESERVATION" => Some(Self::FutureReservation),
                "RESERVATION_TYPE_ALL" => Some(Self::All),
                _ => None,
            }
        }
    }
    /// Possible scope in which the reservation can be shared.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShareType {
        /// No share type specified.
        Unspecified = 0,
        /// Default value, for which reservation is open to only owner project.
        Local = 1,
        /// Shared-reservation is open to specific projects.
        SpecificProjects = 2,
    }
    impl ShareType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHARE_TYPE_UNSPECIFIED",
                Self::Local => "SHARE_TYPE_LOCAL",
                Self::SpecificProjects => "SHARE_TYPE_SPECIFIC_PROJECTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHARE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SHARE_TYPE_LOCAL" => Some(Self::Local),
                "SHARE_TYPE_SPECIFIC_PROJECTS" => Some(Self::SpecificProjects),
                _ => None,
            }
        }
    }
    /// Reservation ownership status to provide distinction for Capacity Planning.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnershipType {
        /// No ownership status specified.
        Unspecified = 0,
        /// For the reservations owned within selected Google Cloud Platform Resource
        /// Container (project/folder/organization).
        Owned = 1,
        /// For the reservations consumable within selected Google Cloud Platform
        /// Resource Container (project/folder/organization), but not owned by them.
        SharedByOthers = 2,
    }
    impl OwnershipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "OWNERSHIP_TYPE_UNSPECIFIED",
                Self::Owned => "OWNERSHIP_TYPE_OWNED",
                Self::SharedByOthers => "OWNERSHIP_TYPE_SHARED_BY_OTHERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNERSHIP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "OWNERSHIP_TYPE_OWNED" => Some(Self::Owned),
                "OWNERSHIP_TYPE_SHARED_BY_OTHERS" => Some(Self::SharedByOthers),
                _ => None,
            }
        }
    }
    /// The form in which data of reservations should be returned.
    /// In case of AGGREGATED, timeseries for selected reservations is returned. If
    /// unspecified, all levels are included.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReservationDataLevel {
        /// No reservation data level specified.
        Unspecified = 0,
        /// aggregated reservations data in a timeseries or aggregation over
        /// timeseries.
        Aggregated = 1,
        /// per reservation detail which is equivalent of Arcus Future Reservation or
        /// Allocation with only limited fields which are useful for Capacity
        /// Planning.
        PerReservation = 2,
    }
    impl ReservationDataLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "RESERVATION_DATA_LEVEL_UNSPECIFIED",
                Self::Aggregated => "RESERVATION_DATA_LEVEL_AGGREGATED",
                Self::PerReservation => "RESERVATION_DATA_LEVEL_PER_RESERVATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESERVATION_DATA_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
                "RESERVATION_DATA_LEVEL_AGGREGATED" => Some(Self::Aggregated),
                "RESERVATION_DATA_LEVEL_PER_RESERVATION" => Some(Self::PerReservation),
                _ => None,
            }
        }
    }
}
/// The `QueryReservations` response.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryReservationsResponse {
    /// The reservations data that match the request.
    #[prost(message, repeated, tag = "1")]
    pub reservations: ::prost::alloc::vec::Vec<ReservationData>,
}
/// A single data point in a time series.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Point {
    /// The time which the data point applies.
    #[prost(message, optional, tag = "1")]
    pub event_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The value of the data point.
    #[prost(double, tag = "2")]
    pub value: f64,
}
/// A collection of data points that describes the predicted time-varying values
/// of a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Forecast {
    /// The resource name of the connection in the form of:
    /// `projects/{project_id}/locations/{location_id}/forecasts/{forecast_id}` or
    /// `organizations/{organization_id}/locations/{location_id}/forecasts/{forecast_id}`
    /// or `folders/{folder_id}/locations/{location_id}/forecasts/{forecast_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The collection of data points that represent the predicted values. Note
    /// that some of these values may be in the past (if, for example, the forecast
    /// was created in the past and predicted values for the present day).
    #[prost(message, optional, tag = "2")]
    pub time_series: ::core::option::Option<TimeSeries>,
    /// The type of forecast.
    #[prost(enumeration = "forecast::ForecastType", tag = "3")]
    pub forecast_type: i32,
    /// The bounds represented by this forecast time series.
    #[prost(enumeration = "forecast::Bounds", tag = "4")]
    pub bounds: i32,
    /// The prediction interval represented by the time series.
    #[prost(enumeration = "forecast::PredictionInterval", tag = "5")]
    pub prediction_interval: i32,
    /// Aggregation Method of the historical usage for which the forecast is
    /// generated
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "6")]
    pub aggregation_method: i32,
}
/// Nested message and enum types in `Forecast`.
pub mod forecast {
    /// The type of the forecast. This describes the method that was used to
    /// produce future time series values from historical time series values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ForecastType {
        /// No forecast type is specified.
        Unspecified = 0,
        /// Statistical forecast.
        Statistical = 1,
        /// Statistical forecast that attempts to predict the seasonal affects of
        /// Black Friday and Cyber Monday.
        StatisticalWithBfcm = 2,
        /// Yearly Seasonality model provides generic seasonality beyond BFCM.
        YearlySeasonality = 3,
    }
    impl ForecastType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "FORECAST_TYPE_UNSPECIFIED",
                Self::Statistical => "STATISTICAL",
                Self::StatisticalWithBfcm => "STATISTICAL_WITH_BFCM",
                Self::YearlySeasonality => "YEARLY_SEASONALITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORECAST_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "STATISTICAL" => Some(Self::Statistical),
                "STATISTICAL_WITH_BFCM" => Some(Self::StatisticalWithBfcm),
                "YEARLY_SEASONALITY" => Some(Self::YearlySeasonality),
                _ => None,
            }
        }
    }
    /// The bounds of the forecast time series.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Bounds {
        /// No bounds is specified.
        Unspecified = 0,
        /// The time series represents the upper bound of the forecast.
        LowerBound = 1,
        /// The time series represents the median expected forecast value.
        Median = 2,
        /// The time series represents the lower bound of the forecast.
        UpperBound = 3,
    }
    impl Bounds {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BOUNDS_UNSPECIFIED",
                Self::LowerBound => "LOWER_BOUND",
                Self::Median => "MEDIAN",
                Self::UpperBound => "UPPER_BOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BOUNDS_UNSPECIFIED" => Some(Self::Unspecified),
                "LOWER_BOUND" => Some(Self::LowerBound),
                "MEDIAN" => Some(Self::Median),
                "UPPER_BOUND" => Some(Self::UpperBound),
                _ => None,
            }
        }
    }
    /// The prediction interval represented by a forecast.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PredictionInterval {
        /// No prediction interval is specified.
        Unspecified = 0,
        /// This represents a prediction interval that has 90% confidence. For
        /// example, for a symmetric prediction interval, a `PredictionInterval`
        /// of `PREDICTION_INTERVAL_90` means that the `UPPER_BOUND` will represent
        /// the 95th precentile.
        PredictionInterval90 = 1,
        /// This represents a prediction interval that has 50% confidence. For
        /// example, for a symmetric prediction interval, a `PredictionInterval`
        /// of `PREDICTION_INTERVAL_50` means that the `UPPER_BOUND` will represent
        /// the 75th precentile.
        PredictionInterval50 = 2,
    }
    impl PredictionInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PREDICTION_INTERVAL_UNSPECIFIED",
                Self::PredictionInterval90 => "PREDICTION_INTERVAL_90",
                Self::PredictionInterval50 => "PREDICTION_INTERVAL_50",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PREDICTION_INTERVAL_UNSPECIFIED" => Some(Self::Unspecified),
                "PREDICTION_INTERVAL_90" => Some(Self::PredictionInterval90),
                "PREDICTION_INTERVAL_50" => Some(Self::PredictionInterval50),
                _ => None,
            }
        }
    }
}
/// A collection of data points that describes the historical time-varying values
/// of a resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageHistory {
    /// The collection of data points that represent the historical values.
    #[prost(message, optional, tag = "1")]
    pub time_series: ::core::option::Option<TimeSeries>,
    /// Method used to convert sampled usage data to time series values.
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "2")]
    pub aggregation_method: i32,
}
/// Nested message and enum types in `UsageHistory`.
pub mod usage_history {
    /// Methods for converting sampled data to time series values.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AggregationMethod {
        /// No aggregation method is specified.
        Unspecified = 0,
        Median = 1,
        /// Time series values represent the 99th percentile of the sampled values.
        Peak = 2,
        /// Time series values represent the 50th(median) percentile of the sampled
        /// values.
        P50 = 3,
        /// Time series values represent the 75th percentile of the sampled values.
        P75 = 4,
        /// Time series values represent the 99th percentile of the sampled values.
        P99 = 5,
    }
    impl AggregationMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "AGGREGATION_METHOD_UNSPECIFIED",
                Self::Median => "MEDIAN",
                Self::Peak => "PEAK",
                Self::P50 => "P50",
                Self::P75 => "P75",
                Self::P99 => "P99",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AGGREGATION_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "MEDIAN" => Some(Self::Median),
                "PEAK" => Some(Self::Peak),
                "P50" => Some(Self::P50),
                "P75" => Some(Self::P75),
                "P99" => Some(Self::P99),
                _ => None,
            }
        }
    }
}
/// A collection of data points that describes the time-varying values of a
/// resource. A time series is identified by its ID.
/// Next : 13
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
    /// Required. The type of location that the time series is summarizing.
    #[prost(enumeration = "time_series::LocationType", tag = "1")]
    pub location_type: i32,
    /// Optional. The location of the usage data in time series.
    #[prost(string, tag = "9")]
    pub location: ::prost::alloc::string::String,
    /// Optional. The location of the usage data in time series.
    #[prost(bool, tag = "11")]
    pub is_spot: bool,
    /// The machine family for the time series values to return. Possible values
    /// include "n1" and "n2d".
    #[prost(string, tag = "2")]
    pub machine_family: ::prost::alloc::string::String,
    /// The disk type for the time series values to return.
    #[prost(string, tag = "6")]
    pub disk_type: ::prost::alloc::string::String,
    /// Optional. The confidential mode for disk.
    #[prost(bool, tag = "12")]
    pub confidential_mode: bool,
    /// The GPU type of the time series.
    #[prost(string, tag = "7")]
    pub gpu_type: ::prost::alloc::string::String,
    /// The TPU type of the time series.
    #[prost(string, tag = "10")]
    pub tpu_type: ::prost::alloc::string::String,
    /// The machine shape of the time series.
    #[prost(message, optional, tag = "8")]
    pub machine_shape: ::core::option::Option<MachineShape>,
    /// The resource for the time series values to return. Possible values include
    /// "gce-vcpus", "gce-ram", "gce-local-ssd", "gce-persistent-disk", "gce-gpu",
    /// "gce-tpu" and "gce-vm".
    #[prost(string, tag = "3")]
    pub cloud_resource_type: ::prost::alloc::string::String,
    /// The data points of this time series. When listing time series, points are
    /// returned in chronological order.
    #[prost(message, repeated, tag = "4")]
    pub points: ::prost::alloc::vec::Vec<Point>,
    /// The units in which the values are reported.
    #[prost(string, tag = "5")]
    pub unit: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TimeSeries`.
pub mod time_series {
    /// The type of location that the time series is summarizing.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationType {
        /// No location type was specified.
        Unspecified = 0,
        /// Time series values represent usage aggregated at the region level.
        Regional = 1,
        /// Time series values represent usage aggregated at the zone level.
        Zonal = 2,
    }
    impl LocationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "LOCATION_TYPE_UNSPECIFIED",
                Self::Regional => "REGIONAL",
                Self::Zonal => "ZONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOCATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "REGIONAL" => Some(Self::Regional),
                "ZONAL" => Some(Self::Zonal),
                _ => None,
            }
        }
    }
}
/// Response entity for reservations data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationData {
    /// Identifier. The resource name of the connection in the form of:
    /// `projects/{project_id}/locations/{location_id}/reservations/{reservation_id}`
    /// or
    /// `organizations/{organization_id}/locations/{location_id}/reservations/{reservation_id}`
    /// or
    /// `folders/{folder_id}/locations/{location_id}/reservations/{reservation_id}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// The collection of data points that represent the aggregated reserved value
    /// for reservations filtered by the criteria.
    #[prost(message, optional, tag = "2")]
    pub time_series: ::core::option::Option<TimeSeries>,
    /// The collection of data points that represent the aggregated used value for
    /// reservations filtered by the criteria.
    #[prost(message, optional, tag = "5")]
    pub used_reservation_values: ::core::option::Option<TimeSeries>,
    /// Future reservations filtered by the criteria.
    #[prost(message, repeated, tag = "3")]
    pub future_reservations: ::prost::alloc::vec::Vec<FutureReservation>,
    /// Allocations filtered by the criteria.
    #[prost(message, repeated, tag = "4")]
    pub allocations: ::prost::alloc::vec::Vec<Allocation>,
}
/// Machine shape details
/// Next : 13
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineShape {
    /// Optional. The VM family.
    #[prost(string, tag = "1")]
    pub machine_family: ::prost::alloc::string::String,
    /// Optional. The characteristics of the sampled VM expressed as a string.
    #[prost(string, tag = "2")]
    pub machine_type: ::prost::alloc::string::String,
    /// Optional. The customer visible string representing the type of VM.
    #[prost(string, tag = "3")]
    pub machine_shape: ::prost::alloc::string::String,
    /// Optional. Number of CPU cores per VM.
    #[prost(double, tag = "4")]
    pub cpu_cores: f64,
    /// Optional. The type of GPU with the VM.
    #[prost(string, tag = "5")]
    pub gpu_type: ::prost::alloc::string::String,
    /// Optional. The GPU name recognized by Compute Engine APIs.
    #[prost(string, tag = "10")]
    pub gpu_compute_type: ::prost::alloc::string::String,
    /// Optional. The number of GPU cores per VM.
    #[prost(int64, tag = "6")]
    pub gpu_cores: i64,
    /// Optional. The number of local SSD partitions per VM.
    #[prost(int64, tag = "7")]
    pub local_ssd_partitions: i64,
    /// Optional. Total amount of local SSD storage.
    #[prost(double, tag = "8")]
    pub local_ssd_gb: f64,
    /// Optional. Total amount of memory with the VM.
    #[prost(double, tag = "9")]
    pub memory_gb: f64,
    /// Optional. The local SSD interface used such as nvme or scsi
    #[prost(string, tag = "11")]
    pub local_ssd_interface: ::prost::alloc::string::String,
    /// Optional. The Min-cpu platform used such as icelake
    #[prost(string, tag = "12")]
    pub min_cpu_platform: ::prost::alloc::string::String,
}
/// The `ExportUsageHistories` request
/// Next : 12
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportUsageHistoriesRequest {
    /// Required. The compute engine resource and location for the time series
    /// values to return. The format is:
    /// projects/{project}/locations/{location} or
    /// organizations/{organization}/locations/{location} or
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Set true to export usage for spot resources.
    #[prost(bool, tag = "11")]
    pub is_spot: bool,
    /// Optional. The machine family for the `UsageHistory` values to return.
    /// Possible values include "n1", and "n2d". See
    /// <https://cloud.google.com/compute/docs/machine-types> for more examples.
    #[prost(string, tag = "2")]
    pub machine_family: ::prost::alloc::string::String,
    /// Optional. The machine shape for the time series values to export.
    #[prost(message, optional, tag = "13")]
    pub machine_shape: ::core::option::Option<MachineShape>,
    /// Optional. The disk_type for the `UsageHistory` values to return request
    /// with persistent-disk resource_type. Possible values include "pd-ssd",
    /// "pd-standard", "pd-balanced", and "pd-extreme".
    #[prost(string, tag = "3")]
    pub disk_type: ::prost::alloc::string::String,
    /// Optional. The GPU type for the `UsageHistory` values to return. Sample
    /// values are "nvidia-tesla-t4", and "nvidia-tesla-a100". See
    /// <https://cloud.google.com/compute/docs/gpus> for a list. Empty gpu_type
    /// will return results matching all GPUs.
    #[prost(string, tag = "9")]
    pub gpu_type: ::prost::alloc::string::String,
    /// Optional. The TPU type for the `UsageHistory` values to return. Empty
    /// tpu_type will return results matching all TPUs.
    #[prost(string, tag = "10")]
    pub tpu_type: ::prost::alloc::string::String,
    /// Required. The resource for the `UsageHistory` values to return. Possible
    /// values include "gce-vcpus", "gce-ram", "gce-local-ssd",
    /// "gce-persistent-disk", "gce-gpu" and "gce-tpu".
    #[prost(string, tag = "4")]
    pub resource_type: ::prost::alloc::string::String,
    /// Optional. The method that should be used to convert sampled usage data to
    /// daily usage values. AGGREGATION_METHOD_UNSPECIFIED will return results
    /// matching all the aggregation methods.
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "5")]
    pub usage_aggregation_method: i32,
    /// Optional. The start date of usage.
    #[prost(message, optional, tag = "6")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. The end date of usage.
    #[prost(message, optional, tag = "7")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Required. Output configuration indicating where the results will be output
    /// to.
    #[prost(message, optional, tag = "8")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
/// The `ExportForecasts` request
/// Next : 13
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportForecastsRequest {
    /// Required. The compute engine resource and location for the time series
    /// values to return. The format is:
    /// projects/{project}/locations/{location} or
    /// organizations/{organization}/locations/{location} or
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The machine family to use to select the `Forecast` values to
    /// return. Possible values include "n1", and "n2d".
    #[prost(string, tag = "2")]
    pub machine_family: ::prost::alloc::string::String,
    /// Optional. The machine shape for the time series values to export.
    #[prost(message, optional, tag = "12")]
    pub machine_shape: ::core::option::Option<MachineShape>,
    /// Optional. The disk_type for the `Forecast` values to return with request
    /// persistent-disk resource_type.
    #[prost(string, tag = "3")]
    pub disk_type: ::prost::alloc::string::String,
    /// Optional. The GPU type for the `Forecast` values to return. Sample values
    /// are "nvidia-tesla-t4", and "nvidia-tesla-a100". See
    /// <https://cloud.google.com/compute/docs/gpus> for a list. Empty gpu_type
    /// will return results matching all GPUs.
    #[prost(string, tag = "10")]
    pub gpu_type: ::prost::alloc::string::String,
    /// Optional. The TPU type for the `Forecast` values to return. Empty tpu_type
    /// will return results matching all TPUs.
    #[prost(string, tag = "11")]
    pub tpu_type: ::prost::alloc::string::String,
    /// Required. The resource for the `Forecast` values to return. Possible values
    /// include "gce-vcpus", "gce-ram", "gce-local-ssd", "gce-persistent-disk",
    /// "gce-gpu" and "gce-tpu".
    #[prost(string, tag = "4")]
    pub resource_type: ::prost::alloc::string::String,
    /// Optional. The prediction interval to use to select the `Forecast` values to
    /// return. PREDICTION_INTERVAL_UNSPECIFIED will return results matching all
    /// prediction intervals.
    #[prost(enumeration = "forecast::PredictionInterval", tag = "5")]
    pub prediction_interval: i32,
    /// Optional. Aggregation Method of the historical usage for which the forecast
    /// is generated.
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "6")]
    pub aggregation_method: i32,
    /// Optional. The start date of forecasts.
    #[prost(message, optional, tag = "7")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. The end date of forecasts.
    #[prost(message, optional, tag = "8")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Required. Output configuration indicating where the results will be output
    /// to.
    #[prost(message, optional, tag = "9")]
    pub output_config: ::core::option::Option<OutputConfig>,
}
/// The `ExportReservationsUsage` request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportReservationsUsageRequest {
    /// Required. The compute engine resource and location of the
    /// reservationsusage. The format is:
    /// projects/{project}/locations/{location} or
    /// organizations/{organization}/locations/{location} or
    /// folders/{folder}/locations/{location}
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The location level of the reservations usage timeseries.
    #[prost(enumeration = "time_series::LocationType", tag = "11")]
    pub location_level: i32,
    /// Required. The resource for the `ReservationsUsage` values to return.
    /// Possible values include "gce-vcpus", "gce-ram", "gce-local-ssd", and
    /// "gce-gpu".
    #[prost(string, tag = "5")]
    pub cloud_resource_type: ::prost::alloc::string::String,
    /// Required. The method that should be used to convert sampled reservations
    /// data to daily usage values.
    #[prost(enumeration = "usage_history::AggregationMethod", tag = "6")]
    pub usage_aggregation_method: i32,
    /// Optional. Type of share settings to filter reservations in response. If
    /// unspecified, all types are included.
    #[prost(enumeration = "export_reservations_usage_request::ShareType", tag = "7")]
    pub share_type: i32,
    /// Optional. The start date of reservations usage.
    #[prost(message, optional, tag = "8")]
    pub start_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Optional. The end date of reservations usage.
    #[prost(message, optional, tag = "9")]
    pub end_date: ::core::option::Option<super::super::super::r#type::Date>,
    /// Required. Output configuration indicating where the results will be output
    /// to.
    #[prost(message, optional, tag = "10")]
    pub output_config: ::core::option::Option<OutputConfig>,
    /// resource to query reservations and usage by.
    #[prost(oneof = "export_reservations_usage_request::Resource", tags = "2, 3, 4")]
    pub resource: ::core::option::Option<export_reservations_usage_request::Resource>,
}
/// Nested message and enum types in `ExportReservationsUsageRequest`.
pub mod export_reservations_usage_request {
    /// Possible scope in which the reservation can be shared.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShareType {
        /// No share type specified.
        Unspecified = 0,
        /// Default value, for which reservation is open to only owner project.
        Local = 1,
        /// Shared-reservation is open to specific projects.
        SpecificProjects = 2,
    }
    impl ShareType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "SHARE_TYPE_UNSPECIFIED",
                Self::Local => "SHARE_TYPE_LOCAL",
                Self::SpecificProjects => "SHARE_TYPE_SPECIFIC_PROJECTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SHARE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SHARE_TYPE_LOCAL" => Some(Self::Local),
                "SHARE_TYPE_SPECIFIC_PROJECTS" => Some(Self::SpecificProjects),
                _ => None,
            }
        }
    }
    /// resource to query reservations and usage by.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Resource {
        /// Optional. The machine family to query reservations and usage by. For
        /// example: n1, n2d.
        #[prost(string, tag = "2")]
        MachineFamily(::prost::alloc::string::String),
        /// Optional. The machine_shape as a filter to select matching reservations
        /// and its usage.
        #[prost(message, tag = "3")]
        MachineShape(super::MachineShape),
        /// Optional. The GPU type to query reservations and usage  by. For example:
        /// NVIDIA T4.
        #[prost(string, tag = "4")]
        GpuType(::prost::alloc::string::String),
    }
}
/// Output configuration for export destination.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OutputConfig {
    /// Export destination.
    #[prost(oneof = "output_config::Destination", tags = "1, 2")]
    pub destination: ::core::option::Option<output_config::Destination>,
}
/// Nested message and enum types in `OutputConfig`.
pub mod output_config {
    /// Export destination.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Destination {
        /// Destination on Cloud Storage.
        #[prost(message, tag = "1")]
        GcsDestination(super::GcsDestination),
        /// Destination on BigQuery.
        #[prost(message, tag = "2")]
        BigqueryDestination(super::BigQueryDestination),
    }
}
/// A Cloud Storage location.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GcsDestination {
    /// Optional. The path to the file in Cloud Storage where the export will be
    /// stored. The URI is in the form `gs://bucketName/fileName`. If the file
    /// already exists, the request succeeds, but the operation fails.
    #[prost(string, tag = "1")]
    pub uri: ::prost::alloc::string::String,
    /// Required. The bucket name to which the export will be stored.
    #[prost(string, tag = "3")]
    pub bucket: ::prost::alloc::string::String,
    /// Required. The object name to which the export will be stored.
    #[prost(string, tag = "4")]
    pub object: ::prost::alloc::string::String,
    /// Optional. Flag to indicate overwrite in case file already exists.
    #[prost(bool, tag = "2")]
    pub force: bool,
}
/// A BigQuery destination for exporting assets to.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BigQueryDestination {
    /// Required. The BigQuery dataset in format
    /// "projects/{projectId}/datasets/{datasetId}", to which the snapshot result
    /// should be exported. If this dataset does not exist, the export call returns
    /// an INVALID_ARGUMENT error.
    #[prost(string, tag = "1")]
    pub dataset: ::prost::alloc::string::String,
    /// Required. The BigQuery table to which the snapshot result should be
    /// written.
    #[prost(string, tag = "2")]
    pub table: ::prost::alloc::string::String,
    /// Optional. The partition key for BigQuery partitioned table.
    #[prost(enumeration = "big_query_destination::PartitionKey", tag = "3")]
    pub partition_key: i32,
    /// Optional. Specifies the action that occurs if the destination table or
    /// partition already exists.
    #[prost(enumeration = "big_query_destination::WriteDisposition", tag = "4")]
    pub write_disposition: i32,
    /// Optional. Specifies the action that occurs if the destination table does
    /// not exist
    #[prost(enumeration = "big_query_destination::CreateDisposition", tag = "5")]
    pub create_disposition: i32,
    /// Optional. Specifies the Cloud Storage location.
    /// Users can choose to provide a location for Cloud Storage bucket to store
    /// the exported data. (as it is possible that some locations are restricted
    /// via org policy for that project) Temporary Cloud Storage bucket creation is
    /// an interim step for BigQuery upload. If no value is provided, the default
    /// location used will be 'US'.
    #[prost(string, tag = "6")]
    pub gcs_location: ::prost::alloc::string::String,
}
/// Nested message and enum types in `BigQueryDestination`.
pub mod big_query_destination {
    /// This enum determines the partition key column for the BigQuery tables.
    /// Partitioning can improve query performance and reduce query cost by
    /// filtering partitions. Refer to
    /// <https://cloud.google.com/bigquery/docs/partitioned-tables> for details.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartitionKey {
        /// Unspecified partition key. Tables won't be partitioned using this
        /// option.
        Unspecified = 0,
        /// The time when the request is received. If specified as partition key,
        /// the result table(s) is partitioned by the RequestTime column, an
        /// additional timestamp column representing when the request was received.
        RequestTime = 1,
    }
    impl PartitionKey {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "PARTITION_KEY_UNSPECIFIED",
                Self::RequestTime => "REQUEST_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARTITION_KEY_UNSPECIFIED" => Some(Self::Unspecified),
                "REQUEST_TIME" => Some(Self::RequestTime),
                _ => None,
            }
        }
    }
    /// Specifies the action that occurs if the destination table or partition
    /// already exists. By default, the data will be appended to the existing
    /// table.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WriteDisposition {
        /// Unspecified write disposition.
        Unspecified = 0,
        /// If the table or partition already exists, BigQuery appends the data to
        /// the table or the latest partition.
        WriteAppend = 1,
        /// If the table or partition already exists, BigQuery overwrites the entire
        /// table or all the partitions data.
        WriteTruncate = 2,
        /// If the table already exists and contains data, an error is returned.
        WriteEmpty = 3,
    }
    impl WriteDisposition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WRITE_DISPOSITION_UNSPECIFIED",
                Self::WriteAppend => "WRITE_APPEND",
                Self::WriteTruncate => "WRITE_TRUNCATE",
                Self::WriteEmpty => "WRITE_EMPTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WRITE_DISPOSITION_UNSPECIFIED" => Some(Self::Unspecified),
                "WRITE_APPEND" => Some(Self::WriteAppend),
                "WRITE_TRUNCATE" => Some(Self::WriteTruncate),
                "WRITE_EMPTY" => Some(Self::WriteEmpty),
                _ => None,
            }
        }
    }
    /// Specifies the action that occurs if the destination table does not exist.
    /// By default, a new table will be created.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreateDisposition {
        /// Unspecified create disposition.
        Unspecified = 0,
        /// If the table does not exist, BigQuery creates the table.
        CreateIfNeeded = 1,
        /// If the table does not exist, an error will be returned.
        CreateNever = 2,
    }
    impl CreateDisposition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CREATE_DISPOSITION_UNSPECIFIED",
                Self::CreateIfNeeded => "CREATE_IF_NEEDED",
                Self::CreateNever => "CREATE_NEVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATE_DISPOSITION_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE_IF_NEEDED" => Some(Self::CreateIfNeeded),
                "CREATE_NEVER" => Some(Self::CreateNever),
                _ => None,
            }
        }
    }
}
/// Represents the metadata of a long-running operation.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// A response message for \[UsageService.ExportUsageHistories\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExportUsageHistoriesResponse {
    /// The response message for the usage history export. In case of bigquery,
    /// it will also contain job id.
    #[prost(string, tag = "1")]
    pub response: ::prost::alloc::string::String,
}
/// A response message for \[UsageService.ExportForecasts\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExportForecastsResponse {
    /// The response message for the forecast export. In case of bigquery,
    /// it will also contain job id.
    #[prost(string, tag = "1")]
    pub response: ::prost::alloc::string::String,
}
/// A response message for \[UsageService.ExportReservationsUsage\].
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExportReservationsUsageResponse {
    /// The response message for the reservations usage export. In case of
    /// bigquery, it will also contain job id.
    #[prost(string, tag = "1")]
    pub response: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod usage_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Provides access to historical and forecasted usage data.
    #[derive(Debug, Clone)]
    pub struct UsageServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl UsageServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> UsageServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UsageServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            UsageServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns a list of the usage histories that are in the parent parameter
        /// and match your specified filters.
        pub async fn query_usage_histories(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryUsageHistoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryUsageHistoriesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.UsageService/QueryUsageHistories",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.UsageService",
                        "QueryUsageHistories",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of the forecasts that are in the parent parameter
        /// and match your specified filters.
        pub async fn query_forecasts(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryForecastsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryForecastsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.UsageService/QueryForecasts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.UsageService",
                        "QueryForecasts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of the reservations that are in the parent parameter
        /// and match your specified filters.
        pub async fn query_reservations(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryReservationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.UsageService/QueryReservations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.UsageService",
                        "QueryReservations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports historical usage data requested by user into either an existing
        /// Cloud Storage bucket or a BigQuery table.
        pub async fn export_usage_histories(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportUsageHistoriesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.UsageService/ExportUsageHistories",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.UsageService",
                        "ExportUsageHistories",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports forecasted usage data requested by user into either an existing
        /// Cloud Storage bucket or a BigQuery table.
        pub async fn export_forecasts(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportForecastsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.UsageService/ExportForecasts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.UsageService",
                        "ExportForecasts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports reservations usage data requested by user into either an existing
        /// Cloud Storage bucket or a new/existing BigQuery table.
        pub async fn export_reservations_usage(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportReservationsUsageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.capacityplanner.v1beta.UsageService/ExportReservationsUsage",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.capacityplanner.v1beta.UsageService",
                        "ExportReservationsUsage",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
