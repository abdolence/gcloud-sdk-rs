// This file is @generated by prost-build.
/// BigQueryDestination is a wrapper for BigQuery output information.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryDestination {
    /// Optional. BigQuery URI to a table, must be of the form
    /// bq://projectId.bqDatasetId.tableId.
    /// Note that the BigQuery dataset must already exist.
    /// VPC-SC restrictions apply.
    #[prost(string, tag = "1")]
    pub table_uri: ::prost::alloc::string::String,
    /// Required. Whether or not to overwrite destination table. By default the
    /// table won't be overwritten and an error will be returned if the table
    /// exists and contains data.
    #[prost(enumeration = "big_query_destination::WriteDisposition", tag = "2")]
    pub write_disposition: i32,
}
/// Nested message and enum types in `BigQueryDestination`.
pub mod big_query_destination {
    /// WriteDisposition controls the behavior when the destination table already
    /// exists.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WriteDisposition {
        /// Default behavior is the same as WRITE_EMPTY.
        Unspecified = 0,
        /// If the table already exists and contains data, an error is returned.
        WriteEmpty = 1,
        /// If the table already exists, the data will be overwritten.
        WriteTruncate = 2,
    }
    impl WriteDisposition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "WRITE_DISPOSITION_UNSPECIFIED",
                Self::WriteEmpty => "WRITE_EMPTY",
                Self::WriteTruncate => "WRITE_TRUNCATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WRITE_DISPOSITION_UNSPECIFIED" => Some(Self::Unspecified),
                "WRITE_EMPTY" => Some(Self::WriteEmpty),
                "WRITE_TRUNCATE" => Some(Self::WriteTruncate),
                _ => None,
            }
        }
    }
}
/// Indicate which LineOfBusiness a party belongs to.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LineOfBusiness {
    /// An unspecified LineOfBusiness. Do not use.
    Unspecified = 0,
    /// Commercial LineOfBusiness.
    Commercial = 1,
    /// Retail LineOfBusiness.
    Retail = 2,
}
impl LineOfBusiness {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "LINE_OF_BUSINESS_UNSPECIFIED",
            Self::Commercial => "COMMERCIAL",
            Self::Retail => "RETAIL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINE_OF_BUSINESS_UNSPECIFIED" => Some(Self::Unspecified),
            "COMMERCIAL" => Some(Self::Commercial),
            "RETAIL" => Some(Self::Retail),
            _ => None,
        }
    }
}
/// BacktestResult is created to test the performance of a model on a dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BacktestResult {
    /// Output only. The resource name of the BacktestResult.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/backtestResults/{backtest_result}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp of creation of this resource.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of the most recent update of this resource.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of the BacktestResult (creating, active, deleting, etc.)
    #[prost(enumeration = "backtest_result::State", tag = "5")]
    pub state: i32,
    /// Required. The resource name of the Dataset to backtest on
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
    #[prost(string, tag = "6")]
    pub dataset: ::prost::alloc::string::String,
    /// Required. The resource name of the Model to use or to backtest.
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/models/{model}"
    #[prost(string, tag = "7")]
    pub model: ::prost::alloc::string::String,
    /// Required. End_time specifies the latest time from which labels are used and
    /// from which data is used to generate features for backtesting.  End_time
    /// should be no later than the end of the date_range of the primary dataset.
    #[prost(message, optional, tag = "9")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The number of consecutive months to conduct backtesting for, ending with
    /// the last full month prior to the end_time according to the dataset's
    /// timezone.
    #[prost(int32, tag = "10")]
    pub backtest_periods: i32,
    /// Required. PerformanceTarget gives information on how the test will be
    /// evaluated.
    #[prost(message, optional, tag = "11")]
    pub performance_target: ::core::option::Option<backtest_result::PerformanceTarget>,
    /// Output only. The line of business (Retail/Commercial) this backtest is for.
    /// Determined by Model, cannot be set by user.
    #[prost(enumeration = "LineOfBusiness", tag = "12")]
    pub line_of_business: i32,
}
/// Nested message and enum types in `BacktestResult`.
pub mod backtest_result {
    /// PerformanceTarget gives hints on how to evaluate the performance of a
    /// model.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PerformanceTarget {
        /// Required. A number that gives the tuner a hint on the number of parties
        /// from this data that will be investigated per period (monthly). This is
        /// used to control how the model is evaluated. For example, when trying AML
        /// AI for the first time, we recommend setting this to the number of parties
        /// investigated in an average month, based on alerts from your existing
        /// automated alerting system.
        #[prost(int64, tag = "1")]
        pub party_investigations_per_period_hint: i64,
    }
    /// The possible states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified, should not occur.
        Unspecified = 0,
        /// The resource has not finished being created.
        Creating = 1,
        /// The resource is active/ready to be used.
        Active = 2,
        /// The resource is in the process of being updated.
        Updating = 3,
        /// The resource is in the process of being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of BacktestResult resources that
/// meet the specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBacktestResultsRequest {
    /// Required. The parent of the BacktestResult is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// In case of paginated results, this is the token that was returned in the
    /// previous ListBacktestResultsResponse. It should be copied here to
    /// retrieve the next page of resources. Empty will give the first page of
    /// ListBacktestResultsRequest, and the last page will return an empty
    /// page_token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Specify a filter to narrow search results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for retrieving a list of BacktestResults
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBacktestResultsResponse {
    /// List of BacktestResult resources
    #[prost(message, repeated, tag = "1")]
    pub backtest_results: ::prost::alloc::vec::Vec<BacktestResult>,
    /// This token should be passed to the next ListBacktestResultsRequest to
    /// retrieve the next page of BacktestResults (empty indicates we are
    /// done).
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific BacktestResult resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBacktestResultRequest {
    /// Required. The resource name of the BacktestResult
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for creating a BacktestResult resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBacktestResultRequest {
    /// Required. The parent of the BacktestResult is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource id of the BacktestResult
    #[prost(string, tag = "2")]
    pub backtest_result_id: ::prost::alloc::string::String,
    /// Required. The BacktestResult that will be created.
    #[prost(message, optional, tag = "3")]
    pub backtest_result: ::core::option::Option<BacktestResult>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for updating a BacktestResult
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBacktestResultRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// BacktestResult resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The new value of the BacktestResult fields that will be updated
    /// according to the update_mask.
    #[prost(message, optional, tag = "2")]
    pub backtest_result: ::core::option::Option<BacktestResult>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for deleting a BacktestResult.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBacktestResultRequest {
    /// Required. The resource name of the BacktestResult.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for exporting BacktestResult metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportBacktestResultMetadataRequest {
    /// Required. The resource name of the BacktestResult.
    #[prost(string, tag = "1")]
    pub backtest_result: ::prost::alloc::string::String,
    /// Required. BigQuery output where the metadata will be written.
    #[prost(message, optional, tag = "2")]
    pub structured_metadata_destination: ::core::option::Option<BigQueryDestination>,
}
/// Response for exporting BacktestResult metadata.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportBacktestResultMetadataResponse {}
/// The Dataset resource contains summary information about a dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
    /// Output only. The resource name of the Dataset.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp of creation of this resource.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of the most recent update of this resource.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. The set of BigQuery tables in the dataset.  The key should be the
    /// table type and the value should be the BigQuery tables in the format
    /// `bq://{project}.{dataset}.{table}`.
    /// Current table types are:
    ///
    ///    * `party`
    ///    * `account_party_link`
    ///    * `transaction`
    ///    * `risk_case_event`
    ///    * `party_supplementary_data`
    #[prost(map = "string, string", tag = "5")]
    pub table_specs: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of the dataset (creating, active, deleting, etc.)
    #[prost(enumeration = "dataset::State", tag = "7")]
    pub state: i32,
    /// Required. Core time window of the dataset. All tables should have complete
    /// data covering this period.
    #[prost(message, optional, tag = "8")]
    pub date_range: ::core::option::Option<super::super::super::r#type::Interval>,
    /// The timezone of the data, default will act as UTC.
    #[prost(message, optional, tag = "9")]
    pub time_zone: ::core::option::Option<super::super::super::r#type::TimeZone>,
}
/// Nested message and enum types in `Dataset`.
pub mod dataset {
    /// The possible states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified, should not occur.
        Unspecified = 0,
        /// The resource has not finished being created.
        Creating = 1,
        /// The resource is active/ready to be used.
        Active = 2,
        /// The resource is in the process of being updated.
        Updating = 3,
        /// The resource is in the process of being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of Dataset resources that meet the
/// specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsRequest {
    /// Required. The parent of the Dataset is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// In case of paginated results, this is the token that was returned in the
    /// previous ListDatasetResponse. It should be copied here to retrieve the
    /// next page of resources. Empty will give the first page of
    /// ListDatasetRequest, and the last page will return an empty page_token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Specify a filter to narrow search results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for retrieving a list of Datasets
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsResponse {
    /// List of Dataset resources
    #[prost(message, repeated, tag = "1")]
    pub datasets: ::prost::alloc::vec::Vec<Dataset>,
    /// This token should be passed to the next ListDatasetsRequest to retrieve
    /// the next page of Datasets (empty indicates we are done).
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific Dataset resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetRequest {
    /// Required. The resource name of the Dataset
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for creating a Dataset resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetRequest {
    /// Required. The parent of the Dataset is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource id of the dataset
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. The dataset that will be created.
    #[prost(message, optional, tag = "3")]
    pub dataset: ::core::option::Option<Dataset>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for updating a Dataset
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatasetRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Dataset resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The new value of the dataset fields that will be updated
    /// according to the update_mask.
    #[prost(message, optional, tag = "2")]
    pub dataset: ::core::option::Option<Dataset>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for deleting a Dataset.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetRequest {
    /// Required. The resource name of the Dataset.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// The EngineConfig resource creates the configuration for training a model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineConfig {
    /// Output only. The resource name of the EngineConfig.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineConfigs/{engine_config}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp of creation of this resource.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of the most recent update of this resource.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of the EngineConfig (creating, active, deleting, etc.)
    #[prost(enumeration = "engine_config::State", tag = "5")]
    pub state: i32,
    /// Required. The resource name of the EngineVersion used in this model tuning.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineVersions/{engine_version}"
    #[prost(string, tag = "6")]
    pub engine_version: ::prost::alloc::string::String,
    /// Optional. Configuration for tuning in creation of the EngineConfig.
    /// This field is required if `hyperparameter_source.type` is not `INHERITED`,
    /// and output-only otherwise.
    #[prost(message, optional, tag = "7")]
    pub tuning: ::core::option::Option<engine_config::Tuning>,
    /// Optional. PerformanceTarget gives information on how the tuning and
    /// training will be evaluated. This field is required if
    /// `hyperparameter_source.type` is not `INHERITED`, and output-only otherwise.
    #[prost(message, optional, tag = "11")]
    pub performance_target: ::core::option::Option<engine_config::PerformanceTarget>,
    /// Output only. The line of business (Retail/Commercial) this engine config is
    /// used for. Determined by EngineVersion, cannot be set by user.
    #[prost(enumeration = "LineOfBusiness", tag = "12")]
    pub line_of_business: i32,
    /// Optional. The origin of hyperparameters for the created EngineConfig. The
    /// default is `TUNING`. In this case, the hyperparameters are selected as a
    /// result of a
    ///   tuning run.
    #[prost(enumeration = "engine_config::HyperparameterSourceType", tag = "15")]
    pub hyperparameter_source_type: i32,
    /// Optional. Configuration of hyperparameters source EngineConfig.
    #[prost(message, optional, tag = "16")]
    pub hyperparameter_source: ::core::option::Option<
        engine_config::HyperparameterSource,
    >,
}
/// Nested message and enum types in `EngineConfig`.
pub mod engine_config {
    /// The parameters needed for the tuning operation, these are used only in
    /// tuning and not passed on to training.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Tuning {
        /// Required. The resource name of the Primary Dataset used in this model
        /// tuning. For information about how primary and auxiliary datasets are
        /// used, refer to the engine version's documentation.  Format:
        /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
        #[prost(string, tag = "1")]
        pub primary_dataset: ::prost::alloc::string::String,
        /// Required. End_time specifies the latest time from which labels are used
        /// and from which data is used to generate features for tuning.  End_time
        /// should be no later than the end of the date_range of the dataset.
        #[prost(message, optional, tag = "10")]
        pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    }
    /// PerformanceTarget gives hints on how to evaluate the performance of a
    /// model.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct PerformanceTarget {
        /// Required. A number that gives the tuner a hint on the number of parties
        /// from this data that will be investigated per period (monthly). This is
        /// used to control how the model is evaluated. For example, when trying AML
        /// AI for the first time, we recommend setting this to the number of parties
        /// investigated in an average month, based on alerts from your existing
        /// automated alerting system.
        #[prost(int64, tag = "1")]
        pub party_investigations_per_period_hint: i64,
    }
    /// Parameters for bootstrapping an Engine Config with the results of another
    /// one.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct HyperparameterSource {
        /// Required. The resource name of the source EngineConfig whose outputs are
        /// used. Format:
        /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineConfigs/{engine_config}"
        #[prost(string, tag = "1")]
        pub source_engine_config: ::prost::alloc::string::String,
        /// Output only. The resource name of the EngineVersion that was used in the
        /// tuning run. Format:
        /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineVersions/{engine_version}"
        #[prost(string, tag = "2")]
        pub source_engine_version: ::prost::alloc::string::String,
    }
    /// The possible states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified, should not occur.
        Unspecified = 0,
        /// The resource has not finished being created.
        Creating = 1,
        /// The resource is active/ready to be used.
        Active = 2,
        /// The resource is in the process of being updated.
        Updating = 3,
        /// The resource is in the process of being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
    /// The type of the hyperparameter source.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HyperparameterSourceType {
        /// Hyperparameter source type is unspecified, defaults to TUNING.
        Unspecified = 0,
        /// The EngineConfig creation starts a tuning job which selects the best
        /// hyperparameters.
        Tuning = 1,
        /// The hyperparameters are inherited from another EngineConfig.
        Inherited = 2,
    }
    impl HyperparameterSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "HYPERPARAMETER_SOURCE_TYPE_UNSPECIFIED",
                Self::Tuning => "TUNING",
                Self::Inherited => "INHERITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HYPERPARAMETER_SOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TUNING" => Some(Self::Tuning),
                "INHERITED" => Some(Self::Inherited),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of EngineConfig resources that
/// meet the specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEngineConfigsRequest {
    /// Required. The parent of the EngineConfig is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// In case of paginated results, this is the token that was returned in the
    /// previous ListEngineConfigsResponse. It should be copied here to retrieve
    /// the next page of resources. Empty will give the first page of
    /// ListEngineConfigsRequest, and the last page will return an empty
    /// page_token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Specify a filter to narrow search results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for retrieving a list of EngineConfigs
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEngineConfigsResponse {
    /// List of EngineConfig resources
    #[prost(message, repeated, tag = "1")]
    pub engine_configs: ::prost::alloc::vec::Vec<EngineConfig>,
    /// This token should be passed to the next ListEngineConfigsRequest to
    /// retrieve the next page of EngineConfigs (empty indicates we are done).
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific EngineConfig resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEngineConfigRequest {
    /// Required. The resource name of the EngineConfig
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for creating an EngineConfig resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEngineConfigRequest {
    /// Required. The parent of the EngineConfig is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource id of the EngineConfig
    #[prost(string, tag = "2")]
    pub engine_config_id: ::prost::alloc::string::String,
    /// Required. The EngineConfig that will be created.
    #[prost(message, optional, tag = "3")]
    pub engine_config: ::core::option::Option<EngineConfig>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for updating an EngineConfig
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEngineConfigRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// EngineConfig resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The new value of the EngineConfig fields that will be updated
    /// according to the update_mask.
    #[prost(message, optional, tag = "2")]
    pub engine_config: ::core::option::Option<EngineConfig>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for deleting an EngineConfig.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEngineConfigRequest {
    /// Required. The resource name of the EngineConfig.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for exporting EngineConfig metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportEngineConfigMetadataRequest {
    /// Required. The resource name of the EngineConfig.
    #[prost(string, tag = "1")]
    pub engine_config: ::prost::alloc::string::String,
    /// Required. BigQuery output where the metadata will be written.
    #[prost(message, optional, tag = "2")]
    pub structured_metadata_destination: ::core::option::Option<BigQueryDestination>,
}
/// Response for exporting EngineConfig metadata.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportEngineConfigMetadataResponse {}
/// EngineVersion controls which version of the engine is used to tune, train,
/// and run the model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EngineVersion {
    /// Output only. Identifier. The resource name of the EngineVersion
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineVersions/{engine_version}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The state of the version.
    #[prost(enumeration = "engine_version::State", tag = "2")]
    pub state: i32,
    /// Output only. Planned time to stop allowing training/tuning using this
    /// version. Existing trained models can still be used for prediction/backtest.
    #[prost(message, optional, tag = "3")]
    pub expected_limitation_start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Planned time to stop supporting the version, in addition
    /// to no training or tuning, models trained on this version
    /// can no longer be used for prediction/backtest.
    #[prost(message, optional, tag = "4")]
    pub expected_decommission_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The line of business (Retail/Commercial) this engine version
    /// is used for.
    #[prost(enumeration = "LineOfBusiness", tag = "5")]
    pub line_of_business: i32,
}
/// Nested message and enum types in `EngineVersion`.
pub mod engine_version {
    /// State determines the lifecycle of a version and the models/engine configs
    /// trained with it.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Default state, should never be used.
        Unspecified = 0,
        /// Version is available for training and inference.
        Active = 1,
        /// Models using this version can still be run, but new ones cannot be
        /// trained.
        Limited = 2,
        /// Version is deprecated, listed for informational purposes only.
        Decommissioned = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Active => "ACTIVE",
                Self::Limited => "LIMITED",
                Self::Decommissioned => "DECOMMISSIONED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "LIMITED" => Some(Self::Limited),
                "DECOMMISSIONED" => Some(Self::Decommissioned),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of EngineVersion resources that meet
/// the specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEngineVersionsRequest {
    /// Required. The parent of the EngineVersion is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The number of resources to be included in the response. The
    /// response contains a next_page_token, which can be used to retrieve the next
    /// page of resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. In case of paginated results, this is the token that was returned
    /// in the previous ListEngineVersionsResponse. It should be copied here to
    /// retrieve the next page of resources. Empty will give the first page of
    /// ListEngineVersionsRequest, and the last page will return an empty
    /// page_token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Specify a filter to narrow search results.
    /// If empty or unset will default to "state!=DEPRECATED",
    /// to view deprecated versions use "state:*" or any other filter.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// The response to a list call containing the list of engine versions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEngineVersionsResponse {
    /// List of EngineVersion resources
    #[prost(message, repeated, tag = "1")]
    pub engine_versions: ::prost::alloc::vec::Vec<EngineVersion>,
    /// This token should be passed to the next EngineVersionsRequest to retrieve
    /// the next page of EngineVersions (empty indicates we are done).
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific EngineVersion resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEngineVersionRequest {
    /// Required. The resource name of the EngineVersion
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Instance is a container for the rest of API resources.
/// Only resources in the same instance can interact with each other.
/// Child resources inherit the location (data residency) and encryption (CMEK).
/// The location of the provided input and output in requests must match the
/// location of the instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    /// Output only. The full path to the Instance resource in this API.
    /// format: "projects/{project}/locations/{location}/instances/{instance}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. Timestamp when the Instance was created.
    /// Assigned by the server.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp when the Instance was last updated.
    /// Assigned by the server.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. State of the instance.
    /// Assigned by the server.
    #[prost(enumeration = "instance::State", tag = "4")]
    pub state: i32,
    /// Labels
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Required. The KMS key name used for CMEK (encryption-at-rest).
    /// format:
    /// "projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}"
    /// VPC-SC restrictions apply.
    #[prost(string, tag = "6")]
    pub kms_key: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
    /// The Resource State
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified, should not occur.
        Unspecified = 0,
        /// The resource has not finished being created.
        Creating = 1,
        /// The resource is active/ready to be used.
        Active = 2,
        /// The resource is in the process of being updated.
        Updating = 3,
        /// The resource is in the process of being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of Instance resources that meet the
/// specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    /// Required. The parent of the Instance is the location for that Instance.
    /// Every location has exactly one instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// In case of paginated results, this is the token that was returned in the
    /// previous ListInstancesResponse. It should be copied here to retrieve the
    /// next page of resources. This will be empty for the first instance of
    /// ListInstancesRequest.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Specify a filter to narrow search results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for retrieving a list of Instances
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesResponse {
    /// List of Instance resources
    #[prost(message, repeated, tag = "1")]
    pub instances: ::prost::alloc::vec::Vec<Instance>,
    /// This token should be passed to the next ListInstancesRequest to retrieve
    /// the next page of Instances.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific Instance resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    /// Required. The resource name of the Instance.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for creating a Instance resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstanceRequest {
    /// Required. The parent of the Instance is the location for that Instance.
    /// Every location has exactly one instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource id of the instance.
    #[prost(string, tag = "2")]
    pub instance_id: ::prost::alloc::string::String,
    /// Required. The instance that will be created.
    #[prost(message, optional, tag = "3")]
    pub instance: ::core::option::Option<Instance>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for updating a Instance
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Instance resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The new value of the instance fields that will be updated
    /// according to the update_mask
    #[prost(message, optional, tag = "2")]
    pub instance: ::core::option::Option<Instance>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for deleting a Instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
    /// Required. The resource name of the Instance.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for adding/removing registered parties from BigQuery tables
/// specified by the customer.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportRegisteredPartiesRequest {
    /// Required. The full path to the Instance resource in this API.
    /// format: "projects/{project}/locations/{location}/instances/{instance}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. List of BigQuery tables. Union of tables will be taken if there
    /// is more than one table. VPC-SC restrictions apply. format:
    /// "bq://{project}.{bqDatasetID}.{bqTableID}" Use of `datasets` is preferred
    /// over the latter due to its simplicity and the reduced risk of errors
    /// `party_tables` and `datasets` must not be provided at the
    /// same time
    #[prost(string, repeated, tag = "2")]
    pub party_tables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Required. Mode of the request.
    #[prost(enumeration = "import_registered_parties_request::UpdateMode", tag = "3")]
    pub mode: i32,
    /// Optional. Is the request will not register the parties, just determine what
    /// woud happen.
    #[prost(bool, tag = "4")]
    pub validate_only: bool,
    /// Required. LineOfBusiness for the specified registered parties.
    #[prost(enumeration = "LineOfBusiness", tag = "5")]
    pub line_of_business: i32,
}
/// Nested message and enum types in `ImportRegisteredPartiesRequest`.
pub mod import_registered_parties_request {
    /// UpdateMode controls the behavior for ImportRegisteredParties.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UpdateMode {
        /// Default mode.
        Unspecified = 0,
        /// Replace parties that are removable in Parties Table with new parties.
        Replace = 1,
        /// Add new parties to Parties Table.
        Append = 2,
    }
    impl UpdateMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UPDATE_MODE_UNSPECIFIED",
                Self::Replace => "REPLACE",
                Self::Append => "APPEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UPDATE_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "REPLACE" => Some(Self::Replace),
                "APPEND" => Some(Self::Append),
                _ => None,
            }
        }
    }
}
/// Response for adding/removing registered parties from BigQuery tables.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImportRegisteredPartiesResponse {
    /// Number of parties added by this operation.
    #[prost(int64, tag = "1")]
    pub parties_added: i64,
    /// Number of parties removed by this operation.
    #[prost(int64, tag = "2")]
    pub parties_removed: i64,
    /// Total number of parties that are registered in this instance, after the
    /// update operation was completed.
    #[prost(int64, tag = "3")]
    pub parties_total: i64,
    /// Number of parties that failed to be removed by this operation.
    #[prost(int64, tag = "4")]
    pub parties_failed_to_remove: i64,
    #[prost(int64, tag = "5")]
    pub parties_uptiered: i64,
    /// Total number of parties that are downtiered in this instance
    #[prost(int64, tag = "6")]
    pub parties_downtiered: i64,
    /// Number of parties that failed to be downtiered
    #[prost(int64, tag = "7")]
    pub parties_failed_to_downtier: i64,
}
/// Request to export a list of currently registered parties.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportRegisteredPartiesRequest {
    /// Required. The full path to the Instance resource in this API.
    /// format: "projects/{project}/locations/{location}/instances/{instance}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. The location to output the RegisteredParties.
    #[prost(message, optional, tag = "2")]
    pub dataset: ::core::option::Option<BigQueryDestination>,
    /// Required. LineOfBusiness to get RegisteredParties from.
    #[prost(enumeration = "LineOfBusiness", tag = "3")]
    pub line_of_business: i32,
}
/// Response to export registered parties request.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportRegisteredPartiesResponse {}
/// Model represents a trained model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Model {
    /// Output only. The resource name of the Model.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/models/{model}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp of creation of this resource.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of the most recent update of this resource.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of the model (creating, active, deleting, etc.)
    #[prost(enumeration = "model::State", tag = "5")]
    pub state: i32,
    /// Output only. The EngineVersion used in training this model.  This is output
    /// only, and is determined from the EngineConfig used.
    #[prost(string, tag = "6")]
    pub engine_version: ::prost::alloc::string::String,
    /// Required. The resource name of the EngineConfig the model training will be
    /// based on. Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineConfigs/{engineConfig}"
    #[prost(string, tag = "7")]
    pub engine_config: ::prost::alloc::string::String,
    /// Required. The resource name of the Primary Dataset used in this model
    /// training. For information about how primary and auxiliary datasets are
    /// used, refer to the engine version's documentation.  Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
    #[prost(string, tag = "8")]
    pub primary_dataset: ::prost::alloc::string::String,
    /// Required. End_time specifies the latest time from which labels are used and
    /// from which data is used to generate features for training.  End_time should
    /// be no later than the end of the date_range of the dataset.
    #[prost(message, optional, tag = "10")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The line of business (Retail/Commercial) this model is used
    /// for. Determined by EngineConfig, cannot be set by user.
    #[prost(enumeration = "LineOfBusiness", tag = "12")]
    pub line_of_business: i32,
}
/// Nested message and enum types in `Model`.
pub mod model {
    /// The possible states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified, should not occur.
        Unspecified = 0,
        /// The resource has not finished being created.
        Creating = 1,
        /// The resource is active/ready to be used.
        Active = 2,
        /// The resource is in the process of being updated.
        Updating = 3,
        /// The resource is in the process of being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of Model resources that meet the
/// specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsRequest {
    /// Required. The parent of the Model is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// In case of paginated results, this is the token that was returned in the
    /// previous ListModelsResponse. It should be copied here to retrieve the next
    /// page of resources. Empty will give the first page of ListModelsRequest, and
    /// the last page will return an empty page_token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Specify a filter to narrow search results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for retrieving a list of Models
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListModelsResponse {
    /// List of Model resources
    #[prost(message, repeated, tag = "1")]
    pub models: ::prost::alloc::vec::Vec<Model>,
    /// This token should be passed to the next ListModelsRequest to
    /// retrieve the next page of Models (empty indicicates we are done).
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific Model resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetModelRequest {
    /// Required. The resource name of the Model
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for creating a Model resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateModelRequest {
    /// Required. The parent of the Model is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource id of the Model
    #[prost(string, tag = "2")]
    pub model_id: ::prost::alloc::string::String,
    /// Required. The Model that will be created.
    #[prost(message, optional, tag = "3")]
    pub model: ::core::option::Option<Model>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for updating a Model
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateModelRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Model resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The new value of the Model fields that will be updated according
    /// to the update_mask.
    #[prost(message, optional, tag = "2")]
    pub model: ::core::option::Option<Model>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for deleting a Model.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteModelRequest {
    /// Required. The resource name of the Model.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for exporting Model metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportModelMetadataRequest {
    /// Required. The resource name of the Model.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. BigQuery output where the metadata will be written.
    #[prost(message, optional, tag = "2")]
    pub structured_metadata_destination: ::core::option::Option<BigQueryDestination>,
}
/// Response for exporting Model metadata.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportModelMetadataResponse {}
/// PredictionResult is the result of using a model to create predictions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PredictionResult {
    /// Output only. The resource name of the PredictionResult.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/predictionResults/{prediction_result}"
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Output only. The timestamp of creation of this resource.
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The timestamp of the most recent update of this resource.
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Labels
    #[prost(map = "string, string", tag = "4")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. State of the PredictionResult (creating, active, deleting,
    /// etc.)
    #[prost(enumeration = "prediction_result::State", tag = "5")]
    pub state: i32,
    /// Required. The resource name of the Dataset to do predictions on
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/dataset/{dataset_id}"
    #[prost(string, tag = "6")]
    pub dataset: ::prost::alloc::string::String,
    /// Required. The resource name of the Model to use to use to make predictions
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/models/{model}"
    #[prost(string, tag = "7")]
    pub model: ::prost::alloc::string::String,
    /// Required. Specifies the latest time from which data is used to generate
    /// features for predictions.  This time should be no later than the end of the
    /// [date_range][google.cloud.financialservices.v1.Dataset.date_range] of the
    /// dataset.
    #[prost(message, optional, tag = "9")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The number of consecutive months to produce predictions for, ending with
    /// the last full month prior to
    /// [end_time][google.cloud.financialservices.v1.PredictionResult.end_time]
    /// according to the dataset's timezone.
    #[prost(int32, tag = "10")]
    pub prediction_periods: i32,
    /// Required. Where to write the output of the predictions.
    #[prost(message, optional, tag = "11")]
    pub outputs: ::core::option::Option<prediction_result::Outputs>,
    /// Output only. The line of business (Retail/Commercial) this prediction is
    /// for. Determined by Model, cannot be set by user.
    #[prost(enumeration = "LineOfBusiness", tag = "12")]
    pub line_of_business: i32,
}
/// Nested message and enum types in `PredictionResult`.
pub mod prediction_result {
    /// Outputs is a list of places where the operation will write results.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Outputs {
        /// Required. The location to output the predictions.
        #[prost(message, optional, tag = "1")]
        pub prediction_destination: ::core::option::Option<super::BigQueryDestination>,
        /// The location to output explainability information.  If not specified
        /// no explainability data will be output.
        #[prost(message, optional, tag = "2")]
        pub explainability_destination: ::core::option::Option<
            super::BigQueryDestination,
        >,
    }
    /// The possible states of a resource.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// State is unspecified, should not occur.
        Unspecified = 0,
        /// The resource has not finished being created.
        Creating = 1,
        /// The resource is active/ready to be used.
        Active = 2,
        /// The resource is in the process of being updated.
        Updating = 3,
        /// The resource is in the process of being deleted.
        Deleting = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATE_UNSPECIFIED",
                Self::Creating => "CREATING",
                Self::Active => "ACTIVE",
                Self::Updating => "UPDATING",
                Self::Deleting => "DELETING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATING" => Some(Self::Creating),
                "ACTIVE" => Some(Self::Active),
                "UPDATING" => Some(Self::Updating),
                "DELETING" => Some(Self::Deleting),
                _ => None,
            }
        }
    }
}
/// Request for retrieving a paginated list of PredictionResult resources that
/// meet the specified criteria.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPredictionResultsRequest {
    /// Required. The parent of the PredictionResult is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// In case of paginated results, this is the token that was returned in the
    /// previous ListPredictionResultsResponse. It should be copied here to
    /// retrieve the next page of resources. Empty will give the first page of
    /// ListPredictionResultsRequest, and the last page will return an empty
    /// page_token.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Specify a filter to narrow search results.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Specify a field to use for ordering.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
/// Response for retrieving a list of PredictionResults
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPredictionResultsResponse {
    /// List of PredictionResult resources
    #[prost(message, repeated, tag = "1")]
    pub prediction_results: ::prost::alloc::vec::Vec<PredictionResult>,
    /// This token should be passed to the next ListPredictionResultsRequest to
    /// retrieve the next page of PredictionResults (empty indicicates we are
    /// done).
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request for retrieving a specific PredictionResult resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPredictionResultRequest {
    /// Required. The resource name of the PredictionResult
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for creating a PredictionResult resource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePredictionResultRequest {
    /// Required. The parent of the PredictionResult is the Instance.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Required. The resource id of the PredictionResult
    #[prost(string, tag = "2")]
    pub prediction_result_id: ::prost::alloc::string::String,
    /// Required. The PredictionResult that will be created.
    #[prost(message, optional, tag = "3")]
    pub prediction_result: ::core::option::Option<PredictionResult>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for updating a PredictionResult
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePredictionResultRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// PredictionResult resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The new value of the PredictionResult fields that will be updated
    /// according to the update_mask.
    #[prost(message, optional, tag = "2")]
    pub prediction_result: ::core::option::Option<PredictionResult>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for deleting a PredictionResult.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePredictionResultRequest {
    /// Required. The resource name of the PredictionResult.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for exporting PredictionResult metadata.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportPredictionResultMetadataRequest {
    /// Required. The resource name of the PredictionResult.
    #[prost(string, tag = "1")]
    pub prediction_result: ::prost::alloc::string::String,
    /// Required. BigQuery output where the metadata will be written.
    #[prost(message, optional, tag = "2")]
    pub structured_metadata_destination: ::core::option::Option<BigQueryDestination>,
}
/// Response for exporting PredictionResult metadata.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportPredictionResultMetadataResponse {}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    /// format: "/projects/{project}/..."
    /// VPC-SC restrictions apply.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation of the
    /// operation.
    ///
    /// Successfully cancelled operations have a
    /// [google.longrunning.Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod aml_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The AML (Anti Money Laundering) service allows users to perform REST
    /// operations on aml.
    #[derive(Debug, Clone)]
    pub struct AmlClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AmlClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AmlClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AmlClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AmlClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists instances.
        pub async fn list_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListInstancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an instance.
        pub async fn get_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Instance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "GetInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instance.
        pub async fn create_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/CreateInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "CreateInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Instance.
        pub async fn update_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/UpdateInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "UpdateInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an instance.
        pub async fn delete_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/DeleteInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "DeleteInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Imports the list of registered parties. See
        /// [Create and manage
        /// instances](https://cloud.google.com/financial-services/anti-money-laundering/docs/create-and-manage-instances#import-registered-parties)
        /// for information on the input schema and response for this method.
        pub async fn import_registered_parties(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportRegisteredPartiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ImportRegisteredParties",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ImportRegisteredParties",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports the list of registered parties. See
        /// [Create and manage
        /// instances](https://cloud.google.com/financial-services/anti-money-laundering/docs/create-and-manage-instances#export-registered-parties)
        /// for information on the output schema for this method.
        pub async fn export_registered_parties(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportRegisteredPartiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ExportRegisteredParties",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ExportRegisteredParties",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists datasets.
        pub async fn list_datasets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDatasetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDatasetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListDatasets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListDatasets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a dataset.
        pub async fn get_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "GetDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a dataset.
        pub async fn create_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/CreateDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "CreateDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Dataset.
        pub async fn update_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/UpdateDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "UpdateDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a dataset.
        pub async fn delete_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDatasetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/DeleteDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "DeleteDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists models.
        pub async fn list_models(
            &mut self,
            request: impl tonic::IntoRequest<super::ListModelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListModelsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListModels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListModels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a model.
        pub async fn get_model(
            &mut self,
            request: impl tonic::IntoRequest<super::GetModelRequest>,
        ) -> std::result::Result<tonic::Response<super::Model>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.financialservices.v1.AML", "GetModel"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a model.
        pub async fn create_model(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/CreateModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "CreateModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single Model.
        pub async fn update_model(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/UpdateModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "UpdateModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export governance information for a Model resource. For
        /// information on the exported fields, see
        /// [AML output data
        /// model](https://cloud.google.com/financial-services/anti-money-laundering/docs/reference/schemas/aml-output-data-model#model).
        pub async fn export_model_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportModelMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ExportModelMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ExportModelMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a model.
        pub async fn delete_model(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteModelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/DeleteModel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "DeleteModel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists engine configs.
        pub async fn list_engine_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEngineConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEngineConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListEngineConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListEngineConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an engine config.
        pub async fn get_engine_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEngineConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::EngineConfig>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetEngineConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "GetEngineConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an engine config.
        pub async fn create_engine_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEngineConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/CreateEngineConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "CreateEngineConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single EngineConfig.
        pub async fn update_engine_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEngineConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/UpdateEngineConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "UpdateEngineConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export governance information for an EngineConfig resource. For
        /// information on the exported fields, see
        /// [AML output data
        /// model](https://cloud.google.com/financial-services/anti-money-laundering/docs/reference/schemas/aml-output-data-model#engine-config).
        pub async fn export_engine_config_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportEngineConfigMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ExportEngineConfigMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ExportEngineConfigMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an engine config.
        pub async fn delete_engine_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEngineConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/DeleteEngineConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "DeleteEngineConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a single EngineVersion.
        pub async fn get_engine_version(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEngineVersionRequest>,
        ) -> std::result::Result<tonic::Response<super::EngineVersion>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetEngineVersion",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "GetEngineVersion",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EngineVersions for given location.
        pub async fn list_engine_versions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEngineVersionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEngineVersionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListEngineVersions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListEngineVersions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List PredictionResults.
        pub async fn list_prediction_results(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPredictionResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPredictionResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListPredictionResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListPredictionResults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a PredictionResult.
        pub async fn get_prediction_result(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPredictionResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PredictionResult>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetPredictionResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "GetPredictionResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a PredictionResult.
        pub async fn create_prediction_result(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePredictionResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/CreatePredictionResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "CreatePredictionResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single PredictionResult.
        pub async fn update_prediction_result(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePredictionResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/UpdatePredictionResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "UpdatePredictionResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export governance information for a PredictionResult resource. For
        /// information on the exported fields, see
        /// [AML output data
        /// model](https://cloud.google.com/financial-services/anti-money-laundering/docs/reference/schemas/aml-output-data-model#prediction-results).
        pub async fn export_prediction_result_metadata(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ExportPredictionResultMetadataRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ExportPredictionResultMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ExportPredictionResultMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a PredictionResult.
        pub async fn delete_prediction_result(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePredictionResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/DeletePredictionResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "DeletePredictionResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List BacktestResults.
        pub async fn list_backtest_results(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBacktestResultsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBacktestResultsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ListBacktestResults",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ListBacktestResults",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a BacktestResult.
        pub async fn get_backtest_result(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBacktestResultRequest>,
        ) -> std::result::Result<tonic::Response<super::BacktestResult>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/GetBacktestResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "GetBacktestResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a BacktestResult.
        pub async fn create_backtest_result(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBacktestResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/CreateBacktestResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "CreateBacktestResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single BacktestResult.
        pub async fn update_backtest_result(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBacktestResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/UpdateBacktestResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "UpdateBacktestResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export governance information for a BacktestResult resource. For
        /// information on the exported fields, see
        /// [AML output data
        /// model](https://cloud.google.com/financial-services/anti-money-laundering/docs/reference/schemas/aml-output-data-model#backtest-results).
        pub async fn export_backtest_result_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportBacktestResultMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/ExportBacktestResultMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "ExportBacktestResultMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a BacktestResult.
        pub async fn delete_backtest_result(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBacktestResultRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.financialservices.v1.AML/DeleteBacktestResult",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.financialservices.v1.AML",
                        "DeleteBacktestResult",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
