// This file is @generated by prost-build.
/// Represents different forms of credential specification.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Credentials {
    /// The kind of credentials.
    /// }
    #[prost(oneof = "credentials::Kind", tags = "1")]
    pub kind: ::core::option::Option<credentials::Kind>,
}
/// Nested message and enum types in `Credentials`.
pub mod credentials {
    /// The kind of credentials.
    /// }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// OAuth credentials.
        #[prost(message, tag = "1")]
        Oauth(super::OAuthCredentials),
    }
}
/// Represents OAuth credentials.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OAuthCredentials {
    /// The kind of OAuth credentials.
    #[prost(oneof = "o_auth_credentials::Kind", tags = "2, 3")]
    pub kind: ::core::option::Option<o_auth_credentials::Kind>,
}
/// Nested message and enum types in `OAuthCredentials`.
pub mod o_auth_credentials {
    /// The name of the secret containing the access token.
    /// Represents secret-based OAuth credentials.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SecretBased {
        /// Required. An OAuth client ID.
        #[prost(string, tag = "2")]
        pub client_id: ::prost::alloc::string::String,
        /// Required. An OAuth client secret.
        #[prost(string, tag = "3")]
        pub client_secret: ::prost::alloc::string::String,
    }
    /// Read more about Looker access tokens here:
    /// <https://developers.looker.com/api/advanced-usage/looker-api-oauth>
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TokenBased {
        /// Required. The name of the secret containing the access token.
        #[prost(string, tag = "1")]
        pub access_token: ::prost::alloc::string::String,
    }
    /// The kind of OAuth credentials.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Secret-based OAuth credentials.
        #[prost(message, tag = "2")]
        Secret(SecretBased),
        /// Token-based OAuth credentials.
        #[prost(message, tag = "3")]
        Token(TokenBased),
    }
}
/// A collection of references to datasources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DatasourceReferences {
    /// The datasources to use.
    #[prost(oneof = "datasource_references::References", tags = "1, 2, 3")]
    pub references: ::core::option::Option<datasource_references::References>,
}
/// Nested message and enum types in `DatasourceReferences`.
pub mod datasource_references {
    /// The datasources to use.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum References {
        /// References to BigQuery tables.
        #[prost(message, tag = "1")]
        Bq(super::BigQueryTableReferences),
        /// References to LookerStudio datasources.
        #[prost(message, tag = "2")]
        Studio(super::StudioDatasourceReferences),
        /// References to Looker explores.
        #[prost(message, tag = "3")]
        Looker(super::LookerExploreReferences),
    }
}
/// Message representing references to BigQuery tables.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryTableReferences {
    /// Required. References to BigQuery tables.
    #[prost(message, repeated, tag = "1")]
    pub table_references: ::prost::alloc::vec::Vec<BigQueryTableReference>,
}
/// Message representing a reference to a single BigQuery table.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryTableReference {
    /// Required. The project the table belongs to.
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The dataset the table belongs to.
    #[prost(string, tag = "3")]
    pub dataset_id: ::prost::alloc::string::String,
    /// Required. The table id.
    #[prost(string, tag = "4")]
    pub table_id: ::prost::alloc::string::String,
}
/// Message representing references to LookerStudio datasources.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StudioDatasourceReferences {
    /// The references to the studio datasources.
    #[prost(message, repeated, tag = "2")]
    pub studio_references: ::prost::alloc::vec::Vec<StudioDatasourceReference>,
}
/// Message representing a reference to a single LookerStudio datasource.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StudioDatasourceReference {
    /// Required. The id of the datasource.
    #[prost(string, tag = "1")]
    pub datasource_id: ::prost::alloc::string::String,
}
/// Message representing references to Looker explores.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookerExploreReferences {
    /// Required. References to Looker explores.
    #[prost(message, repeated, tag = "1")]
    pub explore_references: ::prost::alloc::vec::Vec<LookerExploreReference>,
    /// Optional. The credentials to use when calling the Looker API.
    ///
    /// Currently supports both oauth token and api keys based credentials, as
    /// described in
    /// <https://cloud.google.com/looker/docs/api-auth#authentication_with_an_sdk>
    #[prost(message, optional, tag = "2")]
    pub credentials: ::core::option::Option<Credentials>,
}
/// Message representing a reference to a single Looker explore.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookerExploreReference {
    /// Required. Looker Model as outlined in
    /// <https://cloud.google.com/looker/docs/lookml-terms-and-concepts#major_lookml_structures>
    /// Name of LookML model.
    #[prost(string, tag = "4")]
    pub lookml_model: ::prost::alloc::string::String,
    /// Required. Looker Explore as outlined in
    /// <https://cloud.google.com/looker/docs/lookml-terms-and-concepts#major_lookml_structures>
    /// Name of LookML explore.
    #[prost(string, tag = "5")]
    pub explore: ::prost::alloc::string::String,
    /// Optional. The schema of the datasource.
    #[prost(message, optional, tag = "8")]
    pub schema: ::core::option::Option<Schema>,
    /// The instance of the Looker explore.
    #[prost(oneof = "looker_explore_reference::Instance", tags = "9, 10")]
    pub instance: ::core::option::Option<looker_explore_reference::Instance>,
}
/// Nested message and enum types in `LookerExploreReference`.
pub mod looker_explore_reference {
    /// The instance of the Looker explore.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Instance {
        /// Required. The base url of the Looker instance.
        #[prost(string, tag = "9")]
        LookerInstanceUri(::prost::alloc::string::String),
        /// Private Looker instance info.
        #[prost(message, tag = "10")]
        PrivateLookerInstanceInfo(super::PrivateLookerInstanceInfo),
    }
}
/// Message representing a private Looker instance info required if the Looker
/// instance is behind a private network.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrivateLookerInstanceInfo {
    /// The Looker instance id.
    #[prost(string, tag = "1")]
    pub looker_instance_id: ::prost::alloc::string::String,
    /// The service directory name of the Looker instance.
    #[prost(string, tag = "2")]
    pub service_directory_name: ::prost::alloc::string::String,
}
/// A datasource that can be used to answer questions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Datasource {
    /// Optional. The schema of the datasource.
    #[prost(message, optional, tag = "7")]
    pub schema: ::core::option::Option<Schema>,
    /// The reference to the datasource.
    #[prost(oneof = "datasource::Reference", tags = "1, 2, 4")]
    pub reference: ::core::option::Option<datasource::Reference>,
}
/// Nested message and enum types in `Datasource`.
pub mod datasource {
    /// The reference to the datasource.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Reference {
        /// A reference to a BigQuery table.
        #[prost(message, tag = "1")]
        BigqueryTableReference(super::BigQueryTableReference),
        /// A reference to a LookerStudio datasource.
        #[prost(string, tag = "2")]
        StudioDatasourceId(::prost::alloc::string::String),
        /// A reference to a Looker explore.
        #[prost(message, tag = "4")]
        LookerExploreReference(super::LookerExploreReference),
    }
}
/// The schema of a Datasource or QueryResult instance.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// Optional. The fields in the schema.
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<Field>,
    /// Optional. Table display_name (same as label in
    /// cloud/data_analytics/anarres/data/looker/proto/model_explore.proto), not
    /// required, currently only Looker has this field.
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
}
/// A field in a schema.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    /// Optional. The name of the field.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The type of the field.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// Optional. A brief description of the field.
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Optional. The mode of the field (e.g., NULLABLE, REPEATED).
    #[prost(string, tag = "4")]
    pub mode: ::prost::alloc::string::String,
    /// Optional. Field display_name (same as label in
    #[prost(string, tag = "8")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Recursive property for nested schema structures.
    #[prost(message, repeated, tag = "9")]
    pub subfields: ::prost::alloc::vec::Vec<Field>,
    /// Optional. Field category, not required, currently only useful for Looker.
    /// We are using a string to avoid depending on an external package and keep
    /// this package self-contained.
    #[prost(string, tag = "10")]
    pub category: ::prost::alloc::string::String,
}
/// A collection of context to apply to this conversation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Context {
    /// Optional. The basic entry point for data owners creating domain knowledge
    /// for Agent.
    ///
    /// Why: Business jargon (e.g., YTD revenue is calculated asâ€¦, Retirement Age
    /// is 65 in the USA, etc) and system instructions (e.g., answer like a Pirate)
    /// can help the model understand the business context around a user question.
    #[prost(string, tag = "1")]
    pub system_instruction: ::prost::alloc::string::String,
    /// Required. Datasources available for answering the question.
    #[prost(message, optional, tag = "7")]
    pub datasource_references: ::core::option::Option<DatasourceReferences>,
    /// Optional. Additional options for the conversation.
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<ConversationOptions>,
}
/// Options for the conversation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversationOptions {
    /// Optional. Options for chart generation.
    #[prost(message, optional, tag = "1")]
    pub chart: ::core::option::Option<ChartOptions>,
    /// Optional. Options for analysis.
    #[prost(message, optional, tag = "2")]
    pub analysis: ::core::option::Option<AnalysisOptions>,
}
/// Options for chart generation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChartOptions {
    /// Optional. When specified, the agent will render generated charts using the
    /// provided format. Defaults to no image.
    #[prost(message, optional, tag = "1")]
    pub image: ::core::option::Option<chart_options::ImageOptions>,
}
/// Nested message and enum types in `ChartOptions`.
pub mod chart_options {
    /// Options for rendering images of generated charts.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ImageOptions {
        /// The kind of image to render.
        #[prost(oneof = "image_options::Kind", tags = "1, 2")]
        pub kind: ::core::option::Option<image_options::Kind>,
    }
    /// Nested message and enum types in `ImageOptions`.
    pub mod image_options {
        /// No image.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct NoImage {}
        /// SVG options.
        #[derive(Clone, Copy, PartialEq, ::prost::Message)]
        pub struct SvgOptions {}
        /// The kind of image to render.
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum Kind {
            /// No image.
            #[prost(message, tag = "1")]
            NoImage(NoImage),
            /// SVG format.
            #[prost(message, tag = "2")]
            Svg(SvgOptions),
        }
    }
}
/// Options for analysis.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AnalysisOptions {
    /// Optional. Options for Python analysis.
    #[prost(message, optional, tag = "1")]
    pub python: ::core::option::Option<analysis_options::Python>,
}
/// Nested message and enum types in `AnalysisOptions`.
pub mod analysis_options {
    /// Options for Python analysis.
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Python {
        /// Optional. Whether to enable Python analysis.
        /// Defaults to false.
        #[prost(bool, tag = "1")]
        pub enabled: bool,
    }
}
/// Request for retrieving BigQuery table contextual data via direct lookup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableContextRequest {
    /// Required.
    #[deprecated]
    #[prost(string, tag = "5")]
    pub project: ::prost::alloc::string::String,
    /// Required. Parent value for RetrieveBigQueryTableContextRequest.
    /// Pattern: `projects/{project}/locations/{location}`
    /// For location, use "global" for now. Regional location value will be
    /// supported in the future.
    #[prost(string, tag = "6")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. User query in natural language.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. A list of direct lookup parameters.
    #[prost(message, repeated, tag = "3")]
    pub direct_lookup: ::prost::alloc::vec::Vec<DirectLookup>,
}
/// Response for retrieving BigQuery table contextual data via direct lookup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableContextResponse {
    /// List of retrieved candidates with their bundled metadata.
    #[deprecated]
    #[prost(message, repeated, tag = "1")]
    pub candidates: ::prost::alloc::vec::Vec<
        retrieve_big_query_table_context_response::Candidate,
    >,
    /// List of retrieved candidates with their bundled metadata.
    #[prost(message, repeated, tag = "2")]
    pub table_candidates: ::prost::alloc::vec::Vec<TableCandidate>,
}
/// Nested message and enum types in `RetrieveBigQueryTableContextResponse`.
pub mod retrieve_big_query_table_context_response {
    /// A retrieved candidate.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Candidate {
        /// The fully qualified resource name of the candidate in its source system,
        /// if applicable. E.g. for BigQuery tables, the format is:
        /// `bigquery.googleapis.com/projects/{project_id}/datasets/{dataset_id}/tables/{table_id}`
        #[prost(string, tag = "1")]
        pub linked_resource: ::prost::alloc::string::String,
        /// Content in string format.
        #[prost(string, tag = "2")]
        pub content: ::prost::alloc::string::String,
    }
}
/// Request for retrieving BigQuery table contextual data via direct lookup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableContextsRequest {
    /// Required. Parent value for RetrieveBigQueryTableContextRequest.
    /// Pattern: `projects/{project}/locations/{location}`
    /// For location, use "global" for now. Regional location value will be
    /// supported in the future.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. User query in natural language.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    /// Optional. A list of direct lookup parameters.
    #[prost(message, repeated, tag = "3")]
    pub direct_lookups: ::prost::alloc::vec::Vec<DirectLookup>,
}
/// Response for retrieving BigQuery table contextual data via direct lookup.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableContextsResponse {
    /// List of retrieved candidates with their bundled metadata.
    #[prost(message, repeated, tag = "1")]
    pub table_candidates: ::prost::alloc::vec::Vec<TableCandidate>,
}
/// Request for retrieving BigQuery table contextual data from recently accessed
/// tables. Response is sorted by semantic similarity to the query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableContextsFromRecentTablesRequest {
    /// Required. Parent value for
    /// RetrieveBigQueryTableContextsFromRecentTablesRequest. Pattern:
    /// `projects/{project}/locations/{location}` For location, use "global" for
    /// now. Regional location value will be supported in the future.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. User query in natural language.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
/// Response for retrieving BigQuery table contextual data from recently
/// accessed tables. Response is sorted by semantic similarity to the query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableContextsFromRecentTablesResponse {
    /// List of retrieved candidates with their bundled metadata.
    #[prost(message, repeated, tag = "1")]
    pub table_candidates: ::prost::alloc::vec::Vec<TableCandidate>,
}
/// Request for retrieving BigQuery table schema with suggested table and column
/// descriptions. Columns are sorted by default BigQuery table schema order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableSuggestedDescriptionsRequest {
    /// Required. Parent value for
    /// RetrieveBigQueryTableSuggestedDescriptionsRequest. Pattern:
    /// `projects/{project}/locations/{location}` For location, use "global" for
    /// now. Regional location value will be supported in the future.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. A list of direct lookup parameters.
    #[prost(message, repeated, tag = "2")]
    pub direct_lookup: ::prost::alloc::vec::Vec<DirectLookup>,
}
/// Response for retrieving BigQuery table schema with suggested table and column
/// descriptions. Columns are sorted by default BigQuery table schema order.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableSuggestedDescriptionsResponse {
    /// List of retrieved candidates with their bundled metadata.
    #[prost(message, repeated, tag = "1")]
    pub table_candidates: ::prost::alloc::vec::Vec<TableCandidate>,
}
/// Request for retrieving BigQuery table schema with suggested NL-SQL examples.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableSuggestedExamplesRequest {
    /// Required. Parent value for RetrieveBigQueryTableSuggestedExamplesRequest.
    /// Pattern: `projects/{project}/locations/{location}`
    /// For location, use "global" for now. Regional location value will be
    /// supported in the future.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. A list of direct lookup parameters.
    #[prost(message, repeated, tag = "2")]
    pub direct_lookup: ::prost::alloc::vec::Vec<DirectLookup>,
}
/// Request for retrieving BigQuery table schema with suggested NL-SQL examples.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryTableSuggestedExamplesResponse {
    /// List of suggested examples.
    #[prost(message, repeated, tag = "2")]
    pub example_suggestions: ::prost::alloc::vec::Vec<
        retrieve_big_query_table_suggested_examples_response::ExampleSuggestion,
    >,
}
/// Nested message and enum types in `RetrieveBigQueryTableSuggestedExamplesResponse`.
pub mod retrieve_big_query_table_suggested_examples_response {
    /// A suggested BigQuery NL-SQL example for the given table.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExampleSuggestion {
        /// The natural language query.
        #[prost(string, tag = "1")]
        pub nl_query: ::prost::alloc::string::String,
        /// The SQL answer to the query.
        #[prost(string, tag = "2")]
        pub sql: ::prost::alloc::string::String,
        /// The linked table resources for the suggested example.
        #[prost(string, repeated, tag = "3")]
        pub linked_bigquery_tables: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
}
/// Request for retrieving BigQuery table references from recently accessed
/// tables. Response is sorted by semantic similarity to the query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryRecentRelevantTablesRequest {
    /// Required. Parent value for RetrieveBigQueryRecentTablesRequest.
    /// Pattern: `projects/{project}/locations/{location}`
    /// For location, use "global" for now. Regional location value will be
    /// supported in the future.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. User query in natural language.
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
}
/// Response for retrieving BigQuery table references from recently accessed
/// tables. Response is sorted by semantic similarity to the query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBigQueryRecentRelevantTablesResponse {
    /// List of retrieved table ids.
    /// The unique identifier for the table. Names are case-sensitive.
    /// Example for BigQuery Table: `{project}.{dataset}.{table}`.
    #[prost(string, repeated, tag = "1")]
    pub table_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Direct lookup parameters.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectLookup {
    /// Optional. Table reference that server invokes a direct lookup of table
    /// metadata upon. The returned candidate will be TableMetadataResult.
    #[prost(message, optional, tag = "1")]
    pub big_query_table_reference: ::core::option::Option<BigQueryTableReference>,
}
/// A retrieved BigQuery table candidate.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableCandidate {
    /// The fully qualified resource name of the candidate in its source system,
    /// if applicable. E.g. for BigQuery tables, the format is:
    /// `bigquery.googleapis.com/projects/{project_id}/datasets/{dataset_id}/tables/{table_id}`.
    #[prost(string, tag = "1")]
    pub linked_resource: ::prost::alloc::string::String,
    /// In-context-learning string. For example, could be in DDL format.
    #[prost(string, tag = "2")]
    pub icl_string: ::prost::alloc::string::String,
    /// Suggested field descriptions for this candidate, if requested.
    #[prost(message, repeated, tag = "3")]
    pub field_suggestions: ::prost::alloc::vec::Vec<table_candidate::FieldSuggestion>,
}
/// Nested message and enum types in `TableCandidate`.
pub mod table_candidate {
    /// A suggested description for a field.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldSuggestion {
        /// The field name.
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        /// The suggested description, if descriptions were requested.
        #[prost(string, tag = "2")]
        pub suggested_description: ::prost::alloc::string::String,
        /// Suggestions for nested fields.
        #[prost(message, repeated, tag = "3")]
        pub nested: ::prost::alloc::vec::Vec<FieldSuggestion>,
    }
}
/// Generated client implementations.
pub mod context_retrieval_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to ask a natural language question with a provided project,
    /// returns BigQuery tables that are relevant to the question within the project
    /// scope that is accessible to the user, along with contextual data including
    /// table schema information as well as sample values.
    #[derive(Debug, Clone)]
    pub struct ContextRetrievalServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ContextRetrievalServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ContextRetrievalServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ContextRetrievalServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ContextRetrievalServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves BigQuery table contextual data for provided table references.
        /// Contextual data includes table schema information as well as sample
        /// values.
        pub async fn retrieve_big_query_table_context(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveBigQueryTableContextRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveBigQueryTableContextResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService/RetrieveBigQueryTableContext",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService",
                        "RetrieveBigQueryTableContext",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves BigQuery table contextual data for provided table references.
        /// Contextual data includes table schema information as well as sample
        /// values.
        pub async fn retrieve_big_query_table_contexts(
            &mut self,
            request: impl tonic::IntoRequest<super::RetrieveBigQueryTableContextsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveBigQueryTableContextsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService/RetrieveBigQueryTableContexts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService",
                        "RetrieveBigQueryTableContexts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves BigQuery table contextual data from recently accessed tables.
        /// Contextual data includes table schema information as well as sample
        /// values.
        pub async fn retrieve_big_query_table_contexts_from_recent_tables(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RetrieveBigQueryTableContextsFromRecentTablesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::RetrieveBigQueryTableContextsFromRecentTablesResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService/RetrieveBigQueryTableContextsFromRecentTables",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService",
                        "RetrieveBigQueryTableContextsFromRecentTables",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves BigQuery table schema with suggested table and column
        /// descriptions.
        pub async fn retrieve_big_query_table_suggested_descriptions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RetrieveBigQueryTableSuggestedDescriptionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveBigQueryTableSuggestedDescriptionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService/RetrieveBigQueryTableSuggestedDescriptions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService",
                        "RetrieveBigQueryTableSuggestedDescriptions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves BigQuery table schema with suggested NL-SQL examples.
        pub async fn retrieve_big_query_table_suggested_examples(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RetrieveBigQueryTableSuggestedExamplesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveBigQueryTableSuggestedExamplesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService/RetrieveBigQueryTableSuggestedExamples",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService",
                        "RetrieveBigQueryTableSuggestedExamples",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves BigQuery table references from recently accessed tables.
        pub async fn retrieve_big_query_recent_relevant_tables(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RetrieveBigQueryRecentRelevantTablesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RetrieveBigQueryRecentRelevantTablesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService/RetrieveBigQueryRecentRelevantTables",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.ContextRetrievalService",
                        "RetrieveBigQueryRecentRelevantTables",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Message for a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Conversation {
    /// Optional. Identifier. The unique resource name of a conversation.
    /// It's not expected to be set when creating a conversation.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Required. Agent(s) in the conversation.
    /// Currently, only one agent is supported. This field is repeated to allow
    /// for future support of multiple agents in a conversation.
    /// Format: `projects/{project}/locations/{location}/dataAgents/{agent}`
    #[prost(string, repeated, tag = "2")]
    pub agents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Output only. Creation timestamp.
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp of the last used conversation.
    #[prost(message, optional, tag = "4")]
    pub last_used_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. Open-ended and user-defined labels that can be set by the client
    /// to tag a conversation (e.g. to filter conversations for specific
    /// surfaces/products).
    #[prost(map = "string, string", tag = "9")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Request for creating a conversation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversationRequest {
    /// Required. Parent value for CreateConversationRequest.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. The conversation id of the conversation to create.
    #[prost(string, tag = "2")]
    pub conversation_id: ::prost::alloc::string::String,
    /// Required. The conversation to create.
    #[prost(message, optional, tag = "3")]
    pub conversation: ::core::option::Option<Conversation>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Request for getting a conversation based on parent and conversation id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversationRequest {
    /// Required. Name of the resource.
    /// Format:
    /// `projects/{project}/locations/{location}/conversations/{conversation}`
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Request for listing conversations based on parent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsRequest {
    /// Required. Parent value for ListConversationsRequest.
    /// Format: `projects/{project}/locations/{location}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. The max page size is 100. All larger page sizes will be coerced
    /// to 100. If unspecified, server will pick 50 as an approperiate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Returned conversations will match criteria specified within the
    /// filter. ListConversations allows filtering by:
    ///   * agent_id
    ///   * labels
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
/// Message for response to listing conversations.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversationsResponse {
    /// The list of conversations.
    #[prost(message, repeated, tag = "1")]
    pub conversations: ::prost::alloc::vec::Vec<Conversation>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Message describing a DataAnalyticsAgent object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAnalyticsAgent {
    /// Optional. The staging context for the agent.
    /// This context is used to test and validate changes before publishing.
    #[prost(message, optional, tag = "5")]
    pub staging_context: ::core::option::Option<Context>,
    /// Optional. The published context for the agent.
    /// This context is used by the Chat API in production.
    #[prost(message, optional, tag = "6")]
    pub published_context: ::core::option::Option<Context>,
    /// Output only. The last published context for the agent.
    /// This is an output-only field populated by the system when the
    /// published context is updated. It is used to restore the agent to a
    /// previous state.
    #[prost(message, optional, tag = "7")]
    pub last_published_context: ::core::option::Option<Context>,
}
/// Message describing a DataAgent object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAgent {
    /// Optional. Identifier. The unique resource name of a Agent.
    /// Format:
    /// `projects/{project}/locations/{location}/dataAgents/{data_agent_id}`
    /// `{data_agent}` is the resource id and should be 63 characters or less and
    /// must match the format described in
    /// <https://google.aip.dev/122#resource-id-segments>
    ///
    /// Example: `projects/1234567890/locations/us-central1/dataAgents/my-agent`.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. User friendly display name.
    ///
    /// * Must be between 1-256 characters.
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    /// Optional. Description of the agent.
    ///
    /// * Must be between 1-1024 characters.
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Optional. Labels to help users filter related agents.
    /// E.g. "sales", "business", "etl", etc.
    /// Note labels are only used for filtering and not for policies.
    /// See <https://cloud.google.com/resource-manager/docs/labels-overview> for more
    /// details on label usage.
    #[prost(map = "string, string", tag = "5")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Output only. The time when the data agent was created.
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time when the data agent was last updated.
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. \[Output only\] The time the data agent was soft deleted.
    #[prost(message, optional, tag = "12")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Timestamp in UTC of when this data agent is considered
    /// expired. This is *always* provided on output, regardless of what was sent
    /// on input.
    #[prost(message, optional, tag = "13")]
    pub purge_time: ::core::option::Option<::prost_types::Timestamp>,
    /// The type of the agent. Can be one of the following:
    /// * Data analytics agent.
    /// * Data engineering agent
    #[prost(oneof = "data_agent::Type", tags = "101")]
    pub r#type: ::core::option::Option<data_agent::Type>,
}
/// Nested message and enum types in `DataAgent`.
pub mod data_agent {
    /// The type of the agent. Can be one of the following:
    /// * Data analytics agent.
    /// * Data engineering agent
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Data analytics agent.
        #[prost(message, tag = "101")]
        DataAnalyticsAgent(super::DataAnalyticsAgent),
    }
}
/// Message for requesting list of DataAgents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAgentsRequest {
    /// Required. Parent value for ListDataAgentsRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListDataAgents` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListDataAgents` must
    /// match the call that provided the page token. The service may return fewer
    /// than this value.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results. See [AIP-160](<https://google.aip.dev/160>) for
    /// syntax.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. User specification for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. If true, the list results will include soft-deleted DataAgents.
    /// Defaults to false.
    #[prost(bool, tag = "6")]
    pub show_deleted: bool,
}
/// Message for response to listing DataAgents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataAgentsResponse {
    /// The list of DataAgent.
    #[prost(message, repeated, tag = "1")]
    pub data_agents: ::prost::alloc::vec::Vec<DataAgent>,
    /// The next page token or empty if none.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for requesting list of accessible DataAgents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessibleDataAgentsRequest {
    /// Required. Parent value for ListAccessibleDataAgentsRequest.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Server may return fewer items than requested.
    /// If unspecified, server will pick an appropriate default.
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    /// Optional. A page token, received from a previous `ListAccessibleDataAgents`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListAccessibleDataAgents` must match the call that provided the page
    /// token. The service may return fewer than this value.
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results. See [AIP-160](<https://google.aip.dev/160>) for
    /// syntax.
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    /// Optional. User specification for how to order the results.
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
    /// Optional. If true, the list results will include soft-deleted DataAgents.
    /// Defaults to false.
    #[prost(bool, tag = "6")]
    pub show_deleted: bool,
    /// Optional. Filter for the creator of the agent.
    #[prost(
        enumeration = "list_accessible_data_agents_request::CreatorFilter",
        tag = "7"
    )]
    pub creator_filter: i32,
}
/// Nested message and enum types in `ListAccessibleDataAgentsRequest`.
pub mod list_accessible_data_agents_request {
    /// Filter for the creator of the agent.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreatorFilter {
        /// Default value.
        Unspecified = 0,
        /// No creator-specific filter will be applied. All agents will be returned.
        None = 1,
        /// Only agents created by the user calling the API will be returned.
        CreatorOnly = 2,
    }
    impl CreatorFilter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CREATOR_FILTER_UNSPECIFIED",
                Self::None => "NONE",
                Self::CreatorOnly => "CREATOR_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CREATOR_FILTER_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "CREATOR_ONLY" => Some(Self::CreatorOnly),
                _ => None,
            }
        }
    }
}
/// Message for response to listing accessible DataAgents.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessibleDataAgentsResponse {
    /// The list of accessible DataAgent.
    #[prost(message, repeated, tag = "1")]
    pub data_agents: ::prost::alloc::vec::Vec<DataAgent>,
    /// The next page token or empty if none.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    /// Unordered list. Locations that could not be reached.
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Message for getting a DataAgent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataAgentRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Message for creating a DataAgent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataAgentRequest {
    /// Required. Value for parent.
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Id of the requesting object.
    /// Must be unique within the parent.
    /// The allowed format is: `^[a-z](\[a-z0-9-\]{0,61}\[a-z0-9\])?$`.
    #[prost(string, tag = "2")]
    pub data_agent_id: ::prost::alloc::string::String,
    /// Required. The resource being created.
    #[prost(message, optional, tag = "3")]
    pub data_agent: ::core::option::Option<DataAgent>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for updating a DataAgent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataAgentRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// DataAgent resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields with non-default values
    /// present in the request will be overwritten. If a wildcard mask is provided,
    /// all fields will be overwritten.
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    /// Required. The resource being updated.
    #[prost(message, optional, tag = "2")]
    pub data_agent: ::core::option::Option<DataAgent>,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "3")]
    pub request_id: ::prost::alloc::string::String,
}
/// Message for deleting a DataAgent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataAgentRequest {
    /// Required. Name of the resource.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
/// Represents the metadata of the long-running operation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. The time the operation finished running.
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Output only. Server-defined resource path for the target of the operation.
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    /// Output only. Name of the verb executed by the operation.
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    /// Output only. Human-readable status of the operation, if any.
    #[prost(string, tag = "5")]
    pub status_message: ::prost::alloc::string::String,
    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    #[prost(bool, tag = "6")]
    pub requested_cancellation: bool,
    /// Output only. API version used to start the operation.
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod data_agent_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service describing handlers for resources.
    #[derive(Debug, Clone)]
    pub struct DataAgentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataAgentServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataAgentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataAgentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataAgentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists DataAgents in a given project and location.
        pub async fn list_data_agents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataAgentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataAgentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/ListDataAgents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "ListDataAgents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataAgents that are accessible to the caller in a given project and
        /// location.
        pub async fn list_accessible_data_agents(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccessibleDataAgentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessibleDataAgentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/ListAccessibleDataAgents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "ListAccessibleDataAgents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single DataAgent.
        pub async fn get_data_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataAgentRequest>,
        ) -> std::result::Result<tonic::Response<super::DataAgent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/GetDataAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "GetDataAgent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new DataAgent in a given project and location.
        pub async fn create_data_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/CreateDataAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "CreateDataAgent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the parameters of a single DataAgent.
        pub async fn update_data_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/UpdateDataAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "UpdateDataAgent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a single DataAgent.
        pub async fn delete_data_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataAgentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/DeleteDataAgent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "DeleteDataAgent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the IAM policy for DataAgent
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the IAM policy for a DataAgent.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataAgentService/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataAgentService",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Request for listing chat messages based on parent and conversation_id.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMessagesRequest {
    /// Required. The conversation to list messages under.
    /// Format:
    /// `projects/{project}/locations/{location}/conversations/{conversation_id}`
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    /// Optional. Requested page size. Server may return fewer items than
    /// requested. The max page size is 100. All larger page sizes will be coerced
    /// to 100. If unspecified, server will pick 50 as an approperiate default.
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    /// Optional. A token identifying a page of results the server should return.
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    /// Optional. Filtering results. See [AIP-160](<https://google.aip.dev/160>) for
    /// syntax.
    ///
    /// ListMessages allows filtering by:
    ///   * create_time (e.g., `createTime > "2025-01-28T06:51:56-08:00"`)
    ///   * update_time
    #[prost(string, tag = "5")]
    pub filter: ::prost::alloc::string::String,
}
/// Response for listing chat messages.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMessagesResponse {
    /// The list of chat messages.
    #[prost(message, repeated, tag = "1")]
    pub messages: ::prost::alloc::vec::Vec<StorageMessage>,
    /// A token identifying a page of results the server should return.
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// A stored message containing user message or system message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageMessage {
    /// The unique resource name of a chat message.
    #[prost(string, tag = "1")]
    pub message_id: ::prost::alloc::string::String,
    /// The message content.
    #[prost(message, optional, tag = "2")]
    pub message: ::core::option::Option<Message>,
}
/// Request for Chat.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChatRequest {
    /// Optional. The GCP project to be used for quota and billing.
    #[deprecated]
    #[prost(string, tag = "1")]
    pub project: ::prost::alloc::string::String,
    /// Required. The parent value for chat request.
    /// Pattern: `projects/{project}/locations/{location}`
    #[prost(string, tag = "3")]
    pub parent: ::prost::alloc::string::String,
    /// Required. Content of current conversation.
    #[prost(message, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<Message>,
    /// Context Provider for the chat request.
    /// It can either be -
    /// inline_context, which is a context provided inline in the request.
    /// data_agent, which is a reference to a data agent resource.
    /// conversation_reference, which is a reference to a persisted conversation
    /// and context using conversation_id and agent_id.
    #[prost(oneof = "chat_request::ContextProvider", tags = "101, 103, 104")]
    pub context_provider: ::core::option::Option<chat_request::ContextProvider>,
}
/// Nested message and enum types in `ChatRequest`.
pub mod chat_request {
    /// Context Provider for the chat request.
    /// It can either be -
    /// inline_context, which is a context provided inline in the request.
    /// data_agent, which is a reference to a data agent resource.
    /// conversation_reference, which is a reference to a persisted conversation
    /// and context using conversation_id and agent_id.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ContextProvider {
        /// Optional. Inline context for the chat request. Use this to chat
        /// statelessly (without managed conversation persistence and without an
        /// Agent) by passing all context inline.
        #[prost(message, tag = "101")]
        InlineContext(super::Context),
        /// Optional. Reference to a persisted conversation and agent context.
        /// Use this to chat with an Agent using managed conversation persistence.
        #[prost(message, tag = "103")]
        ConversationReference(super::ConversationReference),
        /// Optional. Context for the chat request. Use this to chat with an Agent
        /// statelessly, without managed conversation persistence.
        #[prost(message, tag = "104")]
        DataAgentContext(super::DataAgentContext),
    }
}
/// Context for the chat request using a data agent.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataAgentContext {
    /// Required. The name of the data agent resource.
    #[prost(string, tag = "1")]
    pub data_agent: ::prost::alloc::string::String,
    /// Optional. The credentials to use when calling the looker datasource
    ///
    /// Currently supports both oauth token and api keys based credentials, as
    /// described in
    /// <https://cloud.google.com/looker/docs/api-auth#authentication_with_an_sdk>
    #[prost(message, optional, tag = "2")]
    pub credentials: ::core::option::Option<Credentials>,
    /// Optional. Version of context to be used by DCS (e.g. STAGING, PUBLISHED)
    #[prost(enumeration = "data_agent_context::ContextVersion", tag = "3")]
    pub context_version: i32,
}
/// Nested message and enum types in `DataAgentContext`.
pub mod data_agent_context {
    /// List of context versions supported by DCS.
    /// There are two versions of context. This is to maintain versioning for the
    /// data agent.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContextVersion {
        /// Unspecified or unrecognized.
        Unspecified = 0,
        /// Using this version, DCS will use the latest staging context for the
        /// data agent.
        Staging = 1,
        /// Using this version, DCS will use the latest published context for the
        /// data agent.
        Published = 2,
    }
    impl ContextVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "CONTEXT_VERSION_UNSPECIFIED",
                Self::Staging => "STAGING",
                Self::Published => "PUBLISHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONTEXT_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
                "STAGING" => Some(Self::Staging),
                "PUBLISHED" => Some(Self::Published),
                _ => None,
            }
        }
    }
}
/// Reference to a persisted conversation and agent context.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversationReference {
    /// Required. Name of the conversation resource.
    /// Format:
    /// `projects/{project}/locations/{location}/conversations/{conversation_id}`
    #[prost(string, tag = "1")]
    pub conversation: ::prost::alloc::string::String,
    /// Required. Context for the chat request using a data agent.
    #[prost(message, optional, tag = "3")]
    pub data_agent_context: ::core::option::Option<DataAgentContext>,
}
/// A message from an internaction between the user and the system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    /// Output only. For user messages, this is the time at which the system
    /// received the message. For system messages, this is the time at which the
    /// system generated the message.
    #[prost(message, optional, tag = "1")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional. unique id of the message in the conversation for persistence.
    #[prost(string, tag = "4")]
    pub message_id: ::prost::alloc::string::String,
    /// The kind of message.
    #[prost(oneof = "message::Kind", tags = "2, 3")]
    pub kind: ::core::option::Option<message::Kind>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    /// The kind of message.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A message from the user that is interacting with the system.
        #[prost(message, tag = "2")]
        UserMessage(super::UserMessage),
        /// A message from the system in response to the user.
        #[prost(message, tag = "3")]
        SystemMessage(super::SystemMessage),
    }
}
/// A message from the user that is interacting with the system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserMessage {
    /// The kind of content in the user message.
    #[prost(oneof = "user_message::Kind", tags = "1")]
    pub kind: ::core::option::Option<user_message::Kind>,
}
/// Nested message and enum types in `UserMessage`.
pub mod user_message {
    /// The kind of content in the user message.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Text should use this field instead of blob.
        #[prost(string, tag = "1")]
        Text(::prost::alloc::string::String),
    }
}
/// A message from the system in response to the user. This message can also be a
/// message from the user as historical context for multiturn conversations with
/// the system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SystemMessage {
    /// Identifies the group that the event belongs to. Similar events are deemed
    /// to be logically relevant to each other and should be shown together in
    /// the UI.
    #[prost(int32, optional, tag = "12")]
    pub group_id: ::core::option::Option<i32>,
    /// The kind of content in the system message.
    #[prost(oneof = "system_message::Kind", tags = "1, 2, 3, 4, 5, 6")]
    pub kind: ::core::option::Option<system_message::Kind>,
}
/// Nested message and enum types in `SystemMessage`.
pub mod system_message {
    /// The kind of content in the system message.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A direct natural language response to the user message.
        #[prost(message, tag = "1")]
        Text(super::TextMessage),
        /// A message produced during schema resolution.
        #[prost(message, tag = "2")]
        Schema(super::SchemaMessage),
        /// A message produced during data retrieval.
        #[prost(message, tag = "3")]
        Data(super::DataMessage),
        /// A message produced during analysis.
        #[prost(message, tag = "4")]
        Analysis(super::AnalysisMessage),
        /// A message produced during chart generation.
        #[prost(message, tag = "5")]
        Chart(super::ChartMessage),
        /// An error message.
        #[prost(message, tag = "6")]
        Error(super::ErrorMessage),
    }
}
/// A multi-part text message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextMessage {
    /// Optional. The parts of the message.
    #[prost(string, repeated, tag = "1")]
    pub parts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// A message produced during schema resolution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaMessage {
    /// Whether this message contains the query or the result of the schema
    /// resolution.
    #[prost(oneof = "schema_message::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<schema_message::Kind>,
}
/// Nested message and enum types in `SchemaMessage`.
pub mod schema_message {
    /// Whether this message contains the query or the result of the schema
    /// resolution.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A schema resolution query.
        #[prost(message, tag = "1")]
        Query(super::SchemaQuery),
        /// The result of a schema resolution query.
        #[prost(message, tag = "2")]
        Result(super::SchemaResult),
    }
}
/// A query for resolving the schema relevant to the posed question.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaQuery {
    /// Optional. The question to send to the system for schema resolution.
    #[prost(string, tag = "1")]
    pub question: ::prost::alloc::string::String,
}
/// The result of schema resolution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchemaResult {
    /// Optional. The datasources used to resolve the schema query.
    #[prost(message, repeated, tag = "1")]
    pub datasources: ::prost::alloc::vec::Vec<Datasource>,
}
/// A message produced during data retrieval.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataMessage {
    /// Whether this message contains the query, the result, or generated SQL for
    /// the data retrieval.
    #[prost(oneof = "data_message::Kind", tags = "1, 2, 3, 4, 5")]
    pub kind: ::core::option::Option<data_message::Kind>,
}
/// Nested message and enum types in `DataMessage`.
pub mod data_message {
    /// Whether this message contains the query, the result, or generated SQL for
    /// the data retrieval.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A data retrieval query.
        #[prost(message, tag = "1")]
        Query(super::DataQuery),
        /// SQL generated by the system to retrieve data.
        #[prost(string, tag = "2")]
        GeneratedSql(::prost::alloc::string::String),
        /// Retrieved data.
        #[prost(message, tag = "3")]
        Result(super::DataResult),
        /// Looker Query generated by the system to retrieve data.
        #[prost(message, tag = "4")]
        GeneratedLookerQuery(super::LookerQuery),
        /// A BigQuery job executed by the system to retrieve data.
        #[prost(message, tag = "5")]
        BigQueryJob(super::BigQueryJob),
    }
}
/// A query for retrieving data from a Looker explore. See
/// <https://cloud.google.com/looker/docs/reference/looker-api/latest/methods/Query/run_inline_query>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LookerQuery {
    /// Required. The LookML model used to generate the query.
    #[prost(string, tag = "1")]
    pub model: ::prost::alloc::string::String,
    /// Required. The LookML explore used to generate the query.
    #[prost(string, tag = "2")]
    pub explore: ::prost::alloc::string::String,
    /// Optional. The fields to retrieve from the explore.
    #[prost(string, repeated, tag = "3")]
    pub fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. The filters to apply to the explore.
    #[prost(message, repeated, tag = "4")]
    pub filters: ::prost::alloc::vec::Vec<looker_query::Filter>,
    /// Optional. The sorts to apply to the explore.
    #[prost(string, repeated, tag = "5")]
    pub sorts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional. Limit in the query.
    #[prost(string, optional, tag = "6")]
    pub limit: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `LookerQuery`.
pub mod looker_query {
    /// A Looker query filter.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Filter {
        /// Required. The field to filter on.
        #[prost(string, tag = "1")]
        pub field: ::prost::alloc::string::String,
        /// Required. The value f field to filter on.
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
}
/// A query for retrieving data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataQuery {
    /// Optional. A natural language question to answer.
    #[prost(string, tag = "1")]
    pub question: ::prost::alloc::string::String,
    /// Optional. A snake-case name for the query that reflects its intent. It is
    /// used to name the corresponding data result, so that it can be referenced in
    /// later steps.
    ///
    /// * Example: "total_sales_by_product"
    /// * Example: "sales_for_product_12345"
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The datasources available to answer the question.
    #[prost(message, repeated, tag = "2")]
    pub datasources: ::prost::alloc::vec::Vec<Datasource>,
}
/// Retrieved data.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataResult {
    /// Optional. A snake-case name for the data result that reflects its contents.
    /// The name is used to pass the result around by reference, and serves as a
    /// signal about its meaning.
    ///
    /// * Example: "total_sales_by_product"
    /// * Example: "sales_for_product_12345"
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// Optional. The schema of the data.
    #[prost(message, optional, tag = "5")]
    pub schema: ::core::option::Option<Schema>,
    /// Optional. The content of the data. Each row is a struct that matches the
    /// schema. Simple values are represented as strings, while nested structures
    /// are represented as lists or structs.
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<::prost_types::Struct>,
}
/// A BigQuery job executed by the system.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryJob {
    /// Required. The project the job belongs to.
    ///
    /// See <https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference>
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    /// Required. The ID of the job.
    ///
    /// See <https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference>
    #[prost(string, tag = "2")]
    pub job_id: ::prost::alloc::string::String,
    /// Optional. The location of the job.
    ///
    /// See <https://cloud.google.com/bigquery/docs/reference/rest/v2/JobReference>
    #[prost(string, tag = "5")]
    pub location: ::prost::alloc::string::String,
    /// Optional. A reference to the destination table of the job's query results.
    ///
    /// See
    /// <https://cloud.google.com/bigquery/docs/reference/rest/v2/Job#jobconfigurationquery>
    #[prost(message, optional, tag = "3")]
    pub destination_table: ::core::option::Option<BigQueryTableReference>,
    /// Optional. The schema of the job's query results.
    ///
    /// See
    /// <https://cloud.google.com/bigquery/docs/reference/rest/v2/Job#jobstatistics2>
    #[prost(message, optional, tag = "7")]
    pub schema: ::core::option::Option<Schema>,
}
/// A message produced during analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisMessage {
    /// Whether this message contains the query or one of the events from the
    /// analysis.
    #[prost(oneof = "analysis_message::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<analysis_message::Kind>,
}
/// Nested message and enum types in `AnalysisMessage`.
pub mod analysis_message {
    /// Whether this message contains the query or one of the events from the
    /// analysis.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// An analysis query.
        #[prost(message, tag = "1")]
        Query(super::AnalysisQuery),
        /// An event indicating the progress of the analysis.
        #[prost(message, tag = "2")]
        ProgressEvent(super::AnalysisEvent),
    }
}
/// A query for performing an analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisQuery {
    /// Optional. An analysis question to help answer the user's original question.
    #[prost(string, tag = "1")]
    pub question: ::prost::alloc::string::String,
    /// Optional. The names of previously retrieved data results to analyze.
    #[prost(string, repeated, tag = "2")]
    pub data_result_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// An event indicating the progress of an analysis.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisEvent {
    /// The kind of event that occurred during the analysis.
    #[prost(oneof = "analysis_event::Kind", tags = "2, 3, 4, 5, 6, 7, 8, 9, 10, 11")]
    pub kind: ::core::option::Option<analysis_event::Kind>,
}
/// Nested message and enum types in `AnalysisEvent`.
pub mod analysis_event {
    /// The kind of event that occurred during the analysis.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Python codegen planner's reasoning.
        #[prost(string, tag = "2")]
        PlannerReasoning(::prost::alloc::string::String),
        /// Instructions issued for code generation.
        #[prost(string, tag = "3")]
        CoderInstruction(::prost::alloc::string::String),
        /// Generated code.
        #[prost(string, tag = "4")]
        Code(::prost::alloc::string::String),
        /// Output from code execution.
        #[prost(string, tag = "5")]
        ExecutionOutput(::prost::alloc::string::String),
        /// An error from code execution.
        #[prost(string, tag = "6")]
        ExecutionError(::prost::alloc::string::String),
        /// Result as Vega chart JSON string.
        #[prost(string, tag = "7")]
        ResultVegaChartJson(::prost::alloc::string::String),
        /// Result as NL string.
        #[prost(string, tag = "8")]
        ResultNaturalLanguage(::prost::alloc::string::String),
        /// Result as CSV string.
        #[prost(string, tag = "9")]
        ResultCsvData(::prost::alloc::string::String),
        /// Result as a reference to a data source.
        #[prost(string, tag = "10")]
        ResultReferenceData(::prost::alloc::string::String),
        /// A generic error message.
        #[prost(string, tag = "11")]
        Error(::prost::alloc::string::String),
    }
}
/// A message produced during chart generation.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartMessage {
    /// Whether this message contains the query or the result of the chart
    /// generation.
    #[prost(oneof = "chart_message::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<chart_message::Kind>,
}
/// Nested message and enum types in `ChartMessage`.
pub mod chart_message {
    /// Whether this message contains the query or the result of the chart
    /// generation.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// A query for generating a chart.
        #[prost(message, tag = "1")]
        Query(super::ChartQuery),
        /// The result of a chart generation query.
        #[prost(message, tag = "2")]
        Result(super::ChartResult),
    }
}
/// A query for generating a chart.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartQuery {
    /// Optional. Natural language instructions for generating the chart.
    #[prost(string, tag = "1")]
    pub instructions: ::prost::alloc::string::String,
    /// Optional. The name of a previously retrieved data result to use in the
    /// chart.
    #[prost(string, tag = "2")]
    pub data_result_name: ::prost::alloc::string::String,
}
/// The result of a chart generation query.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChartResult {
    /// Optional. A generated Vega chart config.
    /// See <https://vega.github.io/vega/docs/config/>
    #[prost(message, optional, tag = "2")]
    pub vega_config: ::core::option::Option<::prost_types::Struct>,
    /// Optional. A rendering of the chart if this was requested in the context.
    #[prost(message, optional, tag = "3")]
    pub image: ::core::option::Option<Blob>,
}
/// An error message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorMessage {
    /// Output only. The text of the error.
    #[prost(string, tag = "1")]
    pub text: ::prost::alloc::string::String,
}
/// A blob of data with a MIME type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blob {
    /// Required. The IANA standard MIME type of the message data.
    #[prost(string, tag = "1")]
    pub mime_type: ::prost::alloc::string::String,
    /// Required. The data represented as bytes.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Generated client implementations.
pub mod data_chat_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to ask a natural language question on top of BigQuery
    /// and LookerStudio datasources to get back streamed responses of various kinds
    /// to help provide a rich conversational answer.
    #[derive(Debug, Clone)]
    pub struct DataChatServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl DataChatServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> DataChatServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DataChatServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            DataChatServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Answers a data question by generating a stream of [Message]s.
        pub async fn chat(
            &mut self,
            request: impl tonic::IntoRequest<super::ChatRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::Message>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataChatService/Chat",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataChatService",
                        "Chat",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// Creates a new conversation to persist the conversation history. Each
        /// conversation will have multiple messages associated with it.
        pub async fn create_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataChatService/CreateConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataChatService",
                        "CreateConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets details of a single conversation using conversation id and parent.
        pub async fn get_conversation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversationRequest>,
        ) -> std::result::Result<tonic::Response<super::Conversation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataChatService/GetConversation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataChatService",
                        "GetConversation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all conversations for a given parent.
        pub async fn list_conversations(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataChatService/ListConversations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataChatService",
                        "ListConversations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all messages for a given conversation.
        pub async fn list_messages(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMessagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMessagesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.geminidataanalytics.v1alpha.DataChatService/ListMessages",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.geminidataanalytics.v1alpha.DataChatService",
                        "ListMessages",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
